const{entries:$}=Object,{fromEntries:et}=Object,st="ENTRIES",D="KEYS",W="VALUES",_="";class S{set;_type;_path;constructor(t,s){const n=t._tree,o=Array.from(n.keys());this.set=t,this._type=s,this._path=o.length>0?[{node:n,keys:o}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:s}=b(this._path);if(b(s)===_)return{done:!1,value:this.result()};const n=t.get(b(s));return this._path.push({node:n,keys:Array.from(n.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=b(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>b(t)).filter(t=>t!==_).join("")}value(){return b(this._path).node.get(_)}result(){switch(this._type){case W:return this.value();case D:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const b=e=>e[e.length-1],nt=(e,t,s)=>{const n=new Map;if(t===void 0)return n;const o=t.length+1,r=o+s,c=new Uint8Array(r*o).fill(s+1);for(let i=0;i<o;++i)c[i]=i;for(let i=1;i<r;++i)c[i*o]=i;return q(e,t,s,n,c,1,o,""),n},q=(e,t,s,n,o,r,c,i)=>{const h=r*c;t:for(const u of e.keys())if(u===_){const l=o[h-1];l<=s&&n.set(i,[e.get(u),l])}else{let l=r;for(let f=0;f<u.length;++f,++l){const m=u[f],g=c*l,y=g-c;let d=o[g];const a=Math.max(0,l-s-1),w=Math.min(c-1,l+s);for(let p=a;p<w;++p){const O=m!==t[p],C=o[y+p]+ +O,k=o[y+p+1]+1,x=o[g+p]+1,v=o[g+p+1]=Math.min(C,k,x);v<d&&(d=v)}if(d>s)continue t}q(e.get(u),t,s,n,o,l,c,i+u)}};class z{_tree;_prefix;_size=void 0;constructor(t=new Map,s=""){this._tree=t,this._prefix=s}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[s,n]=I(this._tree,t.slice(this._prefix.length));if(s===void 0){const[o,r]=L(n);for(const c of o.keys())if(c!==_&&c.startsWith(r)){const i=new Map;return i.set(c.slice(r.length),o.get(c)),new z(i,t)}}return new z(s,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,ot(this._tree,t)}entries(){return new S(this,st)}forEach(t){for(const[s,n]of this)t(s,n,this)}fuzzyGet(t,s){return nt(this._tree,t,s)}get(t){const s=F(this._tree,t);return s!==void 0?s.get(_):void 0}has(t){return F(this._tree,t)?.has(_)??!1}keys(){return new S(this,D)}set(t,s){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,E(this._tree,t).set(_,s),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=E(this._tree,t);return n.set(_,s(n.get(_))),this}fetch(t,s){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const n=E(this._tree,t);let o=n.get(_);return o===void 0&&n.set(_,o=s()),o}values(){return new S(this,W)}[Symbol.iterator](){return this.entries()}static from(t){const s=new z;for(const[n,o]of t)s.set(n,o);return s}static fromObject(t){return z.from(Object.entries(t))}}const I=(e,t,s=[])=>{if(t.length===0||e==null)return[e,s];for(const n of e.keys())if(n!==_&&t.startsWith(n))return s.push([e,n]),I(e.get(n),t.slice(n.length),s);return s.push([e,t]),I(void 0,"",s)},F=(e,t)=>{if(t.length===0||e==null)return e;for(const s of e.keys())if(s!==_&&t.startsWith(s))return F(e.get(s),t.slice(s.length))},E=(e,t)=>{const s=t.length;t:for(let n=0;e&&n<s;){for(const r of e.keys())if(r!==_&&t[n]===r[0]){const c=Math.min(s-n,r.length);let i=1;for(;i<c&&t[n+i]===r[i];)++i;const h=e.get(r);if(i===r.length)e=h;else{const u=new Map;u.set(r.slice(i),h),e.set(t.slice(n,n+i),u),e.delete(r),e=u}n+=i;continue t}const o=new Map;return e.set(t.slice(n),o),o}return e},ot=(e,t)=>{const[s,n]=I(e,t);if(s!==void 0){if(s.delete(_),s.size===0)R(n);else if(s.size===1){const[o,r]=s.entries().next().value;A(n,o,r)}}},R=e=>{if(e.length===0)return;const[t,s]=L(e);if(t.delete(s),t.size===0)R(e.slice(0,-1));else if(t.size===1){const[n,o]=t.entries().next().value;n!==_&&A(e.slice(0,-1),n,o)}},A=(e,t,s)=>{if(e.length===0)return;const[n,o]=L(e);n.set(o+t,s),n.delete(o)},L=e=>e[e.length-1],rt=(e,t)=>{const s=e._idToShortId.get(t);if(s!=null)return e._storedFields.get(s)},it=/[\n\r\p{Z}\p{P}]+/u,j="or",N="and",ct="and_not",ut=(e,t)=>{e.includes(t)||e.push(t)},B=(e,t)=>{for(const s of t)e.includes(s)||e.push(s)},P=({score:e},{score:t})=>t-e,lt=()=>new Map,M=e=>{const t=new Map;for(const s of Object.keys(e))t.set(parseInt(s,10),e[s]);return t},G=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[j]:(e,t)=>{for(const s of t.keys()){const n=e.get(s);if(n==null)e.set(s,t.get(s));else{const{score:o,terms:r,match:c}=t.get(s);n.score=n.score+o,n.match=Object.assign(n.match,c),B(n.terms,r)}}return e},[N]:(e,t)=>{const s=new Map;for(const n of t.keys()){const o=e.get(n);if(o==null)continue;const{score:r,terms:c,match:i}=t.get(n);B(o.terms,c),s.set(n,{score:o.score+r,terms:o.terms,match:Object.assign(o.match,i)})}return s},[ct]:(e,t)=>{for(const s of t.keys())e.delete(s);return e}},dt=(e,t,s,n,o,r)=>{const{k:c,b:i,d:h}=r;return Math.log(1+(s-t+.5)/(t+.5))*(h+e*(c+1)/(e+c*(1-i+i*n/o)))},at=e=>(t,s,n)=>({term:t,fuzzy:typeof e.fuzzy=="function"?e.fuzzy(t,s,n):e.fuzzy??!1,prefix:typeof e.prefix=="function"?e.prefix(t,s,n):e.prefix===!0,termBoost:typeof e.boostTerm=="function"?e.boostTerm(t,s,n):1}),H=(e,t,s,n)=>{for(const o of Object.keys(e._fieldIds))if(e._fieldIds[o]===s){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${n}" was not present in field "${o}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},ft=(e,t,s,n)=>{if(!e._index.has(n)){H(e,s,t,n);return}const o=e._index.fetch(n,lt),r=o.get(t);r?.get(s)==null?H(e,s,t,n):r.get(s)<=1?r.size<=1?o.delete(t):r.delete(s):r.set(s,r.get(s)-1),e._index.get(n).size===0&&e._index.delete(n)},mt={k:1.2,b:.7,d:.5},gt={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(it),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{typeof console?.[e]=="function"&&console[e](t)},autoVacuum:!0},J={combineWith:j,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:mt},pt={combineWith:N,prefix:(e,t,s)=>t===s.length-1},_t={batchSize:1e3,batchWait:10},Y={minDirtFactor:.1,minDirtCount:20},yt={..._t,...Y},K=Symbol("*"),wt=(e,t)=>{const s=new Map,n={...e._options.searchOptions,...t};for(const[o,r]of e._documentIds){const c=n.boostDocument?n.boostDocument(r,"",e._storedFields.get(o)):1;s.set(o,{score:c,terms:[],match:{}})}return s},U=(e,t=j)=>{if(e.length===0)return new Map;const s=t.toLowerCase(),n=ht[s];if(!n)throw new Error(`Invalid combination operator: ${t}`);return e.reduce(n)||new Map},T=(e,t,s,n,o,r,c,i,h,u=new Map)=>{if(r==null)return u;for(const l of Object.keys(c)){const f=c[l],m=e._fieldIds[l],g=r.get(m);if(g==null)continue;let y=g.size;const d=e._avgFieldLength[m];for(const a of g.keys()){if(!e._documentIds.has(a)){ft(e,m,a,s),y-=1;continue}const w=i?i(e._documentIds.get(a),s,e._storedFields.get(a)):1;if(!w)continue;const p=g.get(a),O=e._fieldLength.get(a)[m],C=dt(p,y,e._documentCount,O,d,h),k=n*o*f*w*C,x=u.get(a);if(x){x.score+=k,ut(x.terms,t);const v=G(x.match,s);v?v.push(l):x.match[s]=[l]}else u.set(a,{score:k,terms:[t],match:{[s]:[l]}})}}return u},xt=(e,t,s)=>{const n={...e._options.searchOptions,...s},o=(n.fields??e._options.fields).reduce((d,a)=>({...d,[a]:G(n.boost,a)||1}),{}),{boostDocument:r,weights:c,maxFuzzy:i,bm25:h}=n,{fuzzy:u,prefix:l}={...J.weights,...c},f=e._index.get(t.term),m=T(e,t.term,t.term,1,t.termBoost,f,o,r,h);let g,y;if(t.prefix&&(g=e._index.atPrefix(t.term)),t.fuzzy){const d=t.fuzzy===!0?.2:t.fuzzy,a=d<1?Math.min(i,Math.round(t.term.length*d)):d;a&&(y=e._index.fuzzyGet(t.term,a))}if(g)for(const[d,a]of g){const w=d.length-t.term.length;if(!w)continue;y?.delete(d);const p=l*d.length/(d.length+.3*w);T(e,t.term,d,p,t.termBoost,a,o,r,h,m)}if(y)for(const d of y.keys()){const[a,w]=y.get(d);if(!w)continue;const p=u*d.length/(d.length+w);T(e,t.term,d,p,t.termBoost,a,o,r,h,m)}return m},Q=(e,t,s={})=>{if(t===K)return wt(e,s);if(typeof t!="string"){const l={...s,...t,queries:void 0},f=t.queries.map(m=>Q(e,m,l));return U(f,l.combineWith)}const{tokenize:n,processTerm:o,searchOptions:r}=e._options,c={tokenize:n,processTerm:o,...r,...s},{tokenize:i,processTerm:h}=c,u=i(t).flatMap(l=>h(l)).filter(l=>!!l).map(at(c)).map(l=>xt(e,l,c));return U(u,c.combineWith)},X=(e,t,s={})=>{const n=Q(e,t,s),o=[];for(const[r,{score:c,terms:i,match:h}]of n){const u=i.length||1,l={id:e._documentIds.get(r),score:c*u,terms:Object.keys(h),queryTerms:i,match:h};Object.assign(l,e._storedFields.get(r)),(s.filter==null||s.filter(l))&&o.push(l)}return t===K&&s.boostDocument==null&&e._options.searchOptions.boostDocument==null||o.sort(P),o},zt=(e,t,s={})=>{s={...e._options.autoSuggestOptions,...s};const n=new Map;for(const{score:r,terms:c}of X(e,t,s)){const i=c.join(" "),h=n.get(i);h!=null?(h.score+=r,h.count+=1):n.set(i,{score:r,terms:c,count:1})}const o=[];for(const[r,{score:c,terms:i,count:h}]of n)o.push({suggestion:r,terms:i,score:c/h});return o.sort(P),o};class bt{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(t?.fields==null)throw new Error('SlimSearch: option "fields" must be provided');const s=t.autoVacuum==null||t.autoVacuum===!0?yt:t.autoVacuum;this._options={...gt,...t,autoVacuum:s,searchOptions:{...J,...t.searchOptions},autoSuggestOptions:{...pt,...t.autoSuggestOptions}},this._index=new z,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=Y,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[s,n]of this._index){const o={};for(const[r,c]of n)o[r]=Object.fromEntries(c);t.push([s,o])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,version:2}}addFields(t){for(let s=0;s<t.length;s++)this._fieldIds[t[s]]=s}}const vt=e=>new bt(e),kt=({documentCount:e,nextId:t,fieldIds:s,averageFieldLength:n,dirtCount:o,version:r},c)=>{if(r!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const i=vt(c);return i._documentCount=e,i._nextId=t,i._idToShortId=new Map,i._fieldIds=s,i._avgFieldLength=n,i._dirtCount=o??0,i._index=new z,i},It=(e,t)=>{const{index:s,documentIds:n,fieldLength:o,storedFields:r}=e,c=kt(e,t);c._documentIds=M(n),c._fieldLength=M(o),c._storedFields=M(r);for(const[i,h]of c._documentIds)c._idToShortId.set(h,i);for(const[i,h]of s){const u=new Map;for(const l of Object.keys(h))u.set(parseInt(l,10),M(h[l]));c._index.set(i,u)}return c},V=(e,t)=>{const s=e.toLowerCase(),n=t.toLowerCase(),o=[];let r=0,c=0;const i=(u,l=!1)=>{let f;c===0?f=u.length>20?`… ${u.slice(-20)}`:u:l?f=u.length+c>100?`${u.slice(0,100-c)}… `:u:f=u.length>20?`${u.slice(0,20)} … ${u.slice(-20)}`:u,f&&o.push(f),c+=f.length,l||(o.push(["mark",t]),c+=t.length,c>=100&&o.push(" …"))};let h=s.indexOf(n,r);if(h===-1)return null;for(;h>=0;){const u=h+n.length;if(i(e.slice(r,h)),r=u,c>100)break;h=s.indexOf(n,r)}return c<100&&i(e.slice(r),!0),o},Mt=(e,t)=>t.contents.reduce((s,[,n])=>s+n,0)-e.contents.reduce((s,[,n])=>s+n,0),Ot=(e,t)=>Math.max(...t.contents.map(([,s])=>s))-Math.max(...e.contents.map(([,s])=>s)),Z=(e,t,s={})=>{const n={};return X(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...s}).forEach(o=>{const{id:r,terms:c,score:i}=o,h=r.includes("@"),u=r.includes("#"),[l,f]=r.split(/[#@]/),m=Number(l),g=c.sort((d,a)=>d.length-a.length).filter((d,a)=>c.slice(a+1).every(w=>!w.includes(d))),{contents:y}=n[m]??={title:"",contents:[]};if(h)y.push([{type:"customField",id:m,index:f,display:g.map(d=>o.c.map(a=>V(a,d))).flat().filter(d=>d!==null)},i]);else{const d=g.map(a=>V(o.h,a)).filter(a=>a!==null);if(d.length&&y.push([{type:u?"heading":"title",id:m,...u&&{anchor:f},display:d},i]),"t"in o&&o.t)for(const a of o.t){const w=g.map(p=>V(a,p)).filter(p=>p!==null);w.length&&y.push([{type:"text",id:m,...u&&{anchor:f},display:w},i])}}}),$(n).sort(([,o],[,r])=>"max"==="total"?Mt(o,r):Ot(o,r)).map(([o,{title:r,contents:c}])=>{if(!r){const i=rt(t,o);i&&(r=i.h)}return{title:r,contents:c.map(([i])=>i)}})},tt=(e,t,s={})=>{const n=zt(t,e,{fuzzy:.2,maxFuzzy:3,...s}).map(({suggestion:o})=>o);return e.includes(" ")?n:n.filter(o=>!o.includes(" "))},Ct=et($(JSON.parse("{\"/\":{\"documentCount\":916,\"nextId\":916,\"documentIds\":{\"0\":\"0\",\"1\":\"2\",\"2\":\"4\",\"3\":\"4#封装好的结构体\",\"4\":\"4#例子\",\"5\":\"4#阶乘和\",\"6\":\"4#高精度加法\",\"7\":\"4#一种写法\",\"8\":\"4#另一种写法\",\"9\":\"5\",\"10\":\"5#例题\",\"11\":\"5#预处理-祖先\",\"12\":\"5#倍增\",\"13\":\"5#欧拉序-st表\",\"14\":\"5#tarjan-离线-并查集\",\"15\":\"5#树链剖分\",\"16\":\"6\",\"17\":\"6#单点修改、区间查询\",\"18\":\"6#另一种常见的-query\",\"19\":\"6#区间修改、区间查询\",\"20\":\"6#标记永久化\",\"21\":\"6#区间加、区间乘、区间和查询\",\"22\":\"6#动态开点线段树\",\"23\":\"6#查询\",\"24\":\"6#查询-1\",\"25\":\"7\",\"26\":\"7#选择排序\",\"27\":\"7#发现了小的就交换\",\"28\":\"7#找到了最小的之后再交换\",\"29\":\"7#冒泡排序\",\"30\":\"7#插入排序\",\"31\":\"7#计数排序\",\"32\":\"7#地精排序\",\"33\":\"9\",\"34\":\"9#啥是编程\",\"35\":\"9#数字电路\",\"36\":\"9#机器语言\",\"37\":\"9#汇编语言\",\"38\":\"9#高级语言\",\"39\":\"9#_60-点游戏\",\"40\":\"9#算-60-点的程序\",\"41\":\"9#的解\",\"42\":\"9#dev-c\",\"43\":\"9#新建文件\",\"44\":\"9#第一个程序-你好世界\",\"45\":\"9#抓虫-debug\",\"46\":\"9#学会输出\",\"47\":\"9#一些单词\",\"48\":\"9#完整含义\",\"49\":\"9#简单框架\",\"50\":\"9#这段程序会输出什么\",\"51\":\"9#转义符\",\"52\":\"9#cout-语句\",\"53\":\"9#cout-语句-1\",\"54\":\"9#cout-语句-2\",\"55\":\"9#字符串与数学表达式\",\"56\":\"9#啥是字符串\",\"57\":\"9#数学表达式\",\"58\":\"9#数学运算符\",\"59\":\"9#口算训练\",\"60\":\"9#变量与赋值语句\",\"61\":\"9#常见数据类型-变量类型\",\"62\":\"9#变量定义规则-比赛环境\",\"63\":\"9#赋值语句\",\"64\":\"9#语法糖\",\"65\":\"10\",\"66\":\"10#学会输入\",\"67\":\"10#oj-使用\",\"68\":\"10#题目页面\",\"69\":\"10#常见评测结果\",\"70\":\"10#条件判断\",\"71\":\"10#新单词\",\"72\":\"10#比较-关系-运算符\",\"73\":\"10#逻辑运算符\",\"74\":\"10#用户名密码验证\",\"75\":\"10#条件判断语法\",\"76\":\"10#下面代码会输出什么-1\",\"77\":\"10#下面代码会输出什么-2\",\"78\":\"10#下面代码会输出什么-3\",\"79\":\"10#下面代码会输出什么-4\",\"80\":\"10#布尔逻辑体系\",\"81\":\"10#运算符优先级\",\"82\":\"11\",\"83\":\"11#数据类型对应的范围\",\"84\":\"11#整数编码\",\"85\":\"11#基础二进制\",\"86\":\"11#原码、反码、补码\",\"87\":\"11#讨厌的浮点数\",\"88\":\"11#保留-位小数\",\"89\":\"11#方法-1\",\"90\":\"11#方法-2-推荐\",\"91\":\"11#关于四舍五入\",\"92\":\"11#字符与整数的对应转换\",\"93\":\"11#数字字符与对应整数\",\"94\":\"11#大小写字母映射到\",\"95\":\"11#大小写字母之间转换\",\"96\":\"11#其他常见基础操作\",\"97\":\"11#数位分解\",\"98\":\"11#闰年判断\",\"99\":\"11#三角形判断\",\"100\":\"11#上下取整\",\"101\":\"11#类型转换\",\"102\":\"12\",\"103\":\"12#vector-向量、动态数组\",\"104\":\"12#deque-双端队列\",\"105\":\"12#stack-栈\",\"106\":\"12#queue-队列\",\"107\":\"14\",\"108\":\"14#题目\",\"109\":\"14#填表-100-分\",\"110\":\"14#刷表-100-分\",\"111\":\"15\",\"112\":\"16\",\"113\":\"17\",\"114\":\"18\",\"115\":\"18#_60-分\",\"116\":\"18#_100-分\",\"117\":\"19\",\"118\":\"20\",\"119\":\"21\",\"120\":\"22\",\"121\":\"23\",\"122\":\"23#真的修改\",\"123\":\"23#不修改\",\"124\":\"24\",\"125\":\"25\",\"126\":\"26\",\"127\":\"27\",\"128\":\"28\",\"129\":\"29\",\"130\":\"30\",\"131\":\"30#while-循环做法\",\"132\":\"30#for-循环做法\",\"133\":\"31\",\"134\":\"31#不考虑不够用的情况\",\"135\":\"31#利用结束程序的语句\",\"136\":\"31#额外标记实现\",\"137\":\"32\",\"138\":\"33\",\"139\":\"33#_60-分\",\"140\":\"33#_100-分\",\"141\":\"34\",\"142\":\"35\",\"143\":\"36\",\"144\":\"36#_70-分\",\"145\":\"36#_100-分\",\"146\":\"36#写法-1\",\"147\":\"36#写法-2\",\"148\":\"37\",\"149\":\"38\",\"150\":\"38#_50-分\",\"151\":\"38#_100-分\",\"152\":\"39\",\"153\":\"39#位运算写法\",\"154\":\"39#dfs-枚举第一行的写法\",\"155\":\"40\",\"156\":\"40#_55-分\",\"157\":\"40#_100-分\",\"158\":\"41\",\"159\":\"42\",\"160\":\"42#ac-代码\",\"161\":\"42#错误代码\",\"162\":\"43\",\"163\":\"44\",\"164\":\"45\",\"165\":\"46\",\"166\":\"47\",\"167\":\"48\",\"168\":\"49\",\"169\":\"50\",\"170\":\"51\",\"171\":\"52\",\"172\":\"52#_75-分做法\",\"173\":\"52#满分做法\",\"174\":\"52#手动交互器\",\"175\":\"53\",\"176\":\"54\",\"177\":\"55\",\"178\":\"56\",\"179\":\"57\",\"180\":\"58\",\"181\":\"59\",\"182\":\"60\",\"183\":\"61\",\"184\":\"61#next-permutation-50-分\",\"185\":\"61#手写-dfs-暴力枚举-30-分\",\"186\":\"61#优化-1-第三行直接算结果-90-分\",\"187\":\"61#继续优化到满分\",\"188\":\"62\",\"189\":\"63\",\"190\":\"63#简单哈希做法\",\"191\":\"64\",\"192\":\"65\",\"193\":\"66\",\"194\":\"67\",\"195\":\"68\",\"196\":\"69\",\"197\":\"70\",\"198\":\"71\",\"199\":\"72\",\"200\":\"73\",\"201\":\"74\",\"202\":\"74#纯暴力搜索-28-分\",\"203\":\"74#暴力搜索-假贪心-46-分\",\"204\":\"74#dp-100-分\",\"205\":\"75\",\"206\":\"76\",\"207\":\"76#中位数\",\"208\":\"76#【40-分】-的暴力\",\"209\":\"76#【60-分】利用插入排序的\",\"210\":\"76#【100-分】对顶堆的-做法\",\"211\":\"76#【100-分】利用多重集的满分\",\"212\":\"76#【100-分】可以但没必要的利用离散化-数据结构的做法\",\"213\":\"76#直接二分套树状数组-查询。\",\"214\":\"76#查询\",\"215\":\"77\",\"216\":\"78\",\"217\":\"79\",\"218\":\"80\",\"219\":\"81\",\"220\":\"82\",\"221\":\"82#二维数组\",\"222\":\"82#一维数组\",\"223\":\"83\",\"224\":\"83#基础做法\",\"225\":\"83#加强版\",\"226\":\"83#-1\",\"227\":\"84\",\"228\":\"85\",\"229\":\"86\",\"230\":\"86#广搜-1-数字上操作\",\"231\":\"86#广搜-2-真的展开九宫格\",\"232\":\"87\",\"233\":\"88\",\"234\":\"89\",\"235\":\"89#暴力\",\"236\":\"89#树状数组写法\",\"237\":\"89#线段树写法\",\"238\":\"89#树状数组写法-1\",\"239\":\"89#线段树写法-1\",\"240\":\"90\",\"241\":\"90#广搜-递推-最少线段覆盖\",\"242\":\"90#深搜-记忆化搜索-最少线段覆盖\",\"243\":\"91\",\"244\":\"92\",\"245\":\"93\",\"246\":\"94\",\"247\":\"95\",\"248\":\"95#纯暴力-0-分\",\"249\":\"95#满分\",\"250\":\"96\",\"251\":\"97\",\"252\":\"98\",\"253\":\"98#_50-分、基础暴力搜索\",\"254\":\"98#_70-分、基础剪枝\",\"255\":\"98#写法-1\",\"256\":\"98#写法-2\",\"257\":\"98#_100-分、状压-dp\",\"258\":\"99\",\"259\":\"100\",\"260\":\"101\",\"261\":\"102\",\"262\":\"102#_1-无脑-if\",\"263\":\"102#_2-循环代替多层-if\",\"264\":\"102#_3-数位分解计算位数-注意特判-0\",\"265\":\"102#_4-利用字符串流\",\"266\":\"103\",\"267\":\"104\",\"268\":\"105\",\"269\":\"106\",\"270\":\"107\",\"271\":\"108\",\"272\":\"108#递归写法\",\"273\":\"109\",\"274\":\"110\",\"275\":\"111\",\"276\":\"112\",\"277\":\"113\",\"278\":\"113#暴力搜索-32-分\",\"279\":\"113#剪枝-100-分\",\"280\":\"113#状压-dp\",\"281\":\"114\",\"282\":\"114#合并在一起求\",\"283\":\"114#分离分别求-一般不常用\",\"284\":\"114#求模式串的-然后在文本串中匹配-常用\",\"285\":\"115\",\"286\":\"116\",\"287\":\"117\",\"288\":\"118\",\"289\":\"119\",\"290\":\"120\",\"291\":\"120#lazy-标记是否还要开方\",\"292\":\"120#用区间和判断\",\"293\":\"121\",\"294\":\"122\",\"295\":\"122#双端队列广搜\",\"296\":\"122#并查集缩点-广搜\",\"297\":\"122#最短路\",\"298\":\"123\",\"299\":\"124\",\"300\":\"125\",\"301\":\"125#暴力枚举深搜\",\"302\":\"125#优化\",\"303\":\"125#dp\",\"304\":\"126\",\"305\":\"126#爆搜\",\"306\":\"126#状压dp\",\"307\":\"127\",\"308\":\"128\",\"309\":\"128#set-里面遍历\",\"310\":\"128#标准做法\",\"311\":\"129\",\"312\":\"129#离散化-权值线段树做法\",\"313\":\"129#动态开点权值线段树\",\"314\":\"129#动态开点权值线段树-1\",\"315\":\"130\",\"316\":\"131\",\"317\":\"131#_60-分\",\"318\":\"131#_100-分\",\"319\":\"132\",\"320\":\"133\",\"321\":\"134\",\"322\":\"136\",\"323\":\"136#你画我猜\",\"324\":\"136#最长连签\",\"325\":\"136#充电问题\",\"326\":\"136#找子序列\",\"327\":\"136#查找-404\",\"328\":\"136#简化版问题的做法\",\"329\":\"136#本题思路\",\"330\":\"137\",\"331\":\"137#d-santa-claus-2\",\"332\":\"138\",\"333\":\"138#a-happy-new-year-2025\",\"334\":\"138#b-9x9-sum\",\"335\":\"138#c-snake-numbers\",\"336\":\"138#d-snaky-walk\",\"337\":\"139\",\"338\":\"139#d-squares-in-circle\",\"339\":\"140\",\"340\":\"140#e-vitamin-balance\",\"341\":\"141\",\"342\":\"141#d-gravity\",\"343\":\"141#e-hierarchical-majority-vote\",\"344\":\"142\",\"345\":\"142#a-timeout\",\"346\":\"142#b-compression\",\"347\":\"142#普通排序\",\"348\":\"142#计数排序\",\"349\":\"142#c-自带的去重\",\"350\":\"142#c-not-all-covered\",\"351\":\"142#d-flip-to-gather\",\"352\":\"142#e-minimum-or-path\",\"353\":\"143\",\"354\":\"143#a-frog-1\",\"355\":\"143#b-frog-2\",\"356\":\"143#c-vacation\",\"357\":\"143#d-knapsack-1\",\"358\":\"143#递推\",\"359\":\"143#记忆化搜索\",\"360\":\"143#e-knapsack-2\",\"361\":\"143#二维形式\",\"362\":\"143#化掉第一维\",\"363\":\"143#f-lcs\",\"364\":\"143#g-longest-path\",\"365\":\"143#利用记忆化搜索\",\"366\":\"143#利用拓扑排序\",\"367\":\"143#h-grid-1\",\"368\":\"143#i-coins\",\"369\":\"143#j-sushi\",\"370\":\"143#k-stones\",\"371\":\"143#l-deque\",\"372\":\"143#m-candies\",\"373\":\"143#n-slimes\",\"374\":\"143#o-matching\",\"375\":\"143#p-independent-set\",\"376\":\"143#q-flowers\",\"377\":\"143#r-walk\",\"378\":\"143#s-digit-sum\",\"379\":\"143#t-permutation\",\"380\":\"143#满分\",\"381\":\"143#u-grouping\",\"382\":\"143#v-subtree\",\"383\":\"143#不考虑取模的代码提供思路\",\"384\":\"143#满分代码\",\"385\":\"144\",\"386\":\"144#r12a\",\"387\":\"144#r12b\",\"388\":\"144#辗转相减\",\"389\":\"144#辗转相除\",\"390\":\"144#r12c\",\"391\":\"144#链表\",\"392\":\"144#标记权值重新排序\",\"393\":\"144#标记每个数还在不在\",\"394\":\"144#离线处理\",\"395\":\"144#r12d\",\"396\":\"145\",\"397\":\"145#a-不要三个一\",\"398\":\"145#b-猜数字作弊\",\"399\":\"145#_60-分\",\"400\":\"145#满分\",\"401\":\"145#c-再次抓住牛\",\"402\":\"145#_60-分-1\",\"403\":\"145#_100-分\",\"404\":\"145#是否往左一段\",\"405\":\"145#往右狂奔或者折返回到牛\",\"406\":\"145#d-合法哈夫曼\",\"407\":\"145#子任务-1-10-分\",\"408\":\"145#子任务-2-20-分\",\"409\":\"145#子任务-3-30-分\",\"410\":\"145#子任务-4-40-分\",\"411\":\"146\",\"412\":\"146#打草惊蛇\",\"413\":\"146#借尸还魂\",\"414\":\"146#调虎离山\",\"415\":\"146#欲擒姑纵\",\"416\":\"147\",\"417\":\"147#抛砖引玉\",\"418\":\"147#擒贼擒王\",\"419\":\"147#釜底抽薪\",\"420\":\"147#混水摸鱼\",\"421\":\"147#子任务-2\",\"422\":\"147#_60-分\",\"423\":\"147#_100-分\",\"424\":\"148\",\"425\":\"148#金蝉脱壳\",\"426\":\"148#关门捉贼\",\"427\":\"148#远交近攻\",\"428\":\"148#假道伐虢\",\"429\":\"149\",\"430\":\"149#偷梁换柱\",\"431\":\"149#指桑骂槐\",\"432\":\"149#假痴不癫\",\"433\":\"149#上屋抽梯\",\"434\":\"150\",\"435\":\"150#树上开花\",\"436\":\"150#反客为主\",\"437\":\"150#美人计\",\"438\":\"150#空城计\",\"439\":\"151\",\"440\":\"151#反间计\",\"441\":\"151#苦肉计\",\"442\":\"151#连环计\",\"443\":\"151#_60-分搜索\",\"444\":\"151#_100-分\",\"445\":\"151#走为上\",\"446\":\"151#子任务-2\",\"447\":\"151#子任务-3\",\"448\":\"151#_100-分-1\",\"449\":\"152\",\"450\":\"152#水浒\",\"451\":\"152#三国\",\"452\":\"152#西游\",\"453\":\"152#红楼\",\"454\":\"153\",\"455\":\"153#月名排序\",\"456\":\"153#第一是谁\",\"457\":\"153#随机重复\",\"458\":\"153#三三音乐\",\"459\":\"154\",\"460\":\"154#神好清-而心扰之\",\"461\":\"154#心好静-而欲牵之\",\"462\":\"154#遣其欲-而心自静\",\"463\":\"154#澄其心-而神自清\",\"464\":\"154#_10-分\",\"465\":\"154#_30-分\",\"466\":\"154#_60-分\",\"467\":\"154#_100-分\",\"468\":\"155\",\"469\":\"155#延迟罐罐\",\"470\":\"155#圈个矩形\",\"471\":\"155#因式分解\",\"472\":\"155#无敌闯关\",\"473\":\"155#_30-分\",\"474\":\"155#_60-分\",\"475\":\"155#_100-分\",\"476\":\"156\",\"477\":\"156#达标率比拼\",\"478\":\"156#区间开方和\",\"479\":\"156#多少种得分\",\"480\":\"156#拉多少个群\",\"481\":\"157\",\"482\":\"157#猫咪几岁\",\"483\":\"157#不进位加\",\"484\":\"157#逢七上学\",\"485\":\"157#踏遍线段\",\"486\":\"158\",\"487\":\"158#瞒天过海\",\"488\":\"158#围魏救赵\",\"489\":\"158#借刀杀人\",\"490\":\"158#以逸待劳\",\"491\":\"159\",\"492\":\"159#趁火打劫\",\"493\":\"159#声东击西\",\"494\":\"159#无中生有\",\"495\":\"159#暗渡陈仓\",\"496\":\"160\",\"497\":\"160#隔岸观火\",\"498\":\"160#笑里藏刀\",\"499\":\"160#李代桃僵\",\"500\":\"160#顺手牵羊\",\"501\":\"162\",\"502\":\"162#卖水果\",\"503\":\"162#算得分\",\"504\":\"162#wotojo\",\"505\":\"162#三子棋\",\"506\":\"163\",\"507\":\"163#a-b-b\",\"508\":\"163#abba\",\"509\":\"163#环状字符串\",\"510\":\"164\",\"511\":\"164#a-骰子比大小\",\"512\":\"164#分析\",\"513\":\"164#满分参考代码\",\"514\":\"164#b-停车场收费\",\"515\":\"164#分析-1\",\"516\":\"164#满分参考代码-1\",\"517\":\"164#c-单词排排序\",\"518\":\"164#分析-2\",\"519\":\"164#满分参考代码-2\",\"520\":\"164#d-登记排行榜\",\"521\":\"164#分析-3\",\"522\":\"164#满分参考代码-3\",\"523\":\"165\",\"524\":\"165#温暖的签到题001\",\"525\":\"165#温暖的签到题002\",\"526\":\"165#温暖的签到题003\",\"527\":\"165#温暖的签到题004\",\"528\":\"166\",\"529\":\"166#a-时区转换\",\"530\":\"166#分析\",\"531\":\"166#满分参考代码\",\"532\":\"166#b-每数一位\",\"533\":\"166#分析-1\",\"534\":\"166#分参考代码\",\"535\":\"166#满分参考代码-1\",\"536\":\"166#c-数串质数\",\"537\":\"166#分析-2\",\"538\":\"166#满分参考代码-1-1\",\"539\":\"166#满分参考代码-2\",\"540\":\"166#d-四数转盘\",\"541\":\"166#分析-3\",\"542\":\"166#满分参考代码-3\",\"543\":\"167\",\"544\":\"167#tooy0ung-的数字游戏\",\"545\":\"167#tooy0ung-的美食之旅\",\"546\":\"167#tooy0ung-的-wronganswer\",\"547\":\"167#tooy0ung-的等差数列\",\"548\":\"168\",\"549\":\"168#a-喜欢开方的-33dai\",\"550\":\"168#分析\",\"551\":\"168#满分参考代码\",\"552\":\"168#b-喜欢除法的-tooy0ung\",\"553\":\"168#分析-1\",\"554\":\"168#满分参考代码-1\",\"555\":\"168#c-玩字符串的-didi\",\"556\":\"168#分析-2\",\"557\":\"168#满分参考代码-2\",\"558\":\"168#d-随意发糖的-leez\",\"559\":\"168#分析-3\",\"560\":\"168#满分参考代码-3\",\"561\":\"169\",\"562\":\"169#从大到小吗\",\"563\":\"169#谁赢了\",\"564\":\"169#奇数还是偶数\",\"565\":\"169#tooy0ung的等差数列2-0\",\"566\":\"170\",\"567\":\"170#a-wotojo-型字符串\",\"568\":\"170#分析\",\"569\":\"170#满分参考代码\",\"570\":\"170#b-疯疯疯狂星期四\",\"571\":\"170#分析-1\",\"572\":\"170#满分参考代码-1\",\"573\":\"170#c-tooy0ung的wronganswer-2-0\",\"574\":\"170#分析-2\",\"575\":\"170#满分参考代码1\",\"576\":\"170#满分参考代码2\",\"577\":\"170#d-坏掉的数码管\",\"578\":\"170#分析-3\",\"579\":\"170#满分参考代码-2\",\"580\":\"171\",\"581\":\"171#a-整型溢出\",\"582\":\"171#分析\",\"583\":\"171#满分参考代码\",\"584\":\"171#b-i-的-i-次方\",\"585\":\"171#分析-1\",\"586\":\"171#满分参考代码-1\",\"587\":\"171#c-顺子\",\"588\":\"171#分析-2\",\"589\":\"171#满分参考代码-2\",\"590\":\"171#d-偶数位的数\",\"591\":\"171#分析-3\",\"592\":\"171#满分参考代码-3\",\"593\":\"172\",\"594\":\"172#a-高兴\",\"595\":\"172#分析\",\"596\":\"172#满分参考代码\",\"597\":\"172#b-考试\",\"598\":\"172#分析-1\",\"599\":\"172#满分参考代码-1\",\"600\":\"172#c-加速\",\"601\":\"172#分析-2\",\"602\":\"172#满分参考代码-2\",\"603\":\"172#d-油箱\",\"604\":\"172#分析-3\",\"605\":\"172#满分参考代码-3\",\"606\":\"173\",\"607\":\"173#a-三位数重新排列\",\"608\":\"173#分析\",\"609\":\"173#满分参考代码\",\"610\":\"173#b-千钱买千鸡\",\"611\":\"173#分析-1\",\"612\":\"173#满分参考代码-1\",\"613\":\"173#c-前后洗牌\",\"614\":\"173#分析-2\",\"615\":\"173#满分参考代码-2\",\"616\":\"173#d-一维分形图\",\"617\":\"173#分析-3\",\"618\":\"173#满分参考代码-3\",\"619\":\"174\",\"620\":\"174#凑数\",\"621\":\"174#开三方\",\"622\":\"174#比大小\",\"623\":\"174#吃桃子\",\"624\":\"175\",\"625\":\"175#a-编号第几小的思维场-t1\",\"626\":\"175#分析\",\"627\":\"175#满分参考代码\",\"628\":\"175#b-小猫向日葵\",\"629\":\"175#分析-1\",\"630\":\"175#满分参考代码-1\",\"631\":\"175#c-乒乓球\",\"632\":\"175#题解\",\"633\":\"175#满分参考代码-2\",\"634\":\"175#d-分糖果\",\"635\":\"175#题解-1\",\"636\":\"175#满分参考代码-3\",\"637\":\"176\",\"638\":\"176#a-计算-bmi\",\"639\":\"176#分析\",\"640\":\"176#满分参考代码\",\"641\":\"176#b-零碎文件占用大小\",\"642\":\"176#分析-1\",\"643\":\"176#满分参考代码-1\",\"644\":\"176#c-科学记数法\",\"645\":\"176#分析-2\",\"646\":\"176#满分参考代码-2\",\"647\":\"176#d-变大变大变成回文数\",\"648\":\"176#分析-3\",\"649\":\"176#满分参考代码-3\",\"650\":\"177\",\"651\":\"177#a-测试三位数\",\"652\":\"177#分析\",\"653\":\"177#满分参考代码\",\"654\":\"177#b-猜三位数\",\"655\":\"177#分析-1\",\"656\":\"177#满分参考代码-1\",\"657\":\"177#c-子串取模\",\"658\":\"177#分析-2\",\"659\":\"177#满分参考代码-2\",\"660\":\"177#d-k-的倍数或个位是-k\",\"661\":\"177#分析-3\",\"662\":\"177#满分参考代码-3\",\"663\":\"178\",\"664\":\"178#a-课间休息时间设置\",\"665\":\"178#分析\",\"666\":\"178#满分参考代码\",\"667\":\"178#b-游泳同步起步\",\"668\":\"178#分析-1\",\"669\":\"178#满分参考代码-1\",\"670\":\"178#c-比大小-plus\",\"671\":\"178#分析-2\",\"672\":\"178#满分参考代码-2\",\"673\":\"178#d-小数独验证\",\"674\":\"178#分析-3\",\"675\":\"178#满分参考代码-3\",\"676\":\"179\",\"677\":\"179#a-mb-还是-mib\",\"678\":\"179#分析\",\"679\":\"179#满分参考代码\",\"680\":\"179#b-优化代码-2\",\"681\":\"179#分析-1\",\"682\":\"179#满分参考代码-1\",\"683\":\"179#c-比大小-pro\",\"684\":\"179#分析-2\",\"685\":\"179#满分参考代码-2\",\"686\":\"179#d-按行排序按列排序\",\"687\":\"179#分析-3\",\"688\":\"179#满分参考代码-3\",\"689\":\"180\",\"690\":\"180#a-wyh-问题目名叫啥\",\"691\":\"180#分析\",\"692\":\"180#满分参考代码\",\"693\":\"180#b-惠子相梁\",\"694\":\"180#分析-1\",\"695\":\"180#满分参考代码-1\",\"696\":\"180#c-文件-io\",\"697\":\"180#分析-2\",\"698\":\"180#满分参考代码-2\",\"699\":\"180#d-26-59-s\",\"700\":\"180#分析-3\",\"701\":\"180#满分参考代码-3\",\"702\":\"181\",\"703\":\"181#a-等差数列变化求和\",\"704\":\"181#分析\",\"705\":\"181#满分参考代码\",\"706\":\"181#b-停车费计算\",\"707\":\"181#分析-1\",\"708\":\"181#满分参考代码-1\",\"709\":\"181#c-复制画作\",\"710\":\"181#分析-2\",\"711\":\"181#满分参考代码-2\",\"712\":\"181#d-计算补码\",\"713\":\"181#分析-3\",\"714\":\"181#满分参考代码-3\",\"715\":\"182\",\"716\":\"182#a-33dai-的数字游戏\",\"717\":\"182#分析\",\"718\":\"182#满分参考代码\",\"719\":\"182#b-第三大的数\",\"720\":\"182#分析-1\",\"721\":\"182#满分参考代码-1\",\"722\":\"182#c-曼哈顿圆圈\",\"723\":\"182#分析-2\",\"724\":\"182#满分参考代码-2\",\"725\":\"182#d-朋友平均有几个朋友\",\"726\":\"182#分析-3\",\"727\":\"182#满分参考代码-3\",\"728\":\"183\",\"729\":\"183#p-除以-q\",\"730\":\"183#根号-x\",\"731\":\"183#提交文件夹\",\"732\":\"183#乌龟对对碰\",\"733\":\"184\",\"734\":\"184#a-初赛估分\",\"735\":\"184#b-第-n-个质数\",\"736\":\"184#c-连续打卡与累计打卡\",\"737\":\"184#d-冒泡排序步骤\",\"738\":\"185\",\"739\":\"185#算利润\",\"740\":\"185#星星历\",\"741\":\"185#简单系动词\",\"742\":\"185#唱跳-rap\",\"743\":\"186\",\"744\":\"186#a-粗心的-33dai\",\"745\":\"186#b-a-b-c-d\",\"746\":\"186#c-二进制小数\",\"747\":\"186#d-争先红葫芦\",\"748\":\"187\",\"749\":\"187#今年比赛有没有三等奖\",\"750\":\"187#题解\",\"751\":\"187#参考代码\",\"752\":\"187#公差等差的等差数列们\",\"753\":\"187#题解-1\",\"754\":\"187#参考代码-1\",\"755\":\"187#有几个不重叠的三十三\",\"756\":\"187#题解-2\",\"757\":\"187#参考代码-2\",\"758\":\"187#一道非常简单的排序题\",\"759\":\"187#题解-3\",\"760\":\"187#参考代码-3\",\"761\":\"188\",\"762\":\"188#_33dai-的扑克牌\",\"763\":\"188#题解\",\"764\":\"188#参考代码\",\"765\":\"188#_33dai-的地图探险\",\"766\":\"188#题解-1\",\"767\":\"188#参考代码-1\",\"768\":\"188#_33dai-的小木棍\",\"769\":\"188#题解-2\",\"770\":\"188#参考代码-2\",\"771\":\"188#_33dai-的接龙\",\"772\":\"188#题解-3\",\"773\":\"188#参考代码-3\",\"774\":\"189\",\"775\":\"189#_33dai-的决斗\",\"776\":\"189#题解\",\"777\":\"189#参考代码\",\"778\":\"189#_33dai-的擂台游戏\",\"779\":\"189#题解-1\",\"780\":\"189#参考代码-1\",\"781\":\"189#_33dai-的染色\",\"782\":\"189#题解-2\",\"783\":\"189#参考代码-2\",\"784\":\"189#_33dai-的超速检测\",\"785\":\"189#题解-3\",\"786\":\"189#参考代码-3\",\"787\":\"190\",\"788\":\"190#算出了几个i9\",\"789\":\"190#题解\",\"790\":\"190#参考代码\",\"791\":\"190#分解了一个整数\",\"792\":\"190#题解-1\",\"793\":\"190#参考代码-1\",\"794\":\"190#压缩了一篇文章\",\"795\":\"190#题解-2\",\"796\":\"190#参考代码-2\",\"797\":\"190#发放了多少硬币\",\"798\":\"190#题解-3\",\"799\":\"190#参考代码-3\",\"800\":\"191\",\"801\":\"191#三次方或三的幂\",\"802\":\"191#几个子区间合法\",\"803\":\"191#二分做法\",\"804\":\"191#枚举做法\",\"805\":\"191#字符串有几个洞\",\"806\":\"191#切了又切的纸牌\",\"807\":\"192\",\"808\":\"192#a-点外卖\",\"809\":\"192#分析\",\"810\":\"192#满分参考代码\",\"811\":\"192#b-优化代码\",\"812\":\"192#分析-1\",\"813\":\"192#满分参考代码-1\",\"814\":\"192#c-unrank\",\"815\":\"192#分析-2\",\"816\":\"192#满分参考代码-2\",\"817\":\"192#d-最大逆序对和\",\"818\":\"192#分析-3\",\"819\":\"192#满分参考代码-3\",\"820\":\"193\",\"821\":\"193#a-起床时间\",\"822\":\"193#分析\",\"823\":\"193#满分参考代码\",\"824\":\"193#b-联合-chatgpt\",\"825\":\"193#分析-1\",\"826\":\"193#满分参考代码-1\",\"827\":\"193#c-摩斯电码数数\",\"828\":\"193#分析-2\",\"829\":\"193#满分参考代码-2\",\"830\":\"193#d-校门外好多树\",\"831\":\"193#分析-3\",\"832\":\"193#满分参考代码-3\",\"833\":\"194\",\"834\":\"194#a-桃园南路上的红绿灯\",\"835\":\"194#分析\",\"836\":\"194#满分参考代码\",\"837\":\"194#b-不太随机的随机数列\",\"838\":\"194#分析-1\",\"839\":\"194#满分参考代码-1\",\"840\":\"194#c-假装在洗一副扑克牌\",\"841\":\"194#分析-2\",\"842\":\"194#满分参考代码-2\",\"843\":\"194#李知颖的满分代码\",\"844\":\"194#有趣的递归形式实现逆序输出\",\"845\":\"194#d-可持久化入门之数对\",\"846\":\"194#分析-3\",\"847\":\"194#满分参考代码-3\",\"848\":\"195\",\"849\":\"195#a-难or易\",\"850\":\"195#分析\",\"851\":\"195#满分参考代码\",\"852\":\"195#b-好or坏\",\"853\":\"195#分析-1\",\"854\":\"195#满分参考代码-1\",\"855\":\"195#c-读or过\",\"856\":\"195#分析-2\",\"857\":\"195#满分参考代码-2\",\"858\":\"195#d-缺or满\",\"859\":\"195#分析-3\",\"860\":\"195#满分参考代码-3\",\"861\":\"196\",\"862\":\"196#a-红色警戒\",\"863\":\"196#分析\",\"864\":\"196#满分参考代码\",\"865\":\"196#b-有趣的-运算\",\"866\":\"196#分析-1\",\"867\":\"196#满分参考代码-1\",\"868\":\"196#做法-1\",\"869\":\"196#做法-2\",\"870\":\"196#c-比赛的获奖规则\",\"871\":\"196#分析-2\",\"872\":\"196#满分参考代码-2\",\"873\":\"196#d-真的是毒瘤题吗\",\"874\":\"196#分析-3\",\"875\":\"196#满分参考代码-3\",\"876\":\"197\",\"877\":\"197#a-王老师的新水杯\",\"878\":\"197#分析\",\"879\":\"197#满分参考代码\",\"880\":\"197#b-代老师骑行健身\",\"881\":\"197#分析-1\",\"882\":\"197#满分参考代码-1\",\"883\":\"197#c-数数放了几天假\",\"884\":\"197#分析-2\",\"885\":\"197#满分参考代码-2\",\"886\":\"197#d-再整理一次水杯\",\"887\":\"197#分析-3\",\"888\":\"197#满分参考代码-3\",\"889\":\"199\",\"890\":\"199#a-a乘b小于c吗\",\"891\":\"199#分析\",\"892\":\"199#满分参考代码\",\"893\":\"199#b-jonny-办比赛\",\"894\":\"199#分析-1\",\"895\":\"199#满分参考代码-1\",\"896\":\"199#c-分帽子\",\"897\":\"199#分析-2\",\"898\":\"199#满分参考代码-2\",\"899\":\"199#d-tooy0ung的16位内存系统\",\"900\":\"199#分析-3\",\"901\":\"199#满分参考代码-3\",\"902\":\"199#tooy0ung-的代码\",\"903\":\"199#e-tooy0ung的数学简单题\",\"904\":\"199#分析-4\",\"905\":\"199#满分参考代码-4\",\"906\":\"199#tooy0ung-的代码-1\",\"907\":\"199#王彬铸的代码\",\"908\":\"199#f-tooy0ung的贪吃蛇\",\"909\":\"199#分析-5\",\"910\":\"199#满分参考代码-5\",\"911\":\"199#tooy0ung-的代码-2\",\"912\":\"200\",\"913\":\"201\",\"914\":\"202\",\"915\":\"203\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,5],\"1\":[1,1],\"2\":[1],\"3\":[1,113],\"4\":[1],\"5\":[1,22],\"6\":[1],\"7\":[1,18],\"8\":[1,16],\"9\":[1],\"10\":[1,7],\"11\":[2,64],\"12\":[1,83],\"13\":[1,96],\"14\":[3,77],\"15\":[1,76],\"16\":[1],\"17\":[2,58],\"18\":[2,25],\"19\":[2,83],\"20\":[1,80],\"21\":[3,87],\"22\":[1,6],\"23\":[1,71],\"24\":[1,26],\"25\":[1],\"26\":[1],\"27\":[1,34],\"28\":[1],\"29\":[1,34],\"30\":[1,34],\"31\":[1,34],\"32\":[1,36],\"33\":[1],\"34\":[2],\"35\":[1],\"36\":[1,6],\"37\":[1,9],\"38\":[1,10],\"39\":[2,4],\"40\":[3,74],\"41\":[1,9],\"42\":[2],\"43\":[1],\"44\":[3],\"45\":[3],\"46\":[1,16],\"47\":[1,31],\"48\":[1,22],\"49\":[1,13],\"50\":[2,16],\"51\":[1,1],\"52\":[1,17],\"53\":[1,17],\"54\":[1,18],\"55\":[1,6],\"56\":[2,7],\"57\":[1,18],\"58\":[1,21],\"59\":[1,20],\"60\":[1,20],\"61\":[2,31],\"62\":[3,26],\"63\":[1,24],\"64\":[1,32],\"65\":[1],\"66\":[1,31],\"67\":[2,5],\"68\":[1],\"69\":[1,16],\"70\":[1,36],\"71\":[1,4],\"72\":[3,12],\"73\":[1,11],\"74\":[1,32],\"75\":[1,6],\"76\":[3,10],\"77\":[3,11],\"78\":[3,15],\"79\":[3,14],\"80\":[1,28],\"81\":[1,25],\"82\":[1],\"83\":[1,58],\"84\":[1],\"85\":[1,20],\"86\":[3,13],\"87\":[1],\"88\":[2],\"89\":[2,12],\"90\":[4,15],\"91\":[1,41],\"92\":[1,5],\"93\":[1,16],\"94\":[1,17],\"95\":[1,8],\"96\":[1],\"97\":[1,11],\"98\":[1,15],\"99\":[1,6],\"100\":[1,16],\"101\":[1,30],\"102\":[1,3],\"103\":[4,41],\"104\":[3,28],\"105\":[3,18],\"106\":[3,20],\"107\":[1],\"108\":[1,9],\"109\":[3,89],\"110\":[3,83],\"111\":[1,40],\"112\":[3,46],\"113\":[1,51],\"114\":[1],\"115\":[2,57],\"116\":[2,66],\"117\":[1,61],\"118\":[1,36],\"119\":[1,50],\"120\":[1,50],\"121\":[1],\"122\":[1,55],\"123\":[1,63],\"124\":[1,51],\"125\":[1,68],\"126\":[1,84],\"127\":[1,86],\"128\":[1,70],\"129\":[1,52],\"130\":[1],\"131\":[2,38],\"132\":[2,36],\"133\":[1],\"134\":[1,37],\"135\":[1,43],\"136\":[1,49],\"137\":[3,60],\"138\":[1],\"139\":[2,59],\"140\":[2,75],\"141\":[8,70],\"142\":[7,68],\"143\":[1],\"144\":[2,70],\"145\":[2],\"146\":[2,108],\"147\":[2,94],\"148\":[1,56],\"149\":[1],\"150\":[2,62],\"151\":[2,72],\"152\":[1],\"153\":[1,52],\"154\":[2,79],\"155\":[3],\"156\":[2,63],\"157\":[2,70],\"158\":[3,94],\"159\":[1],\"160\":[2,86],\"161\":[1,63],\"162\":[1,72],\"163\":[4,65],\"164\":[3,89],\"165\":[3,60],\"166\":[3,62],\"167\":[3,76],\"168\":[3,70],\"169\":[3,78],\"170\":[3,62],\"171\":[3],\"172\":[2,58],\"173\":[1,72],\"174\":[1,41],\"175\":[4,44],\"176\":[5,60],\"177\":[4,48],\"178\":[4,61],\"179\":[4,73],\"180\":[4,48],\"181\":[2,77],\"182\":[4,100],\"183\":[4],\"184\":[2,62],\"185\":[5,75],\"186\":[6,84],\"187\":[1,76],\"188\":[4,47],\"189\":[3],\"190\":[1,59],\"191\":[1,48],\"192\":[5,85],\"193\":[5,66],\"194\":[5,53],\"195\":[5,81],\"196\":[5,181],\"197\":[5,65],\"198\":[5,156],\"199\":[5,79],\"200\":[1,65],\"201\":[1],\"202\":[4,78],\"203\":[4,97],\"204\":[4,81],\"205\":[1,53],\"206\":[1],\"207\":[1],\"208\":[4,48],\"209\":[4,52],\"210\":[5,51],\"211\":[4,55],\"212\":[4,3],\"213\":[3,67],\"214\":[1,69],\"215\":[3,93],\"216\":[3,95],\"217\":[6,54],\"218\":[3,58],\"219\":[1,70],\"220\":[1],\"221\":[1,58],\"222\":[1,58],\"223\":[4,1],\"224\":[1,52],\"225\":[1,67],\"226\":[1,71],\"227\":[4,49],\"228\":[1,70],\"229\":[1],\"230\":[4,62],\"231\":[4,63],\"232\":[3,57],\"233\":[3,66],\"234\":[1],\"235\":[1,59],\"236\":[1,89],\"237\":[1,105],\"238\":[1,1],\"239\":[1,102],\"240\":[4],\"241\":[1,108],\"242\":[1,93],\"243\":[1,48],\"244\":[1,67],\"245\":[1,58],\"246\":[1,93],\"247\":[1],\"248\":[3,70],\"249\":[1,78],\"250\":[1,59],\"251\":[1,61],\"252\":[3],\"253\":[3,55],\"254\":[3],\"255\":[2,44],\"256\":[2,54],\"257\":[4,63],\"258\":[1,68],\"259\":[4,124],\"260\":[4,83],\"261\":[1],\"262\":[3,73],\"263\":[3,52],\"264\":[5,52],\"265\":[2,43],\"266\":[3,76],\"267\":[3,86],\"268\":[1,81],\"269\":[1,55],\"270\":[3,84],\"271\":[1,1],\"272\":[1,44],\"273\":[4,66],\"274\":[4,54],\"275\":[7,59],\"276\":[7,77],\"277\":[7],\"278\":[3,47],\"279\":[3,48],\"280\":[2,65],\"281\":[3],\"282\":[1,54],\"283\":[3,64],\"284\":[4,58],\"285\":[3,70],\"286\":[3,72],\"287\":[4,59],\"288\":[4,47],\"289\":[1,65],\"290\":[3],\"291\":[2,77],\"292\":[1,68],\"293\":[5,64],\"294\":[9],\"295\":[1,82],\"296\":[1],\"297\":[1],\"298\":[4,83],\"299\":[3,46],\"300\":[1],\"301\":[1,58],\"302\":[1,58],\"303\":[1,51],\"304\":[2],\"305\":[1,64],\"306\":[1,87],\"307\":[4,81],\"308\":[4],\"309\":[1,52],\"310\":[1,54],\"311\":[3],\"312\":[1,99],\"313\":[1,132],\"314\":[1,99],\"315\":[5],\"316\":[5],\"317\":[2,55],\"318\":[2,69],\"319\":[4,68],\"320\":[6,74],\"321\":[5,103],\"322\":[5],\"323\":[1,24],\"324\":[1,43],\"325\":[1,49],\"326\":[1,45],\"327\":[2],\"328\":[1,36],\"329\":[1,104],\"330\":[1],\"331\":[4,73],\"332\":[1],\"333\":[5,25],\"334\":[3,38],\"335\":[3,94],\"336\":[3,74],\"337\":[1],\"338\":[4,43],\"339\":[1],\"340\":[3,93],\"341\":[1],\"342\":[2,72],\"343\":[4,73],\"344\":[1],\"345\":[2,37],\"346\":[2,9],\"347\":[1,42],\"348\":[1,42],\"349\":[2,48],\"350\":[4,49],\"351\":[4,79],\"352\":[4,84],\"353\":[5],\"354\":[3,46],\"355\":[3,47],\"356\":[2,41],\"357\":[3],\"358\":[1,51],\"359\":[1,54],\"360\":[3],\"361\":[1,49],\"362\":[1,59],\"363\":[2,47],\"364\":[3],\"365\":[1,50],\"366\":[1,70],\"367\":[3,45],\"368\":[2,47],\"369\":[2,54],\"370\":[2,47],\"371\":[2,47],\"372\":[2,50],\"373\":[2,49],\"374\":[2,55],\"375\":[3,54],\"376\":[2,48],\"377\":[2,70],\"378\":[3,59],\"379\":[2,43],\"380\":[1,42],\"381\":[2,54],\"382\":[2],\"383\":[1,61],\"384\":[1,72],\"385\":[1],\"386\":[1,32],\"387\":[1],\"388\":[1,36],\"389\":[1,36],\"390\":[1],\"391\":[1,45],\"392\":[1,44],\"393\":[1,44],\"394\":[1,43],\"395\":[1,61],\"396\":[6],\"397\":[2,62],\"398\":[2],\"399\":[2,73],\"400\":[1,77],\"401\":[2,4],\"402\":[2,91],\"403\":[2,19],\"404\":[1,19],\"405\":[1,97],\"406\":[2,23],\"407\":[5,10],\"408\":[5,6],\"409\":[5,13],\"410\":[5,116],\"411\":[6],\"412\":[1,53],\"413\":[1,110],\"414\":[1,90],\"415\":[1,102],\"416\":[6],\"417\":[1,53],\"418\":[1,53],\"419\":[1,59],\"420\":[1,8],\"421\":[2,82],\"422\":[2,91],\"423\":[2,92],\"424\":[6],\"425\":[1,50],\"426\":[1,58],\"427\":[1,68],\"428\":[1,82],\"429\":[6],\"430\":[1,45],\"431\":[1,52],\"432\":[1,60],\"433\":[1,66],\"434\":[6],\"435\":[1,53],\"436\":[1,68],\"437\":[1,92],\"438\":[1,91],\"439\":[6],\"440\":[1,50],\"441\":[1,52],\"442\":[1,13],\"443\":[2,73],\"444\":[2,124],\"445\":[1,33],\"446\":[2,46],\"447\":[2,65],\"448\":[2,47],\"449\":[6,2],\"450\":[1,43],\"451\":[1,55],\"452\":[1,45],\"453\":[1,118],\"454\":[6,7],\"455\":[1,52],\"456\":[1,57],\"457\":[1,72],\"458\":[1,73],\"459\":[6],\"460\":[2,44],\"461\":[2,49],\"462\":[2,66],\"463\":[2],\"464\":[2,52],\"465\":[2,71],\"466\":[2,57],\"467\":[2,59],\"468\":[6],\"469\":[1,30],\"470\":[1,40],\"471\":[1,60],\"472\":[1,5],\"473\":[2,47],\"474\":[2,4],\"475\":[2,93],\"476\":[6],\"477\":[1,61],\"478\":[1,84],\"479\":[1,50],\"480\":[1,84],\"481\":[6],\"482\":[1,35],\"483\":[1,58],\"484\":[1,533],\"485\":[1,79],\"486\":[6],\"487\":[1,49],\"488\":[1,61],\"489\":[1,61],\"490\":[1,70],\"491\":[6],\"492\":[1,54],\"493\":[1,64],\"494\":[1,97],\"495\":[1,86],\"496\":[6],\"497\":[1,54],\"498\":[1,51],\"499\":[1,69],\"500\":[1,80],\"501\":[4],\"502\":[1,57],\"503\":[1,67],\"504\":[1,74],\"505\":[1,90],\"506\":[4],\"507\":[1,52],\"508\":[1,45],\"509\":[1,97],\"510\":[4],\"511\":[2],\"512\":[1,23],\"513\":[1,49],\"514\":[2],\"515\":[1,31],\"516\":[1,66],\"517\":[2],\"518\":[1,32],\"519\":[1,50],\"520\":[2],\"521\":[1,26],\"522\":[1,44],\"523\":[4],\"524\":[1,47],\"525\":[1,63],\"526\":[1,64],\"527\":[1,88],\"528\":[4],\"529\":[2],\"530\":[1,42],\"531\":[1,41],\"532\":[2],\"533\":[1,30],\"534\":[1,37],\"535\":[1,26],\"536\":[2],\"537\":[1,26],\"538\":[2,47],\"539\":[2,44],\"540\":[2],\"541\":[1,36],\"542\":[1,52],\"543\":[4],\"544\":[2,48],\"545\":[2,60],\"546\":[3,59],\"547\":[2,23],\"548\":[4],\"549\":[3],\"550\":[1,30],\"551\":[1,49],\"552\":[3],\"553\":[1,26],\"554\":[1,27],\"555\":[3],\"556\":[1,38],\"557\":[1,48],\"558\":[3],\"559\":[1,26],\"560\":[1,51],\"561\":[4],\"562\":[2,39],\"563\":[2,49],\"564\":[2,43],\"565\":[2,66],\"566\":[4],\"567\":[3],\"568\":[1,23],\"569\":[1,29],\"570\":[2],\"571\":[1,21],\"572\":[1,56],\"573\":[4],\"574\":[1,46],\"575\":[1,113],\"576\":[1,83],\"577\":[2],\"578\":[1,38],\"579\":[1,62],\"580\":[4],\"581\":[2],\"582\":[1,23],\"583\":[1,28],\"584\":[4],\"585\":[1,15],\"586\":[1,29],\"587\":[2],\"588\":[1,20],\"589\":[1,33],\"590\":[2],\"591\":[1,23],\"592\":[1,35],\"593\":[4],\"594\":[2],\"595\":[1,31],\"596\":[1,31],\"597\":[2],\"598\":[1,20],\"599\":[1,60],\"600\":[2],\"601\":[1,24],\"602\":[1,40],\"603\":[2],\"604\":[1,25],\"605\":[1,52],\"606\":[4],\"607\":[2],\"608\":[1,24],\"609\":[1,27],\"610\":[2],\"611\":[1,31],\"612\":[1,35],\"613\":[2],\"614\":[1,21],\"615\":[1,29],\"616\":[2],\"617\":[1,13],\"618\":[1,39],\"619\":[4],\"620\":[1,31],\"621\":[1,37],\"622\":[1,88],\"623\":[1,74],\"624\":[4],\"625\":[3],\"626\":[1,25],\"627\":[1,31],\"628\":[2],\"629\":[1,23],\"630\":[1,75],\"631\":[2],\"632\":[1,33],\"633\":[1,95],\"634\":[2],\"635\":[1,9],\"636\":[1,66],\"637\":[4],\"638\":[3],\"639\":[1,20],\"640\":[1,26],\"641\":[2],\"642\":[1,24],\"643\":[1,29],\"644\":[2],\"645\":[1,33],\"646\":[1,34],\"647\":[2],\"648\":[1,19],\"649\":[1,40],\"650\":[4],\"651\":[2],\"652\":[1,21],\"653\":[1,33],\"654\":[2],\"655\":[1,30],\"656\":[1,44],\"657\":[2],\"658\":[1,36],\"659\":[1,33],\"660\":[3],\"661\":[1,40],\"662\":[1,48],\"663\":[4],\"664\":[2],\"665\":[1,36],\"666\":[1,27],\"667\":[2],\"668\":[1,51],\"669\":[1,28],\"670\":[3],\"671\":[1,25],\"672\":[1,42],\"673\":[2],\"674\":[1,15],\"675\":[1,44],\"676\":[4],\"677\":[5],\"678\":[1,14],\"679\":[1,33],\"680\":[3],\"681\":[1,9],\"682\":[1,30],\"683\":[3],\"684\":[1,9],\"685\":[1,49],\"686\":[2],\"687\":[1,9],\"688\":[1,39],\"689\":[4],\"690\":[3],\"691\":[1,28],\"692\":[1,29],\"693\":[2],\"694\":[1,5],\"695\":[1,33],\"696\":[3],\"697\":[1,7],\"698\":[1,26],\"699\":[4],\"700\":[1,22],\"701\":[1,43],\"702\":[4],\"703\":[2],\"704\":[1,27],\"705\":[1,63],\"706\":[2],\"707\":[1,21],\"708\":[1,53],\"709\":[2],\"710\":[1,4],\"711\":[1,40],\"712\":[2],\"713\":[1,6],\"714\":[1,42],\"715\":[4],\"716\":[3],\"717\":[1,8],\"718\":[1,39],\"719\":[2],\"720\":[1,17],\"721\":[1,39],\"722\":[2],\"723\":[1,10],\"724\":[1,41],\"725\":[2],\"726\":[1,33],\"727\":[1,47],\"728\":[4],\"729\":[3,35],\"730\":[2,33],\"731\":[1,30],\"732\":[1,76],\"733\":[4],\"734\":[2,49],\"735\":[4,84],\"736\":[2,51],\"737\":[2,51],\"738\":[4],\"739\":[1,41],\"740\":[1,63],\"741\":[1,49],\"742\":[2,54],\"743\":[4],\"744\":[3,38],\"745\":[3,31],\"746\":[2,44],\"747\":[2,44],\"748\":[5],\"749\":[1],\"750\":[1,8],\"751\":[1,25],\"752\":[1],\"753\":[1,9],\"754\":[1,35],\"755\":[1],\"756\":[1,7],\"757\":[1,30],\"758\":[1],\"759\":[1,19],\"760\":[1,38],\"761\":[5,7],\"762\":[2],\"763\":[1,11],\"764\":[1,51],\"765\":[2],\"766\":[1,19],\"767\":[1,39],\"768\":[2],\"769\":[1,13],\"770\":[1,37],\"771\":[2],\"772\":[1,45],\"773\":[1,37],\"774\":[5],\"775\":[2],\"776\":[1,2],\"777\":[1,34],\"778\":[2],\"779\":[1,14],\"780\":[1,30],\"781\":[2],\"782\":[1,5],\"783\":[1,34],\"784\":[2],\"785\":[1,2],\"786\":[1,43],\"787\":[5],\"788\":[1],\"789\":[1,2],\"790\":[1,39],\"791\":[1],\"792\":[1,13],\"793\":[1,35],\"794\":[1],\"795\":[1,4],\"796\":[1,42],\"797\":[1],\"798\":[1,4],\"799\":[1,53],\"800\":[5],\"801\":[1,26],\"802\":[1,26],\"803\":[1,39],\"804\":[1,33],\"805\":[1,35],\"806\":[1,37],\"807\":[4],\"808\":[2],\"809\":[1,29],\"810\":[1,30],\"811\":[2],\"812\":[1,55],\"813\":[1,29],\"814\":[2],\"815\":[1,32],\"816\":[1,52],\"817\":[2],\"818\":[1,34],\"819\":[1,39],\"820\":[4],\"821\":[2],\"822\":[1,37],\"823\":[1,24],\"824\":[3],\"825\":[1,27],\"826\":[1,29],\"827\":[2],\"828\":[1,26],\"829\":[1,31],\"830\":[2],\"831\":[1,27],\"832\":[1,51],\"833\":[4],\"834\":[2],\"835\":[1,43],\"836\":[1,30],\"837\":[2],\"838\":[1,44],\"839\":[1,47],\"840\":[2],\"841\":[1,21],\"842\":[1,18],\"843\":[1,25],\"844\":[1,31],\"845\":[2],\"846\":[1,33],\"847\":[1,34],\"848\":[4],\"849\":[3],\"850\":[1,20],\"851\":[1,27],\"852\":[3],\"853\":[1,19],\"854\":[1,31],\"855\":[2],\"856\":[1,30],\"857\":[1,37],\"858\":[3],\"859\":[1,33],\"860\":[1,29],\"861\":[4],\"862\":[2],\"863\":[1,22],\"864\":[1,24],\"865\":[3],\"866\":[1,27],\"867\":[1],\"868\":[2,28],\"869\":[2,30],\"870\":[2],\"871\":[1,20],\"872\":[1,63],\"873\":[3],\"874\":[1,34],\"875\":[1,76],\"876\":[4],\"877\":[2],\"878\":[1,25],\"879\":[1,23],\"880\":[2],\"881\":[1,27],\"882\":[1,30],\"883\":[2],\"884\":[1,27],\"885\":[1,36],\"886\":[2],\"887\":[1,28],\"888\":[1,29],\"889\":[1],\"890\":[2],\"891\":[1,32],\"892\":[1,27],\"893\":[3],\"894\":[1,21],\"895\":[1,29],\"896\":[2],\"897\":[1,32],\"898\":[1,34],\"899\":[2],\"900\":[1,34],\"901\":[1],\"902\":[2,57],\"903\":[2],\"904\":[1,59],\"905\":[1],\"906\":[2,38],\"907\":[1,46],\"908\":[2],\"909\":[1,26],\"910\":[1],\"911\":[2,27],\"912\":[1,3],\"913\":[1],\"914\":[1],\"915\":[1]},\"averageFieldLength\":[1.915938864628822,47.78213251311256],\"storedFields\":{\"0\":{\"h\":\"首页\",\"t\":[\"之前的 33 Wiki 的内容都会逐渐迁移到这里。\"]},\"1\":{\"h\":\"题解\",\"t\":[\"这里会放比赛题解以及题目题解\"]},\"2\":{\"h\":\"高精度模板\"},\"3\":{\"h\":\"封装好的结构体\",\"t\":[\"实现的内容：\",\"BigIntTiny a;：定义了一个大整数变量 a，会自动初始化为 \",\"BigIntTiny a = 33;：通过一个 int 类型的值初始化。\",\"BigIntTiny a = s;：通过一个 string s; 来初始化。\",\"a.get_pos(pos)：获取第 pos 位的数位内容\",\"a.to_str()：得到对应的字符串，一般用来输出\",\"a = -a;：取反\",\"a < b、a == b、...：比较大小\",\"a + b：高精度加法，允许（a += b;）\",\"a - b：高精度减法\",\"a * b：高精度乘法\",\"a / b：高精度除法\",\"a % b：高精度取模\",\"实际上因为定义了 int 对高精度的转换，所以加减乘除都能直接高精对低精运算。\",\"struct BigIntTiny { int sign; std::vector<int> v; BigIntTiny() : sign(1) {} BigIntTiny(const std::string &s) { *this = s; } BigIntTiny(int v) { char buf[21]; sprintf(buf, \\\"%d\\\", v); *this = buf; } void zip(int unzip) { if (unzip == 0) { for (int i = 0; i < (int)v.size(); i++) v[i] = get_pos(i * 4) + get_pos(i * 4 + 1) * 10 + get_pos(i * 4 + 2) * 100 + get_pos(i * 4 + 3) * 1000; } else for (int i = (v.resize(v.size() * 4), (int)v.size() - 1), a; i >= 0; i--) a = (i % 4 >= 2) ? v[i / 4] / 100 : v[i / 4] % 100, v[i] = (i & 1) ? a / 10 : a % 10; setsign(1, 1); } int get_pos(unsigned pos) const { return pos >= v.size() ? 0 : v[pos]; } BigIntTiny &setsign(int newsign, int rev) { for (int i = (int)v.size() - 1; i > 0 && v[i] == 0; i--) v.erase(v.begin() + i); sign = (v.size() == 0 || (v.size() == 1 && v[0] == 0)) ? 1 : (rev ? newsign * sign : newsign); return *this; } std::string to_str() const { BigIntTiny b = *this; std::string s; for (int i = (b.zip(1), 0); i < (int)b.v.size(); ++i) s += char(*(b.v.rbegin() + i) + '0'); return (sign < 0 ? \\\"-\\\" : \\\"\\\") + (s.empty() ? std::string(\\\"0\\\") : s); } bool absless(const BigIntTiny &b) const { if (v.size() != b.v.size()) return v.size() < b.v.size(); for (int i = (int)v.size() - 1; i >= 0; i--) if (v[i] != b.v[i]) return v[i] < b.v[i]; return false; } BigIntTiny operator-() const { BigIntTiny c = *this; c.sign = (v.size() > 1 || v[0]) ? -c.sign : 1; return c; } BigIntTiny &operator=(const std::string &s) { if (s[0] == '-') *this = s.substr(1); else { for (int i = (v.clear(), 0); i < (int)s.size(); ++i) v.push_back(*(s.rbegin() + i) - '0'); zip(0); } return setsign(s[0] == '-' ? -1 : 1, sign = 1); } bool operator<(const BigIntTiny &b) const { return sign != b.sign ? sign < b.sign : (sign == 1 ? absless(b) : b.absless(*this)); } bool operator==(const BigIntTiny &b) const { return v == b.v && sign == b.sign; } BigIntTiny &operator+=(const BigIntTiny &b) { if (sign != b.sign) return *this = (*this) - -b; v.resize(std::max(v.size(), b.v.size()) + 1); for (int i = 0, carry = 0; i < (int)b.v.size() || carry; i++) { carry += v[i] + b.get_pos(i); v[i] = carry % 10000, carry /= 10000; } return setsign(sign, 0); } BigIntTiny operator+(const BigIntTiny &b) const { BigIntTiny c = *this; return c += b; } void add_mul(const BigIntTiny &b, int mul) { v.resize(std::max(v.size(), b.v.size()) + 2); for (int i = 0, carry = 0; i < (int)b.v.size() || carry; i++) { carry += v[i] + b.get_pos(i) * mul; v[i] = carry % 10000, carry /= 10000; } } BigIntTiny operator-(const BigIntTiny &b) const { if (sign != b.sign) return (*this) + -b; if (absless(b)) return -(b - *this); BigIntTiny c; for (int i = 0, borrow = 0; i < (int)v.size(); i++) { borrow += v[i] - b.get_pos(i); c.v.push_back(borrow); c.v.back() -= 10000 * (borrow >>= 31); } return c.setsign(sign, 0); } BigIntTiny operator*(const BigIntTiny &b) const { if (b < *this) return b * *this; BigIntTiny c, d = b; for (int i = 0; i < (int)v.size(); i++, d.v.insert(d.v.begin(), 0)) c.add_mul(d, v[i]); return c.setsign(sign * b.sign, 0); } BigIntTiny operator/(const BigIntTiny &b) const { BigIntTiny c, d; d.v.resize(v.size()); double db = 1.0 / (b.v.back() + (b.get_pos((unsigned)b.v.size() - 2) / 1e4) + (b.get_pos((unsigned)b.v.size() - 3) + 1) / 1e8); for (int i = (int)v.size() - 1; i >= 0; i--) { c.v.insert(c.v.begin(), v[i]); int m = (int)((c.get_pos((int)b.v.size()) * 10000 + c.get_pos((int)b.v.size() - 1)) * db); c = c - b * m, d.v[i] += m; while (!(c < b)) c = c - b, d.v[i] += 1; } return d.setsign(sign * b.sign, 0); } BigIntTiny operator%(const BigIntTiny &b) const { return *this - *this / b * b; } bool operator>(const BigIntTiny &b) const { return b < *this; } bool operator<=(const BigIntTiny &b) const { return !(b < *this); } bool operator>=(const BigIntTiny &b) const { return !(*this < b); } bool operator!=(const BigIntTiny &b) const { return !(*this == b); } };\"]},\"4\":{\"h\":\"例子\"},\"5\":{\"h\":\"阶乘和\",\"t\":[\"int main(){ int n; cin >> n; BigIntTiny sum = 0; BigIntTiny now = 1; for(int i = 1; i <= n; i++) { now = now * i; sum += now; } cout << sum.to_str(); return 0; }\"]},\"6\":{\"h\":\"高精度加法\"},\"7\":{\"h\":\"一种写法\",\"t\":[\"string t; BigIntTiny a, b; int main(){ cin >> t; a = t; cin >> t; b = t; cout << (a + b).to_str(); return 0; }\"]},\"8\":{\"h\":\"另一种写法\",\"t\":[\"string a, b; int main(){ cin >> a >> b; cout << ((BigIntTiny)a + (BigIntTiny)b).to_str(); return 0; }\"]},\"9\":{\"h\":\"最近公共祖先\"},\"10\":{\"h\":\"例题\",\"t\":[\"给定一棵 个点的树， 是根节点， 个询问。\",\"每次询问点两个点的 lca。\"]},\"11\":{\"h\":\"预处理 祖先\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 500000; int n, m, s, nn; vector<int> e[MAXN + 5]; int fa[MAXN + 5]; // fa[u] 记录 u 的父节点 int faNN[MAXN + 5]; // faNN[u] 记录 u 的 nn 层祖宗节点 int dep[MAXN + 5]; // dep[u] 记录 1 为根节点时的深度 void dfs(int u, int father) { fa[u] = father; for (int v : e[u]) { if (v == father) continue; dep[v] = dep[u] + 1; dfs(v, u); } } int lca(int u, int v) { if (dep[v] < dep[u]) swap(u, v); while (dep[v] - dep[u] >= nn) v = faNN[v]; while (dep[v] != dep[u]) v = fa[v]; while (faNN[v] != faNN[u]) u = faNN[u], v = faNN[v]; while (u != v) u = fa[u], v = fa[v]; return u; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m >> s; nn = sqrt(n); for (int i = 1; i <= n - 1; i++) { int u, v; cin >> u >> v; e[u].push_back(v); e[v].push_back(u); } dep[s] = 0; dfs(s, 0); for (int u = 1; u <= n; u++) { faNN[u] = u; for (int i = 1; i <= nn; i++) faNN[u] = fa[faNN[u]]; } while (m--) { int u, v; cin >> u >> v; cout << lca(u, v) << \\\"\\\\n\\\"; } return 0; }\"]},\"12\":{\"h\":\"倍增\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 500'000; int n, m, s; vector<int> e[MAXN + 5]; // f[i][j] 记录 i 的 2^j 级别祖先 int f[MAXN + 5][25]; // dis[i] 求节点 i 的深度 int dis[MAXN + 5]; void dfs(int u, int fa) { f[u][0] = fa; for (int i = 0; i < e[u].size(); i++) { int v = e[u][i]; if (v == fa) continue; dis[v] = dis[u] + 1; dfs(v, u); } } // lca(u,v) 返回 u,v 的最近公共祖先 int lca(int u, int v) { // 保证 u 在上面，v 在下面 if (dis[v] < dis[u]) swap(u, v); // 拉到同样的深度 for (int j = 20; j >= 0; j--) if (dis[v] - dis[u] >= (1 << j)) v = f[v][j]; // 初始两点之间是祖孙关系时，拉到同样深度就会变成同一个点 if (u == v) return u; // 同步往上走，跳到了 lca 下面一跳位 for (int j = 20; j >= 0; j--) if (f[u][j] != f[v][j]) u = f[u][j], v = f[v][j]; return f[u][0]; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m >> s; for (int i = 1; i <= n - 1; i++) { int u, v; cin >> u >> v; e[u].push_back(v); e[v].push_back(u); } dis[s] = 0; dfs(s, 0); // 预处理深度 dis[u]，以及一级祖先 f[u][0] // i 的 2^j 级别祖先 = i 的 2^{j-1} 级别祖先的 2^{j-1} 级别祖先 for (int j = 1; (1LL << j) <= n; j++) for (int i = 1; i <= n; i++) f[i][j] = f[f[i][j - 1]][j - 1]; while (m--) { int u, v; cin >> u >> v; cout << lca(u, v) << \\\"\\\\n\\\"; } return 0; }\"]},\"13\":{\"h\":\"欧拉序+st表\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 500'000; int n, m, s; vector<int> e[MAXN + 5]; // dis[i] 存 i 的深度 int dis[MAXN + 5]; // <深度, 点的编号> vector<pair<int, int>> a; // pos[i] 存 i 在 a 中第一次出现的下标 int pos[MAXN + 5]; void dfs(int u, int fa) { a.push_back({dis[u], u}); pos[u] = (int)a.size() - 1; for (int i = 0; i < e[u].size(); i++) { int v = e[u][i]; if (v == fa) continue; dis[v] = dis[u] + 1; dfs(v, u); a.push_back({dis[u], u}); } } // 处理 a 数组的 st 表 // st[i][j] 存 a[i] 开始的 2^j 个元素中的最小值下标 int st[MAXN * 2 + 5][20]; void initST() { int len = a.size(); for (int i = 0; i < len; i++) st[i][0] = i; for (int j = 1; (1LL << j) <= len; j++) { for (int i = 0; i + (1LL << j) - 1 < len; i++) { // i 为起点，2^j 长度的最小值下标 int L = st[i][j - 1]; int R = st[i + (1LL << (j - 1))][j - 1]; if (a[L].first < a[R].first) st[i][j] = L; else st[i][j] = R; } } } int lca(int u, int v) { if (pos[u] > pos[v]) swap(u, v); // 找到 pos[u]~pos[v] 之间 first 最小的下标 int len = pos[v] - pos[u] + 1; int j = log2(len); // pos[u] 开头的 2^j 和 pos[v] 结尾的 2^j 的最小值的最小值 int L = st[pos[u]][j]; int R = st[pos[v] - (1LL << j) + 1][j]; if (a[L].first < a[R].first) return a[L].second; else return a[R].second; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m >> s; for (int i = 1; i <= n - 1; i++) { int u, v; cin >> u >> v; e[u].push_back(v); e[v].push_back(u); } dis[s] = 0; dfs(s, 0); initST(); while (m--) { int u, v; cin >> u >> v; cout << lca(u, v) << \\\"\\\\n\\\"; } return 0; }\"]},\"14\":{\"h\":\"tarjan(离线+并查集)\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 1000000; const int MAXM = 1000000; int n, m, s; vector<int> e[MAXN + 5]; //(v, 问题 id) vector<pair<int, int> > ask[MAXN + 5]; int ans[MAXM + 5]; // 问题 id 为 i 的问题答案 // 每个点是否搜过了 bool vis[MAXN + 5]; // 并查集 int fa[MAXN + 5]; int findFa(int x) { if (fa[x] == x) return x; else return fa[x] = findFa(fa[x]); } void dfs(int u, int from) { for (int i = 0; i < ask[u].size(); i++) if (vis[ask[u][i].first]) ans[ask[u][i].second] = findFa(ask[u][i].first); vis[u] = true; for (int i = 0; i < e[u].size(); i++) { int v = e[u][i]; if (v == from) continue; dfs(v, u); fa[v] = u; } } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m >> s; for (int i = 1; i <= n - 1; i++) { int u, v; cin >> u >> v; e[u].push_back(v); e[v].push_back(u); } memset(ans, 0, sizeof(ans)); // 读询问 for (int i = 1; i <= m; i++) { int u, v, id; cin >> u >> v; id = i; if (u == v) ans[i] = u; else { ask[u].push_back(make_pair(v, id)); ask[v].push_back(make_pair(u, id)); } } // tarjan for (int i = 1; i <= n; i++) { fa[i] = i; vis[i] = false; } dfs(s, 0); for (int i = 1; i <= m; i++) cout << ans[i] << \\\"\\\\n\\\"; return 0; }\"]},\"15\":{\"h\":\"树链剖分\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 500000 + 5; int n, m, s; vector<int> e[MAXN]; //每个点的：父节点、深度、大小、重子节点 int fa[MAXN], dep[MAXN], siz[MAXN], hson[MAXN]; void dfs_build(int u, int fat) { hson[u] = 0; siz[hson[u]] = 0; siz[u] = 1; for (int i = 0; i < e[u].size(); i++) { int v = e[u][i]; if (v == fat) continue; dep[v] = dep[u] + 1; fa[v] = u; dfs_build(v, u); siz[u] += siz[v]; if (siz[v] > siz[hson[u]]) hson[u] = v; } } //每个点的：所在链的链顶、重边优先的 dfs 序、dfs序对应的节点编号 int tot, top[MAXN], dfn[MAXN], rnk[MAXN]; void dfs_div(int u, int fa) { dfn[u] = ++tot; rnk[tot] = u; if (hson[u]) { top[hson[u]] = top[u]; dfs_div(hson[u], u); for (int i = 0; i < e[u].size(); i++) { int v = e[u][i]; if (v == fa || v == hson[u]) continue; top[v] = v; dfs_div(v, u); } } } int lca(int u, int v) { while (top[u] != top[v]) { if (dep[top[u]] > dep[top[v]]) u = fa[top[u]]; else v = fa[top[v]]; } return dep[u] > dep[v] ? v : u; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m >> s; for (int i = 1; i <= n - 1; i++) { int u, v; cin >> u >> v; e[u].push_back(v); e[v].push_back(u); } dep[s] = 1; fa[s] = 0; dfs_build(s, 0); tot = 0; top[s] = s; dfs_div(s, 0); while (m--) { int u, v; cin >> u >> v; cout << lca(u, v) << \\\"\\\\n\\\"; } return 0; }\"]},\"16\":{\"h\":\"线段树\"},\"17\":{\"h\":\"单点修改、区间查询\",\"t\":[\"【模板】树状数组 1\",\"#include <bits/stdc++.h> using namespace std; const int MAXN = 500000; int n, m; int a[MAXN + 5]; int t[MAXN * 4 + 5]; void build(int now, int l, int r) { if (l == r) { t[now] = a[l]; return; } int mid = (l + r) / 2; build(now * 2, l, mid); build(now * 2 + 1, mid + 1, r); t[now] = t[now * 2] + t[now * 2 + 1]; } void update(int now, int l, int r, int x, int y) { if (l == r) { t[now] += y; return; } int mid = (l + r) / 2; if (x <= mid) update(now * 2, l, mid, x, y); if (x > mid) update(now * 2 + 1, mid + 1, r, x, y); t[now] = t[now * 2] + t[now * 2 + 1]; } int query(int now, int l, int r, int x, int y) { if (x <= l && r <= y) return t[now]; int mid = (l + r) / 2; int res = 0; if (x <= mid) res += query(now * 2, l, mid, x, y); if (y >= mid + 1) res += query(now * 2 + 1, mid + 1, r, x, y); return res; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m; for (int i = 1; i <= n; i++) cin >> a[i]; build(1, 1, n); for (int i = 1; i <= m; i++) { int op, x, y; cin >> op; if (op == 1) { cin >> x >> y; update(1, 1, n, x, y); } if (op == 2) { cin >> x >> y; cout << query(1, 1, n, x, y) << \\\"\\\\n\\\"; } } return 0; }\"]},\"18\":{\"h\":\"另一种常见的 query\",\"t\":[\"不需要判断 [x,y] 是否和左/右半边有重叠\",\"int query(int now, int l, int r, int x, int y) { if (y < l || r < x) return 0; if (x <= l && r <= y) return t[now]; int mid = (l + r) / 2; int res = 0; res += query(now * 2, l, mid, x, y); res += query(now * 2 + 1, mid + 1, r, x, y); return res; }\"]},\"19\":{\"h\":\"区间修改、区间查询\",\"t\":[\"【模板】线段树 1\",\"#include <bits/stdc++.h> #define int long long using namespace std; const int MAXN = 100000; int n, m; int a[MAXN + 5]; // 线段树：单点修改、区间查询（区间和） int t[4 * MAXN + 5], lazy[4 * MAXN + 5]; // 基于a[]建线段树 void build(int now, int l, int r) { if (l == r) { t[now] = a[l]; return; } int mid = (l + r) / 2; build(now * 2, l, mid); build(now * 2 + 1, mid + 1, r); t[now] = t[now * 2] + t[now * 2 + 1]; } void down(int now, int l, int r) { int mid = (l + r) / 2; // 左子树 now*2,l,mid // 右子树 now*2+1,mid+1,r lazy[now * 2] += lazy[now]; t[now * 2] += (mid - l + 1) * lazy[now]; lazy[now * 2 + 1] += lazy[now]; t[now * 2 + 1] += (r - mid) * lazy[now]; lazy[now] = 0; } // 当前做到了树上的now号节点，当前节点对应的区间为 [l,r] // 需要给 [x,y] 这些数都加 z void update(int now, int l, int r, int x, int y, int z) { if (x <= l && r <= y) { t[now] += (r - l + 1) * z; lazy[now] += z; return; } int mid = (l + r) / 2; // 左子树 now*2,l,mid // 右子树 now*2+1,mid+1,r down(now, l, r); // 把之前欠的结清 if (x <= mid) update(now * 2, l, mid, x, y, z); if (y > mid) update(now * 2 + 1, mid + 1, r, x, y, z); t[now] = t[now * 2] + t[now * 2 + 1]; } int query(int now, int l, int r, int x, int y) { //[l,r] 是 [x,y] 的子区间 if (x <= l && r <= y) return t[now]; int mid = (l + r) / 2; // 左子树 now*2,l,mid // 右子树 now*2+1,mid+1,r down(now, l, r); // 把之前欠的结清 int res = 0; if (x <= mid) res += query(now * 2, l, mid, x, y); if (y > mid) res += query(now * 2 + 1, mid + 1, r, x, y); return res; } signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m; for (int i = 1; i <= n; i++) { cin >> a[i]; } build(1, 1, n); while (m--) { int op, x, y, z; cin >> op; if (op == 1) { cin >> x >> y >> z; update(1, 1, n, x, y, z); } else { cin >> x >> y; // cout sum(a[x]~a[y]) cout << query(1, 1, n, x, y) << \\\"\\\\n\\\"; } } return 0; }\"]},\"20\":{\"h\":\"标记永久化\",\"t\":[\"#include <bits/stdc++.h> #define int long long using namespace std; const int MAXN = 100000; int n, m; int a[MAXN + 5]; // 线段树 int t[4 * MAXN + 5], lazy[4 * MAXN + 5]; // 基于a[]建线段树 void build(int now, int l, int r) { if (l == r) { t[now] = a[l]; return; } int mid = (l + r) / 2; build(now * 2, l, mid); build(now * 2 + 1, mid + 1, r); t[now] = t[now * 2] + t[now * 2 + 1]; } // 当前做到了树上的now号节点，当前节点对应的区间为 [l,r] // 需要给 [x,y] 这些数都加 z void update(int now, int l, int r, int x, int y, int z) { t[now] += (min(y, r) - max(x, l) + 1) * z; if (x <= l && r <= y) { lazy[now] += z; return; } int mid = (l + r) / 2; // 左子树 now*2,l,mid // 右子树 now*2+1,mid+1,r if (x <= mid) update(now * 2, l, mid, x, y, z); if (y > mid) update(now * 2 + 1, mid + 1, r, x, y, z); } int query(int now, int l, int r, int x, int y, int lazySum) { //[l,r] 是 [x,y] 的子区间 if (x <= l && r <= y) return t[now] + (r - l + 1) * lazySum; int mid = (l + r) / 2; // 左子树 now*2,l,mid // 右子树 now*2+1,mid+1,r int res = 0; lazySum += lazy[now]; if (x <= mid) res += query(now * 2, l, mid, x, y, lazySum); if (y > mid) res += query(now * 2 + 1, mid + 1, r, x, y, lazySum); return res; } signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m; for (int i = 1; i <= n; i++) { cin >> a[i]; } build(1, 1, n); while (m--) { int op, x, y, z; cin >> op; if (op == 1) { cin >> x >> y >> z; update(1, 1, n, x, y, z); } else { cin >> x >> y; // cout sum(a[x]~a[y]) cout << query(1, 1, n, x, y, 0) << \\\"\\\\n\\\"; } } return 0; }\"]},\"21\":{\"h\":\"区间加、区间乘、区间和查询\",\"t\":[\"#include <bits/stdc++.h> #define int long long using namespace std; const int MAXN = 100000; int n, m, p; int a[MAXN + 5]; // 线段树：单点修改、区间查询（区间和） int t[4 * MAXN + 5]; int lazyAdd[4 * MAXN + 5], lazyMul[4 * MAXN + 5]; // 基于a[]建线段树 void build(int now, int l, int r) { lazyAdd[now] = 0; lazyMul[now] = 1; if (l == r) { t[now] = a[l]; return; } int mid = (l + r) / 2; build(now * 2, l, mid); build(now * 2 + 1, mid + 1, r); t[now] = t[now * 2] + t[now * 2 + 1]; t[now] %= p; } void down(int now, int l, int r) { int mid = (l + r) / 2; // 左子树 now*2,l,mid // 右子树 now*2+1,mid+1,r int add = lazyAdd[now]; int mul = lazyMul[now]; lazyMul[now * 2] *= mul; lazyMul[now * 2] %= p; lazyAdd[now * 2] *= mul; lazyAdd[now * 2] %= p; t[now * 2] *= mul; t[now * 2] %= p; lazyAdd[now * 2] += add; lazyAdd[now * 2] %= p; t[now * 2] += (mid - l + 1) * add; t[now * 2] %= p; lazyMul[now * 2 + 1] *= mul; lazyMul[now * 2 + 1] %= p; lazyAdd[now * 2 + 1] *= mul; lazyAdd[now * 2 + 1] %= p; t[now * 2 + 1] *= mul; t[now * 2 + 1] %= p; lazyAdd[now * 2 + 1] += add; lazyAdd[now * 2 + 1] %= p; t[now * 2 + 1] += (r - mid) * add; t[now * 2 + 1] %= p; lazyAdd[now] = 0; lazyMul[now] = 1; } // 当前做到了树上的now号节点，当前节点对应的区间为 [l,r] // 需要给 [x,y] 这些数都加 z void update_add(int now, int l, int r, int x, int y, int z) { if (x <= l && r <= y) { t[now] += (r - l + 1) * z; t[now] %= p; lazyAdd[now] += z; lazyAdd[now] %= p; return; } int mid = (l + r) / 2; // 左子树 now*2,l,mid // 右子树 now*2+1,mid+1,r down(now, l, r); // 把之前欠的结清 if (x <= mid) update_add(now * 2, l, mid, x, y, z); if (y > mid) update_add(now * 2 + 1, mid + 1, r, x, y, z); t[now] = t[now * 2] + t[now * 2 + 1]; t[now] %= p; } void update_mul(int now, int l, int r, int x, int y, int z) { if (x <= l && r <= y) { t[now] *= z; t[now] %= p; lazyMul[now] *= z; lazyMul[now] %= p; lazyAdd[now] *= z; lazyAdd[now] %= p; return; } int mid = (l + r) / 2; // 左子树 now*2,l,mid // 右子树 now*2+1,mid+1,r down(now, l, r); // 把之前欠的结清 if (x <= mid) update_mul(now * 2, l, mid, x, y, z); if (y > mid) update_mul(now * 2 + 1, mid + 1, r, x, y, z); t[now] = t[now * 2] + t[now * 2 + 1]; t[now] %= p; } int query(int now, int l, int r, int x, int y) { //[l,r] 是 [x,y] 的子区间 if (x <= l && r <= y) return t[now]; int mid = (l + r) / 2; // 左子树 now*2,l,mid // 右子树 now*2+1,mid+1,r down(now, l, r); // 把之前欠的结清 int res = 0; if (x <= mid) res += query(now * 2, l, mid, x, y); if (y > mid) res += query(now * 2 + 1, mid + 1, r, x, y); return res % p; } signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m >> p; for (int i = 1; i <= n; i++) { cin >> a[i]; } build(1, 1, n); while (m--) { int op, x, y, z; cin >> op; if (op == 1) { cin >> x >> y >> z; update_mul(1, 1, n, x, y, z); } else if (op == 2) { cin >> x >> y >> z; update_add(1, 1, n, x, y, z); } else if (op == 3) { cin >> x >> y; // cout sum(a[x]~a[y]) cout << query(1, 1, n, x, y) << \\\"\\\\n\\\"; } } return 0; }\"]},\"22\":{\"h\":\"动态开点线段树\",\"t\":[\"下面是权值线段树的单点修改，区间查询，以及基础的线段树上二分。\",\"如果要进行区间修改，一般来说会标记永久化。\",\"中位数\"]},\"23\":{\"h\":\"查询\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 100000; const int MAXAI = 1'000'000'000; const int MAXTOT = 30 * MAXN; int n, m; int a[MAXN + 5]; // 动态开点线段树维护权值数组 int tot = 1; // 节点数量 int lson[MAXTOT + 5], rson[MAXTOT + 5]; // 左右子节点 int t[MAXTOT + 5]; void update(int now, int l, int r, int x, int y) { if (l == r) { t[now] += y; return; } int mid = (l + r) / 2; if (x <= mid) { if (!lson[now]) lson[now] = ++tot; update(lson[now], l, mid, x, y); } if (x > mid) { if (!rson[now]) rson[now] = ++tot; update(rson[now], mid + 1, r, x, y); } t[now] = t[lson[now]] + t[rson[now]]; } int query(int now, int l, int r, int x, int y) { if (x <= l && r <= y) return t[now]; int mid = (l + r) / 2; int res = 0; if (x <= mid && lson[now]) res += query(lson[now], l, mid, x, y); if (y >= mid + 1 && rson[now]) res += query(rson[now], mid + 1, r, x, y); return res; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; // 找中位数 for (int i = 1; i <= n; i++) { update(1, 1, MAXAI, a[i], 1); if (i % 2 == 0) continue; int k = i / 2 + 1; // 找到排名为k的数是几 int l = 1; int r = MAXAI; int ans = -1; while (l <= r) { int mid = (l + r) / 2; if (query(1, 1, MAXAI, 1, mid) >= k) { ans = mid; r = mid - 1; } else l = mid + 1; } cout << ans << \\\"\\\\n\\\"; } return 0; }\"]},\"24\":{\"h\":\"查询\",\"t\":[\"int dfs(int now, int l, int r, int k) { if (l == r) return l; int mid = (l + r) / 2; if (t[lson[now]] >= k) return dfs(lson[now], l, mid, k); return dfs(rson[now], mid + 1, r, k - t[lson[now]]); } ... int k = i / 2 + 1; // 找到排名为k的数是几 cout << dfs(1, 0, MAXAI, k) << \\\"\\\\n\\\";\"]},\"25\":{\"h\":\"排序算法\"},\"26\":{\"h\":\"选择排序\"},\"27\":{\"h\":\"发现了小的就交换\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n; int a[1005]; int main() { //输入 cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; //选择排序 for (int i = 1; i <= n; i++) for (int j = i + 1; j <= n; j++) if (a[j] < a[i]) swap(a[j], a[i]); //输出 for (int i = 1; i <= n; i++) cout << a[i] << \\\" \\\"; return 0; }\"]},\"28\":{\"h\":\"找到了最小的之后再交换\"},\"29\":{\"h\":\"冒泡排序\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n; int a[1005]; int main() { //输入 cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; //冒泡排序 for (int i = 1; i <= n - 1; i++) for (int j = 1; j <= n - 1; j++) if (a[j] > a[j + 1]) swap(a[j], a[j + 1]); //输出 for (int i = 1; i <= n; i++) cout << a[i] << \\\" \\\"; return 0; }\"]},\"30\":{\"h\":\"插入排序\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n; int a[1005]; int main() { //输入 cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; //插入排序 for (int i = 2; i <= n; i++) for (int j = i; j >= 2; j--) if (a[j] < a[j - 1]) swap(a[j], a[j - 1]); //输出 for (int i = 1; i <= n; i++) cout << a[i] << \\\" \\\"; return 0; }\"]},\"31\":{\"h\":\"计数排序\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n; int a[1005]; int cnt[2005]; int main() { //输入 cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; //计数排序 for (int i = 1; i <= n; i++) cnt[a[i]]++; //输出 for (int i = 1; i <= 2000; i++) for (int j = 1; j <= cnt[i]; j++) cout << i << \\\" \\\"; return 0; }\"]},\"32\":{\"h\":\"地精排序\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n; int a[1005]; int main() { // 输入 cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; // 排序 int pos = 1; // 地精的位置 while (pos != n) { if (a[pos] <= a[pos + 1]) pos++; else { swap(a[pos], a[pos + 1]); if (pos != 1) pos--; } } // 输出 for (int i = 1; i <= n; i++) cout << a[i] << \\\" \\\"; return 0; }\"]},\"33\":{\"h\":\"入门基础\"},\"34\":{\"h\":\"啥是编程？\"},\"35\":{\"h\":\"数字电路\"},\"36\":{\"h\":\"机器语言\",\"t\":[\"000000011 011000001 011000010 100000000 011011111 010000000\"]},\"37\":{\"h\":\"汇编语言\",\"t\":[\"LOAD 3 MOV 0 1 MOV 0 2 ADD MOV 3 7 OUT\"]},\"38\":{\"h\":\"高级语言\",\"t\":[\"int x1, x2, x3; x1 = 3; x2 = 3; x3 = x1 + x2; cout << x3;\"]},\"39\":{\"h\":\"60 点游戏\",\"t\":[\" 加减乘除怎么算出 ？\",\"可以改变顺序、用小括号\"]},\"40\":{\"h\":\"算 60 点的程序\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const double EPS = 1e-8; // 用于浮点数比较的误差范围 bool isZero(double x) { return abs(x) < EPS; } // 计算表达式的值 double evaluateExpression(double a, char op, double b) { switch (op) { case '+': return a + b; case '-': return a - b; case '*': return a * b; case '/': if (isZero(b)) throw runtime_error(\\\"Division by zero\\\"); return a / b; default: return 0.0; } } // 生成所有可能的表达式并计算结果 void findExpressions(vector<int>& nums, vector<char> ops, string expr, int index, double result, bool used[5]) { if (index == 5) { if (isZero(result - 60)) { cout << expr << \\\" = 60\\\" << endl; } return; } for (int i = 0; i < 5; ++i) { if (!used[i]) { used[i] = true; for (char op : ops) { string newExpr; double newValue; if (index == 0) { // 第一个数字直接加入表达式 newExpr = to_string(nums[i]); newValue = nums[i]; } else { // 添加运算符和下一个数字 newExpr = \\\"(\\\" + expr + \\\" \\\" + string(1, op) + \\\" \\\" + to_string(nums[i]) + \\\")\\\"; newValue = evaluateExpression(result, op, nums[i]); } findExpressions(nums, ops, newExpr, index + 1, newValue, used); } used[i] = false; } } } int main() { vector<int> nums(5); vector<char> ops = {'+', '-', '*', '/'}; cout << \\\"请输入5个1到10之间的整数：\\\" << endl; for (int i = 0; i < 5; ++i) { cin >> nums[i]; } bool used[5] = {false}; findExpressions(nums, ops, \\\"\\\", 0, 0.0, used); return 0; }\"]},\"41\":{\"h\":\"的解\",\"t\":[\"((((3 + 6) - 8) + 5) * 10) = 60 ((((3 + 6) + 5) - 8) * 10) = 60 ((((3 * 6) - 8) * 5) + 10) = 60 ((((3 - 8) + 6) + 5) * 10) = 60 ((((3 - 8) + 10) + 5) * 6) = 60 ((((3 - 8) + 5) + 6) * 10) = 60 ((((3 - 8) + 5) + 10) * 6) = 60 ((((3 * 8) + 6) * 10) / 5) = 60 ((((3 * 8) + 6) / 5) * 10) = 60 ((((3 + 10) - 8) + 5) * 6) = 60 ((((3 + 10) + 5) - 8) * 6) = 60 ((((3 / 10) * 5) + 6) * 8) = 60 ((((3 + 5) + 6) - 8) * 10) = 60 ((((3 + 5) * 6) / 8) * 10) = 60 ((((3 + 5) * 6) * 10) / 8) = 60 ((((3 + 5) - 8) + 6) * 10) = 60 ((((3 + 5) - 8) + 10) * 6) = 60 ((((3 + 5) * 8) + 6) - 10) = 60 ((((3 + 5) * 8) - 10) + 6) = 60 ((((3 + 5) / 8) * 6) * 10) = 60 ((((3 + 5) / 8) * 10) * 6) = 60 ((((3 + 5) + 10) - 8) * 6) = 60 ((((3 + 5) * 10) * 6) / 8) = 60 ((((3 + 5) * 10) / 8) * 6) = 60 ((((3 * 5) / 10) + 6) * 8) = 60 ((((3 + 6) - 8) + 5) * 10) = 60 ((((3 + 6) + 5) - 8) * 10) = 60 ((((3 * 6) - 8) * 5) + 10) = 60 ((((3 - 8) + 6) + 5) * 10) = 60 ((((3 - 8) + 10) + 5) * 6) = 60 ((((3 - 8) + 5) + 6) * 10) = 60 ((((3 - 8) + 5) + 10) * 6) = 60 ((((3 * 8) + 6) * 10) / 5) = 60 ((((3 * 8) + 6) / 5) * 10) = 60 ((((3 + 10) - 8) + 5) * 6) = 60 ((((3 + 10) + 5) - 8) * 6) = 60 ((((3 / 10) * 5) + 6) * 8) = 60 ((((3 + 5) + 6) - 8) * 10) = 60 ((((3 + 5) * 6) / 8) * 10) = 60 ((((3 + 5) * 6) * 10) / 8) = 60 ((((3 + 5) - 8) + 6) * 10) = 60 ((((3 + 5) - 8) + 10) * 6) = 60 ((((3 + 5) * 8) + 6) - 10) = 60 ((((3 + 5) * 8) - 10) + 6) = 60 ((((3 + 5) / 8) * 6) * 10) = 60 ((((3 + 5) / 8) * 10) * 6) = 60 ((((3 + 5) + 10) - 8) * 6) = 60 ((((3 + 5) * 10) * 6) / 8) = 60 ((((3 + 5) * 10) / 8) * 6) = 60 ((((3 * 5) / 10) + 6) * 8) = 60 ((((3 + 6) - 8) + 5) * 10) = 60 ((((3 + 6) + 5) - 8) * 10) = 60 ((((3 * 6) - 8) * 5) + 10) = 60 ((((3 - 8) + 6) + 5) * 10) = 60 ((((3 - 8) + 10) + 5) * 6) = 60 ((((3 - 8) + 5) + 6) * 10) = 60 ((((3 - 8) + 5) + 10) * 6) = 60 ((((3 * 8) + 6) * 10) / 5) = 60 ((((3 * 8) + 6) / 5) * 10) = 60 ((((3 + 10) - 8) + 5) * 6) = 60 ((((3 + 10) + 5) - 8) * 6) = 60 ((((3 / 10) * 5) + 6) * 8) = 60 ((((3 + 5) + 6) - 8) * 10) = 60 ((((3 + 5) * 6) / 8) * 10) = 60 ((((3 + 5) * 6) * 10) / 8) = 60 ((((3 + 5) - 8) + 6) * 10) = 60 ((((3 + 5) - 8) + 10) * 6) = 60 ((((3 + 5) * 8) + 6) - 10) = 60 ((((3 + 5) * 8) - 10) + 6) = 60 ((((3 + 5) / 8) * 6) * 10) = 60 ((((3 + 5) / 8) * 10) * 6) = 60 ((((3 + 5) + 10) - 8) * 6) = 60 ((((3 + 5) * 10) * 6) / 8) = 60 ((((3 + 5) * 10) / 8) * 6) = 60 ((((3 * 5) / 10) + 6) * 8) = 60 ((((3 + 6) - 8) + 5) * 10) = 60 ((((3 + 6) + 5) - 8) * 10) = 60 ((((3 * 6) - 8) * 5) + 10) = 60 ((((3 - 8) + 6) + 5) * 10) = 60 ((((3 - 8) + 10) + 5) * 6) = 60 ((((3 - 8) + 5) + 6) * 10) = 60 ((((3 - 8) + 5) + 10) * 6) = 60 ((((3 * 8) + 6) * 10) / 5) = 60 ((((3 * 8) + 6) / 5) * 10) = 60 ((((3 + 10) - 8) + 5) * 6) = 60 ((((3 + 10) + 5) - 8) * 6) = 60 ((((3 / 10) * 5) + 6) * 8) = 60 ((((3 + 5) + 6) - 8) * 10) = 60 ((((3 + 5) * 6) / 8) * 10) = 60 ((((3 + 5) * 6) * 10) / 8) = 60 ((((3 + 5) - 8) + 6) * 10) = 60 ((((3 + 5) - 8) + 10) * 6) = 60 ((((3 + 5) * 8) + 6) - 10) = 60 ((((3 + 5) * 8) - 10) + 6) = 60 ((((3 + 5) / 8) * 6) * 10) = 60 ((((3 + 5) / 8) * 10) * 6) = 60 ((((3 + 5) + 10) - 8) * 6) = 60 ((((3 + 5) * 10) * 6) / 8) = 60 ((((3 + 5) * 10) / 8) * 6) = 60 ((((3 * 5) / 10) + 6) * 8) = 60 ((((6 + 3) - 8) + 5) * 10) = 60 ((((6 + 3) + 5) - 8) * 10) = 60 ((((6 - 3) + 8) - 5) * 10) = 60 ((((6 - 3) - 5) + 8) * 10) = 60 ((((6 * 3) - 8) * 5) + 10) = 60 ((((6 / 3) + 8) * 5) + 10) = 60 ((((6 / 3) * 10) - 8) * 5) = 60 ((((6 + 8) - 3) - 5) * 10) = 60 ((((6 + 8) - 10) * 3) * 5) = 60 ((((6 + 8) - 10) * 5) * 3) = 60 ((((6 + 8) - 5) - 3) * 10) = 60 ((((6 - 8) + 3) + 5) * 10) = 60 ((((6 - 8) + 5) + 3) * 10) = 60 ((((6 * 8) - 3) + 10) + 5) = 60 ((((6 * 8) - 3) + 5) + 10) = 60 ((((6 * 8) + 10) - 3) + 5) = 60 ((((6 * 8) + 10) + 5) - 3) = 60 ((((6 * 8) + 5) - 3) + 10) = 60 ((((6 * 8) + 5) + 10) - 3) = 60 ((((6 - 10) + 8) * 3) * 5) = 60 ((((6 - 10) + 8) * 5) * 3) = 60 ((((6 * 10) + 3) - 8) + 5) = 60 ((((6 * 10) + 3) + 5) - 8) = 60 ((((6 * 10) - 3) + 8) - 5) = 60 ((((6 * 10) - 3) - 5) + 8) = 60 ((((6 * 10) / 3) - 8) * 5) = 60 ((((6 * 10) + 8) - 3) - 5) = 60 ((((6 * 10) + 8) - 5) - 3) = 60 ((((6 * 10) - 8) + 3) + 5) = 60 ((((6 * 10) - 8) + 5) + 3) = 60 ((((6 * 10) + 5) + 3) - 8) = 60 ((((6 * 10) + 5) - 8) + 3) = 60 ((((6 * 10) - 5) - 3) + 8) = 60 ((((6 * 10) - 5) + 8) - 3) = 60 ((((6 * 10) / 5) + 8) * 3) = 60 ((((6 + 5) + 3) - 8) * 10) = 60 ((((6 + 5) - 8) + 3) * 10) = 60 ((((6 - 5) - 3) + 8) * 10) = 60 ((((6 - 5) + 8) - 3) * 10) = 60 ((((6 / 5) * 10) + 8) * 3) = 60 ((((6 + 3) - 8) + 5) * 10) = 60 ((((6 + 3) + 5) - 8) * 10) = 60 ((((6 - 3) + 8) - 5) * 10) = 60 ((((6 - 3) - 5) + 8) * 10) = 60 ((((6 * 3) - 8) * 5) + 10) = 60 ((((6 / 3) + 8) * 5) + 10) = 60 ((((6 / 3) * 10) - 8) * 5) = 60 ((((6 + 8) - 3) - 5) * 10) = 60 ((((6 + 8) - 10) * 3) * 5) = 60 ((((6 + 8) - 10) * 5) * 3) = 60 ((((6 + 8) - 5) - 3) * 10) = 60 ((((6 - 8) + 3) + 5) * 10) = 60 ((((6 - 8) + 5) + 3) * 10) = 60 ((((6 * 8) - 3) + 10) + 5) = 60 ((((6 * 8) - 3) + 5) + 10) = 60 ((((6 * 8) + 10) - 3) + 5) = 60 ((((6 * 8) + 10) + 5) - 3) = 60 ((((6 * 8) + 5) - 3) + 10) = 60 ((((6 * 8) + 5) + 10) - 3) = 60 ((((6 - 10) + 8) * 3) * 5) = 60 ((((6 - 10) + 8) * 5) * 3) = 60 ((((6 * 10) + 3) - 8) + 5) = 60 ((((6 * 10) + 3) + 5) - 8) = 60 ((((6 * 10) - 3) + 8) - 5) = 60 ((((6 * 10) - 3) - 5) + 8) = 60 ((((6 * 10) / 3) - 8) * 5) = 60 ((((6 * 10) + 8) - 3) - 5) = 60 ((((6 * 10) + 8) - 5) - 3) = 60 ((((6 * 10) - 8) + 3) + 5) = 60 ((((6 * 10) - 8) + 5) + 3) = 60 ((((6 * 10) + 5) + 3) - 8) = 60 ((((6 * 10) + 5) - 8) + 3) = 60 ((((6 * 10) - 5) - 3) + 8) = 60 ((((6 * 10) - 5) + 8) - 3) = 60 ((((6 * 10) / 5) + 8) * 3) = 60 ((((6 + 5) + 3) - 8) * 10) = 60 ((((6 + 5) - 8) + 3) * 10) = 60 ((((6 - 5) - 3) + 8) * 10) = 60 ((((6 - 5) + 8) - 3) * 10) = 60 ((((6 / 5) * 10) + 8) * 3) = 60 ((((6 + 3) - 8) + 5) * 10) = 60 ((((6 + 3) + 5) - 8) * 10) = 60 ((((6 - 3) + 8) - 5) * 10) = 60 ((((6 - 3) - 5) + 8) * 10) = 60 ((((6 * 3) - 8) * 5) + 10) = 60 ((((6 / 3) + 8) * 5) + 10) = 60 ((((6 / 3) * 10) - 8) * 5) = 60 ((((6 + 8) - 3) - 5) * 10) = 60 ((((6 + 8) - 10) * 3) * 5) = 60 ((((6 + 8) - 10) * 5) * 3) = 60 ((((6 + 8) - 5) - 3) * 10) = 60 ((((6 - 8) + 3) + 5) * 10) = 60 ((((6 - 8) + 5) + 3) * 10) = 60 ((((6 * 8) - 3) + 10) + 5) = 60 ((((6 * 8) - 3) + 5) + 10) = 60 ((((6 * 8) + 10) - 3) + 5) = 60 ((((6 * 8) + 10) + 5) - 3) = 60 ((((6 * 8) + 5) - 3) + 10) = 60 ((((6 * 8) + 5) + 10) - 3) = 60 ((((6 - 10) + 8) * 3) * 5) = 60 ((((6 - 10) + 8) * 5) * 3) = 60 ((((6 * 10) + 3) - 8) + 5) = 60 ((((6 * 10) + 3) + 5) - 8) = 60 ((((6 * 10) - 3) + 8) - 5) = 60 ((((6 * 10) - 3) - 5) + 8) = 60 ((((6 * 10) / 3) - 8) * 5) = 60 ((((6 * 10) + 8) - 3) - 5) = 60 ((((6 * 10) + 8) - 5) - 3) = 60 ((((6 * 10) - 8) + 3) + 5) = 60 ((((6 * 10) - 8) + 5) + 3) = 60 ((((6 * 10) + 5) + 3) - 8) = 60 ((((6 * 10) + 5) - 8) + 3) = 60 ((((6 * 10) - 5) - 3) + 8) = 60 ((((6 * 10) - 5) + 8) - 3) = 60 ((((6 * 10) / 5) + 8) * 3) = 60 ((((6 + 5) + 3) - 8) * 10) = 60 ((((6 + 5) - 8) + 3) * 10) = 60 ((((6 - 5) - 3) + 8) * 10) = 60 ((((6 - 5) + 8) - 3) * 10) = 60 ((((6 / 5) * 10) + 8) * 3) = 60 ((((6 + 3) - 8) + 5) * 10) = 60 ((((6 + 3) + 5) - 8) * 10) = 60 ((((6 - 3) + 8) - 5) * 10) = 60 ((((6 - 3) - 5) + 8) * 10) = 60 ((((6 * 3) - 8) * 5) + 10) = 60 ((((6 / 3) + 8) * 5) + 10) = 60 ((((6 / 3) * 10) - 8) * 5) = 60 ((((6 + 8) - 3) - 5) * 10) = 60 ((((6 + 8) - 10) * 3) * 5) = 60 ((((6 + 8) - 10) * 5) * 3) = 60 ((((6 + 8) - 5) - 3) * 10) = 60 ((((6 - 8) + 3) + 5) * 10) = 60 ((((6 - 8) + 5) + 3) * 10) = 60 ((((6 * 8) - 3) + 10) + 5) = 60 ((((6 * 8) - 3) + 5) + 10) = 60 ((((6 * 8) + 10) - 3) + 5) = 60 ((((6 * 8) + 10) + 5) - 3) = 60 ((((6 * 8) + 5) - 3) + 10) = 60 ((((6 * 8) + 5) + 10) - 3) = 60 ((((6 - 10) + 8) * 3) * 5) = 60 ((((6 - 10) + 8) * 5) * 3) = 60 ((((6 * 10) + 3) - 8) + 5) = 60 ((((6 * 10) + 3) + 5) - 8) = 60 ((((6 * 10) - 3) + 8) - 5) = 60 ((((6 * 10) - 3) - 5) + 8) = 60 ((((6 * 10) / 3) - 8) * 5) = 60 ((((6 * 10) + 8) - 3) - 5) = 60 ((((6 * 10) + 8) - 5) - 3) = 60 ((((6 * 10) - 8) + 3) + 5) = 60 ((((6 * 10) - 8) + 5) + 3) = 60 ((((6 * 10) + 5) + 3) - 8) = 60 ((((6 * 10) + 5) - 8) + 3) = 60 ((((6 * 10) - 5) - 3) + 8) = 60 ((((6 * 10) - 5) + 8) - 3) = 60 ((((6 * 10) / 5) + 8) * 3) = 60 ((((6 + 5) + 3) - 8) * 10) = 60 ((((6 + 5) - 8) + 3) * 10) = 60 ((((6 - 5) - 3) + 8) * 10) = 60 ((((6 - 5) + 8) - 3) * 10) = 60 ((((6 / 5) * 10) + 8) * 3) = 60 ((((8 - 3) + 6) - 5) * 10) = 60 ((((8 - 3) * 6) * 10) / 5) = 60 ((((8 - 3) * 6) / 5) * 10) = 60 ((((8 - 3) + 10) - 5) * 6) = 60 ((((8 - 3) * 10) * 6) / 5) = 60 ((((8 - 3) * 10) / 5) * 6) = 60 ((((8 - 3) - 5) + 6) * 10) = 60 ((((8 - 3) - 5) + 10) * 6) = 60 ((((8 - 3) / 5) * 6) * 10) = 60 ((((8 - 3) / 5) * 10) * 6) = 60 ((((8 * 3) + 6) * 10) / 5) = 60 ((((8 * 3) + 6) / 5) * 10) = 60 ((((8 + 6) - 3) - 5) * 10) = 60 ((((8 + 6) - 10) * 3) * 5) = 60 ((((8 + 6) - 10) * 5) * 3) = 60 ((((8 + 6) - 5) - 3) * 10) = 60 ((((8 - 6) * 5) + 10) * 3) = 60 ((((8 * 6) - 3) + 10) + 5) = 60 ((((8 * 6) - 3) + 5) + 10) = 60 ((((8 * 6) + 10) - 3) + 5) = 60 ((((8 * 6) + 10) + 5) - 3) = 60 ((((8 * 6) + 5) - 3) + 10) = 60 ((((8 * 6) + 5) + 10) - 3) = 60 ((((8 + 10) - 3) - 5) * 6) = 60 ((((8 + 10) / 3) + 6) * 5) = 60 ((((8 + 10) - 5) - 3) * 6) = 60 ((((8 - 10) + 6) * 3) * 5) = 60 ((((8 - 10) + 6) * 5) * 3) = 60 ((((8 - 5) - 3) + 6) * 10) = 60 ((((8 - 5) - 3) + 10) * 6) = 60 ((((8 - 5) / 3) * 6) * 10) = 60 ((((8 - 5) / 3) * 10) * 6) = 60 ((((8 - 5) + 6) - 3) * 10) = 60 ((((8 - 5) * 6) / 3) * 10) = 60 ((((8 - 5) * 6) * 10) / 3) = 60 ((((8 - 5) + 10) - 3) * 6) = 60 ((((8 - 5) * 10) / 3) * 6) = 60 ((((8 - 5) * 10) * 6) / 3) = 60 ((((8 * 5) - 10) / 3) * 6) = 60 ((((8 * 5) - 10) * 6) / 3) = 60 ((((8 - 3) + 6) - 5) * 10) = 60 ((((8 - 3) * 6) * 10) / 5) = 60 ((((8 - 3) * 6) / 5) * 10) = 60 ((((8 - 3) + 10) - 5) * 6) = 60 ((((8 - 3) * 10) * 6) / 5) = 60 ((((8 - 3) * 10) / 5) * 6) = 60 ((((8 - 3) - 5) + 6) * 10) = 60 ((((8 - 3) - 5) + 10) * 6) = 60 ((((8 - 3) / 5) * 6) * 10) = 60 ((((8 - 3) / 5) * 10) * 6) = 60 ((((8 * 3) + 6) * 10) / 5) = 60 ((((8 * 3) + 6) / 5) * 10) = 60 ((((8 + 6) - 3) - 5) * 10) = 60 ((((8 + 6) - 10) * 3) * 5) = 60 ((((8 + 6) - 10) * 5) * 3) = 60 ((((8 + 6) - 5) - 3) * 10) = 60 ((((8 - 6) * 5) + 10) * 3) = 60 ((((8 * 6) - 3) + 10) + 5) = 60 ((((8 * 6) - 3) + 5) + 10) = 60 ((((8 * 6) + 10) - 3) + 5) = 60 ((((8 * 6) + 10) + 5) - 3) = 60 ((((8 * 6) + 5) - 3) + 10) = 60 ((((8 * 6) + 5) + 10) - 3) = 60 ((((8 + 10) - 3) - 5) * 6) = 60 ((((8 + 10) / 3) + 6) * 5) = 60 ((((8 + 10) - 5) - 3) * 6) = 60 ((((8 - 10) + 6) * 3) * 5) = 60 ((((8 - 10) + 6) * 5) * 3) = 60 ((((8 - 5) - 3) + 6) * 10) = 60 ((((8 - 5) - 3) + 10) * 6) = 60 ((((8 - 5) / 3) * 6) * 10) = 60 ((((8 - 5) / 3) * 10) * 6) = 60 ((((8 - 5) + 6) - 3) * 10) = 60 ((((8 - 5) * 6) / 3) * 10) = 60 ((((8 - 5) * 6) * 10) / 3) = 60 ((((8 - 5) + 10) - 3) * 6) = 60 ((((8 - 5) * 10) / 3) * 6) = 60 ((((8 - 5) * 10) * 6) / 3) = 60 ((((8 * 5) - 10) / 3) * 6) = 60 ((((8 * 5) - 10) * 6) / 3) = 60 ((((8 - 3) + 6) - 5) * 10) = 60 ((((8 - 3) * 6) * 10) / 5) = 60 ((((8 - 3) * 6) / 5) * 10) = 60 ((((8 - 3) + 10) - 5) * 6) = 60 ((((8 - 3) * 10) * 6) / 5) = 60 ((((8 - 3) * 10) / 5) * 6) = 60 ((((8 - 3) - 5) + 6) * 10) = 60 ((((8 - 3) - 5) + 10) * 6) = 60 ((((8 - 3) / 5) * 6) * 10) = 60 ((((8 - 3) / 5) * 10) * 6) = 60 ((((8 * 3) + 6) * 10) / 5) = 60 ((((8 * 3) + 6) / 5) * 10) = 60 ((((8 + 6) - 3) - 5) * 10) = 60 ((((8 + 6) - 10) * 3) * 5) = 60 ((((8 + 6) - 10) * 5) * 3) = 60 ((((8 + 6) - 5) - 3) * 10) = 60 ((((8 - 6) * 5) + 10) * 3) = 60 ((((8 * 6) - 3) + 10) + 5) = 60 ((((8 * 6) - 3) + 5) + 10) = 60 ((((8 * 6) + 10) - 3) + 5) = 60 ((((8 * 6) + 10) + 5) - 3) = 60 ((((8 * 6) + 5) - 3) + 10) = 60 ((((8 * 6) + 5) + 10) - 3) = 60 ((((8 + 10) - 3) - 5) * 6) = 60 ((((8 + 10) / 3) + 6) * 5) = 60 ((((8 + 10) - 5) - 3) * 6) = 60 ((((8 - 10) + 6) * 3) * 5) = 60 ((((8 - 10) + 6) * 5) * 3) = 60 ((((8 - 5) - 3) + 6) * 10) = 60 ((((8 - 5) - 3) + 10) * 6) = 60 ((((8 - 5) / 3) * 6) * 10) = 60 ((((8 - 5) / 3) * 10) * 6) = 60 ((((8 - 5) + 6) - 3) * 10) = 60 ((((8 - 5) * 6) / 3) * 10) = 60 ((((8 - 5) * 6) * 10) / 3) = 60 ((((8 - 5) + 10) - 3) * 6) = 60 ((((8 - 5) * 10) / 3) * 6) = 60 ((((8 - 5) * 10) * 6) / 3) = 60 ((((8 * 5) - 10) / 3) * 6) = 60 ((((8 * 5) - 10) * 6) / 3) = 60 ((((8 - 3) + 6) - 5) * 10) = 60 ((((8 - 3) * 6) * 10) / 5) = 60 ((((8 - 3) * 6) / 5) * 10) = 60 ((((8 - 3) + 10) - 5) * 6) = 60 ((((8 - 3) * 10) * 6) / 5) = 60 ((((8 - 3) * 10) / 5) * 6) = 60 ((((8 - 3) - 5) + 6) * 10) = 60 ((((8 - 3) - 5) + 10) * 6) = 60 ((((8 - 3) / 5) * 6) * 10) = 60 ((((8 - 3) / 5) * 10) * 6) = 60 ((((8 * 3) + 6) * 10) / 5) = 60 ((((8 * 3) + 6) / 5) * 10) = 60 ((((8 + 6) - 3) - 5) * 10) = 60 ((((8 + 6) - 10) * 3) * 5) = 60 ((((8 + 6) - 10) * 5) * 3) = 60 ((((8 + 6) - 5) - 3) * 10) = 60 ((((8 - 6) * 5) + 10) * 3) = 60 ((((8 * 6) - 3) + 10) + 5) = 60 ((((8 * 6) - 3) + 5) + 10) = 60 ((((8 * 6) + 10) - 3) + 5) = 60 ((((8 * 6) + 10) + 5) - 3) = 60 ((((8 * 6) + 5) - 3) + 10) = 60 ((((8 * 6) + 5) + 10) - 3) = 60 ((((8 + 10) - 3) - 5) * 6) = 60 ((((8 + 10) / 3) + 6) * 5) = 60 ((((8 + 10) - 5) - 3) * 6) = 60 ((((8 - 10) + 6) * 3) * 5) = 60 ((((8 - 10) + 6) * 5) * 3) = 60 ((((8 - 5) - 3) + 6) * 10) = 60 ((((8 - 5) - 3) + 10) * 6) = 60 ((((8 - 5) / 3) * 6) * 10) = 60 ((((8 - 5) / 3) * 10) * 6) = 60 ((((8 - 5) + 6) - 3) * 10) = 60 ((((8 - 5) * 6) / 3) * 10) = 60 ((((8 - 5) * 6) * 10) / 3) = 60 ((((8 - 5) + 10) - 3) * 6) = 60 ((((8 - 5) * 10) / 3) * 6) = 60 ((((8 - 5) * 10) * 6) / 3) = 60 ((((8 * 5) - 10) / 3) * 6) = 60 ((((8 * 5) - 10) * 6) / 3) = 60 ((((10 + 3) - 8) + 5) * 6) = 60 ((((10 + 3) + 5) - 8) * 6) = 60 ((((10 - 3) + 8) - 5) * 6) = 60 ((((10 - 3) - 5) + 8) * 6) = 60 ((((10 / 3) * 6) - 8) * 5) = 60 ((((10 * 6) + 3) - 8) + 5) = 60 ((((10 * 6) + 3) + 5) - 8) = 60 ((((10 * 6) - 3) + 8) - 5) = 60 ((((10 * 6) - 3) - 5) + 8) = 60 ((((10 * 6) / 3) - 8) * 5) = 60 ((((10 * 6) + 8) - 3) - 5) = 60 ((((10 * 6) + 8) - 5) - 3) = 60 ((((10 * 6) - 8) + 3) + 5) = 60 ((((10 * 6) - 8) + 5) + 3) = 60 ((((10 * 6) + 5) + 3) - 8) = 60 ((((10 * 6) + 5) - 8) + 3) = 60 ((((10 * 6) - 5) - 3) + 8) = 60 ((((10 * 6) - 5) + 8) - 3) = 60 ((((10 * 6) / 5) + 8) * 3) = 60 ((((10 + 8) - 3) - 5) * 6) = 60 ((((10 + 8) / 3) + 6) * 5) = 60 ((((10 + 8) - 5) - 3) * 6) = 60 ((((10 - 8) + 3) + 5) * 6) = 60 ((((10 - 8) * 3) + 6) * 5) = 60 ((((10 - 8) + 5) + 3) * 6) = 60 ((((10 + 5) + 3) - 8) * 6) = 60 ((((10 + 5) * 3) / 6) * 8) = 60 ((((10 + 5) * 3) * 8) / 6) = 60 ((((10 + 5) / 6) * 3) * 8) = 60 ((((10 + 5) / 6) * 8) * 3) = 60 ((((10 + 5) - 8) + 3) * 6) = 60 ((((10 + 5) * 8) * 3) / 6) = 60 ((((10 + 5) * 8) / 6) * 3) = 60 ((((10 - 5) - 3) + 8) * 6) = 60 ((((10 - 5) + 8) - 3) * 6) = 60 ((((10 / 5) * 6) + 8) * 3) = 60 ((((10 + 3) - 8) + 5) * 6) = 60 ((((10 + 3) + 5) - 8) * 6) = 60 ((((10 - 3) + 8) - 5) * 6) = 60 ((((10 - 3) - 5) + 8) * 6) = 60 ((((10 / 3) * 6) - 8) * 5) = 60 ((((10 * 6) + 3) - 8) + 5) = 60 ((((10 * 6) + 3) + 5) - 8) = 60 ((((10 * 6) - 3) + 8) - 5) = 60 ((((10 * 6) - 3) - 5) + 8) = 60 ((((10 * 6) / 3) - 8) * 5) = 60 ((((10 * 6) + 8) - 3) - 5) = 60 ((((10 * 6) + 8) - 5) - 3) = 60 ((((10 * 6) - 8) + 3) + 5) = 60 ((((10 * 6) - 8) + 5) + 3) = 60 ((((10 * 6) + 5) + 3) - 8) = 60 ((((10 * 6) + 5) - 8) + 3) = 60 ((((10 * 6) - 5) - 3) + 8) = 60 ((((10 * 6) - 5) + 8) - 3) = 60 ((((10 * 6) / 5) + 8) * 3) = 60 ((((10 + 8) - 3) - 5) * 6) = 60 ((((10 + 8) / 3) + 6) * 5) = 60 ((((10 + 8) - 5) - 3) * 6) = 60 ((((10 - 8) + 3) + 5) * 6) = 60 ((((10 - 8) * 3) + 6) * 5) = 60 ((((10 - 8) + 5) + 3) * 6) = 60 ((((10 + 5) + 3) - 8) * 6) = 60 ((((10 + 5) * 3) / 6) * 8) = 60 ((((10 + 5) * 3) * 8) / 6) = 60 ((((10 + 5) / 6) * 3) * 8) = 60 ((((10 + 5) / 6) * 8) * 3) = 60 ((((10 + 5) - 8) + 3) * 6) = 60 ((((10 + 5) * 8) * 3) / 6) = 60 ((((10 + 5) * 8) / 6) * 3) = 60 ((((10 - 5) - 3) + 8) * 6) = 60 ((((10 - 5) + 8) - 3) * 6) = 60 ((((10 / 5) * 6) + 8) * 3) = 60 ((((10 + 3) - 8) + 5) * 6) = 60 ((((10 + 3) + 5) - 8) * 6) = 60 ((((10 - 3) + 8) - 5) * 6) = 60 ((((10 - 3) - 5) + 8) * 6) = 60 ((((10 / 3) * 6) - 8) * 5) = 60 ((((10 * 6) + 3) - 8) + 5) = 60 ((((10 * 6) + 3) + 5) - 8) = 60 ((((10 * 6) - 3) + 8) - 5) = 60 ((((10 * 6) - 3) - 5) + 8) = 60 ((((10 * 6) / 3) - 8) * 5) = 60 ((((10 * 6) + 8) - 3) - 5) = 60 ((((10 * 6) + 8) - 5) - 3) = 60 ((((10 * 6) - 8) + 3) + 5) = 60 ((((10 * 6) - 8) + 5) + 3) = 60 ((((10 * 6) + 5) + 3) - 8) = 60 ((((10 * 6) + 5) - 8) + 3) = 60 ((((10 * 6) - 5) - 3) + 8) = 60 ((((10 * 6) - 5) + 8) - 3) = 60 ((((10 * 6) / 5) + 8) * 3) = 60 ((((10 + 8) - 3) - 5) * 6) = 60 ((((10 + 8) / 3) + 6) * 5) = 60 ((((10 + 8) - 5) - 3) * 6) = 60 ((((10 - 8) + 3) + 5) * 6) = 60 ((((10 - 8) * 3) + 6) * 5) = 60 ((((10 - 8) + 5) + 3) * 6) = 60 ((((10 + 5) + 3) - 8) * 6) = 60 ((((10 + 5) * 3) / 6) * 8) = 60 ((((10 + 5) * 3) * 8) / 6) = 60 ((((10 + 5) / 6) * 3) * 8) = 60 ((((10 + 5) / 6) * 8) * 3) = 60 ((((10 + 5) - 8) + 3) * 6) = 60 ((((10 + 5) * 8) * 3) / 6) = 60 ((((10 + 5) * 8) / 6) * 3) = 60 ((((10 - 5) - 3) + 8) * 6) = 60 ((((10 - 5) + 8) - 3) * 6) = 60 ((((10 / 5) * 6) + 8) * 3) = 60 ((((10 + 3) - 8) + 5) * 6) = 60 ((((10 + 3) + 5) - 8) * 6) = 60 ((((10 - 3) + 8) - 5) * 6) = 60 ((((10 - 3) - 5) + 8) * 6) = 60 ((((10 / 3) * 6) - 8) * 5) = 60 ((((10 * 6) + 3) - 8) + 5) = 60 ((((10 * 6) + 3) + 5) - 8) = 60 ((((10 * 6) - 3) + 8) - 5) = 60 ((((10 * 6) - 3) - 5) + 8) = 60 ((((10 * 6) / 3) - 8) * 5) = 60 ((((10 * 6) + 8) - 3) - 5) = 60 ((((10 * 6) + 8) - 5) - 3) = 60 ((((10 * 6) - 8) + 3) + 5) = 60 ((((10 * 6) - 8) + 5) + 3) = 60 ((((10 * 6) + 5) + 3) - 8) = 60 ((((10 * 6) + 5) - 8) + 3) = 60 ((((10 * 6) - 5) - 3) + 8) = 60 ((((10 * 6) - 5) + 8) - 3) = 60 ((((10 * 6) / 5) + 8) * 3) = 60 ((((10 + 8) - 3) - 5) * 6) = 60 ((((10 + 8) / 3) + 6) * 5) = 60 ((((10 + 8) - 5) - 3) * 6) = 60 ((((10 - 8) + 3) + 5) * 6) = 60 ((((10 - 8) * 3) + 6) * 5) = 60 ((((10 - 8) + 5) + 3) * 6) = 60 ((((10 + 5) + 3) - 8) * 6) = 60 ((((10 + 5) * 3) / 6) * 8) = 60 ((((10 + 5) * 3) * 8) / 6) = 60 ((((10 + 5) / 6) * 3) * 8) = 60 ((((10 + 5) / 6) * 8) * 3) = 60 ((((10 + 5) - 8) + 3) * 6) = 60 ((((10 + 5) * 8) * 3) / 6) = 60 ((((10 + 5) * 8) / 6) * 3) = 60 ((((10 - 5) - 3) + 8) * 6) = 60 ((((10 - 5) + 8) - 3) * 6) = 60 ((((10 / 5) * 6) + 8) * 3) = 60 ((((5 + 3) + 6) - 8) * 10) = 60 ((((5 + 3) * 6) / 8) * 10) = 60 ((((5 + 3) * 6) * 10) / 8) = 60 ((((5 + 3) - 8) + 6) * 10) = 60 ((((5 + 3) - 8) + 10) * 6) = 60 ((((5 + 3) * 8) + 6) - 10) = 60 ((((5 + 3) * 8) - 10) + 6) = 60 ((((5 + 3) / 8) * 6) * 10) = 60 ((((5 + 3) / 8) * 10) * 6) = 60 ((((5 + 3) + 10) - 8) * 6) = 60 ((((5 + 3) * 10) * 6) / 8) = 60 ((((5 + 3) * 10) / 8) * 6) = 60 ((((5 * 3) / 10) + 6) * 8) = 60 ((((5 + 6) + 3) - 8) * 10) = 60 ((((5 + 6) - 8) + 3) * 10) = 60 ((((5 - 8) + 3) + 6) * 10) = 60 ((((5 - 8) + 3) + 10) * 6) = 60 ((((5 - 8) + 6) + 3) * 10) = 60 ((((5 - 8) + 10) + 3) * 6) = 60 ((((5 * 8) - 10) / 3) * 6) = 60 ((((5 * 8) - 10) * 6) / 3) = 60 ((((5 + 10) + 3) - 8) * 6) = 60 ((((5 + 10) * 3) / 6) * 8) = 60 ((((5 + 10) * 3) * 8) / 6) = 60 ((((5 + 10) / 6) * 3) * 8) = 60 ((((5 + 10) / 6) * 8) * 3) = 60 ((((5 + 10) - 8) + 3) * 6) = 60 ((((5 + 10) * 8) * 3) / 6) = 60 ((((5 + 10) * 8) / 6) * 3) = 60 ((((5 / 10) * 3) + 6) * 8) = 60 ((((5 + 3) + 6) - 8) * 10) = 60 ((((5 + 3) * 6) / 8) * 10) = 60 ((((5 + 3) * 6) * 10) / 8) = 60 ((((5 + 3) - 8) + 6) * 10) = 60 ((((5 + 3) - 8) + 10) * 6) = 60 ((((5 + 3) * 8) + 6) - 10) = 60 ((((5 + 3) * 8) - 10) + 6) = 60 ((((5 + 3) / 8) * 6) * 10) = 60 ((((5 + 3) / 8) * 10) * 6) = 60 ((((5 + 3) + 10) - 8) * 6) = 60 ((((5 + 3) * 10) * 6) / 8) = 60 ((((5 + 3) * 10) / 8) * 6) = 60 ((((5 * 3) / 10) + 6) * 8) = 60 ((((5 + 6) + 3) - 8) * 10) = 60 ((((5 + 6) - 8) + 3) * 10) = 60 ((((5 - 8) + 3) + 6) * 10) = 60 ((((5 - 8) + 3) + 10) * 6) = 60 ((((5 - 8) + 6) + 3) * 10) = 60 ((((5 - 8) + 10) + 3) * 6) = 60 ((((5 * 8) - 10) / 3) * 6) = 60 ((((5 * 8) - 10) * 6) / 3) = 60 ((((5 + 10) + 3) - 8) * 6) = 60 ((((5 + 10) * 3) / 6) * 8) = 60 ((((5 + 10) * 3) * 8) / 6) = 60 ((((5 + 10) / 6) * 3) * 8) = 60 ((((5 + 10) / 6) * 8) * 3) = 60 ((((5 + 10) - 8) + 3) * 6) = 60 ((((5 + 10) * 8) * 3) / 6) = 60 ((((5 + 10) * 8) / 6) * 3) = 60 ((((5 / 10) * 3) + 6) * 8) = 60 ((((5 + 3) + 6) - 8) * 10) = 60 ((((5 + 3) * 6) / 8) * 10) = 60 ((((5 + 3) * 6) * 10) / 8) = 60 ((((5 + 3) - 8) + 6) * 10) = 60 ((((5 + 3) - 8) + 10) * 6) = 60 ((((5 + 3) * 8) + 6) - 10) = 60 ((((5 + 3) * 8) - 10) + 6) = 60 ((((5 + 3) / 8) * 6) * 10) = 60 ((((5 + 3) / 8) * 10) * 6) = 60 ((((5 + 3) + 10) - 8) * 6) = 60 ((((5 + 3) * 10) * 6) / 8) = 60 ((((5 + 3) * 10) / 8) * 6) = 60 ((((5 * 3) / 10) + 6) * 8) = 60 ((((5 + 6) + 3) - 8) * 10) = 60 ((((5 + 6) - 8) + 3) * 10) = 60 ((((5 - 8) + 3) + 6) * 10) = 60 ((((5 - 8) + 3) + 10) * 6) = 60 ((((5 - 8) + 6) + 3) * 10) = 60 ((((5 - 8) + 10) + 3) * 6) = 60 ((((5 * 8) - 10) / 3) * 6) = 60 ((((5 * 8) - 10) * 6) / 3) = 60 ((((5 + 10) + 3) - 8) * 6) = 60 ((((5 + 10) * 3) / 6) * 8) = 60 ((((5 + 10) * 3) * 8) / 6) = 60 ((((5 + 10) / 6) * 3) * 8) = 60 ((((5 + 10) / 6) * 8) * 3) = 60 ((((5 + 10) - 8) + 3) * 6) = 60 ((((5 + 10) * 8) * 3) / 6) = 60 ((((5 + 10) * 8) / 6) * 3) = 60 ((((5 / 10) * 3) + 6) * 8) = 60 ((((5 + 3) + 6) - 8) * 10) = 60 ((((5 + 3) * 6) / 8) * 10) = 60 ((((5 + 3) * 6) * 10) / 8) = 60 ((((5 + 3) - 8) + 6) * 10) = 60 ((((5 + 3) - 8) + 10) * 6) = 60 ((((5 + 3) * 8) + 6) - 10) = 60 ((((5 + 3) * 8) - 10) + 6) = 60 ((((5 + 3) / 8) * 6) * 10) = 60 ((((5 + 3) / 8) * 10) * 6) = 60 ((((5 + 3) + 10) - 8) * 6) = 60 ((((5 + 3) * 10) * 6) / 8) = 60 ((((5 + 3) * 10) / 8) * 6) = 60 ((((5 * 3) / 10) + 6) * 8) = 60 ((((5 + 6) + 3) - 8) * 10) = 60 ((((5 + 6) - 8) + 3) * 10) = 60 ((((5 - 8) + 3) + 6) * 10) = 60 ((((5 - 8) + 3) + 10) * 6) = 60 ((((5 - 8) + 6) + 3) * 10) = 60 ((((5 - 8) + 10) + 3) * 6) = 60 ((((5 * 8) - 10) / 3) * 6) = 60 ((((5 * 8) - 10) * 6) / 3) = 60 ((((5 + 10) + 3) - 8) * 6) = 60 ((((5 + 10) * 3) / 6) * 8) = 60 ((((5 + 10) * 3) * 8) / 6) = 60 ((((5 + 10) / 6) * 3) * 8) = 60 ((((5 + 10) / 6) * 8) * 3) = 60 ((((5 + 10) - 8) + 3) * 6) = 60 ((((5 + 10) * 8) * 3) / 6) = 60 ((((5 + 10) * 8) / 6) * 3) = 60 ((((5 / 10) * 3) + 6) * 8) = 60\"]},\"42\":{\"h\":\"Dev-C++\"},\"43\":{\"h\":\"新建文件\"},\"44\":{\"h\":\"第一个程序：你好世界！\"},\"45\":{\"h\":\"抓虫（debug）\"},\"46\":{\"h\":\"学会输出\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { cout << \\\"Hello World\\\"; return 0; }\"]},\"47\":{\"h\":\"一些单词\",\"t\":[\"include : 包含\",\"bits/stdc++.h : 万能头文件、包括了很多C++自带功能\",\"using : 使用\",\"namespace : name+space 命名空间\",\"std : standard 标准\",\"int : integer 整数\",\"main : 主要的\",\"cout : character+out 字符输出\",\"Hello World : 你好世界\",\"return : 返回\",\"0 : 没有消息就是最好的消息，0 表示成功运行结束\"]},\"48\":{\"h\":\"完整含义\",\"t\":[\"#include <bits/stdc++.h> //使用万能头文件 using namespace std; // 使用标准命名空间 int main() // 定义一个返回整数的主函数 { // 函数体使用大括号包裹 cout << \\\"Hello World\\\"; // 输出 Hello World return 0; // 返回 0 }\"]},\"49\":{\"h\":\"简单框架\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { // 要做的事写中间 return 0; }\"]},\"50\":{\"h\":\"这段程序会输出什么？\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { cout << \\\"Hello World\\\"; cout << \\\"Hello Hello\\\"; cout << \\\"World World\\\"; return 0; }\"]},\"51\":{\"h\":\"转义符\",\"t\":[\"有一些特殊字符需要使用转义符的方式表示\"]},\"52\":{\"h\":\"语句\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { cout << \\\"Hello World\\\\n\\\"; cout << \\\"Hello Hello\\\\n\\\"; cout << \\\"World World\\\"; return 0; }\"]},\"53\":{\"h\":\"语句\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { cout << \\\"Hello World\\\\n\\\" << \\\"Hello Hello\\\\n\\\"; cout << \\\"World World\\\"; return 0; }\"]},\"54\":{\"h\":\"语句\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { cout << \\\"Hello World\\\\nHello Hello\\\\nWorld World\\\"; return 0; }\"]},\"55\":{\"h\":\"字符串与数学表达式\",\"t\":[\"American Standard Code for Information Interchange\"]},\"56\":{\"h\":\"啥是字符串？\",\"t\":[\"钥匙串是一串钥匙，字符串就是一串字符呗\",\"'a'\",\"字符\",\"\\\"abcdefg\\\"\",\"字符串\",\"\\\"a\\\"\",\"字符串\",\"\\\"\\\"\",\"字符串\",\"空串也是字符串\"]},\"57\":{\"h\":\"数学表达式\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { cout << 14 + 3 << \\\"\\\\n\\\"; cout << 14 - 3 << \\\"\\\\n\\\"; cout << 14 * 3 << \\\"\\\\n\\\"; cout << 14 / 3 << \\\"\\\\n\\\"; return 0; }\"]},\"58\":{\"h\":\"数学运算符\",\"t\":[\"+: 加法\",\"-：减法\",\"*：乘法\",\"/：除法\",\"%：取余/取模\",\"(): 数学中的小括号、中括号、大括号在 C++ 中统统用小括号\",\"如果两个运算数都是整数，运算结果也会是整数（除法变成整除） 只要有一个运算数是小数（浮点数），运算结果就会的到小数\",\"取余只能在整数间进行！不能除以0或对0取余！\"]},\"59\":{\"h\":\"口算训练\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { cout << (25 / 5 - 5 / 5) % 5 * 10 + 2 << \\\"\\\\n\\\"; return 0; }\"]},\"60\":{\"h\":\"变量与赋值语句\",\"t\":[\"可以储存数据的一块空间\",\"#include <bits/stdc++.h> using namespace std; int main() { int a; a = 3; a = 4; cout << a << \\\"\\\\n\\\"; return 0; }\"]},\"61\":{\"h\":\"常见数据类型/变量类型\",\"t\":[\"整数： int、long long\",\"小数（浮点数）：float、double\",\"字符：char\",\"布尔：bool\",\"字符串：string\",\"#include <bits/stdc++.h> using namespace std; int main() { int a = 8; cout << a / 3 << \\\"\\\\n\\\"; return 0; }\"]},\"62\":{\"h\":\"变量定义规则（比赛环境）\",\"t\":[\"变量定义方法：\",\"变量类型 变量名;\",\"变量类型 变量名 = 初始值;\",\"变量类型 变量名1, 变量名2, 变量名3;\",\"变量命名规则：\",\"字母或下划线开头\",\"只能包含字母、数字、下划线\",\"不能是 C++ 关键字\",\"以下哪些不符合规则？\",\"abc\",\"a1b2c3\",\"x4\",\"100x\",\"myScore__\",\"main()\",\"_123\",\"int\",\"_x3\"]},\"63\":{\"h\":\"赋值语句\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { int a, b; a = 3; b = 5; a = b; b = a; cout << a << \\\" \\\" << b << \\\"\\\\n\\\"; return 0; }\",\"#include <bits/stdc++.h> using namespace std; int main() { int a = 3; a = a + 5; cout << a << \\\"\\\\n\\\"; return 0; }\",\"#include <bits/stdc++.h> using namespace std; int main() { string a = \\\"123\\\"; string b = \\\"456\\\"; cout << (a + b) << \\\"\\\\n\\\"; return 0; }\"]},\"64\":{\"h\":\"语法糖\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { int a = 3; double b = 2.5; b += a; a += b; a++; cout << a << \\\"\\\\n\\\"; return 0; }\",\"a += b; ~ a = a + b;\",\"a -= b; ~ a = a - b;\",\"a *= b; ~ a = a * b;\",\"a /= b; ~ a = a / b;\",\"a %= b; ~ a = a % b;\",\"a++; ~ 将 a 增加 ；作为表达式时，值为增加之前的值\",\"++a; ~ 将 a 增加 ；作为表达式时，值为增加之后的值\"]},\"65\":{\"h\":\"输入语句与条件判断\"},\"66\":{\"h\":\"学会输入\",\"t\":[\"cout : character + out 字符输出\",\"cin : character + in 字符输入\",\"#include <bits/stdc++.h> using namespace std; int main() { int a, b; char c; cin >> a >> c >> b; cout << a + b << \\\"\\\\n\\\"; return 0; }\",\"int a, b; char c; cin >> a >> c >> b; cout << a + b << \\\"\\\\n\\\"; return 0;\",\"输入这些分别会输出什么？\",\"13+11：\",\"13-11：\",\"13 11：\"]},\"67\":{\"h\":\"OJ 使用\",\"t\":[\"OJ ~ Online Judge ~ 在线评测\"]},\"68\":{\"h\":\"题目页面\"},\"69\":{\"h\":\"常见评测结果\",\"t\":[\"Accepted ：程序输出完全正确\",\"Wrong Answer ：答案错误\",\"Time Limit Exceeded ：运行时间超限\",\"Memory Limit Exceeded ：运行内存超限\",\"Runtime Error：运行时错误\",\"Compile Error：编译失败\"]},\"70\":{\"h\":\"条件判断\",\"t\":[\"登陆 OJ 网站时输错了密码会怎么样？\",\"#include <bits/stdc++.h> using namespace std; int main() { string username; // 储存输入的用户名 string password; // 储存输入的密码 cout << \\\"请输入用户名:\\\"; cin >> username; cout << \\\"请输入密码:\\\"; cin >> password; // 判断用户名密码是否正确 如果((username为\\\"admin\\\")并且(password为\\\"123456\\\")) { cout << \\\"用户名密码正确！\\\"; } 否则 { cout << \\\"用户名密码不正确！\\\"; } return 0; }\"]},\"71\":{\"h\":\"新单词\",\"t\":[\"if：如果\",\"else：否则\"]},\"72\":{\"h\":\"比较（关系）运算符\",\"t\":[\">：大于\",\"<：小于\",\"==：等于\",\"!=：不等于\",\"<=：小于等于\",\">=：大于等于\"]},\"73\":{\"h\":\"逻辑运算符\",\"t\":[\"&&：and，并且（与）\",\"||：or，或者（或）\",\"!：not，不是（非）\"]},\"74\":{\"h\":\"用户名密码验证\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { string username; // 储存输入的用户名 string password; // 储存输入的密码 cout << \\\"请输入用户名:\\\"; cin >> username; cout << \\\"请输入密码:\\\"; cin >> password; // 判断用户名密码是否正确 if ((username == \\\"admin\\\") and (password == \\\"123456\\\")) { cout << \\\"用户名密码正确！\\\"; } else { cout << \\\"用户名密码不正确！\\\"; } return 0; }\"]},\"75\":{\"h\":\"条件判断语法\",\"t\":[\"if (条件表达式) { 条件成立时执行的语句 } else { 条件不成立时执行的语句 }\",\"if ( ) { } else if ( ) { } else { }\"]},\"76\":{\"h\":\"下面代码会输出什么？（1）\",\"t\":[\"if (1 > 2) cout << \\\"Yes\\\"; else cout << \\\"No\\\";\"]},\"77\":{\"h\":\"下面代码会输出什么？（2）\",\"t\":[\"if (2 > 1) cout << \\\"A\\\"; if (1 > 2) cout << \\\"B\\\"; else cout << \\\"C\\\";\"]},\"78\":{\"h\":\"下面代码会输出什么？（3）\",\"t\":[\"int x = 60; if (x < 60) { cout << \\\"A\\\\n\\\"; } else if (x < 100) { cout << \\\"B\\\\n\\\"; } else { cout << \\\"C\\\\n\\\"; }\"]},\"79\":{\"h\":\"下面代码会输出什么？（4）\",\"t\":[\"int x = 50; if (1 <= x <= 30) cout << \\\"A\\\"; else cout << \\\"B\\\";\"]},\"80\":{\"h\":\"布尔逻辑体系\",\"t\":[\"Boolean [adj.] 布尔逻辑体系的（分别以 1 和 0 代指真和假）\",\"真（1 < 2）：true、\",\"假（1 > 2）：false、\",\"真：\",\"假：\",\"真：\",\"int x = 50; if (1 <= x <= 30) cout << \\\"A\\\"; else cout << \\\"B\\\";\"]},\"81\":{\"h\":\"运算符优先级\",\"t\":[\"单目运算符： \",\"a++、a--\",\"not !\",\"--\",\"数学运算符\",\"乘除：* / %\",\"加减：+ -\",\"比较运算符\",\"大于小于号：< <= > >=\",\"相等不等：== !=\",\"双目逻辑运算：\",\"且：and &&\",\"或：or ||\",\"赋值运算：= += -= *= /= %=\"]},\"82\":{\"h\":\"基础数据类型\"},\"83\":{\"h\":\"数据类型对应的范围\",\"t\":[\"bit：位(1个二进制位)，计算机储存的最小单位\",\"Byte：字节（8个连续的二进制位），计算机储存的基本单位\",\" B(Byte) = bit\",\" KB(KiB) = B（ B）\",\" MB(MiB) = KB\",\" GB(GiB) = MB\",\" TB(TiB) = GB\",\" PB(PiB) = TB\",\"数据类型名\",\"内容(一般情况)\",\"占用内存大小\",\"能储存的范围\",\"scanf/printf 标识符(g++)\",\"int/signed\",\"32 位整数\",\"4 Bytes\",\" 约 \",\"%d/%d\",\"long long\",\"64 位整数\",\"8 Bytes\",\" 约 .\",\"%lld/%lld\",\"char\",\"字符\",\"1 Byte\",\"至少能储存 常见范围为 \",\"%c/%c\",\"float\",\"单精度浮点数\",\"4 Bytes\",\" 有效数字 位\",\"%f/%f\",\"double\",\"双精度浮点数\",\"8 Bytes\",\" 有效数字 位\",\"%lf/%f\",\"unsigned int\",\"无符号 32 位整数\",\"4 Bytes\",\" 约 \",\"%u/%u\",\"unsigned long long\",\"无符号 64 位整数\",\"8 Bytes\",\" 约 \",\"%llu/%llu\"]},\"84\":{\"h\":\"整数编码\"},\"85\":{\"h\":\"基础二进制\",\"t\":[\"二进制即要求满二进一，因此每一位为 或 \",\"二进制从最低位到最高位，数位的权值分别为：\",\"即 \",\" 转换成十进制结果如下\",\"原始数位： 1 0 1 1 0 1 对应权值：32 16 8 4 2 1 转十进制：32 + 8 + 4 + 1 = 45\"]},\"86\":{\"h\":\"原码、反码、补码\",\"t\":[\"原码 \",\"最高位为符号位，正数为 ，负数为 。\",\"剩下位置为原数绝对值的二进制。\",\"反码 \",\"正数反码与原码一致。\",\"负数反码除最高位之外，在原码基础上取反。\",\"补码 \",\"正数补码与原码一致\",\"负数补码在反码基础上加 。\"]},\"87\":{\"h\":\"讨厌的浮点数\"},\"88\":{\"h\":\"保留 位小数\"},\"89\":{\"h\":\"方法 1\",\"t\":[\"头文件：#include <cstdio>（<bits/stdc++.h> 包含了这个头文件）\",\"语句： printf(\\\"%.xf\\\", a);\"]},\"90\":{\"h\":\"方法 2（推荐）\",\"t\":[\"头文件：#include<iostream>、#include<iomanip>（<bits/stdc++.h> 包含了这两个头文件）\",\"语句：cout << fixed << setprecision(x) << a;\"]},\"91\":{\"h\":\"关于四舍五入\",\"t\":[\"如果题目说保留 位小数，那么就按照上面方式输出就可以了。\",\"但是需要注意的是，这种方式并不是我们直观中的四舍五入。\",\"对于 舍和 入的部分是没有问题的，对于舍入位是 ，且后面还有大于 的数位时也是没有问题的。但如果舍入位是 且后没有其他数了，那么有可能会有两个小问题。\",\"如果是 double 类型可以精确储存的数，那么会舍入到最接近的偶数数位，比如在保留 位小数的情况下：\",\" -> \",\" -> \",\" -> \",\" -> \",\"保留 位小数的情况下：\",\" -> \",\" -> \",\"如果是 double 类型无法无法精确储存的数，实际上储存的数可能会有一点点偏差，也会造成和我们所想不同。 比如如果输入 ，那么保留 位小数输出的会是 ，因为保留 位小数输出后，我们会发现实际储存的数大概是 ，执行的自然是 舍操作。\",\"现在的出题人一般都不会说四舍五入，而是用精度控制，比如相对或绝对误差在 （即 ）以内就算对，此时你保留 位小数就肯定够了。\"]},\"92\":{\"h\":\"字符与整数的对应转换\",\"t\":[\"char c; int a;\"]},\"93\":{\"h\":\"数字字符与对应整数\",\"t\":[\"'0' ~ '9' 对应的 ASCII 为 48 ~ 57\",\"数字字符转换为对应整数：(int)(c - '0')\",\"数字转换为对应字符：(char)(a + '0')\"]},\"94\":{\"h\":\"大小写字母映射到\",\"t\":[\"'a' ~ 'z' 对应的 ASCII 为 97 ~ 122\",\"'A' ~ 'Z' 对应的 ASCII 为 65 ~ 90\",\"大写字母映射到 ：(int)(c - 'A')\",\"小写字母映射到 ：(int)(c - 'a')\"]},\"95\":{\"h\":\"大小写字母之间转换\",\"t\":[\"大写转小写：(char)(c - 'A' + 'a')\",\"小写转大写：(char)(c - 'a' + 'A')\"]},\"96\":{\"h\":\"其他常见基础操作\"},\"97\":{\"h\":\"数位分解\",\"t\":[\"% 10：取出个位\",\"/ 10：去掉个位\",\"个位：a % 10\",\"十位：a / 10 % 10\",\"百位：a / 100 % 10\",\"千位：a / 1000 % 10\"]},\"98\":{\"h\":\"闰年判断\",\"t\":[\"普通闰年：y % 4 == 0 && y % 100 != 0\",\"世纪闰年：y % 400 == 0\",\"闰年判断：(y % 4 == 0 && y % 100 != 0) || y % 400 == 0\",\"因为 && 优先级高于 ||，所以不写那个小括号也可以。\"]},\"99\":{\"h\":\"三角形判断\",\"t\":[\"任意两边之和大于第三边。\",\"a + b > c && a + c > b && b + c > a\"]},\"100\":{\"h\":\"上下取整\",\"t\":[\"int p, q, x;，这里我们只讨论 的情况。\",\"下取整（） \",\"x = p / q\",\"上取整（） \",\"if (p % q == 0) x = p / q; else x = p / q + 1;\",\"x = (p + (q - 1)) / q;\",\"x = p / q + (p % q != 0);\"]},\"101\":{\"h\":\"类型转换\",\"t\":[\"用一个目标类型的数参与运算（必须是更优先的类型）： \",\"1.0 * a\",\"1LL * a（默认情况下 1 为 int 类型，在后面加上 ll 或 LL 可以得到一个 long long 类型的 1）\",\"存入一个目标类型的变量： \",\"char c = 'a' - 32;\",\"用 (type) 前缀，这个前缀会把紧跟着的数变为 type 类型。 \",\"(double)p / q\",\"(char)('a' - 32)\"]},\"102\":{\"h\":\"容器库常用内容\",\"t\":[\"C++ 文档：容器库\"]},\"103\":{\"h\":\"vector（向量、动态数组）\",\"t\":[\"vector<int> a;：定义了一个名字叫作 a，可以存 int 的动态数组。初始数组为空。\",\"vector<int> a[100];：定义了 个动态数组 a[0]~a[99] 都是动态数组。\",\"a.push_back(x);： 添加元素，把 x 添加到动态数组末尾。\",\"a[pos]：访问元素，访问下标为 pos 的元素\",\"a.clear()：清空数组，清空整个数组，数组大小也归零了。\",\"a.resize(100)：更改数组大小，把数组大小修改为 100\",\"a.size()：当前数组大小\",\"a.empty()：数组是否为空，数组是空的就返回真\",\"a.begin()：起始位置迭代器：\",\"a.end()：结束位置迭代器：\"]},\"104\":{\"h\":\"deque（双端队列）\",\"t\":[\"deque<int> q;：定义了一个名字叫作 q 的双端队列。\",\"q.front()：返回队头（的引用）。\",\"q.back()：返回队尾（的引用）。\",\"q.push_back(x);：从队列末尾放入 x。\",\"q.push_front(x);：从队列开头放入 x。\",\"q.pop_back();：从队列末尾弹出元素。\",\"q.pop_front();：从队列开头弹出元素。\",\"q[pos]：访问元素，访问下标为 pos 的元素\",\"q.clear()：清空双端队列，双端队列大小也归零了。\",\"q.size()：当前队列大小\",\"q.empty()：队列是否为空，队列是空的就返回真\"]},\"105\":{\"h\":\"stack（栈）\",\"t\":[\"stack<int> sta;：定义了一个名字叫作 sta 的栈。\",\"sta.top()：返回栈顶（的引用）。\",\"sta.push(x);：把 x 压入栈。\",\"sta.pop();：弹出栈顶元素。\",\"sta.size()：当前栈大小\",\"sta.empty()：栈是否为空，栈是空的就返回真\"]},\"106\":{\"h\":\"queue（队列）\",\"t\":[\"queue<int> q;：定义了一个名字叫作 q 的队列。\",\"q.front()：返回队头（的引用）。\",\"q.back()：返回队尾（的引用）。\",\"q.push(x);：把 x 压入队列。\",\"q.pop();：弹出队头。\",\"q.size()：当前队列大小\",\"q.empty()：队列是否为空，队列是空的就返回真\"]},\"107\":{\"h\":\"铺砖块\"},\"108\":{\"h\":\"题目\",\"t\":[\"给你一个 的地板，你需要用 和 的砖块密铺它，问：有多少种方案（答案 。）。\"]},\"109\":{\"h\":\"填表 100 分\",\"t\":[\"总耗时：3863ms\",\"如果每次加法后直接取模会退化成超时 70 分\",\"如果每次加法后用 if 判断以及减法，总耗时 5626ms\",\"#include <bits/stdc++.h> #define int long long using namespace std; const int MAXN = 1000; const int MAXM = 15; const int MOD = 998244353; int n, m; // g[sta] 存所有可以达成 sta 状态的 pre vector<int> g[(1 << MAXM)]; // dfs 预处理 g 数组 // 当前行状态为 sta(0~m-1)，当前看第 pos 个位置，目前下一行被变成了 nxt void dfs(int sta, int pos, int nxt) { // 0~m-1 这些位置都安置好了，说明 sta 铺满可以达成 nxt if (pos == m) { g[nxt].push_back(sta); return; } // 当前位置有东西就直接看下一个位置 if (sta & (1 << pos)) { dfs(sta, pos + 1, nxt); return; } // 现在当前位置肯定没东西，先竖着放一个 dfs(sta, pos + 1, nxt + (1 << pos)); // 下一个位置如果也是空的，那么可以横着放一个 if (pos + 1 < m && !(sta & (1 << (pos + 1)))) dfs(sta, pos + 2, nxt); } int f[MAXN + 5][1 << MAXM]; signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m; for (int sta = 0; sta <= (1 << m) - 1; sta++) dfs(sta, 0, 0); f[1][0] = 1; for (int i = 2; i <= n + 1; i++) for (int sta = 0; sta <= (1 << m) - 1; sta++) { for (int pre : g[sta]) f[i][sta] += f[i - 1][pre]; f[i][sta] %= MOD; } // 注意 f[n][(1<<m)-1] 不是正确答案 // 比如第 n 行有连续两个的空位也是对的 cout << f[n + 1][0]; return 0; }\"]},\"110\":{\"h\":\"刷表 100 分\",\"t\":[\"总耗时：1467ms\",\"#include <bits/stdc++.h> #define int long long using namespace std; const int MAXN = 1000; const int MAXM = 15; const int MOD = 998244353; int n, m; // g[sta] 存所有 sta 可以达成状态的 nxt vector<int> g[(1 << MAXM)]; // dfs 预处理 g 数组 // 当前行状态为 sta(0~m-1)，当前看第 pos 个位置，目前下一行被变成了 nxt void dfs(int sta, int pos, int nxt) { // 0~m-1 这些位置都安置好了，说明 sta 铺满可以达成 nxt if (pos == m) { g[sta].push_back(nxt); return; } // 当前位置有东西就直接看下一个位置 if (sta & (1 << pos)) { dfs(sta, pos + 1, nxt); return; } // 现在当前位置肯定没东西，先竖着放一个 dfs(sta, pos + 1, nxt + (1 << pos)); // 下一个位置如果也是空的，那么可以横着放一个 if (pos + 1 < m && !(sta & (1 << (pos + 1)))) dfs(sta, pos + 2, nxt); } int f[MAXN + 5][1 << MAXM]; signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m; for (int sta = 0; sta <= (1 << m) - 1; sta++) dfs(sta, 0, 0); f[1][0] = 1; for (int i = 1; i <= n; i++) for (int sta = 0; sta <= (1 << m) - 1; sta++) { if (!f[i][sta]) continue; f[i][sta] %= MOD; for (int nxt : g[sta]) f[i + 1][nxt] += f[i][sta]; } // 注意 f[n][(1<<m)-1] 不是正确答案 // 比如第 n 行有连续两个的空位也是对的 cout << f[n + 1][0] % MOD; return 0; }\"]},\"111\":{\"h\":\"卖水果\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n, x, y; int a1, a2, a3, a4; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> x >> y; cin >> a1 >> a2 >> a3 >> a4; int plan1 = (n / 10) * 4 * x; int plan2 = (n / 2) * y; int plan3 = (a1 + a2 + a3 + a4) * n; //cout << plan1 << \\\" \\\" << plan2 << \\\" \\\" << plan3 << \\\"\\\\n\\\"; if (plan1 > plan2 && plan1 > plan3) { cout << plan1 << \\\"\\\\n\\\"; } else if (plan2 > plan3) { cout << plan2 << \\\"\\\\n\\\"; } else { cout << plan3 << \\\"\\\\n\\\"; } return 0; }\"]},\"112\":{\"h\":\"最长上升子序列长度（简单版）\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 5000; int n; int a[MAXN + 5]; // f[i]: 以 a[i] 结尾的 LIS 长度 int f[MAXN + 5]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; int ans = 0; for (int i = 1; i <= n; i++) { f[i] = 1; for (int j = 1; j <= i - 1; j++) if (a[j] < a[i]) f[i] = max(f[i], f[j] + 1); ans = max(ans, f[i]); } cout << ans; return 0; }\"]},\"113\":{\"h\":\"最长上升子序列长度\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 200'000; const int MAXAI = 1'000'000'000; int n; int a[MAXN + 5]; // f[i]: 以 a[i] 结尾的 LIS 长度 int f[MAXN + 5]; // g[len]: 当前长度为 len 的 LIS 的最小结尾 int g[MAXN + 5]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; int ans = 0; for (int i = 1; i <= n; i++) g[i] = MAXAI + 1; for (int i = 1; i <= n; i++) { int len = lower_bound(g + 1, g + n + 1, a[i]) - g; f[i] = len; g[len] = a[i]; ans = max(ans, f[i]); } cout << ans; return 0; }\"]},\"114\":{\"h\":\"最长上升子序列方案\"},\"115\":{\"h\":\"60 分\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 5000; int n; int a[MAXN + 5]; // f[i]: 以 a[i] 结尾的 LIS 长度 int f[MAXN + 5]; // pre[i]: 以 a[i] 结尾的 LIS 的上一个元素下标 int pre[MAXN + 5]; // 方案，实际上也可以递归输出 vector<int> plan; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; int ansI = 1; for (int i = 1; i <= n; i++) { f[i] = 1; for (int j = 1; j <= i - 1; j++) if (a[j] < a[i] && f[j] + 1 > f[i]) { f[i] = f[j] + 1; pre[i] = j; } if (f[i] > f[ansI]) ansI = i; } cout << f[ansI] << \\\"\\\\n\\\"; while (ansI) { plan.push_back(a[ansI]); ansI = pre[ansI]; } for (int i = (int)plan.size() - 1; i >= 0; i--) cout << plan[i] << \\\" \\\"; return 0; }\"]},\"116\":{\"h\":\"100 分\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 200'000; const int MAXAI = 1'000'000'000; int n; int a[MAXN + 5]; // f[i]: 以 a[i] 结尾的 LIS 长度 int f[MAXN + 5]; // g[len]: 当前长度为 len 的 LIS 最小结尾的元素下标 int g[MAXN + 5]; // pre[i]: 以 a[i] 结尾的 LIS 的上一个元素下标 int pre[MAXN + 5]; // 方案，实际上也可以递归输出 vector<int> plan; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; int ansI = 1; for (int i = 1; i <= n; i++) g[i] = 0; a[0] = MAXAI + 1; for (int i = 1; i <= n; i++) { int l = 1; int r = n; int len; while (l <= r) { int mid = (l + r) / 2; if (a[g[mid]] >= a[i]) { len = mid; r = mid - 1; } else l = mid + 1; } f[i] = len; g[len] = i; pre[i] = g[len - 1]; if (f[i] > f[ansI]) ansI = i; } cout << f[ansI] << \\\"\\\\n\\\"; while (ansI) { plan.push_back(a[ansI]); ansI = pre[ansI]; } for (int i = (int)plan.size() - 1; i >= 0; i--) cout << plan[i] << \\\" \\\"; return 0; }\"]},\"117\":{\"h\":\"最长不上升子序列长度\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 200'000; const int MAXAI = 1'000'000'000; int n; int a[MAXN + 5]; // 这里 LIS 指最长不上升子序列长度 >= >= >= // f[i]: 以 b[i] 结尾的 LIS 长度 int f[MAXN + 5]; // g[len]: 当前长度为 len 的 LIS 的最小结尾 int g[MAXN + 5]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; int ans = 0; for (int i = 1; i <= n; i++) g[i] = 0; for (int i = 1; i <= n; i++) { int l = 1; int r = n; int len; while (l <= r) { int mid = (l + r) / 2; if (g[mid] < a[i]) { len = mid; r = mid - 1; } else { l = mid + 1; } } f[i] = len; g[len] = a[i]; ans = max(ans, f[i]); } cout << ans; return 0; }\"]},\"118\":{\"h\":\"最长上升奇偶子序列\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n; int a[5005]; int f[5005]; // 以 a[i] 结尾的最长子序列 int main() { cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; int ans = 0; for (int i = 1; i <= n; i++) { f[i] = 1; for (int j = 1; j < i; j++) if (a[j] % 2 != a[i] % 2 && a[j] < a[i]) f[i] = max(f[i], f[j] + 1); ans = max(ans, f[i]); } cout << ans; return 0; }\"]},\"119\":{\"h\":\"最长上升子序列方案数\",\"t\":[\"#include <bits/stdc++.h> #define int long long using namespace std; const int MOD = 1'000'000'000 + 7; int n; int a[5005]; int f[5005]; // 以 a[i] 结尾的最长上升子序列长度 int g[5005]; // 以 a[i] 结尾的最长上升子序列方案数 signed main() { cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; int ansF = 0; // 最长上升子序列的长度 for (int i = 1; i <= n; i++) { f[i] = 1; for (int j = 1; j < i; j++) if (a[j] < a[i]) f[i] = max(f[i], f[j] + 1); ansF = max(ansF, f[i]); if (f[i] == 1) g[i] = 1; else { g[i] = 0; for (int j = 1; j < i; j++) if (a[j] < a[i] && f[j] == f[i] - 1) g[i] += g[j]; g[i] %= MOD; } } int ans = 0; // 最长上升子序列的方案数 for (int i = 1; i <= n; i++) if (f[i] == ansF) ans += g[i]; cout << ans % MOD; return 0; }\"]},\"120\":{\"h\":\"最长公共子序列长度\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 1000; int n, m; int a[1005], b[1005]; // f[i][j] 记录 a 前 i 个元素与 b 前 j 个元素的 LCS 长度 int f[1005][1005]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m; for (int i = 1; i <= n; i++) cin >> a[i]; for (int i = 1; i <= m; i++) cin >> b[i]; for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) if (a[i] == b[j]) f[i][j] = f[i - 1][j - 1] + 1; else f[i][j] = max(f[i - 1][j], f[i][j - 1]); cout << f[n][m]; return 0; }\"]},\"121\":{\"h\":\"排列的最长公共子序列长度\"},\"122\":{\"h\":\"真的修改\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 100000; int n; int a[MAXN + 5]; int b[MAXN + 5]; int rnk[MAXN + 5]; // rnk[i] 表示 i 在 a 的排名 int ans; // f[i]: 以 b[i] 结尾的 LIS 长度 int f[MAXN + 5]; // g[len]: 当前长度为 len 的 LIS 的最小结尾 int g[MAXN + 5]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; for (int i = 1; i <= n; i++) cin >> b[i]; // 真的修改 b[i] for (int i = 1; i <= n; i++) rnk[a[i]] = i; for (int i = 1; i <= n; i++) b[i] = rnk[b[i]]; // LIS for (int i = 1; i <= n; i++) g[i] = n + 1; for (int i = 1; i <= n; i++) { int len = lower_bound(g + 1, g + n + 1, b[i]) - g; f[i] = len; g[len] = b[i]; ans = max(ans, f[i]); } cout << ans << \\\"\\\\n\\\"; return 0; }\"]},\"123\":{\"h\":\"不修改\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 100000; int n; int a[MAXN + 5]; int b[MAXN + 5]; int rnk[MAXN + 5]; // rnk[i] 表示 i 在 a 的排名 int ans; // f[i]: 以 b[i] 结尾的 LIS 长度 int f[MAXN + 5]; // g[len]: 当前长度为 len 的 LIS 的最小结尾 int g[MAXN + 5]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; for (int i = 1; i <= n; i++) cin >> b[i]; // 不修改 b[i]，只是在 b[i] 以 rnk 为依据进行比较 for (int i = 1; i <= n; i++) rnk[a[i]] = i; // LIS for (int i = 1; i <= n; i++) g[i] = 0; rnk[0] = n + 1; for (int i = 1; i <= n; i++) { int l = 1; int r = n; int len; while (l <= r) { int mid = (l + r) / 2; if (rnk[g[mid]] >= rnk[b[i]]) { len = mid; r = mid - 1; } else l = mid + 1; } f[i] = len; g[len] = b[i]; ans = max(ans, f[i]); } cout << ans << \\\"\\\\n\\\"; return 0; }\"]},\"124\":{\"h\":\"反向最长公共子序列\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 1000; int n, m; int a[1005], b[1005]; // f[i][j] 记录 a 前 i 个元素与 b 前 j 个元素的 LCS 长度 int f[1005][1005]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m; for (int i = 1; i <= n; i++) cin >> a[i]; for (int i = 1; i <= m; i++) cin >> b[i]; for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) if (a[i] == b[j]) f[i][j] = f[i - 1][j - 1] + 1; else f[i][j] = max(f[i - 1][j], f[i][j - 1]); cout << n+m-f[n][m]; return 0; }\"]},\"125\":{\"h\":\"最长公共子序列方案\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 1000; int n, m; int a[1005], b[1005]; // f[i][j] 记录 a 前 i 个元素与 b 前 j 个元素的 LCS 长度 int f[1005][1005]; // f[i][j] 的前一个状态 pair<int, int> pre[1005][1005]; // 方案，实际上也可以递归输出 vector<int> plan; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m; for (int i = 1; i <= n; i++) cin >> a[i]; for (int i = 1; i <= m; i++) cin >> b[i]; for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) if (a[i] == b[j]) { f[i][j] = f[i - 1][j - 1] + 1; pre[i][j] = make_pair(i - 1, j - 1); } else { if (f[i - 1][j] > f[i][j - 1]) { f[i][j] = f[i - 1][j]; pre[i][j] = make_pair(i - 1, j); } else { f[i][j] = f[i][j - 1]; pre[i][j] = make_pair(i, j - 1); } } cout << f[n][m] << \\\"\\\\n\\\"; while (n >= 1 && m >= 1) { if (a[n] == b[m]) plan.push_back(a[n]); pair<int, int> preNM = pre[n][m]; n = preNM.first; m = preNM.second; } for (int i = (int)plan.size() - 1; i >= 0; i--) cout << plan[i] << \\\" \\\"; cout << \\\"\\\\n\\\"; return 0; }\"]},\"126\":{\"h\":\"字母的最长公共子序列\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 5000; const int MAXM = 500'000; int n, m; string s; int a[MAXN + 5], b[MAXM + 5]; // f[i][j]: a[1]~a[i] 与 b 构成的长度为 j 的 LCS // 消耗掉了 b 的前 f[i][j] 个字符 int f[MAXN + 5][MAXN + 5]; // 存 b 中每个字母的所有出现位置 vector<int> pos[30]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m; cin >> s; for (int i = 1; i <= n; i++) a[i] = s[i - 1] - 'a' + 1; cin >> s; for (int i = 1; i <= m; i++) b[i] = s[i - 1] - 'a' + 1; for (int i = 1; i <= m; i++) pos[b[i]].push_back(i); // -1 表示无解 for (int i = 0; i <= n; i++) for (int j = 0; j <= n; j++) f[i][j] = -1; f[0][0] = 0; for (int i = 1; i <= n; i++) { for (int j = 0; j <= i; j++) { f[i][j] = f[i - 1][j]; if (j >= 1 && f[i - 1][j - 1] != -1) { // a[1]~a[i-1] 凑出了 j 的长度，用到了 b[1]~b[f[i-1][j-1]] // a[i] 可以使用 f[i-1][j-1]+1 ~ m 范围内的所有字母，找一个最小的 int idx = lower_bound(pos[a[i]].begin(), pos[a[i]].end(), f[i - 1][j - 1] + 1) - pos[a[i]].begin(); if (idx != pos[a[i]].size()) { // 可以凑出来 j 的长度，其中 a[i] 对应的 b[pos[a[i]][idx]] if (f[i][j] == -1 || pos[a[i]][idx] < f[i][j]) f[i][j] = pos[a[i]][idx]; } } } } for (int i = n; i >= 0; i--) { if (f[n][i] != -1) { cout << i << \\\"\\\\n\\\"; return 0; } } return 0; }\"]},\"127\":{\"h\":\"又见采药\",\"t\":[\"#include <bits/stdc++.h> #define int long long using namespace std; int n, k; int nowF, nxtF; vector<pair<int, int>> now, nxt, temp; signed main() { ios::sync_with_stdio(false); cin.tie(0); while (cin >> n >> k) { now.push_back(make_pair(0, 0)); nxt.clear(); temp.clear(); for (int i = 1; i <= n; i++) { int ti, wi; cin >> ti >> wi; // 根据 now 计算 nxt for (auto x : now) { int nowT = x.first; int nowW = x.second; if (nowT + ti <= k) nxt.push_back(make_pair(nowT + ti, nowW + wi)); } // 合并 now、nxt 到 temp int pNow = 0; int pNxt = 0; int maxW = -1; while (pNow < now.size() && pNxt < nxt.size()) { auto op1 = now[pNow]; auto op2 = nxt[pNxt]; if (op1.second < maxW) pNow++; else if (op2.second < maxW) pNxt++; else if (op1.first == op2.first) { if (op1.second > op2.second) temp.push_back(op1), maxW = op1.second; else temp.push_back(op2), maxW = op2.second; pNow++, pNxt++; } else if (op1.first < op2.first) { temp.push_back(op1); maxW = op1.second; pNow++; } else if (op1.first > op2.first) { temp.push_back(op2); maxW = op2.second; pNxt++; } } while (pNow < now.size()) { if (now[pNow].second > maxW) temp.push_back(now[pNow]), maxW = now[pNow].second; pNow++; } while (pNxt < nxt.size()) { if (nxt[pNxt].second > maxW) temp.push_back(nxt[pNxt]), maxW = nxt[pNxt].second; pNxt++; } swap(now, temp); nxt.clear(); temp.clear(); if (i == n) cout << maxW << \\\"\\\\n\\\"; } } return 0; } /* 根据贪心原理，当费用相同时，只需保留价值最高的； 当价值一定时，只需保留费用最低的； 当有两件物品 i,j 且 i 的价值大于 j 的价值并且 i 的费用小于 j 的费用时，只需保留 i。 */\"]},\"128\":{\"h\":\"吃菜\",\"t\":[\"#include <bits/stdc++.h> #define int long long using namespace std; struct Cai { // 味道、价格、对第二个人的价值 int w, c, val; }; bool cmp(Cai &a, Cai &b) { if (a.c != b.c) return a.c > b.c; return a.w > b.w; } int n; Cai a[5005]; // f[i][j]：前 i 道菜，后手吃了 j 道的最大价值 int f[5005][2505]; signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) { cin >> a[i].w >> a[i].c; a[i].val = a[i].w - a[i].c; } sort(a + 1, a + n + 1, cmp); memset(f, 0xc0, sizeof(f)); //-INF/2 f[0][0] = 0; for (int i = 1; i <= n; i++) { for (int j = 0; j <= i / 2; j++) // 最多吃一半 { // 第 i 道菜给先手吃 f[i][j] = f[i - 1][j]; // 第 i 道菜自己吃 if (j > 0 && i >= j * 2 && f[i - 1][j - 1] != -1) // 能吃的上第i道菜 f[i][j] = max(f[i][j], f[i - 1][j - 1] + a[i].val); // cout << i << \\\" \\\" << j << \\\" \\\" << f[i][j] << endl; } } cout << f[n][n / 2] << endl; return 0; }\"]},\"129\":{\"h\":\"求解一元二次方程\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { double a, b, c; cin >> a >> b >> c; // 判断是否有实根 if (b * b - 4 * a * c < 0) { // 没有实根 cout << \\\"No answer!\\\"; } else { // 有实根 double x1 = (-b + sqrt(b * b - 4 * a * c)) / (2 * a); double x2 = (-b - sqrt(b * b - 4 * a * c)) / (2 * a); if (b * b - 4 * a * c == 0) { // 两个实根相等 cout << fixed << setprecision(5) << \\\"x1=x2=\\\" << x1; } else { // 两个实根不相等 if (x1 > x2) { // 当 x1 > x2 时交换两个变量，来保证 x1 较小 double temp = x1; x1 = x2; x2 = temp; // 也可以使用自带的 swap(x1, x2); } cout << fixed << setprecision(5) << \\\"x1=\\\" << x1 << \\\";x2=\\\" << x2; } } return 0; }\"]},\"130\":{\"h\":\"含k个3的数\"},\"131\":{\"h\":\"while 循环做法\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { int m, k; cin >> m >> k; int cnt3 = 0; // 计算 m 里面 3 的数量 int mm = m; while (mm > 0) { // 当前个位为 m % 10 if (mm % 10 == 3) cnt3++; mm /= 10; // 把个位去掉 } if (m % 19 == 0 && cnt3 == k) cout << \\\"YES\\\\n\\\"; else cout << \\\"NO\\\\n\\\"; return 0; }\"]},\"132\":{\"h\":\"for 循环做法\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { int m, k; cin >> m >> k; int cnt3 = 0; // 计算 m 里面 3 的数量 for (int mm = m; mm > 0; mm /= 10) { if (mm % 10 == 3) cnt3++; } if (m % 19 == 0 && cnt3 == k) cout << \\\"YES\\\\n\\\"; else cout << \\\"NO\\\\n\\\"; return 0; }\"]},\"133\":{\"h\":\"津津的储蓄计划\"},\"134\":{\"h\":\"不考虑不够用的情况\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { int money, bank; // 余额、存的钱 money = 0; bank = 0; for (int i = 1; i <= 12; i++) { // 发 300 块 money += 300; // 扣除掉预算 int x; cin >> x; money -= x; // 整百的存钱 bank += money / 100 * 100; money -= money / 100 * 100; // money %= 100; } cout << money + bank / 100 * 120; return 0; }\"]},\"135\":{\"h\":\"利用结束程序的语句\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { int money, bank; // 余额、存的钱 money = 0; bank = 0; for (int i = 1; i <= 12; i++) { // 发 300 块 money += 300; // 扣除掉预算 int x; cin >> x; if (money >= x) money -= x; else { cout << -i; // 当前的 i 就是当前的月份 return 0; // exit(0); } // 整百的存钱 bank += money / 100 * 100; money -= money / 100 * 100; // money %= 100; } cout << money + bank / 100 * 120; return 0; }\"]},\"136\":{\"h\":\"额外标记实现\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { int money, bank; // 余额、存的钱 money = 0; bank = 0; bool flag = false; // 没有出现过不够用 for (int i = 1; i <= 12; i++) { // 发 300 块 money += 300; // 扣除掉预算 int x; cin >> x; if (money >= x) money -= x; else { cout << -i; // 当前的 i 就是当前的月份 flag = true; break; } // 整百的存钱 bank += money / 100 * 100; money -= money / 100 * 100; // money %= 100; } if (flag == false) cout << money + bank / 100 * 120; return 0; }\"]},\"137\":{\"h\":\"报数【2024五一模拟赛】\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int T; int n, x; set<int> ans; bool check(int n, int k, int x) { int pos = n % (2 * k - 2); if (pos == 0) pos = 2 * k - 2; if (pos <= k) return pos == x; return k - (pos - k) == x; } int cal() { ans.clear(); // (n - x) % (2k - 2) == 0 for (int i = 1; i * i <= n - x; i++) { // i == 2k - 2 if ((n - x) % i == 0) { // 因子 i if ((i + 2) % 2 == 0) { int k = (i + 2) / 2; if (ans.find(k) == ans.end()) { if (check(n, k, x)) ans.insert(k); } } // 因子 (n - x) / i if (((n - x) / i + 2) % 2 == 0) { int k = ((n - x) / i + 2) / 2; if (ans.find(k) == ans.end()) { if (check(n, k, x)) ans.insert(k); } } } } // (n + x - 2) % (2k - 2) == 0 for (int i = 1; i * i <= n + x - 2; i++) { // i == 2k - 2 if ((n + x - 2) % i == 0) { // 因子 i if ((i + 2) % 2 == 0) { int k = (i + 2) / 2; if (ans.find(k) == ans.end()) { if (check(n, k, x)) ans.insert(k); } } // 因子 (n + x - 2) / i if (((n + x - 2) / i + 2) % 2 == 0) { int k = ((n + x - 2) / i + 2) / 2; if (ans.find(k) == ans.end()) { if (check(n, k, x)) ans.insert(k); } } } } return ans.size(); } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> T; while (T--) { cin >> n >> x; cout << cal() << \\\"\\\\n\\\"; } return 0; } /* 2k-2 为周期 必要条件为： 如果处于上升：n % (2k - 2) == x 如果处于下降：k - (n % (2k - 2) - k) == x 即 1. (n - x) % (2k - 2) == 0 2. (2k - 2) - (n % (2k - 2)) == x - 2 n % (2k - 2) + (x - 2) == (2k - 2) (n + x - 2) % (2k - 2) == 0 当然这个条件看上去就不充分，再 $O(1)$ 验证一下就好了 */\"]},\"138\":{\"h\":\"与或\"},\"139\":{\"h\":\"60 分\",\"t\":[\"#include<bits/stdc++.h> #define int long long using namespace std; const int MAXN = 200000; int n, k; int a[MAXN + 5]; // 初始是 now，从 pos 开始，x 个 &，y 个 |， int cal(int now, int pos, int x, int y) { for(int i=0;i<x;i++) now = now & a[pos+i]; for(int i=0;i<y;i++) now = now | a[pos+x+i]; return now; } signed main() { cin >> n >> k; for(int i = 1; i <= n; i++) cin >> a[i]; int xx = n - k - 1, yy = k; int ans = cal(a[1], 2, xx, yy); cout << ans << \\\"\\\\n\\\"; int now = a[1]; for(int i = 2; i <= n; i++) { if (yy > 0 && cal(now|a[i], i+1, xx, yy - 1) == ans) { // a[i] 使用 | yy --; now |= a[i]; cout << \\\"|\\\"; } else { now &= a[i]; xx --; cout << \\\"&\\\"; } } return 0; }\"]},\"140\":{\"h\":\"100 分\",\"t\":[\"#include<bits/stdc++.h> #define int long long using namespace std; const int MAXN = 200000; int n, k; int a[MAXN + 5]; // a[1]~a[i] 在 2^j 有几个 1 int cnt1[MAXN+5][65]; // 初始是 now，从 pos 开始，x 个 &，y 个 |， int cal(int now, int pos, int x, int y) { int tempX = 0; int tempY = 0; for(int i=0;i<60;i++){ int nowX = cnt1[pos+x-1][i]-cnt1[pos-1][i]; if(nowX == x) tempX |= 1LL<<i; int nowY = cnt1[pos+x+y-1][i]-cnt1[pos+x-1][i]; if(nowY > 0) tempY |= 1LL<<i; } now &= tempX; now |= tempY; return now; } signed main() { cin >> n >> k; for(int i = 1; i <= n; i++) { cin >> a[i]; for(int j=0;j<60;j++) if(a[i]&(1LL<<j)) cnt1[i][j] = cnt1[i-1][j] + 1; else cnt1[i][j] = cnt1[i-1][j]; } int xx = n - k - 1, yy = k; int ans = cal(a[1], 2, xx, yy); cout << ans << \\\"\\\\n\\\"; int now = a[1]; for(int i = 2; i <= n; i++) { if (yy > 0 && cal(now|a[i], i+1, xx, yy - 1) == ans) { // a[i] 使用 | yy --; now |= a[i]; cout << \\\"|\\\"; } else { now &= a[i]; xx --; cout << \\\"&\\\"; } } return 0; }\"]},\"141\":{\"h\":\"[ICPC2024 Xi'an I] Make Them Straight\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 200000; int n; int a[MAXN + 5], b[MAXN + 5]; // f[首项、公差]：不用改的部分的 b 之和 map<pair<int, int>, long long> f; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; for (int i = 1; i <= n; i++) cin >> b[i]; long long sum = 0; for (int i = 1; i <= n; i++) sum += b[i]; for (int d = 0; d <= 1000000; d++) // 公差 { for (int i = 1; i <= n; i++) { // 如果 0 为首项都会超过 a[i] 就不用看后面的了 if (0 + (i - 1) * d > 1000000) break; // 如果 a[i] 命中了的话的首项 long long a1 = a[i] - (long long)(i - 1) * d; if (a1 < 0) continue; // 如果 a1 为首项，d 为公差，就不用修改 b[i] f[make_pair(a1, d)] += b[i]; } } long long ans = sum; for (auto x : f) ans = min(ans, sum - x.second); cout << ans; return 0; }\"]},\"142\":{\"h\":\"[ICPC2024 Xi'an I] Rubbish Sorting\",\"t\":[\"#include <bits/stdc++.h> using namespace std; // max hash const int MAXN = 27 * 27 * 27 * 27 * 27; int q; string s; // 当前字符串 int x; // 当前垃圾类型 int typ[MAXN + 5]; // 每种字符串的最小类型值 // 当前匹配下标、当前 hash 值 void dfs1(int now, int hsh) { if (now == 5) { if (!typ[hsh] || x < typ[hsh]) typ[hsh] = x; return; } dfs1(now + 1, hsh * 27); if (now < s.size()) dfs1(now + 1, hsh * 27 + (s[now] - 'a' + 1)); } int ans, ansLen; // 当前匹配的类型、对应的匹配的位数 // 当前匹配下标、当前 hash 值，相同位数 void dfs2(int now, int hsh, int cnt) { if (now == 5) { if (!typ[hsh]) return; if (cnt > ansLen || cnt == ansLen && typ[hsh] < ans) { ans = typ[hsh]; ansLen = cnt; } return; } dfs2(now + 1, hsh * 27, cnt); if (now < s.size()) dfs2(now + 1, hsh * 27 + (s[now] - 'a' + 1), cnt + 1); } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> q; while (q--) { int op; cin >> op; if (op == 1) { cin >> s >> x; // s 的类型为 x dfs1(0, 0); } if (op == 2) { cin >> s; // 输出 s 最接近的类型 ansLen = -1; // 接近程度 dfs2(0, 0, 0); cout << ans << \\\"\\\\n\\\"; } } return 0; }\"]},\"143\":{\"h\":\"钓鱼1\"},\"144\":{\"h\":\"70 分\",\"t\":[\"#include <bits/stdc++.h> #define int long long using namespace std; const int MAXN = 100; int n, T; int x[MAXN + 5], a[MAXN + 5], b[MAXN + 5]; priority_queue<pair<int, int>> q; int cal(int pos, int tt) { while (!q.empty()) q.pop(); for (int i = 1; i <= pos; i++) q.push(make_pair(a[i], b[i])); int now = 0; while (tt >= 5) { auto ab = q.top(); q.pop(); q.push(make_pair(ab.first - ab.second, ab.second)); now += max(ab.first, 0LL); tt -= 5; } return now; } signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> T; for (int i = 1; i <= n; i++) cin >> x[i]; for (int i = 1; i <= n; i++) cin >> a[i] >> b[i]; // 枚举走到了第几个钓鱼点 int ans = 0; for (int i = 1; i <= n; i++) { if (x[i] * 2 > T) continue; ans = max(ans, cal(i, T - x[i] * 2)); } cout << ans; return 0; }\"]},\"145\":{\"h\":\"100 分\"},\"146\":{\"h\":\"写法 1\",\"t\":[\"#include <bits/stdc++.h> #define int long long using namespace std; int n, T; int x[105]; int a[105], b[105]; // x[1]~x[R] 中所有超过了 mid 条的钓鱼点，能不能再 t 次以内被钓完 int check(int mid, int t, int R) { int cnt = 0; // 记录一共有多少次超过 mid 条的钓鱼点 for (int i = 1; i <= R; i++) { if (a[i] <= mid) continue; if (b[i] == 0) return false; // 此时超过 mid 的钓鱼点有无限次 cnt += (a[i] - (mid + 1)) / b[i] + 1; // a[i]-(cnt-1)b[i]>=mid+1 } return cnt <= t; } // 能在 x[1]~x[R] 钓鱼，还能钓鱼 t 次 // 返回能钓多少条 int cal(int t, int R) { // 1. 二分找到 siz，使得超过 siz 条的钓鱼点都能被钓完，剩余的钓鱼次数钓的必然都是 siz 条 int l = 0; int r = 1'000'000'000; int siz; while (l <= r) { int mid = (l + r) / 2; if (check(mid, t, R)) { siz = mid; r = mid - 1; } else { l = mid + 1; } } // 2. 根据 siz 算出一共钓了多少条鱼 int sum1 = 0; // 记录超过 siz 的点一共钓了多少条 int cnt1 = 0; // 记录超过 siz 的点一共钓了多少次（必然不是无限次） int cnt2 = 0; // 等于 siz 的点一共有多少次（t-cnt1 次都会在这里消耗） for (int i = 1; i <= R; i++) { if (a[i] < siz) continue; if (a[i] == siz) { if (b[i] == 0) cnt2 = t + 1; // 等于siz的能有无限次 else cnt2++; } if (a[i] > siz) { // 当前的项数 int num = (a[i] - (siz + 1)) / b[i] + 1; // a[i]-(cnt1-1)b[i]>=siz+1 cnt1 += num; // 首项为 a[i]，项数为 num -b[i] sum1 += (a[i] + (a[i] - (num - 1) * b[i])) * num / 2; if ((a[i] - siz) % b[i] == 0) cnt2++; } } // 大于 siz 的所有条数之和 + siz * 等于 siz 条的次数 return sum1 + siz * min(t - cnt1, cnt2); } signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> T; for (int i = 1; i <= n; i++) cin >> x[i]; for (int i = 1; i <= n; i++) cin >> a[i] >> b[i]; // 记录最终答案 int ans = 0; // 枚举右边界，最右能走到 x[R] for (int R = 1; R <= n; R++) { // 还能钓鱼的次数 int t = (T - x[R] * 2) / 5; int now = cal(t, R); ans = max(now, ans); } cout << ans; return 0; }\"]},\"147\":{\"h\":\"写法 2\",\"t\":[\"#include <bits/stdc++.h> #define int long long using namespace std; const int MAXN = 100; int n, T; int x[MAXN + 5], a[MAXN + 5], b[MAXN + 5]; priority_queue<pair<int, int>> q; // siz 及以上数量的次数都钓完，时间够不够 bool calTime(int pos, int siz, int tt) { int cnt = 0; for (int i = 1; i <= pos; i++) { if (a[i] < siz) continue; cnt += (a[i] - siz) / b[i] + 1; } return cnt * 5 <= tt; } // 1~pos 在 tt 的时间最多钓多少条 int cal(int pos, int tt) { int minSiz = 0; // minSiz 大小的鱼可以无限钓 for (int i = 1; i <= pos; i++) if (b[i] == 0) minSiz = max(minSiz, a[i]); int siz = -1; // 时间够把所有 now 条以上的次数都抓完 int l = minSiz + 1; int r = 1'000'000'000; while (l <= r) { int mid = (l + r) / 2; if (calTime(pos, mid, tt)) { siz = mid; // mid 数量的都能搞完，就看看更小的全搞完时间行不行 r = mid - 1; } else { // mid 数量的搞不完，那就看看多大的能搞完 l = mid + 1; } } int now = 0; // 总鱼数 int ttt = 0; // 总时间 for (int i = 1; i <= pos; i++) { if (a[i] >= siz) { int num = (a[i] - siz) / b[i] + 1; // 项数 int s = a[i]; // 第一次 int e = a[i] - b[i] * (num - 1); // 最后一次 now += (s + e) * num / 2; ttt += num * 5; } } // 多余时间不停钓 minSiz 大小的鱼 return now + (tt - ttt) / 5 * minSiz; } signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> T; for (int i = 1; i <= n; i++) cin >> x[i]; for (int i = 1; i <= n; i++) cin >> a[i] >> b[i]; // 枚举走到了第几个钓鱼点 int ans = 0; for (int i = 1; i <= n; i++) { if (x[i] * 2 > T) continue; ans = max(ans, cal(i, T - x[i] * 2)); } cout << ans; return 0; }\"]},\"148\":{\"h\":\"钓鱼2\",\"t\":[\"#include <bits/stdc++.h> #define int long long using namespace std; const int MAXN = 100000; int n, T; int x[MAXN + 5], a[MAXN + 5], b[MAXN + 5]; priority_queue<int> q; signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> T; for (int i = 1; i <= n; i++) x[i] = i; for (int i = 1; i <= n; i++) cin >> a[i]; for (int i = 1; i <= n; i++) cin >> b[i]; // 枚举走到了第几个钓鱼点 int maxNow = 0; int now = 0; for (int i = 1; i <= n; i++) { while (a[i] > 0) { q.push(-a[i]); now += a[i]; a[i] -= b[i]; } while (q.size() > T - x[i] * 2) { now -= -q.top(); q.pop(); } maxNow = max(maxNow, now); cout << maxNow << \\\" \\\"; } return 0; }\"]},\"149\":{\"h\":\"卡片\"},\"150\":{\"h\":\"50 分\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 100000; int n, k; int a[MAXN + 5], b[MAXN + 5]; int q, m, temp; vector<int> all; bool vis[MAXN + 5]; // 被标记了不能翻转？ long long sum; int id[MAXN + 5]; bool cmp(int x, int y) { return a[x] > a[y]; } int main() { cin >> n >> k; for (int i = 1; i <= n; i++) cin >> a[i]; for (int i = 1; i <= n; i++) cin >> b[i]; sum = 0; for (int i = 1; i <= n; i++) { sum += a[i]; a[i] = b[i] - a[i]; // 转换成反转后的增益 id[i] = i; } sort(id + 1, id + n + 1, cmp); cin >> q; while (q--) { cin >> m; for (int i = 1; i <= m; i++) { cin >> temp; all.push_back(temp); vis[temp] = true; } long long now = 0; for (int i = 1, j = 0; i <= n && j < k; i++) { // 被标记了的不能翻转 if (vis[id[i]]) continue; j++; now += a[id[i]]; } cout << sum + now << \\\"\\\\n\\\"; for (int i = 0; i <= m - 1; i++) vis[all[i]] = false; all.clear(); } return 0; }\"]},\"151\":{\"h\":\"100 分\",\"t\":[\"#include <bits/stdc++.h> #define int long long using namespace std; const int MAXN = 100000; int n, k; int a[MAXN + 5], b[MAXN + 5]; int q, m, temp; vector<int> all; long long sum; int id[MAXN + 5]; // 按反转后权值从大到小排序后的 id int rnk[MAXN + 5]; // 每个 id 排序后的排名 long long ans[MAXN + 5]; // a[id[1]]~a[id[i]] 之和 bool cmp(int x, int y) { return a[x] > a[y]; } bool cmpp(int x, int y) { return rnk[x] < rnk[y]; } signed main() { cin >> n >> k; for (int i = 1; i <= n; i++) cin >> a[i]; for (int i = 1; i <= n; i++) cin >> b[i]; sum = 0; for (int i = 1; i <= n; i++) { sum += a[i]; a[i] = b[i] - a[i]; // 转换成反转后的增益 id[i] = i; } sort(id + 1, id + n + 1, cmp); for (int i = 1; i <= n; i++) { rnk[id[i]] = i; ans[i] = ans[i - 1] + a[id[i]]; } cin >> q; while (q--) { cin >> m; all.clear(); for (int i = 1; i <= m; i++) { cin >> temp; all.push_back(temp); } sort(all.begin(), all.end(), cmpp); int now = k; // 需要对 1~now 进行翻转 long long sumNow = 0; // 所有其中不能翻转的贡献之和 for (int i = 0; i < m; i++) { temp = all[i]; if (rnk[temp] <= now) { sumNow += a[temp]; now++; } } cout << sum + ans[now] - sumNow << \\\"\\\\n\\\"; } return 0; }\"]},\"152\":{\"h\":\"关灯1\"},\"153\":{\"h\":\"位运算写法\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 1000; const int MAXM = 10; int n, m; int a[MAXN + 5]; int aa[MAXN + 5]; int cnt(int x) { int res = 0; while (x > 0) { res += 1; x -= (x & (-x)); } return res; } int main() { cin >> n >> m; int mask = (1 << m) - 1; for (int i = 0; i < n; i++) { a[i] = 0; for (int j = 0; j < m; j++) { int x; cin >> x; a[i] = a[i] * 2 + x; } } int ans = -1; for (int first = 0; first <= (1 << m) - 1; first++) { for (int i = 0; i < n; i++) aa[i] = a[i]; int now = cnt(first); aa[0] ^= first; aa[0] ^= (first >> 1); aa[0] ^= ((first << 1) & mask); aa[1] ^= first; for (int i = 1; i < n; i++) { now += cnt(aa[i - 1]); aa[i] ^= aa[i - 1]; aa[i] ^= (aa[i - 1] >> 1); aa[i] ^= ((aa[i - 1] << 1) & mask); aa[i + 1] ^= (aa[i - 1]); } if (aa[n - 1] == 0 && (ans == -1 || now < ans)) ans = now; } cout << ans << \\\"\\\\n\\\"; return 0; }\"]},\"154\":{\"h\":\"dfs 枚举第一行的写法\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n, m; int a[1005][15]; int b[1005][15]; // 记录那些位置操作了 int ans; // 计算 a[x][y] 在当前按键情况下的亮灯情况 int cal(int x, int y) { int sum = 0; sum += a[x][y]; sum += b[x][y]; sum += b[x - 1][y]; sum += b[x + 1][y]; sum += b[x][y - 1]; sum += b[x][y + 1]; return sum % 2; } // 当前枚举第一排的第 pos 个位置 void dfs(int pos) { if (pos == m + 1) { // 第一行的前 m 个都按完了，先清空一下下面 2~n 行的案件情况 for (int i = 2; i <= n; i++) for (int j = 1; j <= m; j++) b[i][j] = 0; // 枚举第 2~n 行分别怎么按 for (int i = 2; i <= n; i++) // 如果上一行的这个位置是一个 1，那么这一行的这个位置就需要按 for (int j = 1; j <= m; j++) if (cal(i - 1, j) == 1) b[i][j] = 1; // 按完了，此时 1~n-1 行全对了，只需要检查最后一行对不对了 bool flag = true; for (int j = 1; j <= m; j++) if (cal(n, j) == 1) flag = false; // 尝试更新答案 if (flag) { // 算算按了几个位置 int cnt = 0; for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) if (b[i][j]) cnt++; if (ans == -1 || cnt < ans) ans = cnt; } return; } b[1][pos] = 0; dfs(pos + 1); // 不按 b[1][pos] = 0; b[1][pos] = 1; dfs(pos + 1); // 按 b[1][pos] = 0; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m; for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) cin >> a[i][j]; ans = -1; dfs(1); cout << ans; return 0; }\"]},\"155\":{\"h\":\"序列染色【弱化版】\"},\"156\":{\"h\":\"55 分\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n, m; string s; int ss[1005]; int th[15]; bool vis[550000]; vector<int> f; queue<int> q; int nowD[15]; int main() { th[0] = 1; for (int i = 1; i <= 12; i++) th[i] = th[i - 1] * 3; cin >> n >> m; cin >> s; for (int i = 0; i < m; i++) if (s[i] == 'b') ss[i] = 1; else ss[i] = 2; f.push_back(0); vis[0] = true; for (int now = m - 1; now >= 0; now--) { for (int x : f) { for (int i = 0; i <= n - 1; i++) nowD[i] = x / th[i] % 3; for (int l = 0; l <= n - 1; l++) if (nowD[l] == 0) { for (int r = l; r <= n - 1; r++) { if (nowD[r] == 0) { int temp = x; for (int i = l; i <= r; i++) if (nowD[i] == 0) temp += ss[now] * th[i]; if (!vis[temp]) { q.push(temp); vis[temp] = true; } } } } } while (!q.empty()) { f.push_back(q.front()); q.pop(); } } cout << f.size(); return 0; }\"]},\"157\":{\"h\":\"100 分\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n, m; string s; int ss[1005]; int th[15]; bool vis[550000]; vector<int> f; // f[0] ~ f[p1 - 1] 都不需要进行染色 1 // f[0] ~ f[p2 - 1] 都不需要进行染色 2 int p1, p2; queue<int> q; int nowD[15]; int main() { th[0] = 1; for (int i = 1; i <= 12; i++) th[i] = th[i - 1] * 3; cin >> n >> m; cin >> s; for (int i = 0; i < m; i++) if (s[i] == 'b') ss[i] = 1; else ss[i] = 2; f.push_back(0); p1 = p2 = 0; vis[0] = true; for (int now = m - 1; now >= 0; now--) { int pp, len; if (ss[now] == 1) pp = p1; else pp = p2; len = f.size(); for (; pp < len; pp++) { int x = f[pp]; for (int i = 0; i <= n - 1; i++) nowD[i] = x / th[i] % 3; for (int l = 0; l <= n - 1; l++) if (nowD[l] == 0) { for (int r = l; r <= n - 1; r++) { if (nowD[r] == 0) { int temp = x; for (int i = l; i <= r; i++) if (nowD[i] == 0) temp += ss[now] * th[i]; if (!vis[temp]) { q.push(temp); vis[temp] = true; } } } } } while (!q.empty()) { f.push_back(q.front()); q.pop(); } if (ss[now] == 1) p1 = pp; else p2 = pp; } cout << f.size(); return 0; }\"]},\"158\":{\"h\":\"关灯1【加强版】\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 1000; int n, m; int g[MAXN + 5][MAXN + 5]; int ans[MAXN + 5][MAXN + 5]; // p[pre] 上一行按键取决于哪些 // p[now] 当前行的按键~ // p[nxt] 下一行的按键~ // 1~m: x1~xm；m+1：是否要整体取反 int pre, now, nxt; bitset<MAXN + 1 + 5> zeroB; bitset<MAXN + 1 + 5> oneB; // 1~m+1 全都是 1 bitset<MAXN + 1 + 5> p[3][MAXN + 5]; // 滚动 pre,now,nxt void freshNow() { pre = now; now = nxt; nxt = 3 - pre - now; } void showFunc() { cout << \\\"---\\\\n\\\"; for (int i = 1; i <= m; i++) { for (int j = 1; j <= m + 1; j++) cout << p[now][i][j]; cout << \\\"\\\\n\\\"; } cout << \\\"---\\\\n\\\"; } // 根据 ans[x] 和 ans[x-1] 算出来 g[x][y] void freshG(int x, int y) { g[x][y] ^= ans[x][y]; if (y > 1) g[x][y] ^= ans[x][y - 1]; if (y < m) g[x][y] ^= ans[x][y + 1]; if (x > 1) g[x][y] ^= ans[x - 1][y]; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m; for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) cin >> g[i][j]; for (int i = 1; i <= m + 1; i++) oneB.set(i); // ---- 构造方程 ---- // 第一行的案件情况 pre = 0, now = 1, nxt = 2; for (int i = 1; i <= m; i++) p[now][i][i] = 1; // 循环生成下一行 for (int i = 1; i <= n; i++) { for (int j = 1; j <= m; j++) { p[nxt][j] = zeroB; // 清空 p[nxt][j] ^= p[now][j]; // 当前按键 if (j > 1) p[nxt][j] ^= p[now][j - 1]; // 左边按键 if (j < m) p[nxt][j] ^= p[now][j + 1]; // 右边按键 p[nxt][j] ^= p[pre][j]; // 上面按键 if (g[i][j] == 1) p[nxt][j][m + 1] = p[nxt][j][m + 1] ^ 1; // 是否要整体取反 } freshNow(); } // ---- 高斯消元 ---- for (int i = 1; i <= m; i++) { for (int j = i; j <= m; j++) if (p[now][j][i] == 1) { swap(p[now][j], p[now][i]); break; } if (p[now][i][i] != 1) continue; // 消掉其他方程的第 i 列 for (int j = 1; j <= m; j++) if (j != i && p[now][j][i] == 1) p[now][j] ^= p[now][i]; } // ---- 生成解 --- // 第一行按键情况 for (int i = 1; i <= m; i++) ans[1][i] = p[now][i][m + 1]; // 依次推每一行 for (int i = 2; i <= n; i++) { for (int j = 1; j <= m; j++) { freshG(i - 1, j); ans[i][j] = g[i - 1][j]; } } int ansCnt = 0; for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) ansCnt += ans[i][j]; cout << ansCnt; return 0; }\"]},\"159\":{\"h\":\"关灯2\"},\"160\":{\"h\":\"AC 代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n, k; string ss[1005]; map<string, int> m; int ans = 0; // 当前串有 cnt1 个 '1' // num1 个当前串，num2 个互补串，更新答案 void cal(int cnt1, int num1, int num2) { int cnt0 = n - cnt1; int now; // 操作当前串的零 if (k >= cnt0) { // 当前串全都变成全 ’1' 了，一共变了 num1 个 // 还有 k-cnt0 次操作机会 // 可以把 min(k-cnt0, num2) 个互补串，变为 全 '1' now = num1; now += min(k - cnt0, num2); // 还剩这么多次操作：k - cnt0 - min(k - cnt0, num2); if (now == n && (k - cnt0 - min(k - cnt0, num2)) % 2 == 1) now--; ans = max(ans, now); } // 操作互补串的零 swap(num1, num2); // 让互补串作为当前串，两种串的数量翻转 swap(cnt0, cnt1); // 此时当前串的 01 数量刚好和之前相反 if (k >= cnt0) { // 当前串全都变成全 ’1' 了，一共变了 num1 个 // 还有 k-cnt0 次操作机会 // 可以把 min(k-cnt0, num2) 个互补串，变为 全 '1' now = num1; now += min(k - cnt0, num2); // 还剩这么多次操作：k - cnt0 - min(k - cnt0, num2); if (now == n && (k - cnt0 - min(k - cnt0, num2)) % 2 == 1) now--; ans = max(ans, now); } } int main() { cin >> n >> k; for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) { char c; cin >> c; ss[j] += c; } for (int i = 1; i <= n; i++) m[ss[i]]++; ans = 0; for (auto now : m) { // 钦定 now 需要全 1 string s = now.first; int numS = now.second; string ss = now.first; // 互补串 for (int i = 0; i < ss.size(); i++) if (ss[i] == '0') ss[i] = '1'; else ss[i] = '0'; int numSS = m[ss]; int cnt1 = 0; for (int i = 0; i < s.size(); i++) if (s[i] == '1') cnt1++; // 处理当前列的情况 cal(cnt1, numS, numSS); } cout << ans << \\\"\\\\n\\\"; return 0; }\"]},\"161\":{\"h\":\"错误代码\",\"t\":[\"hack数据：\",\"4 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\",\"#include <bits/stdc++.h> using namespace std; int n, k; string ss[1005]; map<string, int> m; int main() { cin >> n >> k; for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) { char c; cin >> c; ss[j] += c; } for (int i = 1; i <= n; i++) m[ss[i]]++; int ans = 0; for (auto now : m) { // 钦定 now 需要全 1 string s = now.first; int num = now.second; int nowAns = 0; // 能搞定几个 int nowCnt = k; // 还要动几次 for (char c : s) if (c == '0') nowCnt--; if (nowCnt < 0) continue; nowAns += num; // 生成互补串并检查互补串数量 for (int i = 0; i < s.length(); i++) s[i] = 1 - (s[i] - '0') + '0'; num = m[s]; // 互补串数量 nowAns += min(nowCnt, num); nowCnt -= min(nowCnt, num); // 消耗剩余次数 if (nowAns == n) nowAns -= nowCnt % 2; ans = max(ans, nowAns); } cout << ans << \\\"\\\\n\\\"; return 0; }\"]},\"162\":{\"h\":\"关灯3\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 1000; int n, k; // 每一列以及相反列 bitset<MAXN + 5> a[MAXN + 5], aa[MAXN + 5], tempB; bool nowCol[MAXN + 5]; // 第 j 列是否整体翻转 int main() { cin >> n >> k; for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) { int temp; cin >> temp; if (temp) a[j].set(i); else aa[j].set(i); } // 钦定第 col 列不进行单点操作 for (int col = 1; col <= n; col++) { int cnt, M; // 单点次数，行次数 // ---- 方案 1，第 col 列不翻转 ---- cnt = M = 0; // 先算算自己的反转次数 M += a[col].count(); for (int j = 1; j <= n; j++) { if (j == col) continue; // 其他列一共需要几次 int now = 0; // 第 col 列操作完后，第 j 列的 1 的数量 tempB = a[col] ^ a[j]; now += tempB.count(); if (now <= n - now) cnt += now, nowCol[j] = false; else cnt += n - now, M++, nowCol[j] = true; } if (cnt <= k) { cout << cnt + M << \\\"\\\\n\\\"; // 第 col 列变化 for (int i = 1; i <= n; i++) if (a[col][i] == 1) cout << i << \\\" \\\" << 0 << \\\"\\\\n\\\"; // 其他列变化 for (int j = 1; j <= n; j++) { if (j == col) continue; if (nowCol[j]) cout << 0 << \\\" \\\" << j << \\\"\\\\n\\\"; for (int i = 1; i <= n; i++) if (nowCol[j] == false && (a[j][i] != a[col][i]) || nowCol[j] == true && (a[j][i] == a[col][i])) cout << i << \\\" \\\" << j << \\\"\\\\n\\\"; } return 0; } // ---- 方案 1，第 col 列不翻转 ---- cnt = M = 0; // 先算算自己的反转次数 M++; M += aa[col].count(); for (int j = 1; j <= n; j++) { if (j == col) continue; // 其他列一共需要几次 int now = 0; // 第 col 列操作完后，第 j 列的 1 的数量 tempB = aa[col] ^ a[j]; now += tempB.count(); if (now <= n - now) cnt += now, nowCol[j] = false; else cnt += n - now, M++, nowCol[j] = true; } if (cnt <= k) { cout << cnt + M << \\\"\\\\n\\\"; // 第 col 列变化 cout << 0 << \\\" \\\" << col << \\\"\\\\n\\\"; for (int i = 1; i <= n; i++) if (aa[col][i] == 1) cout << i << \\\" \\\" << 0 << \\\"\\\\n\\\"; // 其他列变化 for (int j = 1; j <= n; j++) { if (j == col) continue; if (nowCol[j]) cout << 0 << \\\" \\\" << j << \\\"\\\\n\\\"; for (int i = 1; i <= n; i++) if (nowCol[j] == false && (a[j][i] != aa[col][i]) || nowCol[j] == true && (a[j][i] == aa[col][i])) cout << i << \\\" \\\" << j << \\\"\\\\n\\\"; } return 0; } } cout << \\\"-1\\\\n\\\"; return 0; }\"]},\"163\":{\"h\":\"[NOIP2016 提高组] 蚯蚓\",\"t\":[\"#include <bits/stdc++.h> #define int long long using namespace std; int n, m, q, u, v, t; int a[100005]; queue<int> qq[3]; bool cmp(int x, int y) { return x > y; } signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m >> q >> u >> v >> t; for (int i = 1; i <= n; i++) cin >> a[i]; sort(a + 1, a + n + 1, cmp); for (int i = 1; i <= n; i++) qq[0].push(a[i]); int sumq = 0; for (int i = 1; i <= m; i++) { int maxi = -1; for (int i = 0; i <= 2; i++) if (!qq[i].empty() && (maxi == -1 || qq[i].front() > qq[maxi].front())) maxi = i; int now = qq[maxi].front() + sumq; sumq += q; qq[maxi].pop(); int l = now * u / v; int r = now - l; if (l < r) swap(l, r); l -= sumq; r -= sumq; qq[1].push(l); qq[2].push(r); if (i % t == 0) cout << now << \\\" \\\"; } cout << \\\"\\\\n\\\"; for (int i = 1; i <= n + m; i++) { int maxi = -1; for (int i = 0; i <= 2; i++) if (!qq[i].empty() && (maxi == -1 || qq[i].front() > qq[maxi].front())) maxi = i; if (i % t == 0) cout << qq[maxi].front() + sumq << ' '; qq[maxi].pop(); } cout << \\\"\\\\n\\\"; return 0; }\"]},\"164\":{\"h\":\"[NOI2014] 随机数生成器\",\"t\":[\"#include <bits/stdc++.h> #define ll long long using namespace std; const int MAXNM = 5000; const int INF = 0x3f3f3f3f; int x0; ll a, b, c, d; int n, m, q; // int x[MAXNM * MAXNM + 5]; int T[MAXNM * MAXNM + 5]; int get(int x, int y) { return T[(x - 1) * m + y]; } // 数字 i 所在的位置是 id[i]; int id[MAXNM * MAXNM + 5]; // 第 i 行的可选范围是 canL[i] canR[i] int canL[MAXNM + 5], canR[MAXNM + 5]; vector<int> ans; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> x0 >> a >> b >> c >> d; cin >> n >> m >> q; // x[0] = x0; T[0] = x0; for (int i = 1; i <= n * m; i++) { // x[i] = (a * x[i - 1] * x[i - 1] + b * x[i - 1] + c) % d; // T[i] = i; T[i] = (a * T[i - 1] * T[i - 1] + b * T[i - 1] + c) % d; } for (int i = 1; i <= n * m; i++) { // swap(T[i], T[T[i] % i + 1]); int pos = T[i] % i + 1; T[i] = T[pos]; T[pos] = i; } while (q--) { int ui, vi; cin >> ui >> vi; swap(T[ui], T[vi]); } /* for (int i = 1; i <= n; i++) { for (int j = 1; j <= m; j++) cout << get(i, j) << \\\" \\\"; cout << \\\"\\\\n\\\"; } */ for (int i = 1; i <= n; i++) { canL[i] = 1, canR[i] = m; for (int j = 1; j <= m; j++) { int now = get(i, j); id[now] = i * (m + 1) + j; } } for (int i = 1; i <= n * m; i++) { int nowX = id[i] / (m + 1); int nowY = id[i] % (m + 1); // 执行 N*M 次 if (canL[nowX] <= nowY && nowY <= canR[nowX]) { // 下面的for最多被执行 N+M-1 次，每次都是 O(n)，能过 for (int row = 1; row < nowX; row++) canR[row] = min(canR[row], nowY); for (int row = nowX + 1; row <= n; row++) canL[row] = max(canL[row], nowY); ans.push_back(i); } } for (int id : ans) cout << id << \\\" \\\"; cout << \\\"\\\\n\\\"; return 0; } // x[i] = (ax[i-1]^2 + bx[i-1] + c) % d\"]},\"165\":{\"h\":\"[NOI2014] 起床困难综合症\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int L = 30; const int MAXN = 100000; int n, m; // 如果第i位是 0/1 最终会变成 0/1 int dig[L + 5][2]; string op[MAXN + 5]; int t[MAXN + 5]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m; for (int i = 1; i <= n; i++) cin >> op[i] >> t[i]; for (int i = 0; i < L; i++) { dig[i][0] = 0; dig[i][1] = 1; } /* cout << \\\"0:\\\"; for (int i = 4; i >= 0; i--) { cout << dig[i][0]; } cout << \\\"\\\\n1:\\\"; for (int i = 4; i >= 0; i--) { cout << dig[i][1]; } cout << \\\"\\\\n---\\\\n\\\"; */ for (int i = n; i >= 1; i--) { // cout << op[i] << \\\" \\\" << t[i] << \\\"\\\\n\\\"; if (op[i] == \\\"AND\\\") { for (int now = 0; now < L; now++) { int tDig = ((t[i] >> now) & 1); if (tDig == 0) { dig[now][0] = dig[now][0]; dig[now][1] = dig[now][0]; } else if (tDig == 1) { dig[now][0] = dig[now][0]; dig[now][1] = dig[now][1]; } } } else if (op[i] == \\\"OR\\\") { for (int now = 0; now < L; now++) { int tDig = ((t[i] >> now) & 1); if (tDig == 0) { dig[now][0] = dig[now][0]; dig[now][1] = dig[now][1]; } else if (tDig == 1) { dig[now][0] = dig[now][1]; dig[now][1] = dig[now][1]; } } } else if (op[i] == \\\"XOR\\\") { for (int now = 0; now < L; now++) { int tDig = ((t[i] >> now) & 1); if (tDig == 0) { dig[now][0] = dig[now][0]; dig[now][1] = dig[now][1]; } else if (tDig == 1) { int pre0 = dig[now][0]; dig[now][0] = dig[now][1]; dig[now][1] = pre0; } } } /* cout << \\\"0:\\\"; for (int i = 4; i >= 0; i--) { cout << dig[i][0]; } cout << \\\"\\\\n1:\\\"; for (int i = 4; i >= 0; i--) { cout << dig[i][1]; } cout << \\\"\\\\n---\\\\n\\\"; */ } int now = 0; int ans = 0; for (int i = L - 1; i >= 0; i--) { if (dig[i][0]) { ans += (1 << i); } else if (dig[i][1]) { if (now + (1 << i) <= m) { ans += (1 << i); now += (1 << i); } } } cout << ans << \\\"\\\\n\\\"; return 0; }\"]},\"166\":{\"h\":\"[SDOI2011] 打地鼠\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 100; int m, n; int a[MAXN + 5][MAXN + 5]; int aa[MAXN + 5][MAXN + 5]; bool check(int r, int c) { // 复制一份，然后开敲 for (int i = 1; i <= m; i++) for (int j = 1; j <= n; j++) aa[i][j] = a[i][j]; // 左上开始，遇到一个地鼠就敲 for (int i = 1; i + r - 1 <= m; i++) for (int j = 1; j + c - 1 <= n; j++) { if (!aa[i][j]) continue; int now = aa[i][j]; for (int x = i; x <= i + r - 1; x++) for (int y = j; y <= j + c - 1; y++) { if (aa[x][y] < now) return false; aa[x][y] -= now; } } for (int i = 1; i <= m; i++) for (int j = 1; j <= n; j++) if (aa[i][j]) return false; return true; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> m >> n; int sum = 0; for (int i = 1; i <= m; i++) for (int j = 1; j <= n; j++) { cin >> a[i][j]; sum += a[i][j]; } int ans = sum; for (int r = 1; r <= m; r++) for (int c = 1; c <= n; c++) { if (sum % (r * c)) continue; if (check(r, c)) ans = min(ans, sum / (r * c)); } cout << ans; return 0; }\"]},\"167\":{\"h\":\"【基础算法练习题】蓄水池问题\",\"t\":[\"#include <bits/stdc++.h> #define int long long using namespace std; int n; int a[305][305]; // first -高度，second 位置 priority_queue<pair<int, pair<int, int>>> q; bool vis[305][305]; int dx[] = {1, -1, 0, 0}; int dy[] = {0, 0, 1, -1}; signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) { cin >> a[i][j]; if (i == 1 || j == 1 || i == n || j == n) { vis[i][j] = true; q.push(make_pair(-a[i][j], make_pair(i, j))); } } int ans = 0; while (!q.empty()) { auto now = q.top(); q.pop(); int height = -now.first; int x = now.second.first; int y = now.second.second; for (int fx = 0; fx < 4; fx++) { int nx = x + dx[fx]; int ny = y + dy[fx]; if (nx < 1 || nx > n || ny < 1 || ny > n || vis[nx][ny]) continue; if (height > a[nx][ny]) { ans += height - a[nx][ny]; a[nx][ny] = height; } vis[nx][ny] = true; q.push(make_pair(-a[nx][ny], make_pair(nx, ny))); } } cout << ans << \\\"\\\\n\\\"; return 0; }\"]},\"168\":{\"h\":\"【基础算法练习题】CF490E加强\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 100000; int n; string s[MAXN + 5]; vector<int> ans; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> s[i]; // s[1] 置最小 if (s[1][0] == '?') s[1][0] = '1'; for (int j = 0; j < s[1].size(); j++) if (s[1][j] == '?') s[1][j] = '0'; // 依次处理，把 s[i] 变成大于 s[i-1] 数中最小的 for (int i = 2; i <= n; i++) { if (s[i].length() < s[i - 1].length()) { cout << \\\"NO\\\\n\\\"; return 0; } if (s[i].length() > s[i - 1].length()) { if (s[i][0] == '?') s[i][0] = '1'; for (int j = 0; j < s[i].size(); j++) if (s[i][j] == '?') s[i][j] = '0'; continue; } bool limit = true; // 前面是否相等 int last = -1; // 上一个可以调整的 ? 的位置 string temp = s[i]; for (int dig = 0; dig < s[i].length(); dig++) { if (s[i][dig] != '?') { if (s[i][dig] > s[i - 1][dig]) limit = false; if (limit && s[i][dig] < s[i - 1][dig]) { if (last == -1) { cout << \\\"NO\\\\n\\\"; return 0; } else { s[i][last] = s[i - 1][last] + 1; for (int k = last + 1; k < dig; k++) if (temp[k] == '?') s[i][k] = '0'; limit = false; } } } else if (s[i][dig] == '?') { if (!limit) { if (dig == 0) s[i][dig] = '1'; else s[i][dig] = '0'; } else { if (s[i - 1][dig] == '9') s[i][dig] = '9'; else { s[i][dig] = s[i - 1][dig]; last = dig; } } } } cout<<endl; if (limit && last == -1) { cout << \\\"NO\\\\n\\\"; return 0; } if (limit) { s[i][last] = s[i - 1][last] + 1; for (int k = last + 1; k < s[i].length(); k++) if (temp[k] == '?') s[i][k] = '0'; } } cout << \\\"YES\\\\n\\\"; for (int i = 1; i <= n; i++) cout << s[i] << \\\"\\\\n\\\"; return 0; }\"]},\"169\":{\"h\":\"【2023暑假专题测试1】最长的Y\",\"t\":[\"#include <bits/stdc++.h> #define int long long using namespace std; const int MAXN = 200000; const int INF = 1'000'000'000'000'000'000LL; string s; int k, n; // allY[0] 存数量 int allY[MAXN + 5]; int sum[MAXN + 5]; // allY 的前缀和 // 首项为 x 末项为 y 的等差数列求和 int cal(int x, int y) { return (x + y) * (y - x + 1) / 2; } // 检查 len 长度的 y 能不能达成 bool check(int len) { int cnt = INF; for (int l = 1; l + len - 1 <= allY[0]; l++) { int r = l + len - 1; int mid = (l + r) / 2; int now = 0; now += (sum[r] - sum[mid - 1]) - cal(allY[mid], allY[mid] + r - mid); now += cal(allY[mid] - (mid - l), allY[mid]) - (sum[mid] - sum[l - 1]); cnt = min(cnt, now); } return cnt <= k; } signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> s >> k; n = s.size(); s = \\\"^\\\" + s + \\\"$\\\"; for (int i = 1; i <= n; i++) if (s[i] == 'Y') allY[++allY[0]] = i; for (int i = 1; i <= allY[0]; i++) sum[i] = sum[i - 1] + allY[i]; int l = 0; int r = allY[0]; int ans = 0; while (l <= r) { int mid = (l + r) / 2; if (check(mid)) { ans = mid; l = mid + 1; } else { r = mid - 1; } } cout << ans; return 0; }\"]},\"170\":{\"h\":\"猜一猜【NOIP2024模拟赛T1】\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n; void ok(int x, int y) { cout << \\\"2 \\\" << x << \\\" \\\" << y << endl; exit(0); } int ask(int x, int y) { cout << \\\"1 \\\" << x << \\\" \\\" << y << endl; int res; cin >> res; if (res >= (n + 2) / 3) ok(x, y); return res; } mt19937 rnd(time(0)); vector<int> now, nxt; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) now.push_back(i); for (int t = 2; t <= n; t *= 2) { // 找到两个数的 gcd 是 t int pos = -1; while (pos == -1) { int x, y; x = y = 1; while (x == y) { x = rnd() % now.size(); y = rnd() % now.size(); } int res = ask(now[x], now[y]); if (res % t == 0) pos = now[x]; } // 所有 t 的倍数放入 nxt nxt.push_back(pos); for (int x : now) { if (x == pos) continue; if (ask(pos, x) % t == 0) { nxt.push_back(x); } } now = nxt; nxt.clear(); } return 0; }\"]},\"171\":{\"h\":\"猜一猜2【NOIP2024模拟赛T2】\"},\"172\":{\"h\":\"75 分做法\",\"t\":[\"快排居然能拿到 75 分\",\"#include <bits/stdc++.h> using namespace std; int n, k, ans; int a[1123456]; bool ask(int x, int y) { cout << \\\"1 \\\" << x << \\\" \\\" << y << endl; int res; cin >> res; return 1 - res; // < 返回 true > 返回 false } void doSwap(int x, int y) { cout << \\\"2 \\\" << x << \\\" \\\" << y << endl; } // 找到 a[l]~a[r] 的第 k 小（存入 ans） void quick_sort(int l, int r) { if (l >= r) return; // 1. 划分左右 int pl, pr; pl = l; pr = r; while (pl < pr) { while (pl < pr && ask(pl, pr)) pr--; if (pl != pr) { doSwap(pl, pr); pl++; } while (pl < pr && ask(pl, pr)) pl++; if (pl != pr) { doSwap(pl, pr); pr--; } } quick_sort(l, pl - 1); quick_sort(pl + 1, r); } int main() { cin >> n; quick_sort(1, n); cout << \\\"3\\\" << endl; return 0; }\"]},\"173\":{\"h\":\"满分做法\",\"t\":[\"先用归并排序，找到每个数最终应该被交换到哪儿，然后再来一口气 次交换完成排序。\",\"#include <bits/stdc++.h> using namespace std; bool xlty(int x, int y) { cout << \\\"1 \\\" << x << \\\" \\\" << y << endl; int res; cin >> res; return 1 - res; // < 返回 true >= 返回 false } void doSwap(int x, int y) { cout << \\\"2 \\\" << x << \\\" \\\" << y << endl; } int n; int a[1123456]; int t[1123456]; void mergeSort(int l, int r) { if (l >= r) return; int mid = (l + r) / 2; mergeSort(l, mid); mergeSort(mid + 1, r); int pl = l, pr = mid + 1, pt = l; while (pl <= mid && pr <= r) { if (xlty(a[pl], a[pr])) t[pt++] = a[pl++]; else t[pt++] = a[pr++]; } while (pl <= mid) t[pt++] = a[pl++]; while (pr <= r) t[pt++] = a[pr++]; for (int i = l; i <= r; i++) a[i] = t[i]; } // a[1~n] 是最终这些数希望达成的顺序 // 记录当前数的顺序 int now[1123456]; // 记录每个数当前在哪儿 int pos[1123456]; int main() { cin >> n; for (int i = 1; i <= n; i++) a[i] = i; mergeSort(1, n); for (int i = 1; i <= n; i++) { pos[i] = i; now[i] = i; } // 每个位置把正确的数交换过来 for (int i = 1; i <= n; i++) { // 第 i 个位置需要是 a[i] if (now[i] != a[i]) { doSwap(i, pos[a[i]]); // i ~ now[i] // pos[a[i]] ~ a[i] int posX = i, x = now[i]; int posY = pos[a[i]], y = a[i]; swap(pos[x], pos[y]); swap(now[posX], now[posY]); } } cout << \\\"3\\\" << endl; return 0; }\"]},\"174\":{\"h\":\"手动交互器\",\"t\":[\"这个代码把你要测试的排列输进去，就可以两个程序完成手动交互了。\",\"#include <bits/stdc++.h> using namespace std; int n, T; int a[5005]; int rnk[5005]; int main() { cin >> n; for (int i = 1; i <= n; i++) { cin >> a[i]; } int op, x, y; while (1) { cin >> op; if (op == 3) break; if (op == 1) { cin >> x >> y; if (a[x] < a[y]) cout << 0 << \\\"\\\\n\\\"; else cout << 1 << \\\"\\\\n\\\"; } if (op == 2) { cin >> x >> y; swap(a[x], a[y]); for (int i = 1; i <= n; i++) cout << a[i] << \\\" \\\"; cout << \\\"\\\\n\\\"; } } for (int i = 1; i <= n; i++) cout << a[i] << \\\" \\\"; cout << \\\"\\\\n\\\"; return 0; }\"]},\"175\":{\"h\":\"[NOIP2011 提高组] 铺地毯\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n; int x[10000 + 5], y[10000 + 5]; int xx[10000 + 5], yy[10000 + 5]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) { int a, b, g, k; cin >> a >> b >> g >> k; x[i] = a, y[i] = b; xx[i] = a + g, yy[i] = b + k; } int X, Y; cin >> X >> Y; int ans = -1; for (int i = 1; i <= n; i++) if (x[i] <= X && X <= xx[i] && y[i] <= Y && Y <= yy[i]) ans = i; cout << ans; return 0; }\"]},\"176\":{\"h\":\"[NOIP 2007 提高组] 矩阵取数游戏\",\"t\":[\"#include <bits/stdc++.h> #define int long long using namespace std; const int MAXN = 80; int n, m; int a[MAXN + 5]; __int128 two[MAXN + 5]; __int128 dp[MAXN + 5][MAXN + 5]; void out(__int128 x) { if (x / 10 > 0) out(x / 10); cout << (int)(x % 10); } signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m; two[0] = 1; for (int i = 1; i <= m; i++) two[i] = two[i - 1] * 2; __int128 ans = 0; while (n--) { for (int i = 1; i <= m; i++) cin >> a[i]; for (int len = 1; len <= m; len++) { for (int l = 1; l + len - 1 <= m; l++) { int r = l + len - 1; if (len == 1) { dp[l][r] = a[l] * two[m]; continue; } dp[l][r] = max(dp[l + 1][r] + a[l] * two[m - len + 1], dp[l][r - 1] + a[r] * two[m - len + 1]); } } ans += dp[1][m]; } out(ans); return 0; }\"]},\"177\":{\"h\":\"[NOIP2008 提高组] 传纸条\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int m, n; int a[55][55]; // f[i][j][ii][jj] 第一个人走到 (i,j)，第二个人走到 (ii,jj) 的最大路径和 int f[55][55][55][55]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> m >> n; for (int i = 1; i <= m; i++) for (int j = 1; j <= n; j++) cin >> a[i][j]; for (int i = 1; i <= m; i++) for (int j = 1; j <= n; j++) for (int ii = 1; ii <= m; ii++) for (int jj = 1; jj <= n; jj++) { f[i][j][ii][jj] = 0; if (i == ii && j == jj && !(i == m && j == n)) continue; f[i][j][ii][jj] = max(f[i][j][ii][jj], f[i - 1][j][ii - 1][jj]); f[i][j][ii][jj] = max(f[i][j][ii][jj], f[i - 1][j][ii][jj - 1]); f[i][j][ii][jj] = max(f[i][j][ii][jj], f[i][j - 1][ii - 1][jj]); f[i][j][ii][jj] = max(f[i][j][ii][jj], f[i][j - 1][ii][jj - 1]); f[i][j][ii][jj] += a[i][j] + a[ii][jj]; } cout << f[m][n][m][n]; return 0; }\"]},\"178\":{\"h\":\"[NOIP2000 提高组] 单词接龙\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n; string s[25]; char c; int lnk[25][25]; int ans; int cnt[25]; void dfs(int now, int len) { ans = max(ans, len); for (int i = 1; i <= n; i++) { //cout << now << \\\" \\\" << i << \\\" \\\" << cnt[i] << \\\" \\\" << lnk[now][i] << endl; if (cnt[i] < 2 && lnk[now][i]) { cnt[i]++; //cout << s[now] << \\\"~\\\" << s[i] << endl; dfs(i, len + s[i].length() - lnk[now][i]); cnt[i]--; } } } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> s[i]; cin >> c; for (int i = 1; i <= n; i++) { for (int j = 1; j <= n; j++) { lnk[i][j] = 0; for (int k = s[i].length() - 1; k > 0; k--) { bool flag = true; for (int p = k; p <= s[i].length() - 1; p++) if (s[i][p] != s[j][p - k]) { flag = false; break; } if (flag) { lnk[i][j] = s[i].length() - 1 - k + 1; break; } } } } ans = 0; for (int i = 1; i <= n; i++) if (s[i][0] == c) { cnt[i]++; dfs(i, s[i].length()); cnt[i]--; } cout << ans << endl; return 0; }\"]},\"179\":{\"h\":\"[NOIP2002 提高组] 字串变换\",\"t\":[\"#include <bits/stdc++.h> using namespace std; string a, b; int n; // 规则数量 string A[10], B[10]; map<string, bool> vis; map<string, int> ans; queue<string> q; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> a >> b; n = 1; while (cin >> A[n] >> B[n]) n++; n--; // bfs q.push(a); vis[a] = true; ans[a] = 0; ans[b] = -1; while (!q.empty() && ans[b] == -1) { string now = q.front(); q.pop(); if (ans[now] == 10) continue; // 第 i 个规则 for (int i = 1; i <= n; i++) { // 第 j 个位置是否匹配规则 for (int j = 0; j + A[i].size() - 1 < now.size(); j++) { bool flag = true; for (int k = j; k <= j + A[i].size() - 1; k++) if (now[k] != A[i][k - j]) { flag = false; break; } if (!flag) continue; string temp = \\\"\\\"; for (int k = 0; k < j; k++) temp += now[k]; temp += B[i]; for (int k = j + A[i].size(); k < now.size(); k++) temp += now[k]; if (vis[temp] == false) { ans[temp] = ans[now] + 1; vis[temp] = true; q.push(temp); } } } } if (ans[b] == -1) cout << \\\"NO ANSWER!\\\"; else cout << ans[b]; return 0; }\"]},\"180\":{\"h\":\"[NOIP2002 普及组] 选数\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n, k; int x[25]; // 判断质数 bool isP(int x) { if (x < 2) return false; for (int i = 2; i * i <= x; i++) if (x % i == 0) return false; return true; } // dfs int ans; void dfs(int pos, int cnt, int sum) { if (cnt == k) { if (isP(sum)) ans++; return; } if (pos == n + 1) return; dfs(pos + 1, cnt + 1, sum + x[pos]); dfs(pos + 1, cnt, sum); } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> k; for (int i = 1; i <= n; i++) cin >> x[i]; ans = 0; dfs(1, 0, 0); cout << ans; return 0; }\"]},\"181\":{\"h\":\"Dropping Test\",\"t\":[\"为了保证四舍五入正确，多保留几位小数\",\"#include <bits/stdc++.h> #define int long long using namespace std; int n, k; int a[1005], b[1005]; double temp[1005]; bool check(double mid) { // 检查选择 n-k 个能否达到 mid 分 // 100 * (x1+x2+x3...)/(y1+y2+y3...) >= mid // (100*x1-mid*y1)+(100*x2-mid*y2)+... >= 0 for (int i = 1; i <= n; i++) temp[i] = 100 * a[i] - mid * b[i]; sort(temp + 1, temp + n + 1); double sum = 0; for (int i = k + 1; i <= n; i++) sum += temp[i]; return sum >= 0; } signed main() { ios::sync_with_stdio(false); cin.tie(0); while (cin >> n >> k) { if (n == 0 && k == 0) break; for (int i = 1; i <= n; i++) cin >> a[i]; for (int i = 1; i <= n; i++) cin >> b[i]; double l = 0; double r = 100; while (r - l > 0.0001) { double mid = (l + r) / 2; if (check(mid)) l = mid; else r = mid; } cout << fixed << setprecision(0) << l << \\\"\\\\n\\\"; } return 0; }\",\"按 1000 分算，就多一位了\",\"#include <bits/stdc++.h> #define int long long using namespace std; int n, k; int a[1005], b[1005]; int temp[1005]; bool check(int mid) { // 检查选择 n-k 个能否达到 mid 分 // 1000 * (x1+x2+x3...)/(y1+y2+y3...) >= mid // (1000*x1-mid*y1)+(1000*x2-mid*y2)+... >= 0 for (int i = 1; i <= n; i++) temp[i] = 1000 * a[i] - mid * b[i]; sort(temp + 1, temp + n + 1); int sum = 0; for (int i = k + 1; i <= n; i++) sum += temp[i]; return sum >= 0; } signed main() { ios::sync_with_stdio(false); cin.tie(0); while (cin >> n >> k) { if (n == 0 && k == 0) break; for (int i = 1; i <= n; i++) cin >> a[i]; for (int i = 1; i <= n; i++) cin >> b[i]; int l = 0; int r = 1000; int ans; while (l <= r) { int mid = (l + r) / 2; if (check(mid)) { l = mid + 1; ans = mid; } else r = mid - 1; } cout << (ans + 5) / 10 << \\\"\\\\n\\\"; } return 0; }\"]},\"182\":{\"h\":\"[NOIP2009 提高组] 靶形数独\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int a[10][10]; // “每行每列每个3x3”的“1~9”是否出现过 bool row[10][10], col[10][10], x33[10][10]; // get33(x,y) 获取在哪个小方块 int get33(int x, int y) { int X = (x - 1) / 3 + 1; int Y = (y - 1) / 3 + 1; return (X - 1) * 3 + Y; } // 获取对应的分值 int getScore(int x, int y) { int X = min(x, 9 - x + 1); int Y = min(y, 9 - y + 1); return min(5 + X, 5 + Y); } // 所有 0 vector<pair<int, int>> v; int score; // 得分 int ans; // 最大得分 void dfs(int now) { if (now == v.size()) { ans = max(ans, score); return; } int x = v[now].first; int y = v[now].second; for (int i = 1; i <= 9; i++) { if (!row[x][i] && !col[y][i] && !x33[get33(x, y)][i]) { row[x][i] = true; col[y][i] = true; x33[get33(x, y)][i] = true; score += getScore(x, y) * i; dfs(now + 1); row[x][i] = false; col[y][i] = false; x33[get33(x, y)][i] = false; score -= getScore(x, y) * i; } } } int main() { ios::sync_with_stdio(false); cin.tie(0); for (int i = 1; i <= 9; i++) for (int j = 1; j <= 9; j++) cin >> a[i][j]; // 处理基础得分、及“每行每列每个3x3”的“1~9”是否出现过 for (int i = 1; i <= 9; i++) for (int j = 1; j <= 9; j++) { int now = a[i][j]; row[i][now] = true; col[j][now] = true; x33[get33(i, j)][now] = true; score += getScore(i, j) * now; } // 所有为 0 的位置放入数组 for (int i = 1; i <= 9; i++) for (int j = 1; j <= 9; j++) if (a[i][j] == 0) v.push_back(make_pair(i, j)); ans = -1; dfs(0); cout << ans; return 0; }\",\"#include <bits/stdc++.h> using namespace std; int a[10][10]; // “每行每列每个3x3”的“1~9”是否出现过 bool row[10][10], col[10][10], x33[10][10]; // get33(x,y) 获取在哪个小方块 int get33[10][10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 0, 4, 4, 4, 5, 5, 5, 6, 6, 6, 0, 4, 4, 4, 5, 5, 5, 6, 6, 6, 0, 4, 4, 4, 5, 5, 5, 6, 6, 6, 0, 7, 7, 7, 8, 8, 8, 9, 9, 9, 0, 7, 7, 7, 8, 8, 8, 9, 9, 9, 0, 7, 7, 7, 8, 8, 8, 9, 9, 9}; int getScore[10][10] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 6, 7, 7, 7, 7, 7, 7, 7, 6, 0, 6, 7, 8, 8, 8, 8, 8, 7, 6, 0, 6, 7, 8, 9, 9, 9, 8, 7, 6, 0, 6, 7, 8, 9, 10, 9, 8, 7, 6, 0, 6, 7, 8, 9, 9, 9, 8, 7, 6, 0, 6, 7, 8, 8, 8, 8, 8, 7, 6, 0, 6, 7, 7, 7, 7, 7, 7, 7, 6, 0, 6, 6, 6, 6, 6, 6, 6, 6, 6}; // 所有 0 vector<pair<int, int>> v; int score; // 得分 int ans; // 最大得分 void dfs(int now) { if (now == v.size()) { ans = max(ans, score); return; } if (score + ((int)v.size() - now) * 9 * 10 <= ans) return; int x = v[now].first; int y = v[now].second; for (int i = 1; i <= 9; i++) { if (!row[x][i] && !col[y][i] && !x33[get33[x][y]][i]) { row[x][i] = true; col[y][i] = true; x33[get33[x][y]][i] = true; score += getScore[x][y] * i; dfs(now + 1); row[x][i] = false; col[y][i] = false; x33[get33[x][y]][i] = false; score -= getScore[x][y] * i; } } } // 每一个方块有几个 0，以此为依据排列所有 0 int cnt0[10]; bool cmp(pair<int, int> x, pair<int, int> y) { return cnt0[get33[x.first][x.second]] < cnt0[get33[y.first][y.second]]; } int main() { ios::sync_with_stdio(false); cin.tie(0); for (int i = 1; i <= 9; i++) for (int j = 1; j <= 9; j++) cin >> a[i][j]; // 处理基础得分、及“每行每列每个3x3”的“1~9”是否出现过 // 以及每一个小方块 0 的数量 for (int i = 1; i <= 9; i++) for (int j = 1; j <= 9; j++) { int now = a[i][j]; row[i][now] = true; col[j][now] = true; x33[get33[i][j]][now] = true; score += getScore[i][j] * now; cnt0[get33[i][j]] += (now == 0); } // 所有为 0 的位置放入数组 for (int i = 1; i <= 9; i++) for (int j = 1; j <= 9; j++) if (a[i][j] == 0) v.push_back(make_pair(i, j)); // 所有 0 按照所在行的 0 的数量排序 stable_sort(v.begin(), v.end(), cmp); ans = -1; dfs(0); cout << ans; return 0; }\"]},\"183\":{\"h\":\"[NOIP2004 提高组] 虫食算\"},\"184\":{\"h\":\"50 分\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n; string s[3]; int num[30]; // 每个字母选了哪个数字 int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; cin >> s[0]; // 第一行的式子 cin >> s[1]; // 第二行的式子 cin >> s[2]; // 第三行的式子 // 每个字母转成对应的数字，后面就不用 -'A' 了 for (int i = 0; i < n; i++) { s[0][i] -= 'A'; s[1][i] -= 'A'; s[2][i] -= 'A'; } // 枚举 A~Z 的所有可能 for (int i = 0; i <= n - 1; i++) num[i] = i; do { // 检查当前等式是否合法 bool flag = true; int add = 0; // 进位 for (int i = n - 1; i >= 0; i--) { int now = num[s[0][i]] + num[s[1][i]] + add; if (num[s[2][i]] != now % n) { flag = false; break; } add = now / n; } if (flag) { for (int i = 0; i <= n - 1; i++) cout << num[i] << \\\" \\\"; cout << \\\"\\\\n\\\"; return 0; } } while (next_permutation(num, num + n)); return 0; }\"]},\"185\":{\"h\":\"手写 dfs 暴力枚举 30 分\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n; string s[3]; int num[30]; // 每个字母选了哪个数字 bool vis[30]; // 每个数字有没有被用过 void dfs(int row, int col) { // 把位置调整到合适位置 if (row == 3) { col = col - 1; row = 0; } // 如果每一列都填完了 if (col == -1) { // 检查当前等式是否合法 bool flag = true; int add = 0; // 进位 for (int i = n - 1; i >= 0; i--) { int now = num[s[0][i]] + num[s[1][i]] + add; if (num[s[2][i]] != now % n) { flag = false; break; } add = now / n; } if (flag) { for (int i = 0; i <= n - 1; i++) cout << num[i] << \\\" \\\"; cout << \\\"\\\\n\\\"; exit(0); } return; } int now = s[row][col]; // 取出当前位置的数字 if (num[now] == -1) { // 如果没有被确定过，枚举所有可能性，做下一个位置 for (int i = 0; i <= n - 1; i++) if (!vis[i]) { num[now] = i; vis[i] = true; dfs(row + 1, col); num[now] = -1; vis[i] = false; } } else { // 如果已经被确定了，直接做下一个位置 dfs(row + 1, col); } } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; cin >> s[0]; // 第一行的式子 cin >> s[1]; // 第二行的式子 cin >> s[2]; // 第三行的式子 // 每个字母转成对应的数字，后面就不用 -'A' 了 for (int i = 0; i < n; i++) { s[0][i] -= 'A'; s[1][i] -= 'A'; s[2][i] -= 'A'; } for (int i = 0; i <= n - 1; i++) { num[i] = -1; // 每个字母对应的都是没确定 vis[i] = false; // 每个数字都没被用过 } dfs(0, n - 1); // 从个位开始枚举 return 0; }\"]},\"186\":{\"h\":\"优化 1：第三行直接算结果（90 分）\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n; string s[3]; int num[30]; // 每个字母选了哪个数字 bool vis[30]; // 每个数字有没有被用过 int add[30]; // ## 优化 1：每一列的被进位的值 void dfs(int row, int col) { // 如果每一列都填完了，必然合法了 if (col == -1) { for (int i = 0; i <= n - 1; i++) cout << num[i] << \\\" \\\"; cout << \\\"\\\\n\\\"; exit(0); } // ## 优化 1：第三行直接计算，不枚举 if (row == 2) { int a = num[s[0][col]]; int b = num[s[1][col]]; int c = (a + b + add[col]) % n; if (num[s[2][col]] == -1) { // 第三行的字母还没确定的话 // 不能用 c（c 被用过了） 就不管了 if (vis[c]) return; // 设置为 c 做下一个位置 num[s[2][col]] = c; vis[c] = true; add[col - 1] = (a + b + add[col]) / n; dfs(0, col - 1); // 还原 num[s[2][col]] = -1; vis[c] = false; add[col - 1] = 0; } else if (num[s[2][col]] == c) { // 已经确定过了并且正确 add[col - 1] = (a + b + add[col]) / n; dfs(0, col - 1); add[col - 1] = 0; } return; } int now = s[row][col]; // 取出当前位置的数字 if (num[now] == -1) { // 如果没有被确定过，枚举所有可能性，做下一个位置 for (int i = 0; i <= n - 1; i++) if (!vis[i]) { num[now] = i; vis[i] = true; dfs(row + 1, col); num[now] = -1; vis[i] = false; } } else { // 如果已经被确定了，直接做下一个位置 dfs(row + 1, col); } } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; cin >> s[0]; // 第一行的式子 cin >> s[1]; // 第二行的式子 cin >> s[2]; // 第三行的式子 // 每个字母转成对应的数字，后面就不用 -'A' 了 for (int i = 0; i < n; i++) { s[0][i] -= 'A'; s[1][i] -= 'A'; s[2][i] -= 'A'; } for (int i = 0; i <= n - 1; i++) { num[i] = -1; // 每个字母对应的都是没确定 vis[i] = false; // 每个数字都没被用过 } dfs(0, n - 1); // 从个位开始枚举 return 0; }\"]},\"187\":{\"h\":\"继续优化到满分\",\"t\":[\"又加了点优化\",\"// 基础暴力 #include <bits/stdc++.h> using namespace std; int n; string s[3]; int ans[30]; // 每个数字对应的是多少 // 现在来做第col列，从上往下第 row 个字符，之前已经确定了 cnt 个字符 int num[30]; // 每个数字选了多少 int add[30]; // 每一列的进位 bool vis[30]; // 每个数字有没有被用过 bool flag = false; void dfs(int col, int row, int cnt) { if (flag) return; // 优化 2：如果已经确定了 n 个字母了，就直接检查就好了 if (cnt == n) { bool flag = true; int nowAdd = add[col]; for (int i = col; i >= 0; i--) { int now = num[s[0][i]] + num[s[1][i]] + nowAdd; if (now % n != num[s[2][i]]) return; nowAdd = now / n; } for (int i = 0; i < n; i++) ans[i] = num[i]; flag = true; return; } if (col == -1) { flag = true; for (int i = 0; i < n; i++) ans[i] = num[i]; return; } // 优化 3：每一步都去检查一下有没有可能导致前面的式子答案必然错误 for (int i = col - 1; i >= 0; i--) { int d0 = num[s[0][i]]; int d1 = num[s[1][i]]; int d2 = num[s[2][i]]; if (d0 == -1 || d1 == -1 || d2 == -1) continue; if ((d0 + d1) % n != d2 && (d0 + d1 + 1) % n != d2) return; } if (row == 2) { int now = num[s[0][col]] + num[s[1][col]] + add[col]; int d = now % n; int s2col = s[2][col]; if (num[s2col] == -1) { if (vis[d]) return; num[s2col] = d; vis[d] = true; add[col - 1] = now / n; dfs(col - 1, 0, cnt + 1); add[col - 1] = 0; vis[d] = false; num[s2col] = -1; } else { if (d == num[s2col]) { add[col - 1] = now / n; dfs(col - 1, 0, cnt); add[col - 1] = 0; } } return; } int now = s[row][col]; if (num[now] != -1) { dfs(col, row + 1, cnt); return; } for (int i = 0; i < n; i++) { if (!vis[i]) { num[now] = i; vis[i] = true; dfs(col, row + 1, cnt + 1); if (flag) return; num[now] = -1; vis[i] = false; } } } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; cin >> s[0]; cin >> s[1]; cin >> s[2]; for (int i = 0; i < n; i++) { s[0][i] -= 'A'; s[1][i] -= 'A'; s[2][i] -= 'A'; } for (int i = 0; i < n; i++) { num[i] = -1; vis[i] = false; } dfs(n - 1, 0, 0); for (int i = 0; i < n; i++) cout << ans[i] << \\\" \\\"; return 0; }\"]},\"188\":{\"h\":\"[NOIP2007 提高组] 字符串的展开\",\"t\":[\"#include <iostream> using namespace std; int p1, p2, p3; void ff(char a) { if (p1 == 3) a = '*'; else if (p1 == 2) { if ('a' <= a && a <= 'z') a = a - 'a' + 'A'; } else { if ('A' <= a && a <= 'Z') a = a - 'A' + 'a'; } for (int i = 0; i < p2; i++) cout << a; } void f(char a, char b) { string s = \\\"\\\"; if (b <= a) { cout << '-'; return; } if (('0' <= a && a <= '9' && '0' <= b && b <= '9') || ('a' <= a && a <= 'z' && 'a' <= b && b <= 'z') || ('A' <= a && a <= 'Z' && 'A' <= b && b <= 'Z')) { if (p3 == 1) { for (char x = a + 1; x <= b - 1; x++) ff(x); } else { for (char x = b - 1; x >= a + 1; x--) ff(x); } } else { cout << '-'; return; } } int main() { string s; cin >> p1 >> p2 >> p3; cin >> s; for (int i = 0; i < s.length(); i++) { if (s[i] == '-') { if (i != 0 && i != s.length() - 1) f(s[i - 1], s[i + 1]); else cout << '-'; } else cout << s[i]; } return 0; }\"]},\"189\":{\"h\":\"A-B 数对\"},\"190\":{\"h\":\"简单哈希做法\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MOD = 333333; vector<pair<int, int>> hsh[MOD]; void add(int x) { int xx = x % MOD; for (int i = 0; i < hsh[xx].size(); i++) if (hsh[xx][i].first == x) { hsh[xx][i].second++; return; } hsh[xx].push_back(make_pair(x, 1)); } int get(int x) { int xx = x % MOD; for (int i = 0; i < hsh[xx].size(); i++) if (hsh[xx][i].first == x) return hsh[xx][i].second; return 0; } int n, c; int a[200000 + 5]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> c; for (int i = 1; i <= n; i++) { cin >> a[i]; add(a[i]); } long long ans = 0; for (int i = 1; i <= n; i++) ans += get(a[i] + c); cout << ans; return 0; }\"]},\"191\":{\"h\":\"修复公路\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n, m; struct Line { int x, y, t; } a[100000 + 5]; bool cmp(Line a, Line b) { return a.t < b.t; } int fa[1000 + 5]; int cnt[1000 + 5]; int findFa(int x) { if (x == fa[x]) return x; return fa[x] = findFa(fa[x]); } int main() { cin >> n >> m; for (int i = 1; i <= m; i++) cin >> a[i].x >> a[i].y >> a[i].t; sort(a + 1, a + m + 1, cmp); for (int i = 1; i <= n; i++) { fa[i] = i; cnt[i] = 1; } for (int i = 1; i <= m; i++) { int faX = findFa(a[i].x); int faY = findFa(a[i].y); if (faX != faY) { if (cnt[faX] < cnt[faY]) swap(faX, faY); fa[faY] = faX; cnt[faX] += cnt[faY]; } if (cnt[faX] == n) { cout << a[i].t; return 0; } } cout << \\\"-1\\\\n\\\"; return 0; }\"]},\"192\":{\"h\":\"[APC001] C - Not APC\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 3000000; int T; string s; bool flag[MAXN + 5]; // 存每个位置是否被消掉了 // 按顺序存所有 A、P、C 的下标 int cntA, cntP, cntC; int A[MAXN + 5], P[MAXN + 5], C[MAXN + 5]; // 存每组被消除的位置 vector<int> ansA, ansP, ansC; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> T; while (T--) { cin >> s; cntA = cntP = cntC = 0; for (int i = 0; i < s.size(); i++) { flag[i] = false; if (s[i] == 'A') { cntA++; A[cntA] = i; } if (s[i] == 'P') P[++cntP] = i; if (s[i] == 'C') C[++cntC] = i; } /* for(int i=1;i<=cntA;i++) cout<<A[i]<<\\\",\\\"; cout<<\\\"\\\\n\\\"; for(int i=1;i<=cntP;i++) cout<<P[i]<<\\\",\\\"; cout<<\\\"\\\\n\\\"; for(int i=1;i<=cntC;i++) cout<<C[i]<<\\\",\\\"; cout<<\\\"\\\\n\\\"; */ ansA.clear(); ansP.clear(); ansC.clear(); // 当前三个数组处理到的位置 int posA, posP, posC; posA = posP = posC = 1; while (posA <= cntA && posP <= cntP && posC <= cntC) { if (A[posA] < P[posP] && P[posP] < C[posC]) { ansA.push_back(A[posA]); ansP.push_back(P[posP]); ansC.push_back(C[posC]); flag[A[posA]] = true; posA++; flag[P[posP++]] = true; flag[C[posC++]] = true; } else { if (P[posP] < A[posA]) posP++; else if (C[posC] < P[posP]) posC++; else posA++; } } // 输出消除完的字符串 if (ansA.size() * 3 == s.size()) cout << \\\"Perfect\\\\n\\\"; else { for (int i = 0; i < s.size(); i++) if (!flag[i]) cout << s[i]; cout << \\\"\\\\n\\\"; } // 输出消除方案 cout << ansA.size() << \\\"\\\\n\\\"; for (int i = 0; i < ansA.size(); i++) cout << ansA[i] + 1 << \\\" \\\" << ansP[i] + 1 << \\\" \\\" << ansC[i] + 1 << \\\"\\\\n\\\"; } return 0; }\"]},\"193\":{\"h\":\"[CSP-J 2024] 扑克牌\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n; string s; set<string> se; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) { cin >> s; se.insert(s); } cout << 52 - se.size(); return 0; }\",\"#include <bits/stdc++.h> using namespace std; int n; string s; string t1 = \\\"DCHS\\\"; string t2 = \\\"A23456789TJQK\\\"; int cnt[256][256]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) { cin >> s; cnt[s[0]][s[1]]++; } int ans = 52; for (int i = 0; i < 4; i++) for (int j = 0; j < 13; j++) if (cnt[t1[i]][t2[j]]) ans--; cout << ans; return 0; }\",\"#include <bits/stdc++.h> using namespace std; int n; string s[55]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> s[i]; sort(s + 1, s + n + 1); int cnt = (n >= 1); for (int i = 2; i <= n; i++) if (s[i] != s[i - 1]) cnt++; cout << 52 - cnt; return 0; }\",\"#include <bits/stdc++.h> using namespace std; int n; string s; string t1 = \\\"DCHS\\\"; string t2 = \\\"A23456789TJQK\\\"; int c2i[256]; // char to int int cnt[5][15]; // 1~4 花色 1~13数字 int main() { ios::sync_with_stdio(false); cin.tie(0); for (int i = 0; i <= 3; i++) c2i[t1[i]] = i + 1; for (int i = 0; i <= 12; i++) c2i[t2[i]] = i + 1; cin >> n; for (int i = 1; i <= n; i++) { cin >> s; cnt[c2i[s[0]]][c2i[s[1]]]++; } int ans = 52; for (int i = 1; i <= 4; i++) for (int j = 1; j <= 13; j++) if (cnt[i][j]) ans--; cout << ans; return 0; }\"]},\"194\":{\"h\":\"[CSP-J 2024] 地图探险\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int T; int n, m, k; char g[1005][1005]; int dx[4] = {0, 1, 0, -1}; int dy[4] = {1, 0, -1, 0}; bool vis[1005][1005]; void dfs(int x, int y, int d, int step) { vis[x][y] = true; if (step == k) return; int xx = x + dx[d]; int yy = y + dy[d]; if (1 <= xx && xx <= n && 1 <= yy && yy <= m && g[xx][yy] != 'x') dfs(xx, yy, d, step + 1); else { d = (d + 1) % 4; dfs(x, y, d, step + 1); } } int main() { cin >> T; while (T--) { int x, y, d; cin >> n >> m >> k; cin >> x >> y >> d; for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) { cin >> g[i][j]; vis[i][j] = false; } dfs(x, y, d, 0); int ans = 0; for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) ans += vis[i][j]; cout << ans << \\\"\\\\n\\\"; } return 0; }\"]},\"195\":{\"h\":\"[CSP-J 2024] 小木棍\",\"t\":[\"#include <bits/stdc++.h> #define int long long using namespace std; const int INF = 1'000'000'000'000'000'000; int T, n; int ans; int num[] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6}; // 当前考虑第 now 位，之前用了 cnt 个火柴棒 // 之前凑出来了 x void dfs(int now, int cnt, int x) { if (x > ans) return; if (now == 20) return; if (cnt > n) return; if (cnt == n) { ans = min(ans, x); return; } for (int i = 0; i <= 9; i++) { if (now == 1 && i == 0) continue; dfs(now + 1, cnt + num[i], x * 10 + i); } } signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> T; while (T--) { cin >> n; ans = INF; dfs(1, 0, 0); if (ans == INF) cout << \\\"-1\\\\n\\\"; else cout << ans << \\\"\\\\n\\\"; } return 0; }\",\"#include <bits/stdc++.h> #define int long long using namespace std; const int INF = 1'000'000'000'000'000'000; int T, n; int a[21] = {0, -1, 1, 7, 4, 2, 6, 8, 10, 18, 22, 20, 28, 68, 88, 108, 188, 200, 208, 288, 688}; signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> T; while (T--) { cin >> n; if (n <= 20) cout << a[n] << \\\"\\\\n\\\"; else { if (n % 7 == 1) { cout << \\\"10\\\"; n -= 8; } else if (n % 7 == 2) { cout << \\\"1\\\"; n -= 2; } else if (n % 7 == 3) { cout << \\\"200\\\"; n -= 17; } else if (n % 7 == 4) { cout << \\\"20\\\"; n -= 11; } else if (n % 7 == 5) { cout << \\\"2\\\"; n -= 5; } else if (n % 7 == 6) { cout << \\\"6\\\"; n -= 6; } for (int i = 1; i <= n / 7; i++) cout << \\\"8\\\"; cout << \\\"\\\\n\\\"; } } return 0; }\"]},\"196\":{\"h\":\"[CSP-J 2024] 接龙\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 100000; const int MAXCI = 200000; // MAXLI MAXK MAXSIJ const int MAXR = 100; int T; // 数据组数 int n, k, q; // n 个人，最长 k 的子序列，q 个任务 vector<int> S[MAXN + 5]; // S[i] 存第 i 个人的词库 int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> T; while (T--) { cin >> n >> k >> q; for (int i = 1; i <= n; i++) { S[i].clear(); int li, temp; cin >> li; for (int j = 1; j <= li; j++) { cin >> temp; S[i].push_back(temp); } } while (q--) { int r, c; cin >> r >> c; // 能否在 r 轮凑出来 c bool flag = false; for (int i = 1; i <= n; i++) { for (int j = 0; j <= (int)S[i].size() - 1; j++) { if (S[i][j] != 1) continue; for (int jj = j + 1; jj <= (int)S[i].size() - 1; jj++) { if (jj - j + 1 > k) break; if (S[i][jj] == c) { flag = true; break; } } if (flag) break; } if (flag) break; } cout << flag << \\\"\\\\n\\\"; } } return 0; }\",\"#include <bits/stdc++.h> using namespace std; const int MAXN = 100000; const int MAXCI = 200000; // MAXLI MAXK MAXSIJ const int MAXR = 100; int T; // 数据组数 int n, k, q; // n 个人，最长 k 的子序列，q 个任务 vector<int> S[MAXN + 5]; // S[i] 存第 i 个人的词库 int r, c; // r 轮要凑出来 c bool flag; // 能否达成 // 当前是第 now 轮 // 上一轮是 last 这个人接的龙 // 上一个人接到了 num，当前需要 num 开头 void dfs(int now, int last, int num) { if (flag) return; if (now == r + 1) { if (num == c) flag = true; return; } for (int i = 1; i <= n; i++) { if (i == last) continue; for (int j = 0; j <= (int)S[i].size() - 1; j++) { if (S[i][j] != num) continue; for (int jj = j + 1; jj <= (int)S[i].size() - 1; jj++) { if (jj - j + 1 > k) break; dfs(now + 1, i, S[i][jj]); } } } } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> T; while (T--) { cin >> n >> k >> q; for (int i = 1; i <= n; i++) { S[i].clear(); int li, temp; cin >> li; for (int j = 1; j <= li; j++) { cin >> temp; S[i].push_back(temp); } } while (q--) { cin >> r >> c; flag = false; dfs(1, 0, 1); cout << flag << \\\"\\\\n\\\"; } } return 0; }\",\"#include <bits/stdc++.h> using namespace std; const int MAXN = 100000; const int MAXCI = 200000; // MAXLI MAXK MAXSIJ const int MAXR = 100; int T; // 数据组数 int n, k, q; // n 个人，最长 k 的子序列，q 个任务 vector<int> S[MAXN + 5]; // S[i] 存第 i 个人的词库 // f[i][j]: i 轮由谁达成 j 结尾 // 0：没人能达成 // -1：>= 两个人能达成 // ~：~ 这个人能达成 int f[MAXR + 5][MAXCI + 5]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> T; while (T--) { cin >> n >> k >> q; for (int i = 1; i <= n; i++) { S[i].clear(); int li, temp; cin >> li; for (int j = 1; j <= li; j++) { cin >> temp; S[i].push_back(temp); } } // 处理 f[][] f[0][1] = -1; for (int i = 1; i <= MAXR; i++) { // 多测清空 for (int j = 1; j <= MAXCI; j++) f[i][j] = 0; // x 这个人可以把 yy 接到 zz for (int x = 1; x <= n; x++) { for (int y = 0; y <= (int)S[x].size() - 1; y++) { int yy = S[x][y]; // 上一轮能接到 yy 这一轮才能接到 zz if (f[i - 1][yy] == 0 || f[i - 1][yy] == x) continue; for (int z = y + 1; z <= (int)S[x].size() - 1; z++) { if (z - y + 1 > k) break; int zz = S[x][z]; if (f[i][zz] != 0 && f[i][zz] != x) f[i][zz] = -1; else f[i][zz] = x; } } } } while (q--) { int r, c; cin >> r >> c; cout << (bool)f[r][c] << \\\"\\\\n\\\"; } } return 0; }\",\"#include <bits/stdc++.h> using namespace std; const int MAXN = 100000; const int MAXCI = 200000; // MAXLI MAXK MAXSIJ const int MAXR = 100; int T; // 数据组数 int n, k, q; // n 个人，最长 k 的子序列，q 个任务 vector<int> S[MAXN + 5]; // S[i] 存第 i 个人的词库 // f[i][j]: i 轮由谁达成 j 结尾 // 0：没人能达成 // -1：>= 两个人能达成 // ~：~ 这个人能达成 int f[MAXR + 5][MAXCI + 5]; // 当前这个人，每个位置的数前一轮能否达成 bool vis[MAXCI + 5]; // vis 对应的前缀和 int sum[MAXCI + 5]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> T; while (T--) { cin >> n >> k >> q; for (int i = 1; i <= n; i++) { S[i].clear(); int li, temp; cin >> li; for (int j = 1; j <= li; j++) { cin >> temp; S[i].push_back(temp); } } // 处理 f[][] f[0][1] = -1; for (int i = 1; i <= MAXR; i++) { // 多测清空 for (int j = 1; j <= MAXCI; j++) f[i][j] = 0; // x 这个人可以把 yy 接到 zz for (int x = 1; x <= n; x++) { for (int z = 0; z <= (int)S[x].size() - 1; z++) { int zz = S[x][z]; // 更新 vis[z]（前一轮能否由别人达成 zz） if (f[i - 1][zz] == 0 || f[i - 1][zz] == x) vis[z] = 0; else vis[z] = 1; // 更新 sum[z] if (z == 0) sum[z] = vis[z]; else sum[z] = sum[z - 1] + vis[z]; // 判断 f[i][zz] 能否由 x 达成 // 取决于 z 前面 k-1 个位置区间和是否大于 0 int now; if (z == 0) now = 0; else now = sum[z - 1]; if (z - k >= 0) now -= sum[z - k]; if (now == 0) continue; if (f[i][zz] != 0 && f[i][zz] != x) f[i][zz] = -1; else f[i][zz] = x; } } } while (q--) { int r, c; cin >> r >> c; cout << (bool)f[r][c] << \\\"\\\\n\\\"; } } return 0; }\",\"#include <bits/stdc++.h> using namespace std; const int MAXR = 100; const int MAXN = 100000; // MAXQ=MAXN const int MAXCI = 200000; int T; // 数据组数 int n, k, q; // 人数、接龙序列上限、任务个数 int r[MAXN + 5], c[MAXN + 5]; vector<int> s[MAXN + 5]; bool vis[MAXCI + 5]; // vis[i] 能否由 1 走到 i // ======== 测试点 1 ======== void subtask1() { for (int i = 1; i <= MAXCI; i++) vis[i] = false; for (int i = 1; i <= n; i++) { for (int j = 0; j < s[i].size(); j++) { if (s[i][j] != 1) continue; for (int jj = j + 1; jj <= min(j + k - 1, (int)s[i].size() - 1); jj++) vis[s[i][jj]] = true; } } for (int i = 1; i <= q; i++) cout << vis[c[i]] << \\\"\\\\n\\\"; } // ======== 测试点 2,3 ======== bool ok; // 判断当前的 r,c 是否能完成 // 要判断 R 轮能否接到 C // 当前处理第 now 轮，上一个人是 last // 上一个结束的数字/这次开始的数字是 num void dfs(int R, int C, int now, int last, int num) { if (ok) return; if (now > R) { if (num == C) ok = true; return; } // 进行当前接龙 for (int i = 1; i <= n; i++) { if (i == last) continue; for (int j = 0; j < s[i].size(); j++) { if (s[i][j] != num) continue; for (int jj = j + 1; jj <= min(j + k - 1, (int)s[i].size() - 1); jj++) { int nxt = s[i][jj]; // num 可以由第 i 个人接到 jj dfs(R, C, now + 1, i, nxt); } } } } void subtask2() { for (int i = 1; i <= q; i++) { ok = false; dfs(r[i], c[i], 1, 0, 1); cout << ok << \\\"\\\\n\\\"; } } // ======== 70 分 ======== // 第 i 轮，以 j 结尾是谁达成的 // 0：无法达成 // -1：有大于等于两个人达成 // ~： 这个人达成的 int dp[MAXR + 5][MAXCI + 5]; void subtask3() { // 预处理 dp dp[0][1] = -1; for (int i = 1; i <= MAXR; i++) // MAXR { // 清空之前的影响 for (int j = 1; j <= MAXCI; j++) dp[i][j] = 0; for (int j = 1; j <= n; j++) // 每个人 { for (int x = 0; x <= (int)s[j].size() - 1; x++) { int xx = s[j][x]; // 第 j 个人可以从 xx 接龙到 yy // 如果上一轮没法达成 xx ，或者上一轮达成的人就是 j // 那这一轮无法达成 yy if (dp[i - 1][xx] == 0 || dp[i - 1][xx] == j) continue; for (int y = x + 1; y <= (int)s[j].size() - 1; y++) { if (y - x + 1 > k) break; int yy = s[j][y]; if (dp[i][yy] == 0 || dp[i][yy] == j) dp[i][yy] = j; else dp[i][yy] = -1; } } } } // 输出 for (int i = 1; i <= q; i++) cout << (bool)dp[r[i]][c[i]] << \\\"\\\\n\\\"; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> T; while (T--) { cin >> n >> k >> q; for (int i = 1; i <= n; i++) { int li, sij; cin >> li; s[i].clear(); for (int j = 1; j <= li; j++) { cin >> sij; s[i].push_back(sij); } } bool flag1 = true; // r==1 bool flag2 = true; // r<=5 for (int i = 1; i <= q; i++) { cin >> r[i] >> c[i]; if (r[i] != 1) flag1 = false; if (r[i] > 5) flag2 = false; } if (flag1) subtask1(); else if (flag2) subtask2(); else subtask3(); } return 0; }\"]},\"197\":{\"h\":\"[CSP-S 2024] 决斗\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 100000; int n; int r[MAXN + 5]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> r[i]; sort(r + 1, r + n + 1); for (int i = 2; i <= n; i++) // 攻击者 { // 找最小的能被 i 攻击的 j for (int j = 1; j <= i - 1; j++) { if (r[j] != 0 && r[j] < r[i]) { r[j] = 0; break; } } } int ans = 0; for (int i = 1; i <= n; i++) ans += (r[i] != 0); cout << ans; return 0; }\",\"#include <bits/stdc++.h> using namespace std; const int MAXN = 100000; int n; int r[MAXN + 5]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> r[i]; sort(r + 1, r + n + 1); // 记录最小的还没有被攻击的是哪一个 int j = 1; for (int i = 2; i <= n; i++) // 攻击者 { if (r[j] < r[i]) { r[j] = 0; j++; } } int ans = 0; for (int i = 1; i <= n; i++) ans += (r[i] != 0); cout << ans; return 0; }\",\"#include <bits/stdc++.h> using namespace std; const int MAXN = 100000; const int MAXRI = MAXN; int n; int r[MAXN + 5]; int cnt[MAXRI + 5]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) { cin >> r[i]; cnt[r[i]]++; } for (int i = 1, j = 1; i <= MAXRI; i++) // 攻击者 { if (cnt[i] == 0) continue; // 有 cnt[i] 个人的攻击力为 i // j 枚举他能攻击多少人 int now = cnt[i]; // 记录还能打几个人 while (j < i) { if (cnt[j] <= now) { // 攻击力为 j 的人全都被攻击了 now -= cnt[j]; cnt[j] = 0; j++; } else { // 攻击力为 j 的人被攻击了 now 个 cnt[j] -= now; now = 0; break; } } } int ans = 0; for (int i = 1; i <= MAXRI; i++) ans += cnt[i]; cout << ans; return 0; }\",\"#include <bits/stdc++.h> using namespace std; const int MAXN = 100000; const int MAXRI = MAXN; int n; int r[MAXN + 5]; int cnt[MAXRI + 5]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) { cin >> r[i]; cnt[r[i]]++; } int ans = 0; for (int i = 1; i <= MAXRI; i++) ans = max(ans, cnt[i]); cout << ans; return 0; }\"]},\"198\":{\"h\":\"[CSP-S 2024] 超速检测\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int T; const int MAXN = 100000; // MAXM // 车的数量、测速仪数量、主干道长度、限速 int n, m, L, V; // 第 i 辆车的初始位置、初始速度、加速度 int d[MAXN + 5], v[MAXN + 5], a[MAXN + 5]; // 测速点的位置 int p[MAXN + 5]; // A 性质 void subtaskA() { // p 保证了有序，最后一个测速点就是 p[m] int ans1 = 0; // 超速车的数量 int ans2 = m; // 可以关闭多少台 for (int i = 1; i <= n; i++) // 超速了且在最后测速点之前抄的 if (v[i] > V && d[i] <= p[m]) ans1++; if (ans1 != 0) ans2--; cout << ans1 << \\\" \\\" << ans2 << \\\"\\\\n\\\"; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> T; while (T--) { cin >> n >> m >> L >> V; for (int i = 1; i <= n; i++) cin >> d[i] >> v[i] >> a[i]; for (int i = 1; i <= m; i++) cin >> p[i]; subtaskA(); } return 0; }\",\"#include <bits/stdc++.h> using namespace std; int T; const int MAXN = 100000; // MAXM // 车的数量、测速仪数量、主干道长度、限速 int n, m, L, V; // 第 i 辆车的初始位置、初始速度、加速度 int d[MAXN + 5], v[MAXN + 5], a[MAXN + 5]; // 测速点的位置 int p[MAXN + 5]; // AB 性质 // 检查在 d 的位置开始，以 v 的初速度，a 的加速度 // 到 p 的位置的时候是否会超速 bool check(int d, int v, int a, int p) { if (d > p) return false; int s = p - d; // 位移 // sqrt(v*v + 2*a*s) > V return v * v + 2 * a * s > V * V; } void subtaskAB() { // p 保证了有序，最后一个测速点就是 p[m] int ans1 = 0; // 超速车的数量 int ans2 = m; // 可以关闭多少台 for (int i = 1; i <= n; i++) // 超速了且在最后测速点之前抄的 if (check(d[i], v[i], a[i], p[m]) && d[i] <= p[m]) ans1++; if (ans1 != 0) ans2--; cout << ans1 << \\\" \\\" << ans2 << \\\"\\\\n\\\"; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> T; while (T--) { cin >> n >> m >> L >> V; for (int i = 1; i <= n; i++) cin >> d[i] >> v[i] >> a[i]; for (int i = 1; i <= m; i++) cin >> p[i]; subtaskAB(); } return 0; }\",\"#include <bits/stdc++.h> using namespace std; int T; const int MAXN = 100000; // MAXM // 车的数量、测速仪数量、主干道长度、限速 int n, m, L, V; // 第 i 辆车的初始位置、初始速度、加速度 int d[MAXN + 5], v[MAXN + 5], a[MAXN + 5]; // 测速点的位置 int p[MAXN + 5]; // 返回当前属性下的超速区间（位置） vector<pair<int, int>> line; // 所有超速区间 // 超速区间按照结束位置排序 bool cmp(pair<int, int> a, pair<int, int> b) { return a.second < b.second; } void work() { line.clear(); // 算出所有超速区间 for (int i = 1; i <= n; i++) { if (a[i] == 0) { // 不超速 if (v[i] <= V) continue; // 整个路程都超速 line.push_back(make_pair(d[i], L)); } else if (a[i] > 0) { // 算算啥时候开始超速 if (v[i] > V) // 一开始就超速 line.push_back(make_pair(d[i], L)); else { // 算算走多久之后开始超过 V 的速度 // 可以想想这里为什么可以规避浮点运算 int s = (V * V - v[i] * v[i]) / (2 * a[i]) + 1; if (d[i] + s <= L) line.push_back(make_pair(d[i] + s, L)); } } else if (a[i] < 0) { // 一开始就不超速，肯定不可能再超速了 if (v[i] <= V) continue; // 算算最后的超速位置 // 可以想想这里的细节，为什么是上取整减一 // 注意这里不能写 + (2 * a[i] - 1) 来实现，因为这边分子分母是负数 int s = (V * V - v[i] * v[i]) / (2 * a[i]); if ((V * V - v[i] * v[i]) % (2 * a[i]) == 0) s--; if (s < 0) s = 0; line.push_back(make_pair(d[i], min(L, d[i] + s))); } } // 调试 /* for (auto x : line) { cout << x.first << \\\"~\\\" << x.second << \\\"\\\\n\\\"; } */ sort(line.begin(), line.end(), cmp); int pos = 1; // 下一个考虑的测速点下标 int last = -1; // 最新选上的测速点位置 int ans1 = 0; // 超速车数量 int ans2 = 0; // 需要开启的测速点数量 for (int i = 0; i < line.size(); i++) { // 如果当前区间已经有启用了的测速点，超速车多一台，不用新测速点 if (line[i].first <= last) { ans1++; continue; } // 找到最后一个可行的测速点，下一个测速点没超过右端点就变为下一个 while (pos < m && p[pos + 1] <= line[i].second) pos++; // 看看这个测试点要不要启用 if (pos <= m && line[i].first <= p[pos] && p[pos] <= line[i].second) { last = p[pos]; // 更新最新测速点位置 pos++; // 下一个要考虑后面的测速点了 ans1++; // 这辆车会被检测超速 ans2++; // 选用了一个测速点 } } cout << ans1 << \\\" \\\" << m - ans2 << '\\\\n'; } int main() { freopen(\\\"detect.in\\\", \\\"r\\\", stdin); freopen(\\\"detect.out\\\", \\\"w\\\", stdout); ios::sync_with_stdio(false); cin.tie(0); cin >> T; while (T--) { cin >> n >> m >> L >> V; for (int i = 1; i <= n; i++) cin >> d[i] >> v[i] >> a[i]; for (int i = 1; i <= m; i++) cin >> p[i]; work(); } return 0; }\"]},\"199\":{\"h\":\"[CSP-S 2024] 染色\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 15; int T; int n; int a[MAXN + 5]; int c[MAXN + 5]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> T; while (T--) { cin >> n; for (int i = 0; i < n; i++) cin >> a[i]; int ans = 0; for (int sta = 0; sta < (1LL << n); sta++) { // 当前染色状态是 sta for (int i = 0; i < n; i++) { // 找最近的同色 int pos = -1; for (int j = i - 1; j >= 0; j--) if (((sta >> j) & 1) == ((sta >> i) & 1)) { pos = j; break; } if (pos == -1 || a[pos] != a[i]) c[i] = 0; else c[i] = a[i]; } int now = 0; for (int i = 0; i < n; i++) now += c[i]; ans = max(ans, now); } cout << ans << \\\"\\\\n\\\"; } return 0; }\",\"#include <bits/stdc++.h> using namespace std; const int MAXN = 15; int T; int n; int a[MAXN + 5]; int c[MAXN + 5]; int color[MAXN + 5]; int ans; void dfs(int now) { if (now > n) { // 当前染色状态是 color[1~n] int now = 0; for (int i = 1; i <= n; i++) { // 找最近的同色 int pos = 0; for (int j = i - 1; j >= 1; j--) if (color[j] == color[i]) { pos = j; break; } if (pos != 0 && a[pos] == a[i]) now += a[i]; } ans = max(ans, now); return; } color[now] = 1; dfs(now + 1); color[now] = 0; dfs(now + 1); } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> T; while (T--) { cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; ans = 0; dfs(1); cout << ans << \\\"\\\\n\\\"; } return 0; }\",\"#include <bits/stdc++.h> using namespace std; const int MAXN = 2000; int T; int n; int a[MAXN + 5]; // 前 i 项、第 i 项为 j 颜色、上一个异色为 k 位置的最大得分 int f[MAXN + 5][2][MAXN + 5]; int now(int i, int j) { if (a[i] == a[j]) return a[i]; else return 0; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> T; while (T--) { cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; int ans = 0; for (int i = 1; i <= n; i++) { for (int j = 1; j <= n; j++) f[i][0][j] = f[i][1][j] = 0; // 上一个异色的位置是 j（j==0 表示没有异色），不是左边的时候 // 上一个同色的位置就是 i-1 for (int j = 0; j <= i - 2; j++) { f[i][0][j] = f[i - 1][0][j] + now(i, i - 1); f[i][1][j] = f[i - 1][1][j] + now(i, i - 1); ans = max(ans, f[i][0][j]); ans = max(ans, f[i][1][j]); } // 上一个异色的位置是 i-1，找上一个同色的位置 for (int j = 0; j <= i - 2; j++) { f[i][0][i - 1] = max(f[i][0][i - 1], f[i - 1][1][j] + now(i, j)); f[i][1][i - 1] = max(f[i][1][i - 1], f[i - 1][0][j] + now(i, j)); } ans = max(ans, f[i][0][i - 1]); ans = max(ans, f[i][1][i - 1]); } cout << ans << \\\"\\\\n\\\"; } return 0; }\",\"#include <bits/stdc++.h> using namespace std; const int MAXN = 2000; int T; int n; int a[MAXN + 5]; // 前 i 项、上一个异色为 j 位置的最大得分 int f[MAXN + 5][MAXN + 5]; int now(int i, int j) { if (a[i] == a[j]) return a[i]; else return 0; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> T; while (T--) { cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; int ans = 0; for (int i = 1; i <= n; i++) { for (int j = 1; j <= n; j++) f[i][j] = 0; // 上一个异色的位置是 j（j==0 表示没有异色），不是左边的时候 // 上一个同色的位置就是 i-1 for (int j = 0; j <= i - 2; j++) { f[i][j] = f[i - 1][j] + now(i, i - 1); ans = max(ans, f[i][j]); } // 上一个异色的位置是 i-1，找上一个同色的位置 for (int j = 0; j <= i - 2; j++) f[i][i - 1] = max(f[i][i - 1], f[i - 1][j] + now(i, j)); ans = max(ans, f[i][i - 1]); } cout << ans << \\\"\\\\n\\\"; } return 0; }\"]},\"200\":{\"h\":\"01迷宫\",\"t\":[\"#include <bits/stdc++.h> using namespace std; char g[1003][1003]; int vis[1003][1003]; int dx[] = {0, 1, 0, -1}, dy[] = {-1, 0, 1, 0}, nx, ny, n, m; int now, ans[1003][1003]; //“可变长数组” //ax.clear(); //ax.size(); //ax.push_back(x); //ax[i] vector<int> ax, ay; //记录dfs走过的点 void dfs(int x, int y, int flag) { vis[x][y] = flag; //标记当前位置走过了 now++; //当前能走到的点多一个 ax.push_back(x); //储存dfs走过的路 ay.push_back(y); for (int i = 0; i < 4; i++) { nx = x + dx[i]; ny = y + dy[i]; if (g[x][y] == g[nx][ny]) continue; if (nx && ny && nx <= n && ny <= n) if (vis[nx][ny] != flag) dfs(nx, ny, flag); } } int main() { //输入 cin >> n >> m; for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) cin >> g[i][j]; //处理每个询问 memset(vis, 0, sizeof(vis)); memset(ans, -1, sizeof(ans)); for (int i = 1; i <= m; i++) { int x, y; cin >> x >> y; if (ans[x][y] == -1) { now = 0; dfs(x, y, i); //dfs路径上所有点可以走到的点的数量设置为now for (int i = 0; i < ax.size(); i++) ans[ax[i]][ay[i]] = now; ax.clear(); ay.clear(); } cout << ans[x][y] << endl; } }\"]},\"201\":{\"h\":\"垃圾陷阱\"},\"202\":{\"h\":\"纯暴力搜索（28 分）\",\"t\":[\"#include <bits/stdc++.h> using namespace std; // D 井的深度, G 垃圾数量 int D, G; struct Trash { // 落下的时间、能维持的生命、可以垫高的高度 int t, f, h; }; Trash a[105]; bool cmp(Trash a, Trash b) { return a.t < b.t; } // 现在考虑第 now 个垃圾 // 之前高度为 H，能活到 F 点，达到 H/F 的时间是 T int ans1, ans2; // 几点钟能出去、最多活到几点钟 void dfs(int now, int H, int F, int T) { ans2 = max(ans2, F); if (H >= D) ans1 = min(ans1, T); if (now > G) return; // 判断能不能见到当前垃圾 if (a[now].t > F) return; // 垫高 dfs(now + 1, H + a[now].h, F, a[now].t); // 吃掉 dfs(now + 1, H, F + a[now].f, a[now].t); } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> D >> G; for (int i = 1; i <= G; i++) cin >> a[i].t >> a[i].f >> a[i].h; sort(a + 1, a + G + 1, cmp); if (G <= 20) { // 暴力搜索 ans1 = 1001; ans2 = 0; dfs(1, 0, 10, 0); if (ans1 != 1001) cout << ans1; else cout << ans2; return 0; } return 0; }\"]},\"203\":{\"h\":\"暴力搜索+假贪心（46 分）\",\"t\":[\"#include <bits/stdc++.h> using namespace std; // D 井的深度, G 垃圾数量 int D, G; struct Trash { // 落下的时间、能维持的生命、可以垫高的高度 int t, f, h; }; Trash a[105]; bool cmp(Trash a, Trash b) { return a.t < b.t; } // 现在考虑第 now 个垃圾 // 之前高度为 H，能活到 F 点，达到 H/F 的时间是 T int ans1, ans2; // 几点钟能出去、最多活到几点钟 void dfs(int now, int H, int F, int T) { ans2 = max(ans2, F); if (H >= D) ans1 = min(ans1, T); if (now > G) return; // 判断能不能见到当前垃圾 if (a[now].t > F) return; // 垫高 dfs(now + 1, H + a[now].h, F, a[now].t); // 吃掉 dfs(now + 1, H, F + a[now].f, a[now].t); } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> D >> G; for (int i = 1; i <= G; i++) cin >> a[i].t >> a[i].f >> a[i].h; sort(a + 1, a + G + 1, cmp); if (G <= 20) { // 暴力搜索 ans1 = 1001; ans2 = 0; dfs(1, 0, 10, 0); if (ans1 != 1001) cout << ans1; else cout << ans2; return 0; } // 写一个假贪心，活不下来时，吃掉最近的垃圾 int H, F, T; // 当前高度，当前能活到的时间，当前时间 H = 0, F = 10; for (int i = 1; i <= G; i++) { // 吃垃圾直到能见到当前垃圾 while (F < a[i].t) { // 吃一个垃圾 int pos = -1; for (int j = i - 1; j >= 1; j--) { if (a[j].f == 0) continue; if (pos == -1 || a[j].f < a[pos].f || a[j].f == a[pos].f && a[j].h < a[pos].h) pos = j; } if (pos == -1) break; F += a[pos].f; H -= a[pos].h; a[pos].f = 0; } // 如果能见到，更新高度 if (F >= a[i].t) { H += a[i].h; if (H >= D) { cout << a[i].t; return 0; } } } cout << F << \\\"\\\\n\\\"; return 0; }\"]},\"204\":{\"h\":\"DP（100 分）\",\"t\":[\"#include <bits/stdc++.h> using namespace std; // D 井的深度, G 垃圾数量 int D, G; struct Trash { // 落下的时间、能维持的生命、可以垫高的高度 int t, f, h; }; Trash a[105]; bool cmp(Trash a, Trash b) { return a.t < b.t; } int f[105][1000 + 5]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> D >> G; for (int i = 1; i <= G; i++) cin >> a[i].t >> a[i].f >> a[i].h; sort(a + 1, a + G + 1, cmp); memset(f, -1, sizeof(f)); for (int i = 0; i <= 10; i++) f[0][i] = 0; for (int i = 0; i <= G - 1; i++) { for (int j = 0; j <= a[G].t; j++) { // 当前状态为前 i 个垃圾，生命为 j 时的状态 if (f[i][j] == -1) continue; // 加入下一个垃圾时能否修改状态 if (j < a[i + 1].t) f[i + 1][j] = f[i][j]; else { // 下一个垃圾是吃了还是垫高 // 垫高 f[i + 1][j] = max(f[i + 1][j], f[i][j] + a[i + 1].h); // 吃了（吃完后的高度不变，生命可以达到 j~j+a[i+1].f） for (int k = j; k <= min(j + a[i + 1].f, a[G].t); k++) f[i + 1][k] = max(f[i + 1][k], f[i][j]); } } } // 检查到第几个垃圾的时候能出去 int pos = G + 1; for (int i = 0; i <= G; i++) for (int j = 0; j <= a[G].t; j++) if (f[i][j] >= D) pos = min(pos, i); if (pos != G + 1) { cout << a[pos].t; return 0; } // 单独计算能活多久 int ans = 10; for (int i = 1; i <= G; i++) if (a[i].t <= ans) ans += a[i].f; cout << ans; return 0; }\"]},\"205\":{\"h\":\"银行贷款\",\"t\":[\"#include <bits/stdc++.h> using namespace std; double w0, w, m; bool check(double p) { double ww0 = w0; for (int i = 1; i <= m; i++) ww0 = (ww0 * (1 + p) - w); return ww0 <= 0; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> w0 >> w >> m; double ans; for (double p = 0.0001;; p += 0.0001) { if (check(p)) ans = p; else break; } cout << fixed << setprecision(1) << ans * 100; return 0; }\",\"#include <bits/stdc++.h> using namespace std; double w0, w, m; bool check(double p) { double ww0 = w0; for (int i = 1; i <= m; i++) ww0 = (ww0 * (1 + p) - w); return ww0 <= 0; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> w0 >> w >> m; double l = 0; double r = 3; while (r - l > 0.0001) { double mid = (l + r) / 2; if (check(mid)) l = mid; else r = mid; } cout << fixed << setprecision(1) << l * 100; return 0; }\"]},\"206\":{\"h\":\"中位数\"},\"207\":{\"h\":\"中位数\"},\"208\":{\"h\":\"【40 分】 的暴力\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n; int a[100000 + 5]; vector<int> t; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; for (int i = 1; i <= n; i += 2) { // 求前 i 项的中位数 t.clear(); for (int j = 1; j <= i; j++) t.push_back(a[j]); sort(t.begin(), t.end()); cout << t[t.size() / 2] << \\\"\\\\n\\\"; } return 0; }\",\"#include <bits/stdc++.h> using namespace std; int n; int a[100000 + 5]; vector<int> t; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; for (int i = 1; i <= n; i += 2) { sort(a + 1, a + i + 1); cout << a[i / 2 + 1] << \\\"\\\\n\\\"; } return 0; }\"]},\"209\":{\"h\":\"【60 分】利用插入排序的\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n; int a[100000 + 5]; vector<int> t; void f(int pos) { // 把 a[pos] 插入到 a[1]~a[pos-1] 中的合适位置 while (pos > 1 && a[pos] < a[pos - 1]) { swap(a[pos], a[pos - 1]); pos--; } } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; for (int i = 1; i <= n; i += 2) { if (i == 1) { cout << a[1] << \\\"\\\\n\\\"; continue; } f(i - 1); // 把 a[i-1] 插入到 a[1]~a[i-2] 的合适位置 f(i); // 把 a[i] 插入到 a[1]~a[i-1] 的合适位置 cout << a[i / 2 + 1] << \\\"\\\\n\\\"; } return 0; }\"]},\"210\":{\"h\":\"【100 分】对顶堆的 做法\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n; int a[100000 + 5]; priority_queue<int> small, big; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; for (int i = 1; i <= n; i += 2) { if (i == 1) small.push(a[i]); else { // a[i-1]放进对顶堆 if (a[i - 1] <= small.top()) small.push(a[i - 1]); else big.push(-a[i - 1]); // a[i]放进对顶堆 if (a[i] <= small.top()) small.push(a[i]); else big.push(-a[i]); // 协调两边，保证左边的大小比右边大一个 while (big.size() > small.size()) { small.push(-big.top()); big.pop(); } while (small.size() > big.size() + 1) { big.push(-small.top()); small.pop(); } } cout << small.top() << \\\"\\\\n\\\"; } return 0; }\"]},\"211\":{\"h\":\"【100 分】利用多重集的满分\",\"t\":[\"需要注意：如果 s.insert(x) 时，multiset 中之前有 x，那么会插入到之前的 x 的后面。\",\"#include <bits/stdc++.h> using namespace std; int n, a[112345]; multiset<int> s; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; s.insert(a[1]); auto it = s.begin(); cout << a[1] << \\\"\\\\n\\\"; for (int i = 2; i + 1 <= n; i += 2) { if (a[i] > a[i + 1]) swap(a[i], a[i + 1]); s.insert(a[i]); s.insert(a[i + 1]); int now = (*it); if (now <= a[i]) it++; else if (a[i + 1] < now) it--; cout << (*it) << \\\"\\\\n\\\"; } return 0; }\"]},\"212\":{\"h\":\"【100 分】可以但没必要的利用离散化+数据结构的做法\",\"t\":[\"离散化+权值树状数组+第 k 名查询\"]},\"213\":{\"h\":\"直接二分套树状数组， 查询。\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 100000; int n; int a[MAXN + 5]; int temp[MAXN + 5]; // 权值树状数组 int t[MAXN + 5]; int lowbit(int x) { return x & (-x); } // a[x]++ void add(int x) { for (int i = x; i <= n; i += lowbit(i)) t[i]++; } int query(int x) { int res = 0; for (int i = x; i >= 1; i -= lowbit(i)) res += t[i]; return res; } int kth(int x) { int l = 1; int r = n; int ans = -1; // 找到第一个前缀和大于等于 x 的位置 while (l <= r) { int mid = (l + r) / 2; if (query(mid) >= x) { ans = mid; r = mid - 1; } else l = mid + 1; } return ans; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; // 离散化：a[i] 替换为了对应的排名（从1开始） // temp[i] 是离散化后的i在离散化之前的数 for (int i = 1; i <= n; i++) temp[i] = a[i]; sort(temp + 1, temp + n + 1); for (int i = 1; i <= n; i++) a[i] = lower_bound(temp + 1, temp + n + 1, a[i]) - temp; // 树状数组求中位数 add(a[1]); cout << temp[a[1]] << \\\"\\\\n\\\"; for (int i = 3; i <= n; i += 2) { add(a[i - 1]); add(a[i]); cout << temp[kth((i + 1) / 2)] << \\\"\\\\n\\\"; } return 0; }\"]},\"214\":{\"h\":\"查询\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 100000; int n, log2n; int a[MAXN + 5]; vector<int> temp; // 权值树状数组 int t[MAXN + 5]; int lowbit(int x) { return x & (-x); } void add(int x) { for (int i = x; i <= n; i += lowbit(i)) t[i]++; } int kth(int x) { int pos = 0, cnt = 0; for (int i = log2n; i >= 0; i--) { pos += (1 << i); if (pos > n || cnt + t[pos] >= x) pos -= (1 << i); else cnt += t[pos]; } return pos + 1; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; log2n = log2(n); for (int i = 1; i <= n; i++) cin >> a[i]; // 离散化：a[i] 替换为了对应的排名（从1开始） // temp[i-1] 是离散化后的i在离散化之前的数 for (int i = 1; i <= n; i++) temp.push_back(a[i]); sort(temp.begin(), temp.end()); for (int i = 1; i <= n; i++) a[i] = lower_bound(temp.begin(), temp.end(), a[i]) - temp.begin() + 1; // 树状数组求中位数 add(a[1]); cout << temp[a[1] - 1] << \\\"\\\\n\\\"; for (int i = 3; i <= n; i += 2) { add(a[i - 1]); add(a[i]); cout << temp[kth((i + 1) / 2) - 1] << \\\"\\\\n\\\"; } return 0; }\"]},\"215\":{\"h\":\"[JSOI2008] 星球大战\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 400000; const int MAXM = 200000; int n, m; // 点数（编号从 0 ~ n-1）、边数 // 基础存图，e[u] 存所有 u 连接到的点 vector<int> e[MAXN + 5]; int k; // 被摧毁的星球数量 int star[MAXN + 5]; // 按顺序存被摧毁的星球 bool flag[MAXN + 5]; // 标记每个星球是否被摧毁了 int nowAns; // 记录当前的连通块数量（不包括被摧毁的星球） int ans[MAXN + 5]; // 记录每个星球被摧毁后的答案（有几个连通块） // 并查集 int fa[MAXN + 5]; int findFa(int x) { if (fa[x] == x) return x; return fa[x] = findFa(fa[x]); } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m; for (int i = 1; i <= m; i++) { int u, v; cin >> u >> v; e[u].push_back(v); e[v].push_back(u); } cin >> k; for (int i = 1; i <= k; i++) { cin >> star[i]; flag[star[i]] = true; } // 并查集初始化 for (int i = 1; i <= n; i++) fa[i] = i; // 建立除了被摧毁的星球之外的连接关系 nowAns = n - k; for (int u = 0; u <= n - 1; u++) { if (flag[u] == true) continue; for (int i = 0; i < e[u].size(); i++) { int v = e[u][i]; if (flag[v] == true) continue; // 合并 u,v int rootU = findFa(u); int rootV = findFa(v); if (rootU != rootV) { fa[rootU] = rootV; nowAns--; } } } ans[k] = nowAns; // k 个星球都被摧毁之后的状态 // 从后往前恢复每个星球 for (int i = k; i >= 1; i--) { // 恢复 star[i] int u = star[i]; nowAns++; flag[u] = false; // 这个点现在没有被摧毁 // 恢复所有 u 的连接关系 for (int i = 0; i < e[u].size(); i++) { int v = e[u][i]; if (flag[v] == true) continue; // 恢复 u,v（合并 u,v） int rootU = findFa(u); int rootV = findFa(v); if (rootU != rootV) { fa[rootU] = rootV; nowAns--; } } // 记录答案，恢复了第 i~k 个点之后，就是前 i-1 个点被摧毁时的状态 ans[i - 1] = nowAns; } for (int i = 0; i <= k; i++) cout << ans[i] << \\\"\\\\n\\\"; return 0; }\"]},\"216\":{\"h\":\"[JSOI2008] 最大数\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 200000; int m, d; // 单点变大、前缀最值查询 int T[MAXN + 5]; void update(int x, int y) { for (int i = x; i <= m; i += (i & -i)) T[i] = max(T[i], y); } int query(int x) { int res = -1; for (int i = x; i >= 1; i -= (i & -i)) res = max(res, T[i]); return res; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> m >> d; for (int i = 1; i <= m; i++) T[i] = -1; int t = 0; int len = 0; for (int i = 1; i <= m; i++) { char op; long long x; cin >> op >> x; if (op == 'A') { // 在末尾插入一个数 // 强制在线：插入的数为(上一次查询的答案+x)%d x = ((t + x) % d + d) % d; len++; // 插入到正序的第len个，树状数组中就是从最后位置m倒序的第len个 update(m - len + 1, x); } if (op == 'Q') { // 查询末尾 x 个数的最大值 t = query(m - (len - x + 1) + 1); cout << t << \\\"\\\\n\\\"; } } return 0; }\",\"#include <bits/stdc++.h> using namespace std; const int MAXN = 200000; int m; long long d; // 区间赋值、区间最值查询 namespace SegTree { int t[MAXN * 4 + 5]; // 表示当前节点对应区间全部都要赋值为 tag[now] // 如果 tag[now] 为 -1，即没有全部赋值 int tag[MAXN * 4 + 5]; void build(int now, int l, int r) { tag[now] = -1; if (l == r) { // 如果是基于 a[] 建树，就改成 t[now]=a[l]; t[now] = -1; return; } int mid = (l + r) / 2; build(now * 2, l, mid); build(now * 2 + 1, mid + 1, r); t[now] = max(t[now * 2], t[now * 2 + 1]); } // 下传一层懒标记 void down(int now, int l, int r) { if (l == r || tag[now] == -1) return; t[now * 2] = tag[now]; tag[now * 2] = tag[now]; t[now * 2 + 1] = tag[now]; tag[now * 2 + 1] = tag[now]; tag[now] = -1; } // a[x]~a[y] 赋值为 z void update(int now, int l, int r, int x, int y, int z) { if (x <= l && r <= y) { t[now] = z; tag[now] = z; return; } down(now, l, r); int mid = (l + r) / 2; if (x <= mid) update(now * 2, l, mid, x, y, z); if (mid + 1 <= y) update(now * 2 + 1, mid + 1, r, x, y, z); t[now] = max(t[now * 2], t[now * 2 + 1]); } // 查询 a[x]~a[y] 的最大值 int query(int now, int l, int r, int x, int y) { if (x <= l && r <= y) return t[now]; down(now, l, r); int res = -1; // 设置为小于所有数的值 int mid = (l + r) / 2; if (x <= mid) res = max(res, query(now * 2, l, mid, x, y)); if (mid + 1 <= y) res = max(res, query(now * 2 + 1, mid + 1, r, x, y)); return res; } } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> m >> d; SegTree::build(1, 1, m); int t = 0; int len = 0; for (int i = 1; i <= m; i++) { char op; long long x; cin >> op >> x; if (op == 'A') { // 在末尾插入一个数 // 强制在线：插入的数为(上一次查询的答案+x)%d x = ((t + x) % d + d) % d; len++; SegTree::update(1, 1, m, len, len, x); } if (op == 'Q') { // 查询末尾 x 个数的最大值 t = SegTree::query(1, 1, m, len - x + 1, len); cout << t << \\\"\\\\n\\\"; } } return 0; }\"]},\"217\":{\"h\":\"[USACO1.5] 八皇后 Checker Challenge\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n, cnt; int ans[15]; //ans[x]:第x层放在了第ans[x]列 //当前考虑第step层放在第几列 void dfs(int step) { if (step > n) { cnt++; if (cnt <= 3) { for (int i = 1; i <= n; i++) cout << ans[i] << \\\" \\\"; cout << \\\"\\\\n\\\"; } return; } for (int i = 1; i <= n; i++) { //判断是否冲突 bool flag = true; for (int j = 1; j <= step - 1; j++) { //(step,i) (j,ans[j]) if (step == j || i == ans[j] || step - i == j - ans[j] || step + i == j + ans[j]) { flag = false; break; } } if (flag) { ans[step] = i; dfs(step + 1); } } } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; dfs(1); cout << cnt << endl; return 0; }\"]},\"218\":{\"h\":\"校门外的树（增强版）\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int L, N; // 1: 有树 // 2: 有树苗 // 3: 空穴 int a[10000 + 5]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> L >> N; for (int i = 0; i <= L; i++) a[i] = 1; int ans1 = 0; // 最终有多少棵树苗 int ans2 = 0; // 砍掉了多少棵树苗 while (N--) { int op, A, B, C, D; cin >> op; if (op == 0) { cin >> A >> B; // 砍掉 A~B for (int i = A; i <= B; i++) { if (a[i] == 2) ans2++; a[i] = 3; } } if (op == 1) { cin >> C >> D; // 种上 C~D for (int i = C; i <= D; i++) if (a[i] == 3) a[i] = 2; } } for (int i = 0; i <= L; i++) if (a[i] == 2) ans1++; cout << ans1 << \\\"\\\\n\\\" << ans2; return 0; }\"]},\"219\":{\"h\":\"书的复制\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int m, k; int a[505]; bool check(int x) { int cnt = 0; // 需要几个人 int now = 0; // 当前这个人花的时间 for (int i = 1; i <= m; i++) { // 这一本书 x 都抄不完 if (a[i] > x) return false; // 看看前一个人能不能再抄一本书 if (now + a[i] > x) { cnt++; now = a[i]; } else now += a[i]; } if (now > 0) cnt++; return cnt <= k; } struct Plan { int l, r, tim; }; vector<Plan> plan; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> m >> k; for (int i = 1; i <= m; i++) cin >> a[i]; // # 找到最少时间 // 枚举每个人花费不超过多少时间 int ans = 0; for (int i = 1;; i++) { if (check(i)) { ans = i; break; } } // cout << ans << \\\"\\\\n\\\"; // # 根据最少时间生成方案 int last = m; int now = 0; for (int i = m; i >= 1; i--) { if (now + a[i] <= ans) now += a[i]; else { plan.push_back((Plan){i + 1, last, now}); now = a[i]; last = i; } } plan.push_back((Plan){1, last, now}); for (int i = (int)plan.size() - 1; i >= 0; i--) cout << plan[i].l << \\\" \\\" << plan[i].r << \\\"\\\\n\\\"; return 0; }\",\"#include <bits/stdc++.h> using namespace std; int m, k; int a[505]; bool check(int x) { int cnt = 0; // 需要几个人 int now = 0; // 当前这个人花的时间 for (int i = 1; i <= m; i++) { // 这一本书 x 都抄不完 if (a[i] > x) return false; // 看看前一个人能不能再抄一本书 if (now + a[i] > x) { cnt++; now = a[i]; } else now += a[i]; } if (now > 0) cnt++; return cnt <= k; } struct Plan { int l, r, tim; }; vector<Plan> plan; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> m >> k; for (int i = 1; i <= m; i++) cin >> a[i]; // # 找到最少时间 // 枚举每个人花费不超过多少时间 int ans = 0; int l = 1; int r = 1000000000; while (l <= r) { int mid = (l + r) / 2; if (check(mid)) { ans = mid; r = mid - 1; } else l = mid + 1; } // cout << ans << \\\"\\\\n\\\"; // # 根据最少时间生成方案 int last = m; int now = 0; for (int i = m; i >= 1; i--) { if (now + a[i] <= ans) now += a[i]; else { plan.push_back((Plan){i + 1, last, now}); now = a[i]; last = i; } } plan.push_back((Plan){1, last, now}); for (int i = (int)plan.size() - 1; i >= 0; i--) cout << plan[i].l << \\\" \\\" << plan[i].r << \\\"\\\\n\\\"; return 0; }\"]},\"220\":{\"h\":\"多米诺骨牌\"},\"221\":{\"h\":\"二维数组\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n; int a[1005], b[1005]; const int BASE = 5 * 1000 + 5; // 前 i 项，差为 j 时最少反转次数（+Base） int dp[1005][11234]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; int suma = 0; int sumb = 0; for (int i = 1; i <= n; i++) { cin >> a[i] >> b[i]; suma += a[i]; sumb += b[i]; } memset(dp, -1, sizeof(dp)); dp[0][suma - sumb + BASE] = 0; for (int i = 1; i <= n; i++) { int now = (b[i] - a[i]) - (a[i] - b[i]); for (int j = -5000; j <= 5000; j++) { dp[i][j + BASE] = dp[i - 1][j + BASE]; if (dp[i - 1][j + BASE - now] != -1) { if (dp[i][j + BASE] == -1) dp[i][j + BASE] = dp[i - 1][j + BASE - now] + 1; else dp[i][j + BASE] = min(dp[i][j + BASE], dp[i - 1][j + BASE - now] + 1); } } } for (int i = 0; i <= 5000; i++) { if (dp[n][i + BASE] == -1 && dp[n][-i + BASE] == -1) continue; if (dp[n][i + BASE] == -1) { cout << dp[n][-i + BASE]; return 0; } if (dp[n][-i + BASE] == -1) { cout << dp[n][i + BASE]; return 0; } cout << min(dp[n][-i + BASE], dp[n][i + BASE]); return 0; } return 0; }\"]},\"222\":{\"h\":\"一维数组\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n; int a[1005], b[1005]; const int BASE = 5 * 1000 + 5; //当差为i时最少反转次数（+Base） int dp[11234]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; int suma = 0; int sumb = 0; for (int i = 1; i <= n; i++) { cin >> a[i] >> b[i]; suma += a[i]; sumb += b[i]; } memset(dp, -1, sizeof(dp)); dp[suma - sumb + BASE] = 0; for (int i = 1; i <= n; i++) { int now = (b[i] - a[i]) - (a[i] - b[i]); if (now > 0) { for (int j = 5000; j >= -5000; j--) if (dp[j + BASE - now] != -1) { if (dp[j + BASE] == -1) dp[j + BASE] = dp[j + BASE - now] + 1; else dp[j + BASE] = min(dp[j + BASE], dp[j + BASE - now] + 1); } } else { for (int j = -5000; j <= 5000; j++) if (dp[j + BASE - now] != -1) { if (dp[j + BASE] == -1) dp[j + BASE] = dp[j + BASE - now] + 1; else dp[j + BASE] = min(dp[j + BASE], dp[j + BASE - now] + 1); } } } for (int i = 0; i <= 5000; i++) { if (dp[i + BASE] == -1 && dp[-i + BASE] == -1) continue; if (dp[i + BASE] == -1) { cout << dp[-i + BASE]; return 0; } if (dp[-i + BASE] == -1) { cout << dp[i + BASE]; return 0; } cout << min(dp[-i + BASE], dp[i + BASE]) << endl; return 0; } return 0; }\"]},\"223\":{\"h\":\"[NOIP2011 提高组] 选择客栈\",\"t\":[\"核心就是求某个区间的某种颜色的客栈数量\"]},\"224\":{\"h\":\"基础做法\",\"t\":[\"、\",\"用前缀和来加速\",\"#include <bits/stdc++.h> #define int long long using namespace std; int n, k, p; int sum[55][200005]; //同色前缀和 int a[200005]; //颜色 int b[200005]; //低消 signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> k >> p; for (int i = 1; i <= n; i++) cin >> a[i] >> b[i]; int ans = 0; int lastP = 0; for (int i = 1; i <= n; i++) { for (int j = 0; j <= k - 1; j++) sum[j][i] = sum[j][i - 1]; sum[a[i]][i]++; if (b[i] <= p) lastP = i; if (lastP == i) ans += sum[a[i]][lastP] - 1; else ans += sum[a[i]][lastP]; } cout << ans << \\\"\\\\n\\\"; return 0; }\"]},\"225\":{\"h\":\"加强版\",\"t\":[\"、\",\"把每种颜色的下标存入动态数组，用二分来算区间数量。\",\"#include <bits/stdc++.h> #define int long long using namespace std; const int MAXN = 2000000; const int MAXK = 10000; int n, k, p; vector<int> col[MAXK + 5]; // 颜色为 i 的客栈编号 int a[MAXN + 5]; // 颜色 int b[MAXN + 5]; // 低消 signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> k >> p; for (int i = 1; i <= n; i++) { cin >> a[i] >> b[i]; col[a[i]].push_back(i); } int ans = 0; int lastP = 0; for (int i = 1; i <= n; i++) { if (b[i] <= p) lastP = i; int pos = upper_bound(col[a[i]].begin(), col[a[i]].end(), lastP) - col[a[i]].begin(); if (pos == 0) continue; pos--; // 最后一个大于等于 lastP 的同色下标 if (col[a[i]][pos] == i) ans += pos; else ans += pos + 1; } cout << ans << \\\"\\\\n\\\"; return 0; }\"]},\"226\":{\"h\":\"\",\"t\":[\"既然每种颜色的下标有序，每次求的范围也是递增的，那么类似双指针的做法，在上次求到的位置往后看就好。\",\"这样每个位置最多只被看一次。\",\"#include <bits/stdc++.h> #define int long long using namespace std; const int MAXN = 2000000; const int MAXK = 10000; int n, k, p; vector<int> col[MAXK + 5]; // 颜色为 i 的客栈编号 int pos[MAXK + 5]; // 下一次从哪个位置开始看 int a[MAXN + 5]; // 颜色 int b[MAXN + 5]; // 低消 signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> k >> p; for (int i = 1; i <= n; i++) { cin >> a[i] >> b[i]; col[a[i]].push_back(i); } int ans = 0; int lastP = 0; for (int i = 1; i <= n; i++) { if (b[i] <= p) lastP = i; // 颜色 a[i] 的当前位置没超过范围、且再 lastP 之前、且不是 i // 就往后挪 while (pos[a[i]] < col[a[i]].size() && col[a[i]][pos[a[i]]] <= lastP && col[a[i]][pos[a[i]]] != i) pos[a[i]]++; ans += pos[a[i]]; } cout << ans << \\\"\\\\n\\\"; return 0; }\"]},\"227\":{\"h\":\"[NOIP2014 提高组] 生活大爆炸版石头剪刀布\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int a[5][5] = { 1, 0, 2, 2, 0, 5, 1, 0, 2, 0, 5, 5, 1, 0, 2, 5, 5, 5, 1, 2, 5, 5, 5, 5, 1}; int N, Na, Nb; int x[205]; int y[205]; int main() { ios::sync_with_stdio(false); cin.tie(0); for (int i = 0; i <= 4; i++) for (int j = 0; j <= 4; j++) if (a[i][j] == 5) a[i][j] = 2 - a[j][i]; cin >> N >> Na >> Nb; for (int i = 0; i <= Na - 1; i++) cin >> x[i]; for (int i = 0; i <= Nb - 1; i++) cin >> y[i]; int xScore = 0; int yScore = 0; for (int i = 0; i <= N - 1; i++) { int xx = x[i % Na]; int yy = y[i % Nb]; int now = a[xx][yy]; if (now == 2) xScore++; if (now == 0) yScore++; } cout << xScore << \\\" \\\" << yScore; return 0; }\"]},\"228\":{\"h\":\"封锁阳光大学\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n, m; vector<int> e[10000 + 5]; // 0 未编号、1/2 编号 int tag[10000 + 5]; int cntAll; // 当前连通块大小（被标记的数量） int cnt1; // 当前连通块被标记了 1 的数量 // 当前点为 now，应该被标记上 num void dfs(int now, int num) { // 已经被标记过 if (tag[now] != 0) { if (tag[now] != num) { cout << \\\"Impossible\\\"; exit(0); } return; } // 没有被标记过 tag[now] = num; cntAll++; if (num == 1) cnt1++; for (int i = 0; i < e[now].size(); i++) { int nxt = e[now][i]; dfs(nxt, 3 - num); } } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m; for (int i = 1; i <= m; i++) { int u, v; cin >> u >> v; e[u].push_back(v); e[v].push_back(u); } int ans = 0; for (int i = 1; i <= n; i++) { if (tag[i] == 0) { cntAll = 0; cnt1 = 0; dfs(i, 1); ans += min(cnt1, cntAll - cnt1); } } cout << ans; return 0; }\"]},\"229\":{\"h\":\"八数码难题\"},\"230\":{\"h\":\"广搜 1（数字上操作）\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n; int ten[10]; map<int, int> dis; queue<int> q; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; ten[0] = 1; for (int i = 1; i <= 8; i++) ten[i] = ten[i - 1] * 10; q.push(n); dis[n] = 0; while (!q.empty() && dis.find(123804765) == dis.end()) { int now = q.front(); q.pop(); // 0 的位置、目标的位置 int pos = -1, t; for (int i = 0; i <= 8; i++) if (now / ten[i] % 10 == 0) { pos = i; break; } // 上下左右 for (int i = 1; i <= 4; i++) { if (i == 1) t = pos - 3; if (i == 2) t = pos + 3; if (i == 3) { if (pos % 3 == 0) t = -1; else t = pos - 1; } if (i == 4) { if (pos % 3 == 2) t = -1; else t = pos + 1; } if (0 <= t && t <= 8) { // pos 上是 0，t 上是 x int x = now / ten[t] % 10; int nxt = now - x * ten[t] + x * ten[pos]; if (dis.find(nxt) == dis.end()) { dis[nxt] = dis[now] + 1; q.push(nxt); } } } } cout << dis[123804765]; return 0; }\"]},\"231\":{\"h\":\"广搜 2（真的展开九宫格）\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int ed = 123804765; map<int, int> dis; queue<int> q; int main() { ios::sync_with_stdio(false); cin.tie(0); int st; cin >> st; q.push(st); dis[st] = 1; while (!q.empty() && dis[ed] == 0) { int now = q.front(); q.pop(); /* d[0][0] d[0][1] d[0][2] d[1][0] d[1][1] d[1][2] d[2][0] d[2][1] d[2][2] */ int d[3][3]; d[0][0] = now / 100000000 % 10; d[0][1] = now / 10000000 % 10; d[0][2] = now / 1000000 % 10; d[1][0] = now / 100000 % 10; d[1][1] = now / 10000 % 10; d[1][2] = now / 1000 % 10; d[2][0] = now / 100 % 10; d[2][1] = now / 10 % 10; d[2][2] = now / 1 % 10; int x, y; for (int i = 0; i <= 2; i++) for (int j = 0; j <= 2; j++) if (d[i][j] == 0) x = i, y = j; if (x != 0) { swap(d[x][y], d[x - 1][y]); int nxt = 0; for (int i = 0; i <= 2; i++) for (int j = 0; j <= 2; j++) nxt = nxt * 10 + d[i][j]; if (dis[nxt] == 0) { dis[nxt] = dis[now] + 1; q.push(nxt); } swap(d[x][y], d[x - 1][y]); } if (x != 2) { swap(d[x][y], d[x + 1][y]); int nxt = 0; for (int i = 0; i <= 2; i++) for (int j = 0; j <= 2; j++) nxt = nxt * 10 + d[i][j]; if (dis[nxt] == 0) { dis[nxt] = dis[now] + 1; q.push(nxt); } swap(d[x][y], d[x + 1][y]); } if (y != 0) { swap(d[x][y], d[x][y - 1]); int nxt = 0; for (int i = 0; i <= 2; i++) for (int j = 0; j <= 2; j++) nxt = nxt * 10 + d[i][j]; if (dis[nxt] == 0) { dis[nxt] = dis[now] + 1; q.push(nxt); } swap(d[x][y], d[x][y - 1]); } if (y != 2) { swap(d[x][y], d[x][y + 1]); int nxt = 0; for (int i = 0; i <= 2; i++) for (int j = 0; j <= 2; j++) nxt = nxt * 10 + d[i][j]; if (dis[nxt] == 0) { dis[nxt] = dis[now] + 1; q.push(nxt); } swap(d[x][y], d[x][y + 1]); } } cout << dis[ed] - 1; return 0; }\"]},\"232\":{\"h\":\"[HNOI2004] 敲砖块\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n, m; int a[55][55]; int cnt[55][55]; //列向下计数 int sum[55][55]; //列向下求和 int dp[55][55][50 * 51 / 2 + 5]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m; for (int i = n; i >= 1; i--) { for (int j = 1; j <= i; j++) { cin >> a[i][j]; cnt[i][j] = cnt[i + 1][j] + 1; sum[i][j] = sum[i + 1][j] + a[i][j]; } } n++; memset(dp, -1, sizeof(dp)); for (int i = 1; i <= n; i++) dp[n][i][0] = 0; for (int j = 1; j <= n; j++) { for (int i = n; i >= 1; i--) { if (j > i) break; for (int k = 1; k <= m; k++) { if (dp[i - 1][j - 1][k - cnt[i][j]] != -1) dp[i][j][k] = dp[i - 1][j - 1][k - cnt[i][j]] + sum[i][j]; if (dp[i][j - 1][k - cnt[i][j]] != -1) { if (dp[i][j][k] == -1) dp[i][j][k] = dp[i][j - 1][k - cnt[i][j]] + sum[i][j]; else dp[i][j][k] = max(dp[i][j][k], dp[i][j - 1][k - cnt[i][j]] + sum[i][j]); } if (dp[i + 1][j][k - 1] != -1) { if (dp[i][j][k] == -1) dp[i][j][k] = dp[i + 1][j][k - 1] + a[i][j]; else dp[i][j][k] = max(dp[i][j][k], dp[i + 1][j][k - 1] + a[i][j]); } } } } int ans = 0; for (int i = 1; i <= n; i++) ans = max(ans, dp[n][i][m]); cout << ans << \\\"\\\\n\\\"; return 0; }\"]},\"233\":{\"h\":\"【模板】最长公共子序列\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 100000; int n; int a[MAXN + 5]; int b[MAXN + 5]; int rnk[MAXN + 5]; // rnk[i] 表示 i 在 a 的排名 int ans; // f[i]: 以 b[i] 结尾的 LIS 长度 int f[MAXN + 5]; // g[len]: 当前长度为 len 的 LIS 的最小结尾 int g[MAXN + 5]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; for (int i = 1; i <= n; i++) cin >> b[i]; // 真的修改 b[i] for (int i = 1; i <= n; i++) rnk[a[i]] = i; for (int i = 1; i <= n; i++) b[i] = rnk[b[i]]; // LIS for (int i = 1; i <= n; i++) g[i] = n + 1; for (int i = 1; i <= n; i++) { int len = lower_bound(g + 1, g + n + 1, b[i]) - g; f[i] = len; g[len] = b[i]; ans = max(ans, f[i]); } cout << ans << \\\"\\\\n\\\"; return 0; }\",\"#include <bits/stdc++.h> using namespace std; const int MAXN = 100000; int n; int a[MAXN + 5]; int b[MAXN + 5]; int rnk[MAXN + 5]; // rnk[i] 表示 i 在 a 的排名 int ans; // f[i]: 以 b[i] 结尾的 LIS 长度 int f[MAXN + 5]; // g[len]: 当前长度为 len 的 LIS 的最小结尾 int g[MAXN + 5]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; for (int i = 1; i <= n; i++) cin >> b[i]; // 不修改 b[i]，只是在 b[i] 以 rnk 为依据进行比较 for (int i = 1; i <= n; i++) rnk[a[i]] = i; // LIS for (int i = 1; i <= n; i++) g[i] = 0; rnk[0] = n + 1; for (int i = 1; i <= n; i++) { int l = 1; int r = n; int len; while (l <= r) { int mid = (l + r) / 2; if (rnk[g[mid]] >= rnk[b[i]]) { len = mid; r = mid - 1; } else l = mid + 1; } f[i] = len; g[len] = b[i]; ans = max(ans, f[i]); } cout << ans << \\\"\\\\n\\\"; return 0; }\"]},\"234\":{\"h\":\"鬼子进村\"},\"235\":{\"h\":\"暴力\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 50000; int n, m; int a[MAXN + 5]; // 1 表示被摧毁了，0 表示没被摧毁 stack<int> st; // 记录摧毁的房子 int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m; a[0] = 1; a[n + 1] = 1; while (m--) { char op; cin >> op; if (op == 'D') { int x; cin >> x; a[x] = 1; st.push(x); } if (op == 'R') { a[st.top()] = 0; st.pop(); } if (op == 'Q') { int x; cin >> x; int L, R; // 记录 x左边右边的第一个被摧毁的位置 for (int i = x; i >= 0; i--) if (a[i] == 1) { L = i; break; } for (int i = x; i <= n + 1; i++) if (a[i] == 1) { R = i; break; } if (L == R) cout << 0 << \\\"\\\\n\\\"; else cout << R - L - 1 << \\\"\\\\n\\\"; } } return 0; }\"]},\"236\":{\"h\":\"树状数组写法\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 50000; int n, m; int a[MAXN + 5]; // 1 表示被摧毁了，0 表示没被摧毁 stack<int> st; // 记录摧毁的房子 // 树状数组 int t[MAXN + 5]; int lowbit(int x) { return x & -x; } // a[x]+=y void update(int x, int y) { for (int i = x; i <= n; i += lowbit(i)) t[i] += y; } // sum(a[1]~a[x]) int query(int x) { int res = 0; for (int i = x; i > 0; i -= lowbit(i)) res += t[i]; return res; } int my_lower_bound(int x) { // 找到第一个 query(i) 大于等于 x 的 i int l = 1; int r = n; int ans = -1; while (l <= r) { int mid = (l + r) / 2; if (query(mid) >= x) { ans = mid; r = mid - 1; } else l = mid + 1; } return ans; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m; a[0] = 1; a[n + 1] = 1; while (m--) { char op; cin >> op; if (op == 'D') { int x; cin >> x; a[x] = 1; update(x, 1); st.push(x); } if (op == 'R') { a[st.top()] = 0; update(st.top(), -1); st.pop(); } if (op == 'Q') { int x; cin >> x; if (a[x] == 1) { cout << 0 << \\\"\\\\n\\\"; continue; } int cnt = query(x); // x及左边有多少个房子被摧毁了 int L, R; // 记录 x左边右边的第一个被摧毁的位置 if (cnt == 0) L = 0; // 左边没有房子被摧毁时，认为左边第一个被摧毁的是 0 号位置 else L = my_lower_bound(cnt); if (cnt == st.size()) R = n + 1; // 左边没有房子被摧毁时，认为右边第一个被摧毁的是 n + 1 号位置 else R = my_lower_bound(cnt + 1); cout << R - L - 1 << \\\"\\\\n\\\"; } } return 0; }\"]},\"237\":{\"h\":\"线段树写法\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 50000; int n, m; int a[MAXN + 5]; // 1 表示被摧毁了，0 表示没被摧毁 stack<int> st; // 记录摧毁的房子 // 线段树 int t[MAXN * 4 + 5]; int lazy[MAXN * 4 + 5]; // 当前节点为 now，对应的线段为 [l,r] void build(int now, int l, int r) { if (l == r) { t[now] = a[l]; return; } int mid = (l + r) / 2; build(now * 2, l, mid); build(now * 2 + 1, mid + 1, r); t[now] = t[now * 2] + t[now * 2 + 1]; } // 下传一层懒标记 // 当前节点为 now，对应的线段为 [l,r] void down(int now, int l, int r) { if (l == r || lazy[now] == 0) return; int mid = (l + r) / 2; t[now * 2] += (mid - l + 1) * lazy[now]; t[now * 2 + 1] += (r - mid) * lazy[now]; lazy[now * 2] += lazy[now]; lazy[now * 2 + 1] += lazy[now]; lazy[now] = 0; } // 做到了 now 节点，对应区间为 [l,r] // 单点修改：a[x]~a[y] += z void update(int now, int l, int r, int x, int y, int z) { // 当前区间完全属于要查询的部分就偷个懒 if (x <= l && r <= y) { t[now] += (r - l + 1) * z; lazy[now] += z; return; } // 下传懒标记 down(now, l, r); // 左子节点：now * 2 [l, mid] // 右子节点：now * 2 + 1 [mid + 1, r] int mid = (l + r) / 2; if (x <= mid) update(now * 2, l, mid, x, y, z); if (y >= mid + 1) update(now * 2 + 1, mid + 1, r, x, y, z); t[now] = t[now * 2] + t[now * 2 + 1]; } // 做到了 now 节点，对应区间为 [l,r] // 查询 [x,y] 在当前节点中的部分之和 int query(int now, int l, int r, int x, int y) { // 当前区间完全属于要查询的部分就直接返回 if (x <= l && r <= y) return t[now]; // 下传懒标记 down(now, l, r); // 左子节点：now * 2 [l, mid] // 右子节点：now * 2 + 1 [mid + 1, r] int mid = (l + r) / 2; int res = 0; if (x <= mid) res += query(now * 2, l, mid, x, y); if (y >= mid + 1) res += query(now * 2 + 1, mid + 1, r, x, y); return res; } int my_lower_bound(int x) { // 找到第一个 query(i) 大于等于 x 的 i int l = 1; int r = n; int ans = -1; while (l <= r) { int mid = (l + r) / 2; if (query(1, 1, n, 1, mid) >= x) { ans = mid; r = mid - 1; } else l = mid + 1; } return ans; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m; a[0] = 1; a[n + 1] = 1; build(1, 1, n); while (m--) { char op; cin >> op; if (op == 'D') { int x; cin >> x; a[x] = 1; update(1, 1, n, x, x, 1); st.push(x); } if (op == 'R') { a[st.top()] = 0; update(1, 1, n, st.top(), st.top(), -1); st.pop(); } if (op == 'Q') { int x; cin >> x; if (a[x] == 1) { cout << 0 << \\\"\\\\n\\\"; continue; } int cnt = query(1, 1, n, 1, x); // x及左边有多少个房子被摧毁了 int L, R; // 记录 x左边右边的第一个被摧毁的位置 if (cnt == 0) L = 0; // 左边没有房子被摧毁时，认为左边第一个被摧毁的是 0 号位置 else L = my_lower_bound(cnt); if (cnt == st.size()) R = n + 1; // 左边没有房子被摧毁时，认为右边第一个被摧毁的是 n + 1 号位置 else R = my_lower_bound(cnt + 1); cout << R - L - 1 << \\\"\\\\n\\\"; } } return 0; }\"]},\"238\":{\"h\":\"树状数组写法\",\"t\":[\"略\"]},\"239\":{\"h\":\"线段树写法\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 50000; int n, m; int a[MAXN + 5]; // 1 表示被摧毁了，0 表示没被摧毁 stack<int> st; // 记录摧毁的房子 // 线段树 int t[MAXN * 4 + 5]; int lazy[MAXN * 4 + 5]; // 当前节点为 now，对应的线段为 [l,r] void build(int now, int l, int r) { if (l == r) { t[now] = a[l]; return; } int mid = (l + r) / 2; build(now * 2, l, mid); build(now * 2 + 1, mid + 1, r); t[now] = t[now * 2] + t[now * 2 + 1]; } // 下传一层懒标记 // 当前节点为 now，对应的线段为 [l,r] void down(int now, int l, int r) { if (l == r || lazy[now] == 0) return; int mid = (l + r) / 2; t[now * 2] += (mid - l + 1) * lazy[now]; t[now * 2 + 1] += (r - mid) * lazy[now]; lazy[now * 2] += lazy[now]; lazy[now * 2 + 1] += lazy[now]; lazy[now] = 0; } // 做到了 now 节点，对应区间为 [l,r] // 单点修改：a[x]~a[y] += z void update(int now, int l, int r, int x, int y, int z) { // 当前区间完全属于要查询的部分就偷个懒 if (x <= l && r <= y) { t[now] += (r - l + 1) * z; lazy[now] += z; return; } // 下传懒标记 down(now, l, r); // 左子节点：now * 2 [l, mid] // 右子节点：now * 2 + 1 [mid + 1, r] int mid = (l + r) / 2; if (x <= mid) update(now * 2, l, mid, x, y, z); if (y >= mid + 1) update(now * 2 + 1, mid + 1, r, x, y, z); t[now] = t[now * 2] + t[now * 2 + 1]; } // 做到了 now 节点，对应区间为 [l,r] // 查询 [x,y] 在当前节点中的部分之和 int query(int now, int l, int r, int x, int y) { // 当前区间完全属于要查询的部分就直接返回 if (x <= l && r <= y) return t[now]; // 下传懒标记 down(now, l, r); // 左子节点：now * 2 [l, mid] // 右子节点：now * 2 + 1 [mid + 1, r] int mid = (l + r) / 2; int res = 0; if (x <= mid) res += query(now * 2, l, mid, x, y); if (y >= mid + 1) res += query(now * 2 + 1, mid + 1, r, x, y); return res; } // 找到第一个权值前缀和大于等于 x 的 位置 int segtree_lowerbound(int now, int l, int r, int x) { if (l == r) return l; int mid = (l + r) / 2; if (t[now * 2] >= x) return segtree_lowerbound(now * 2, l, mid, x); return segtree_lowerbound(now * 2 + 1, mid + 1, r, x - t[now * 2]); } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m; a[0] = 1; a[n + 1] = 1; build(1, 1, n); while (m--) { char op; cin >> op; if (op == 'D') { int x; cin >> x; a[x] = 1; update(1, 1, n, x, x, 1); st.push(x); } if (op == 'R') { a[st.top()] = 0; update(1, 1, n, st.top(), st.top(), -1); st.pop(); } if (op == 'Q') { int x; cin >> x; if (a[x] == 1) { cout << 0 << \\\"\\\\n\\\"; continue; } int cnt = query(1, 1, n, 1, x); // x及左边有多少个房子被摧毁了 int L, R; // 记录 x左边右边的第一个被摧毁的位置 if (cnt == 0) L = 0; // 左边没有房子被摧毁时，认为左边第一个被摧毁的是 0 号位置 else L = segtree_lowerbound(1,1,n,cnt); if (cnt == st.size()) R = n + 1; // 左边没有房子被摧毁时，认为右边第一个被摧毁的是 n + 1 号位置 else R = segtree_lowerbound(1,1,n,cnt + 1); cout << R - L - 1 << \\\"\\\\n\\\"; } } return 0; }\"]},\"240\":{\"h\":\"[NOIP2010 提高组] 引水入城\"},\"241\":{\"h\":\"广搜+递推+最少线段覆盖\",\"t\":[\"#include<bits/stdc++.h> #define int long long using namespace std; const int MAXN = 500; int n, m; int a[MAXN + 5][MAXN + 5]; queue<pair<int, int>> q; bool vis[MAXN + 5][MAXN + 5]; int dx[] = {0, 0, 1, -1}; int dy[] = {1, -1, 0, 0}; // 存所有点，为递推顺序做准备 vector<pair<int,int>> points; bool cmp(pair<int,int> x, pair<int,int> y) { return a[x.first][x.second] < a[y.first][y.second]; } // a[i][j] 能走到 a[n][first ~ seoncd] pair<int,int> L[MAXN + 5][MAXN + 5]; vector<pair<int,int>> b; signed main() { cin >> n >> m; for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) cin >> a[i][j]; // 1. 第一行为起点的搜索，判断是否有解 for (int j = 1; j <= m; j++) { vis[1][j] = true; q.push(make_pair(1, j)); } while(!q.empty()) { pair<int, int> now = q.front(); q.pop(); for (int i = 0; i <= 3; i++) { int nx = now.first + dx[i]; int ny = now.second + dy[i]; if (1 <= nx && nx <= n && 1 <= ny && ny <= m && !vis[nx][ny] && a[nx][ny] < a[now.first][now.second]) { vis[nx][ny] = true; q.push(make_pair(nx, ny)); } } } // 算算最后一行有几个位置不可以 int cnt = 0; for (int j = 1; j <= m; j++) if (!vis[n][j]) cnt++; if (cnt != 0) { cout << 0 << \\\"\\\\n\\\"; cout << cnt << \\\"\\\\n\\\"; return 0; } // 2. 构建每个第一行的点对应的区间 for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) points.push_back(make_pair(i, j)); sort(points.begin(), points.end(), cmp); /* for(int i=0;i<points.size();i++) cout<<points[i].first<<\\\" \\\"<<points[i].second<<\\\"\\\\n\\\"; */ for(int i=0;i<points.size();i++) { int x = points[i].first; int y = points[i].second; L[x][y].first = m+1; L[x][y].second = 0; if(x==n) L[x][y] = make_pair(y,y); for(int j=0;j<=3;j++){ int nx = points[i].first + dx[j]; int ny = points[i].second + dy[j]; if (1 <= nx && nx <= n && 1 <= ny && ny <= m && a[nx][ny] < a[x][y]) { L[x][y].first = min(L[x][y].first, L[nx][ny].first); L[x][y].second = max(L[x][y].second, L[nx][ny].second); } } } for(int j=1;j<=m;j++) { //cout<<j<<\\\":\\\"<<L[1][j].first<<\\\" \\\"<<L[1][j].second<<\\\"\\\\n\\\"; if(L[1][j].first<=L[1][j].second) b.push_back(L[1][j]); } // 3. 最少区间覆盖问题 // b 数组里面的这些区间最少用几个能覆盖 1~m sort(b.begin(), b.end());//其实不用排序 int l = 1, r = 0; int ans = 0; while (r < m) { for (int i = 0; i < b.size(); i++) if (b[i].first <= l && l <= b[i].second) r = max(r, b[i].second); l = r + 1; ans++; } cout << 1 << \\\"\\\\n\\\"; cout << ans << \\\"\\\\n\\\"; return 0; }\"]},\"242\":{\"h\":\"深搜+记忆化搜索+最少线段覆盖\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 500; int n, m; int a[MAXN + 5][MAXN + 5]; bool vis[MAXN + 5][MAXN + 5]; int dx[] = {0, 0, 1, -1}; int dy[] = {1, -1, 0, 0}; void dfs(int x, int y) { for (int i = 0; i < 4; i++) { int xx = x + dx[i]; int yy = y + dy[i]; if (1 <= xx && xx <= n && 1 <= yy && yy <= m && a[xx][yy] < a[x][y] && vis[xx][yy] == false) { vis[xx][yy] = true; dfs(xx, yy); } } } // 存第一行能访问到的所有区间 vector<pair<int, int>> b; pair<int, int> book[MAXN + 5][MAXN + 5]; pair<int, int> dfsdfs(int x, int y) { if (book[x][y].first != 0 || book[x][y].second != 0) return book[x][y]; int l, r; l = m + 1, r = 0; if (x == n) l = r = y; for (int i = 0; i < 4; i++) { int xx = x + dx[i]; int yy = y + dy[i]; if (1 <= xx && xx <= n && 1 <= yy && yy <= m && a[xx][yy] < a[x][y]) { pair<int, int> nxt = dfsdfs(xx, yy); l = min(l, nxt.first); r = max(r, nxt.second); } } return book[x][y] = make_pair(l, r); } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m; for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) cin >> a[i][j]; // 1. 判断是否有解，从第一行开始搜看能否覆盖下面的所有位置 for (int j = 1; j <= m; j++) if (vis[1][j] == false) { vis[1][j] = true; dfs(1, j); } int cnt = 0; // 有几个位置没有被染上 for (int j = 1; j <= m; j++) if (vis[n][j] == false) cnt++; if (cnt > 0) { cout << \\\"0\\\\n\\\"; cout << cnt << \\\"\\\\n\\\"; return 0; } // 2. 算出来第一行每个位置能覆盖哪个区间 for (int j = 1; j <= m; j++) b.push_back(dfsdfs(1, j)); // 3. 最少区间覆盖 int ans = 0; int last = 0; // 上一个覆盖到的位置，接下来要覆盖 last+1 while (last != m) { int now = last + 1; // 当前要覆盖 last+1 for (int i = 0; i < b.size(); i++) { if (b[i].first <= now && now <= b[i].second) last = max(last, b[i].second); } ans++; } cout << 1 << \\\"\\\\n\\\"; cout << ans; return 0; }\"]},\"243\":{\"h\":\"村村通\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 1000; // 并查集 int fa[MAXN + 5]; int cnt[MAXN + 5]; int findFa(int x) { if (fa[x] == x) return x; return fa[x] = findFa(fa[x]); } // --------- int n, m; int main() { while (cin >> n) { if (n == 0) break; cin >> m; // 并查集初始化 for (int i = 1; i <= n; i++) fa[i] = i; // 处理 m 组关系 for (int i = 1; i <= m; i++) { int u, v; cin >> u >> v; int faU = findFa(u); int faV = findFa(v); if (faU != faV) fa[faU] = faV; } // 计算答案 int ans = 0; for (int i = 1; i <= n; i++) if (fa[i] == i) ans++; cout << ans - 1 << \\\"\\\\n\\\"; } return 0; }\"]},\"244\":{\"h\":\"包裹快递\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n; // 包裹数 // 第 i 个包裹接收时间段，以及距离上一个站点的路程 int x[200000 + 5], y[200000 + 5], s[200000 + 5]; // 检查最大速度为 maxV 时能否送完 // 显然最优方案就是最大速度狂飙 bool check(double maxV) { double tim = 0; // 当前时间 for (int i = 1; i <= n; i++) { tim += s[i] / maxV; // 送达时间 if (tim < x[i]) tim = x[i]; if (tim > y[i]) return false; } return true; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> x[i] >> y[i] >> s[i]; for (double maxV = 0.001;; maxV += 0.001) { if (check(maxV)) { cout << fixed << setprecision(2) << maxV; return 0; } } return 0; }\",\"#include <bits/stdc++.h> using namespace std; int n; // 包裹数 // 第 i 个包裹接收时间段，以及距离上一个站点的路程 int x[200000 + 5], y[200000 + 5], s[200000 + 5]; // 检查最大速度为 maxV 时能否送完 // 显然最优方案就是最大速度狂飙 bool check(long double maxV) { long double tim = 0; // 当前时间 for (int i = 1; i <= n; i++) { tim += s[i] / maxV; // 送达时间 if (tim < x[i]) tim = x[i]; if (tim > y[i]) return false; } return true; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> x[i] >> y[i] >> s[i]; long double l = 0; long double r = 1000000000; while (r - l >= 0.0001) { long double mid = (l + r) / 2; if (check(mid)) r = mid; else l = mid; } cout << fixed << setprecision(2) << l; return 0; }\"]},\"245\":{\"h\":\"切绳子\",\"t\":[\"#include <bits/stdc++.h> #define int long long using namespace std; int n, k; double L[112345]; // 返回能不能切出来 k 段 x bool check(double x) { int cnt = 0; for (int i = 1; i <= n; i++) cnt += L[i] / x; return cnt >= k; } signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> k; for (int i = 1; i <= n; i++) cin >> L[i]; double l = 0; double r = 100000; while (r - l > 1e-4) { double mid = (l + r) / 2; if (check(mid) == true) l = mid; else r = mid; } cout << l << \\\"\\\\n\\\"; return 0; }\"]},\"246\":{\"h\":\"斯诺登的密码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; string sStr[] = { \\\"one\\\", \\\"two\\\", \\\"three\\\", \\\"four\\\", \\\"five\\\", \\\"six\\\", \\\"seven\\\", \\\"eight\\\", \\\"nine\\\", \\\"ten\\\", \\\"eleven\\\", \\\"twelve\\\", \\\"thirteen\\\", \\\"fourteen\\\", \\\"fifteen\\\", \\\"sixteen\\\", \\\"seventeen\\\", \\\"eighteen\\\", \\\"nineteen\\\", \\\"twenty\\\", \\\"a\\\", \\\"both\\\", \\\"another\\\", \\\"first\\\", \\\"second\\\", \\\"third\\\"}; int sNum[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 1, 2, 1, 1, 2, 3}; int getNum(string s) { for (int i = 0; i < s.size(); i++) if ('A' <= s[i] && s[i] <= 'Z') s[i] = s[i] - 'A' + 'a'; for (int i = 0; i < 26; i++) if (s == sStr[i]) return sNum[i]; return 0; } int a[10]; // a[1]~a[6] 六个数字 int main() { ios::sync_with_stdio(false); cin.tie(0); for (int i = 1; i <= 6; i++) { string s; cin >> s; a[i] = getNum(s); a[i] = a[i] * a[i] % 100; } sort(a + 1, a + 6 + 1); int pos = 6; for (int i = 1; i <= 6; i++) if (a[i] != 0) { pos = i; break; } cout << a[pos]; for (int i = pos + 1; i <= 6; i++) if (a[i] < 10) cout << \\\"0\\\" << a[i]; else cout << a[i]; return 0; }\"]},\"247\":{\"h\":\"数独\"},\"248\":{\"h\":\"纯暴力 0 分\",\"t\":[\"// 最暴力枚举的代码 #include <bits/stdc++.h> using namespace std; int a[10][10]; int idx[10][10] = { {}, {0, 1, 1, 1, 2, 2, 2, 3, 3, 3}, {0, 1, 1, 1, 2, 2, 2, 3, 3, 3}, {0, 1, 1, 1, 2, 2, 2, 3, 3, 3}, {0, 4, 4, 4, 5, 5, 5, 6, 6, 6}, {0, 4, 4, 4, 5, 5, 5, 6, 6, 6}, {0, 4, 4, 4, 5, 5, 5, 6, 6, 6}, {0, 7, 7, 7, 8, 8, 8, 9, 9, 9}, {0, 7, 7, 7, 8, 8, 8, 9, 9, 9}, {0, 7, 7, 7, 8, 8, 8, 9, 9, 9}}; void dfs(int nowX, int nowY) { // 九行都填完了就检查 if (nowX > 9) { // 位运算检查 for (int i = 1; i <= 9; i++) { // 第 i 行 int sta = 0; for (int j = 1; j <= 9; j++) sta = sta | (1 << (a[i][j] - 1)); if (sta != ((1 << 9) - 1)) return; // 第 i 列 sta = 0; for (int j = 1; j <= 9; j++) sta = sta | (1 << (a[j][i] - 1)); if (sta != ((1 << 9) - 1)) return; } // 检查九宫格 int sta[10]; for (int i = 1; i <= 9; i++) sta[i] = 0; for (int i = 1; i <= 9; i++) for (int j = 1; j <= 9; j++) { int nowIdx = idx[i][j]; sta[nowIdx] = sta[nowIdx] | (1 << (a[i][j] - 1)); } for (int i = 1; i <= 9; i++) if (sta[i] != ((1 << 9) - 1)) return; for (int i = 1; i <= 9; i++) { for (int j = 1; j <= 9; j++) cout << a[i][j] << \\\" \\\"; cout << \\\"\\\\n\\\"; } exit(0); } // 算出来下一个位置的行列编号 int nxtX, nxtY; nxtX = nowX; nxtY = nowY + 1; if (nxtY > 9) nxtX++, nxtY = 1; // 如果已经填了就不管了 if (a[nowX][nowY] != 0) { dfs(nxtX, nxtY); return; } // 考虑 1~9 的所有可能性 for (int i = 1; i <= 9; i++) { a[nowX][nowY] = i; dfs(nxtX, nxtY); a[nowX][nowY] = 0; } } int main() { ios::sync_with_stdio(false); cin.tie(0); for (int i = 1; i <= 9; i++) for (int j = 1; j <= 9; j++) cin >> a[i][j]; dfs(1, 1); // 从 (1,1) 的位置开始搜索 return 0; }\"]},\"249\":{\"h\":\"满分\",\"t\":[\"// 最暴力枚举的代码 #include <bits/stdc++.h> using namespace std; int a[10][10]; int idx[10][10] = { {}, {0, 1, 1, 1, 2, 2, 2, 3, 3, 3}, {0, 1, 1, 1, 2, 2, 2, 3, 3, 3}, {0, 1, 1, 1, 2, 2, 2, 3, 3, 3}, {0, 4, 4, 4, 5, 5, 5, 6, 6, 6}, {0, 4, 4, 4, 5, 5, 5, 6, 6, 6}, {0, 4, 4, 4, 5, 5, 5, 6, 6, 6}, {0, 7, 7, 7, 8, 8, 8, 9, 9, 9}, {0, 7, 7, 7, 8, 8, 8, 9, 9, 9}, {0, 7, 7, 7, 8, 8, 8, 9, 9, 9}}; bool flag1[10][10]; // 第 i 行有没有数字 j bool flag2[10][10]; // 第 i 列有没有数字 j bool flag3[10][10]; // 第 i 个九宫格有没有数字 j void dfs(int nowX, int nowY) { // 九行都填完了就检查 if (nowX > 9) { for (int i = 1; i <= 9; i++) { for (int j = 1; j <= 9; j++) cout << a[i][j] << \\\" \\\"; cout << \\\"\\\\n\\\"; } exit(0); } // 算出来下一个位置的行列编号 int nxtX, nxtY; nxtX = nowX; nxtY = nowY + 1; if (nxtY > 9) nxtX++, nxtY = 1; // 如果已经填了就不管了 if (a[nowX][nowY] != 0) { dfs(nxtX, nxtY); return; } // 考虑 1~9 的所有可能性 for (int i = 1; i <= 9; i++) { // 检查 a[nowX][nowY] 能不能填 i if (flag1[nowX][i] || flag2[nowY][i] || flag3[idx[nowX][nowY]][i]) continue; // 填 i a[nowX][nowY] = i; flag1[nowX][i] = true; flag2[nowY][i] = true; flag3[idx[nowX][nowY]][i] = true; // 做下一步 dfs(nxtX, nxtY); // 撤销影响 a[nowX][nowY] = 0; flag1[nowX][i] = false; flag2[nowY][i] = false; flag3[idx[nowX][nowY]][i] = false; } } int main() { ios::sync_with_stdio(false); cin.tie(0); for (int i = 1; i <= 9; i++) for (int j = 1; j <= 9; j++) { cin >> a[i][j]; if (a[i][j] != 0) { flag1[i][a[i][j]] = true; flag2[j][a[i][j]] = true; flag3[idx[i][j]][a[i][j]] = true; } } dfs(1, 1); // 从 (1,1) 的位置开始搜索 return 0; }\"]},\"250\":{\"h\":\"奶牛晒衣服\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n, a, b; int w[500000 + 5]; // 返回 ans 秒能否烘干所有衣服 bool check(int ans) { // 算“所有衣服需要的烘干机时间”之和 int sum = 0; for (int i = 1; i <= n; i++) { // ans*a：ans 秒能自然烘干的量 // w[i]-ans*a：ans 秒还需要烘的量 // 上取整 (w[i]-ans*a)/b：需要占用烘干机的时间 if (w[i] - ans * a < 0) continue; sum += (w[i] - ans * a) / b; if ((w[i] - ans * a) % b != 0) sum++; } return sum <= ans; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> a >> b; for (int i = 1; i <= n; i++) cin >> w[i]; for (int ans = 1;; ans++) if (check(ans)) { cout << ans; break; } return 0; }\",\"可以进一步优化为先考虑大的\",\"#include <bits/stdc++.h> using namespace std; int n, a, b; int w[500000 + 5]; // 返回 ans 秒能否烘干所有衣服 bool check(int ans) { // 算“所有衣服需要的烘干机时间”之和 int sum = 0; for (int i = 1; i <= n; i++) { // ans*a：ans 秒能自然烘干的量 // w[i]-ans*a：ans 秒还需要烘的量 // 上取整 (w[i]-ans*a)/b：需要占用烘干机的时间 if (w[i] - ans * a < 0) continue; sum += (w[i] - ans * a) / b; if ((w[i] - ans * a) % b != 0) sum++; if (sum > ans) return false; } return true; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> a >> b; for (int i = 1; i <= n; i++) cin >> w[i]; for (int ans = 1;; ans++) if (check(ans)) { cout << ans; break; } return 0; }\",\"略\"]},\"251\":{\"h\":\"团伙\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 1000; int n; // n 个人 int m; // m 组关系 // 并查集 int fa[MAXN * 2 + 5]; int cnt[MAXN * 2 + 5]; int findFa(int x) { if (fa[x] == x) return x; return fa[x] = findFa(fa[x]); } int main() { // n 个人 cin >> n; // 并查集初始化 for (int i = 1; i <= n; i++) { fa[i] = i; cnt[i] = 1; // i+n 为 i 的敌人对应的集合 fa[i + n] = i + n; cnt[i + n] = 0; } // m 组关系 cin >> m; for (int i = 1; i <= m; i++) { char op; int p, q; cin >> op >> p >> q; if (op == 'E') { // 两个人之间为敌人 // 合并 p ~ q+n int fa1 = findFa(p); int fa2 = findFa(q + n); if (fa1 != fa2) { fa[fa1] = fa2; cnt[fa2] += cnt[fa1]; } // 合并 q ~ p+n fa1 = findFa(q); fa2 = findFa(p + n); if (fa1 != fa2) { fa[fa1] = fa2; cnt[fa2] += cnt[fa1]; } } if (op == 'F') { // 两个人之间为朋友 // 合并 p ~ q int fa1 = findFa(p); int fa2 = findFa(q); if (fa1 != fa2) { fa[fa1] = fa2; cnt[fa2] += cnt[fa1]; } } } int ans = 0; for (int i = 1; i <= 2 * n; i++) if (fa[i] == i && cnt[i] > 0) ans++; cout << ans; return 0; }\"]},\"252\":{\"h\":\"[SCOI2005]互不侵犯\"},\"253\":{\"h\":\"50 分、基础暴力搜索\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n, k; int ans; bool vis[10][10]; int dx[] = {0, 0, 1, -1, 1, -1, 1, -1}; int dy[] = {1, -1, 0, 0, 1, 1, -1, -1}; void dfs(int x, int y, int cnt) { if (y == n + 1) { x++; y = 1; } if (cnt == k) { for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) { for (int k = 0; k < 8; k++) { int ii = i + dx[k]; int jj = j + dy[k]; if (vis[ii][jj] && vis[i][j]) return; } } ans++; return; } if(x==n+1) return ; vis[x][y] = true; dfs(x, y + 1, cnt + 1); vis[x][y] = false; dfs(x, y + 1, cnt); } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> k; ans = 0; dfs(1, 1, 0); cout << ans; return 0; }\"]},\"254\":{\"h\":\"70 分、基础剪枝\"},\"255\":{\"h\":\"写法 1\",\"t\":[\"每次放国王之前判断一下。\",\"#include <bits/stdc++.h> using namespace std; int n, k; int ans; bool vis[10][10]; int dx[] = {0, 0, 1, -1, 1, -1, 1, -1}; int dy[] = {1, -1, 0, 0, 1, 1, -1, -1}; void dfs(int x, int y, int cnt) { if (y == n + 1) { x++; y = 1; } if (cnt == k) { ans++; return; } if (x == n + 1) return; if (!vis[x - 1][y - 1] && !vis[x - 1][y] && !vis[x - 1][y + 1] && !vis[x][y - 1]) { vis[x][y] = true; dfs(x, y + 1, cnt + 1); } vis[x][y] = false; dfs(x, y + 1, cnt); } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> k; ans = 0; dfs(1, 1, 0); cout << ans; return 0; }\"]},\"256\":{\"h\":\"写法 2\",\"t\":[\"每次放完后把周边改为不能放，注意不能用 bool 类型标记\",\"#include <bits/stdc++.h> using namespace std; int n, k; int ans; int vis[11][11]; int dx[] = {0, 1, 1, 1}; int dy[] = {1, -1, 0, 1}; void dfs(int x, int y, int cnt) { if (y == n + 1) { x++; y = 1; } if (cnt == k) { ans++; return; } if (x == n + 1) return; if (vis[x][y] == 0) { for (int i = 0; i < 4; i++) { int xx = x + dx[i]; int yy = y + dy[i]; vis[xx][yy]++; } dfs(x, y + 1, cnt + 1); for (int i = 0; i < 4; i++) { int xx = x + dx[i]; int yy = y + dy[i]; vis[xx][yy]--; } } if (cnt + (n - x) * n + (n - y) >= k) { dfs(x, y + 1, cnt); } } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> k; ans = 0; dfs(1, 1, 0); cout << ans; return 0; }\"]},\"257\":{\"h\":\"100 分、状压 DP\",\"t\":[\"#include <bits/stdc++.h> #define int long long using namespace std; int n, k, ans; vector<int> ok; // 存所有合法状态 vector<int> cnt1; // ok[i] 一共有 cnt1[i] 个 1 int dp[10][90][1 << 9]; signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> k; // 预处理所有单行的合法状态 for (int i = 0; i <= (1 << n) - 1; i++) if (!(i & (i >> 1))) { ok.push_back(i); int temp = 0; for (int j = 0; j <= n - 1; j++) if (i & (1 << j)) temp++; cnt1.push_back(temp); } // dp dp[0][0][0] = 1; for (int i = 1; i <= n; i++) for (int j = 0; j <= min(k, n * i); j++) for (int k = 0; k < ok.size(); k++) { int sta = ok[k]; int cnt = cnt1[k]; if (cnt > j) continue; for (int pre : ok) { if ((sta & pre) || (sta & (pre << 1)) || (sta & (pre >> 1))) continue; dp[i][j][sta] += dp[i - 1][j - cnt][pre]; } } // ans ans = 0; for (int sta : ok) ans += dp[n][k][sta]; cout << ans; return 0; }\"]},\"258\":{\"h\":\"逆序对\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n; int a[500000 + 5]; int temp[500000 + 5]; // 树状数组：维护 cnt[i] 存 i 出现了几次 int t[500000 + 5]; int lowbit(int x) { return x & -x; } void update(int x, int y) { for (int i = x; i <= n; i += lowbit(i)) t[i] += y; } int query(int x) { int res = 0; for (int i = x; i >= 1; i -= lowbit(i)) res += t[i]; return res; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; // 离散化 for (int i = 1; i <= n; i++) temp[i] = a[i]; sort(temp + 1, temp + n + 1); int tot = unique(temp + 1, temp + n + 1) - temp - 1; for (int i = 1; i <= n; i++) a[i] = lower_bound(temp + 1, temp + tot + 1, a[i]) - temp; // 逆序对 long long ans = 0; for (int i = 1; i <= n; i++) { // 检查多少组 a[<i] ~ a[i] 逆序对 // 检查 a[1]~a[i-1] 有几个大于 a[i] 的数 // 检查 cnt[a[i]+1]~cnt[n] 和为多少 ans += query(n) - query(a[i]); update(a[i], 1); } cout << ans; return 0; }\"]},\"259\":{\"h\":\"[USACO3.3] 亚瑟王的宫殿\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int r, c; int kingX, kingY; int tot; // 骑士数量 int knightX[40 * 26 + 5], knightY[40 * 26 + 5]; // 骑士坐标 // 任意两点间骑士最短路 int dis[40 + 5][26 + 5][40 + 5][26 + 5]; queue<pair<int, int>> q; int dx[] = {2, 2, 1, 1, -2, -2, -1, -1}; int dy[] = {1, -1, 2, -2, 1, -1, 2, -2}; void bfs(int x, int y) { // 数组初始化 for (int i = 1; i <= r; i++) for (int j = 1; j <= c; j++) dis[x][y][i][j] = -1; // 起点入队 q.push(make_pair(x, y)); dis[x][y][x][y] = 0; // 广搜 while (!q.empty()) { pair<int, int> now = q.front(); q.pop(); for (int i = 0; i < 8; i++) { int nx = now.first + dx[i]; int ny = now.second + dy[i]; if (1 <= nx && nx <= r && 1 <= ny && ny <= c && dis[x][y][nx][ny] == -1) { dis[x][y][nx][ny] = dis[x][y][now.first][now.second] + 1; q.push(make_pair(nx, ny)); } } } } int main() { ios::sync_with_stdio(false); cin.tie(0); // 输入 cin >> r >> c; char tempC; int temp; cin >> tempC >> temp; kingY = tempC - 'A' + 1; kingX = temp; while (cin >> tempC >> temp) { tot++; knightY[tot] = tempC - 'A' + 1; knightX[tot] = temp; } // 计算每个点到其它点的距离 for (int i = 1; i <= r; i++) for (int j = 1; j <= c; j++) bfs(i, j); // 枚举 int ans = 1000000000; for (int i = 1; i <= r; i++) for (int j = 1; j <= c; j++) { // 在 (i,j) 会合 // 方案 1，所有人和王自己去 bool flag = true; // 是否所有骑士都能到 int len1 = 0; // 所有骑士到汇合点的路程 for (int id = 1; id <= tot; id++) { if (dis[knightX[id]][knightY[id]][i][j] == -1) { flag = false; break; } len1 += dis[knightX[id]][knightY[id]][i][j]; } if (!flag) continue; // 王到汇合点的路程 int len2 = abs(kingX - i) + abs(kingY - j); ans = min(ans, len1 + len2); // 方案 2，找个骑士去接王 int xl = max(kingX - 2, 1), xr = min(kingX + 2, r); int yl = max(kingY - 2, 1), yr = min(kingY + 2, c); for (int x = xl; x <= xr; x++) for (int y = yl; y <= yr; y++) { // 检查 x,y 能不能到 i,j if (dis[x][y][i][j] == -1) continue; // 在 (x,y) 位置接王 // 枚举哪个骑士接 for (int id = 1; id <= tot; id++) { // 检查这个骑士能不能到 (x,y) if (dis[knightX[id]][knightY[id]][x][y] == -1) continue; int now = 0; // len1 去掉第 id 个骑士的贡献 now += len1 - dis[knightX[id]][knightY[id]][i][j]; // 第 id 个骑士和王去接王点 now += dis[knightX[id]][knightY[id]][x][y]; now += abs(kingX - x) + abs(kingY - y); // 从接王点骑士去汇合点 now += dis[x][y][i][j]; // 尝试更新答案 ans = min(ans, now); } } } cout << ans; return 0; }\"]},\"260\":{\"h\":\"[NOIP2014 提高组] 飞扬的小鸟\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 10005; const int MAXM = 1005; const int MAXK = 10005; int n, m, k; //宽、高、管道数量 int up[MAXN], down[MAXN]; //每个位置上升与下降的高度 int top[MAXN], bottom[MAXN]; //横坐标为i时的上管道底端与下管道顶端 int cnt[MAXN]; //当前位置及左边有多少个管子 int dp[MAXN][2 * MAXM]; //到每个位置的最小跳跃步数 int main() { ios::sync_with_stdio(false); cin.tie(0); //输入 cin >> n >> m >> k; for (int i = 0; i < n; i++) { cin >> up[i] >> down[i]; top[i] = m + 1; bottom[i] = 0; } top[n] = m + 1; bottom[n] = 0; for (int i = 1; i <= k; i++) { int x, b, t; cin >> x >> b >> t; cnt[x]++; bottom[x] = b; top[x] = t; } //work memset(dp, 0x3f, sizeof(dp)); for (int i = 1; i <= m; i++) dp[0][i] = 0; bool flag = false; int R = 0; int ans = 0x3f3f3f3f; for (int i = 1; i <= n; i++) { cnt[i] += cnt[i - 1]; //上升跳到(i,j)的位置 for (int j = 1 + up[i - 1]; j <= m + up[i - 1]; j++) dp[i][j] = min(dp[i - 1][j - up[i - 1]] + 1, dp[i][j - up[i - 1]] + 1); for (int j = m + 1; j <= m + up[i - 1]; j++) dp[i][m] = min(dp[i][m], dp[i][j]); //下降到(i,j)的位置 for (int j = 1; j <= m - down[i - 1]; j++) dp[i][j] = min(dp[i][j], dp[i - 1][j + down[i - 1]]); //去掉不合理状态并合并 for (int j = 1; j <= m; j++) { if (j >= top[i] || j <= bottom[i] || dp[i][j] > 0x3f3f3f3f) dp[i][j] = 0x3f3f3f3f; if (dp[i][j] != 0x3f3f3f3f) { R = max(R, cnt[i]); if (i == n) { flag = true; ans = min(ans, dp[i][j]); } } } } if (flag) cout << \\\"1\\\\n\\\" << ans << \\\"\\\\n\\\"; else cout << \\\"0\\\\n\\\" << R << \\\"\\\\n\\\"; return 0; }\"]},\"261\":{\"h\":\"口算练习题\"},\"262\":{\"h\":\"1. 无脑 if\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int cal(int x) { bool flag = false; if (x < 0) { flag = true; x = -x; } if (0 <= x && x <= 9) return 1 + flag; else if (10 <= x && x <= 99) return 2 + flag; else if (100 <= x && x <= 999) return 3 + flag; else if (1000 <= x && x <= 9999) return 4 + flag; else if (10000 <= x && x <= 99999) return 5 + flag; else if (100000 <= x && x <= 999999) return 6 + flag; else if (1000000 <= x && x <= 9999999) return 7 + flag; else if (10000000 <= x && x <= 99999999) return 8 + flag; else if (100000000 <= x && x <= 999999999) return 9 + flag; } void f(char op, int a, int b) { int c; if (op == 'a') { c = a + b; op = '+'; } else if (op == 'b') { c = a - b; op = '-'; } else if (op == 'c') { c = a * b; op = '*'; } cout << a << op << b << \\\"=\\\" << c << \\\"\\\\n\\\"; cout << cal(a) + cal(b) + cal(c) + 2 << \\\"\\\\n\\\"; } int main() { int n; cin >> n; char op; // 运算符 int a, b; // 两个运算数 string temp; // 临时字符串 for (int i = 1; i <= n; i++) { cin >> temp; if ('0' <= temp[0] && temp[0] <= '9') { a = 0; for (int j = 0; j < temp.size(); j++) a = a * 10 + (temp[j] - '0'); cin >> b; } else { op = temp[0]; cin >> a; cin >> b; } f(op, a, b); } return 0; }\"]},\"263\":{\"h\":\"2. 循环代替多层 if\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int cal(int x) { bool flag = false; if (x < 0) { flag = true; x = -x; } for (int i = 10, j = 1;; i *= 10, j++) if (x < i) return j + flag; } void f(char op, int a, int b) { int c; if (op == 'a') { c = a + b; op = '+'; } else if (op == 'b') { c = a - b; op = '-'; } else if (op == 'c') { c = a * b; op = '*'; } cout << a << op << b << \\\"=\\\" << c << \\\"\\\\n\\\"; cout << cal(a) + cal(b) + cal(c) + 2 << \\\"\\\\n\\\"; } int main() { int n; cin >> n; char op; // 运算符 int a, b; // 两个运算数 string temp; // 临时字符串 for (int i = 1; i <= n; i++) { cin >> temp; if ('0' <= temp[0] && temp[0] <= '9') { a = 0; for (int j = 0; j < temp.size(); j++) a = a * 10 + (temp[j] - '0'); cin >> b; } else { op = temp[0]; cin >> a; cin >> b; } f(op, a, b); } return 0; }\"]},\"264\":{\"h\":\"3. 数位分解计算位数（注意特判 0）\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int cal(int x) { if (x == 0) return 1; int res = 0; if (x < 0) { res = 1; x = -x; } while (x > 0) { res++; x /= 10; } return res; } void f(char op, int a, int b) { int c; if (op == 'a') { c = a + b; op = '+'; } else if (op == 'b') { c = a - b; op = '-'; } else if (op == 'c') { c = a * b; op = '*'; } cout << a << op << b << \\\"=\\\" << c << \\\"\\\\n\\\"; cout << cal(a) + cal(b) + cal(c) + 2 << \\\"\\\\n\\\"; } int main() { int n; cin >> n; char op; // 运算符 int a, b; // 两个运算数 string temp; // 临时字符串 for (int i = 1; i <= n; i++) { cin >> temp; if ('0' <= temp[0] && temp[0] <= '9') { a = 0; for (int j = 0; j < temp.size(); j++) a = a * 10 + (temp[j] - '0'); cin >> b; } else { op = temp[0]; cin >> a; cin >> b; } f(op, a, b); } return 0; }\"]},\"265\":{\"h\":\"4. 利用字符串流\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n; string s; void f(char c, int a, int b) { stringstream ss; if (c == 'a') ss << a << \\\"+\\\" << b << \\\"=\\\" << a + b << \\\"\\\\n\\\"; if (c == 'b') ss << a << \\\"-\\\" << b << \\\"=\\\" << a - b << \\\"\\\\n\\\"; if (c == 'c') ss << a << \\\"*\\\" << b << \\\"=\\\" << a * b << \\\"\\\\n\\\"; string s; getline(ss, s); cout << s << \\\"\\\\n\\\"; cout << s.length() << \\\"\\\\n\\\"; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; getline(cin, s); char c; int a, b; while (n--) { getline(cin, s); stringstream ss; ss << s; if ('0' <= s[0] && s[0] <= '9') { ss >> a >> b; f(c, a, b); } else { ss >> c >> a >> b; f(c, a, b); } } return 0; }\"]},\"266\":{\"h\":\"[SDOI2009] HH的项链\",\"t\":[\"#include <bits/stdc++.h> #define int long long using namespace std; const int MAXN = 1000000; const int MAXM = 1000000; const int MAXAI = 1000000; int n, m; int a[MAXN + 5]; // 存每个位置为右端点的询问<询问的左端点,询问的编号> vector<pair<int, int>> q[MAXN + 5]; int ans[MAXM + 5]; // pos[i]：i这个种类最新出现的位置 int pos[MAXAI + 5]; // 树状数组 int t[MAXN + 5], treeN; int lowbit(int x) { return x & (-x); } // 第x个数加k void update(int x, int k) { for (int i = x; i <= treeN; i += lowbit(i)) t[i] += k; } // 返回前x个数的和 int query(int x) { int res = 0; for (int i = x; i >= 1; i -= lowbit(i)) res += t[i]; return res; } signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) { cin >> a[i]; pos[a[i]] = -1; } cin >> m; for (int i = 1; i <= m; i++) { int l, r; cin >> l >> r; ans[i] = 0; q[r].push_back(make_pair(l, i)); } treeN = n; for (int r = 1; r <= n; r++) { if (pos[a[r]] != -1) update(pos[a[r]], -1); pos[a[r]] = r; update(r, 1); for (int i = 0; i < q[r].size(); i++) { int l = q[r][i].first; int id = q[r][i].second; ans[id] = query(r) - query(l - 1); } } for (int i = 1; i <= m; i++) cout << ans[i] << \\\"\\\\n\\\"; return 0; }\"]},\"267\":{\"h\":\"[HNOI2006] 马步距离\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int a[40][40]; queue<pair<int, int>> q; int dx[] = {2, 2, 1, 1, -2, -2, -1, -1}; int dy[] = {1, -1, 2, -2, 1, -1, 2, -2}; int main() { ios::sync_with_stdio(false); cin.tie(0); for (int i = 1; i <= 40; i++) for (int j = 1; j <= 40; j++) a[i][j] = -1; q.push(make_pair(20, 20)); a[20][20] = 0; while (!q.empty()) { pair<int, int> now = q.front(); q.pop(); for (int i = 0; i < 8; i++) { int nx = now.first + dx[i]; int ny = now.second + dy[i]; if (1 <= nx && nx <= 40 && 1 <= ny && ny <= 40 && a[nx][ny] == -1) { a[nx][ny] = a[now.first][now.second] + 1; q.push(make_pair(nx, ny)); } } } for (int i = 20; i <= 30; i++) { for (int j = 20; j <= 30; j++) cout << a[i][j] << \\\",\\\"; cout << \\\"\\\\n\\\"; } return 0; } /* 0,3,2,3,2,3,4,5,4,5,6, 3,2,1,2,3,4,3,4,5,6,5, 2,1,4,3,2,3,4,5,4,5,6, 3,2,3,2,3,4,3,4,5,6,5, 2,3,2,3,4,3,4,5,4,5,6, 3,4,3,4,3,4,5,4,5,6,5, 4,3,4,3,4,5,4,5,6,5,6, 5,4,5,4,5,4,5,6,5,6,7, 4,5,4,5,4,5,6,5,6,7,6, 5,6,5,6,5,6,5,6,7,6,7, 6,5,6,5,6,5,6,7,6,7,8 */\",\"#include <bits/stdc++.h> using namespace std; int len[11][11] = { 0, 3, 2, 3, 2, 3, 4, 5, 4, 5, 6, 3, 2, 1, 2, 3, 4, 3, 4, 5, 6, 5, 2, 1, 4, 3, 2, 3, 4, 5, 4, 5, 6, 3, 2, 3, 2, 3, 4, 3, 4, 5, 6, 5, 2, 3, 2, 3, 4, 3, 4, 5, 4, 5, 6, 3, 4, 3, 4, 3, 4, 5, 4, 5, 6, 5, 4, 3, 4, 3, 4, 5, 4, 5, 6, 5, 6, 5, 4, 5, 4, 5, 4, 5, 6, 5, 6, 7, 4, 5, 4, 5, 4, 5, 6, 5, 6, 7, 6, 5, 6, 5, 6, 5, 6, 5, 6, 7, 6, 7, 6, 5, 6, 5, 6, 5, 6, 7, 6, 7, 8}; int main() { ios::sync_with_stdio(false); cin.tie(0); int a, b, aa, bb; cin >> a >> b >> aa >> bb; // 算出要走的距离 +a +b，保证 a>=b a = abs(a - aa); b = abs(b - bb); if (a < b) swap(a, b); int ans = 0; // 贪心通过 +2 +1 完成 +a +b while (a >= 10 || b >= 10) { ans++; a = abs(a - 2); b = abs(b - 1); if (a < b) swap(a, b); } cout << ans + len[a][b]; return 0; }\"]},\"268\":{\"h\":\"病毒检测\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 1123456; int n, ans; string s; string p; queue<int> qt; // 在 tr 上走到的位置 queue<int> qp; // 在 p 上走到的位置 int c2i[256]; bitset<1005> vis[MAXN]; struct Trie { int tr[MAXN][5], tot; //根节点为 0 int cnt[MAXN]; void insert(string &s) { int u = 0; for (int i = 0; i < s.length(); i++) { if (!tr[u][c2i[s[i]]]) tr[u][c2i[s[i]]] = ++tot; u = tr[u][c2i[s[i]]]; } cnt[u]++; } } tr; int main() { ios::sync_with_stdio(false); cin.tie(0); c2i['A'] = 0, c2i['C'] = 1, c2i['T'] = 2, c2i['G'] = 3; cin >> p; cin >> n; for (int i = 1; i <= n; i++) { cin >> s; tr.insert(s); } /* for (int i = 0; i <= tr.tot; i++) { cout << i << \\\" \\\" << tr.cnt[i] << \\\":\\\" << tr.tr[i]['A' - 'A'] << \\\" \\\" << tr.tr[i]['C' - 'A'] << \\\" \\\" << tr.tr[i]['T' - 'A'] << \\\" \\\" << tr.tr[i]['G' - 'A'] << \\\"\\\\n\\\"; } */ qt.push(0); qp.push(0); while (!qt.empty()) { int nowT = qt.front(); qt.pop(); int nowP = qp.front(); qp.pop(); if (nowP == p.length()) { ans += tr.cnt[nowT]; tr.cnt[nowT] = 0; // cout << nowT << \\\" : \\\" << ans << \\\"\\\\n\\\"; continue; } if (p[nowP] == 'A' || p[nowP] == 'C' || p[nowP] == 'T' || p[nowP] == 'G') { if (tr.tr[nowT][c2i[p[nowP]]] && !vis[tr.tr[nowT][c2i[p[nowP]]]][nowP + 1]) { vis[tr.tr[nowT][c2i[p[nowP]]]][nowP + 1] = true; qt.push(tr.tr[nowT][c2i[p[nowP]]]); qp.push(nowP + 1); } } else if (p[nowP] == '?') { for (int i = 0; i < 4; i++) if (tr.tr[nowT][i] && !vis[tr.tr[nowT][i]][nowP + 1]) { vis[tr.tr[nowT][i]][nowP + 1] = true; qt.push(tr.tr[nowT][i]); qp.push(nowP + 1); } } else if (p[nowP] == '*') { for (int i = 0; i < 4; i++) if (tr.tr[nowT][i] && !vis[tr.tr[nowT][i]][nowP]) { vis[tr.tr[nowT][i]][nowP] = true; qt.push(tr.tr[nowT][i]); qp.push(nowP); } if (p[nowP] == '*' && !vis[nowT][nowP + 1]) { vis[nowT][nowP + 1] = true; qt.push(nowT); qp.push(nowP + 1); } } } cout << n - ans << \\\"\\\\n\\\"; return 0; }\"]},\"269\":{\"h\":\"于是他错误的点名开始了\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int N = 500010; //长度*单词数：最坏节点个数 string s; int n, m, ch[N][26], tag[N], tot = 1; int main() { cin >> n; for (int i = 1; i <= n; ++i) { cin >> s; int u = 1; //1号节点: '' for (int j = 0; j < s.length(); j++) { int c = s[j] - 'a'; if (!ch[u][c]) ch[u][c] = ++tot; u = ch[u][c]; } tag[u] = 1; } cin >> m; while (m--) { cin >> s; int u = 1; for (int j = 0; j < s.length(); ++j) { int c = s[j] - 'a'; u = ch[u][c]; if (!u) break; } if (tag[u] == 1) { tag[u] = 2; cout << \\\"OK\\\\n\\\"; } else if (tag[u] == 2) cout << \\\"REPEAT\\\\n\\\"; else cout << \\\"WRONG\\\\n\\\"; } return 0; }\"]},\"270\":{\"h\":\"[ZJOI2010] 数字计数\",\"t\":[\"#include <bits/stdc++.h> #define int long long using namespace std; int L, R; int dp[15][10]; // limit 和 zero 为假时记忆化搜索 dp[pos][dig] int d[15], dlen; // d[dlen]~d[1] int num[15]; // num[i]: d[i]~d[1] 构成的数 int p10[15]; // p10[i]: 10^i // 做到了第 pos 位，是否顶到了上限，之前是否都填的 0，待统计得数字 int dfs(int pos, bool limit, bool zero, int dig) { if (pos == 0) return 0; // 算过了没贴边的结果的话就直接返回 if (!limit && !zero && dp[pos][dig] != -1) return dp[pos][dig]; // 当前这一位的上限 int up = limit ? d[pos] : 9; int sum = 0; // 记录方案数 for (int now = 0; now <= up; now++) // 枚举当前这一位 { if (zero && now == 0) { if (pos != 1) sum += dfs(pos - 1, limit && now == d[pos], zero && now == 0, dig); else sum += (dig == 0); } else if (now == dig && limit && now == d[pos]) sum += num[pos - 1] + 1 + dfs(pos - 1, limit && now == d[pos], zero && now == 0, dig); else if (now == dig) sum += p10[pos - 1] + dfs(pos - 1, limit && now == d[pos], zero && now == 0, dig); else sum += dfs(pos - 1, limit && now == d[pos], zero && now == 0, dig); } // 如果前面没贴边.并且没有前导0，就记忆化一下 if (!limit && !zero) dp[pos][dig] = sum; return sum; } // 计算 0~x 有多少个数字 dig int cal(int x, int dig) { if (x == 0) return dig == 0; // d[] dlen = 0; for (int i = x; i != 0; i /= 10) d[++dlen] = i % 10; // num[] num[0] = 0; for (int i = 1; i <= dlen; i++) num[i] = num[i - 1] + d[i] * p10[i - 1]; // dfs return dfs(dlen, true, true, dig); } signed main() { ios::sync_with_stdio(false); cin.tie(0); p10[0] = 1; for (int i = 1; i <= 12; i++) p10[i] = p10[i - 1] * 10; cin >> L >> R; memset(dp, -1, sizeof(dp)); for (int i = 0; i <= 9; i++) cout << cal(R, i) - cal(L - 1, i) << \\\" \\\"; cout << \\\"\\\\n\\\"; return 0; }\"]},\"271\":{\"h\":\"神奇的幻方\",\"t\":[\"略\"]},\"272\":{\"h\":\"递归写法\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n; int a[40][40]; void f(int x, int y, int num) { if (num > n * n) return; a[x][y] = num; if (x == 1 && y != n) f(n, y + 1, num + 1); else if (y == n && x != 1) f(x - 1, 1, num + 1); else if (x == 1 && y == n) f(x + 1, y, num + 1); else { if (a[x - 1][y + 1] == 0) f(x - 1, y + 1, num + 1); else f(x + 1, y, num + 1); } } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; f(1, n / 2 + 1, 1); for (int i = 1; i <= n; i++) { for (int j = 1; j <= n; j++) cout << a[i][j] << \\\" \\\"; cout << \\\"\\\\n\\\"; } return 0; }\"]},\"273\":{\"h\":\"[SCOI2009] windy 数\",\"t\":[\"#include <bits/stdc++.h> using namespace std; long long n, m; int len, d[20]; long long dp[20][10]; //pre、iszero：避开差为2的限制 //limit：当前位能否为0~9，如果limit为真，表示当前位最多只能是d[pos] long long dfs(int pos, int pre, bool iszero, bool limit) { if (pos == 0) return 1; if (!iszero && !limit && dp[pos][pre] != -1) return dp[pos][pre]; int maxD = limit ? d[pos] : 9; long long ans = 0; for (int now = 0; now <= maxD; now++) { if (iszero) ans += dfs(pos - 1, now, iszero && now == 0, limit && now == d[pos]); else { if (abs(now - pre) < 2) continue; ans += dfs(pos - 1, now, iszero && now == 0, limit && now == d[pos]); } } if (!iszero && !limit) dp[pos][pre] = ans; return ans; } long long cal(long long x) { len = 0; while (x > 0) d[++len] = x % 10, x /= 10; memset(dp, -1, sizeof(dp)); return dfs(len, 0, true, true); } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m; cout << cal(m) - cal(n - 1) << endl; return 0; }\"]},\"274\":{\"h\":\"[NOIP2015 普及组] 求和\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MODNUM = 10007; int n, m; int number[100005]; int color[100005]; int sumOdd[100005]; vector<int> odd[100005]; int sumEven[100005]; vector<int> even[100005]; signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m; for (int i = 1; i <= n; i++) { cin >> number[i]; number[i] %= MODNUM; } for (int i = 1; i <= n; i++) { cin >> color[i]; if (i % 2) odd[color[i]].push_back(i), sumOdd[color[i]] = (sumOdd[color[i]] + number[i]) % MODNUM; else even[color[i]].push_back(i), sumEven[color[i]] = (sumEven[color[i]] + number[i]) % MODNUM; } int ans = 0; for (int i = 1; i <= m; i++) { for (int j = 0; j < odd[i].size(); j++) { int x = odd[i][j]; ans = (ans + x * (sumOdd[i] - number[x] + MODNUM) % MODNUM) % MODNUM; ans = (ans + (odd[i].size() - 1) * x % MODNUM * number[x] % MODNUM) % MODNUM; } for (int j = 0; j < even[i].size(); j++) { int x = even[i][j]; ans = (ans + x * (sumEven[i] - number[x] + MODNUM) % MODNUM) % MODNUM; ans = (ans + (even[i].size() - 1) * x % MODNUM * number[x] % MODNUM) % MODNUM; } } cout << ans << \\\"\\\\n\\\"; return 0; }\"]},\"275\":{\"h\":\"[USACO07MAR] Face The Right Way G\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n; string s, t; int check(int k) { int cnt = 0; for (int i = 0; i + k - 1 < t.size(); i++) if (t[i] == 'B') { cnt++; for (int j = i; j <= i + k - 1; j++) { if (t[j] == 'B') t[j] = 'F'; else t[j] = 'B'; } } for (int i = (int)t.size() - k; i < t.size(); i++) if (t[i] == 'B') return -1; return cnt; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; s = \\\"\\\"; for (int i = 1; i <= n; i++) { char x; cin >> x; s += x; } int ansCnt = n, ansK = 1; for (int k = 1; k <= n; k++) { t = s; int cnt = check(k); if (cnt != -1 && cnt < ansCnt) { ansCnt = cnt; ansK = k; } } cout << ansK << \\\" \\\" << ansCnt << \\\"\\\\n\\\"; return 0; }\",\"#include <bits/stdc++.h> using namespace std; int n; string s, t; int d[5005]; int check(int k) { for (int i = 0; i <= n; i++) d[i] = 0; int cnt = 0; int now = 0; // 差分之和 int i; for (i = 0; i + k - 1 < t.size(); i++) { now += d[i]; if (t[i] == 'B' && now % 2 == 0 || t[i] == 'F' && now % 2 == 1) { cnt++; now++; d[i + k]--; } } for (; i < t.size(); i++) { now += d[i]; if (t[i] == 'B' && now % 2 == 0 || t[i] == 'F' && now % 2 == 1) return -1; } return cnt; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; s = \\\"\\\"; for (int i = 1; i <= n; i++) { char x; cin >> x; s += x; } int ansCnt = n, ansK = 1; for (int k = 1; k <= n; k++) { t = s; int cnt = check(k); if (cnt != -1 && cnt < ansCnt) { ansCnt = cnt; ansK = k; } } cout << ansK << \\\" \\\" << ansCnt << \\\"\\\\n\\\"; return 0; }\"]},\"276\":{\"h\":\"[USACO09OCT] Invasion of the Milkweed G\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n, m, mx, my; char f[10005][105][105]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> m >> n >> my >> mx; for (int i = n; i >= 1; i--) for (int j = 1; j <= m; j++) cin >> f[0][i][j]; f[0][mx][my] = 'M'; // 初始情况检查 bool flag = true; for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) if (f[0][i][j] == '.') flag = false; if (flag) { cout << 0 << \\\"\\\\n\\\"; return 0; } for (int day = 1;; day++) { bool flag = true; // 是否搞定了 for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) { if (f[day - 1][i][j] == '*') { f[day][i][j] = '*'; continue; } if (f[day - 1][i - 1][j - 1] == 'M' || f[day - 1][i - 1][j] == 'M' || f[day - 1][i - 1][j + 1] == 'M' || f[day - 1][i][j - 1] == 'M' || f[day - 1][i][j] == 'M' || f[day - 1][i][j + 1] == 'M' || f[day - 1][i + 1][j - 1] == 'M' || f[day - 1][i + 1][j] == 'M' || f[day - 1][i + 1][j + 1] == 'M') { f[day][i][j] = 'M'; } else { f[day][i][j] = '.'; flag = false; } } /* cout << day << \\\"\\\\n\\\"; for (int i = 1; i <= n; i++) { for (int j = 1; j <= m; j++) cout << f[day][i][j]; cout << \\\"\\\\n\\\"; } */ if (flag) { cout << day << \\\"\\\\n\\\"; return 0; } } return 0; }\",\"#include <bits/stdc++.h> using namespace std; int n, m, mx, my; char f[105][105]; int dis[105][105]; queue<pair<int, int>> q; int dx[] = {-1, -1, -1, 0, 0, 1, 1, 1}; int dy[] = {-1, 0, 1, -1, 1, -1, 0, 1}; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> m >> n >> my >> mx; for (int i = n; i >= 1; i--) for (int j = 1; j <= m; j++) cin >> f[i][j]; f[mx][my] = 'M'; q.push(make_pair(mx, my)); dis[mx][my] = 0; while (!q.empty()) { pair<int, int> now = q.front(); q.pop(); for (int i = 0; i < 8; i++) { int nxtX = now.first + dx[i]; int nxtY = now.second + dy[i]; if (f[nxtX][nxtY] == '.') { q.push(make_pair(nxtX, nxtY)); f[nxtX][nxtY] = 'M'; dis[nxtX][nxtY] = dis[now.first][now.second] + 1; } } } int ans = 0; for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) ans = max(ans, dis[i][j]); cout << ans; return 0; }\"]},\"277\":{\"h\":\"[USACO12MAR] Cows in a Skyscraper G\"},\"278\":{\"h\":\"暴力搜索 32 分\",\"t\":[\"枚举每个物品放到了哪组\",\"#include <bits/stdc++.h> using namespace std; int n, w; int x[18 + 5]; int v[18 + 5]; int ans; // 当前物品，已有分组组数 void dfs(int pos, int cnt) { if (pos == n + 1) { ans = min(ans, cnt); return; } for (int i = 1; i <= cnt; i++) { if (v[i] + x[pos] <= w) { v[i] += x[pos]; dfs(pos + 1, cnt); v[i] -= x[pos]; } } v[cnt + 1] = x[pos]; dfs(pos + 1, cnt + 1); v[cnt + 1] = 0; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> w; for (int i = 1; i <= n; i++) cin >> x[i]; ans = n + 1; dfs(1, 0); cout << ans; return 0; }\"]},\"279\":{\"h\":\"剪枝 100 分\",\"t\":[\"不如最优结果时就不看了\",\"#include <bits/stdc++.h> using namespace std; int n, w; int x[18 + 5]; int v[18 + 5]; int ans; // 当前物品，已有分组组数 void dfs(int pos, int cnt) { if (cnt >= ans) return; if (pos == n + 1) { ans = min(ans, cnt); return; } for (int i = 1; i <= cnt; i++) { if (v[i] + x[pos] <= w) { v[i] += x[pos]; dfs(pos + 1, cnt); v[i] -= x[pos]; } } v[cnt + 1] = x[pos]; dfs(pos + 1, cnt + 1); v[cnt + 1] = 0; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> w; for (int i = 1; i <= n; i++) cin >> x[i]; ans = n + 1; dfs(1, 0); cout << ans; return 0; }\"]},\"280\":{\"h\":\"状压 DP\",\"t\":[\"f[i][sta] 表示 i 组，选了 sta 这些物品，其中体积最小的那组的体积。\",\"如果有了一个这样的合法的状态，就可以考虑塞一个新物品能否达成就要么放到最小的那组，要么新开一组。\",\"新开一组的转移很好理解。如果放到最小的那组，显然就需要考虑每个物品放到“剩下所有物品中最小的那组”后的体积，这每个体积都是能达成的最小体积，这些最小体积中的最小值肯定就是最优的了。\",\"#include <bits/stdc++.h> using namespace std; int n, w; int a[20]; int f[20][300000]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> w; for (int i = 1; i <= n; i++) cin >> a[i]; memset(f, 0x3f, sizeof(f)); f[1][0] = 0; for (int i = 1; i <= n; i++) { for (int j = 0; j <= (1 << n) - 1; j++) { if (f[i][j] != 0x3f3f3f3f) { for (int k = 0; k <= n - 1; k++) { if (j & (1 << k)) continue; if (f[i][j] + a[k + 1] <= w) f[i][j + (1 << k)] = min(f[i][j + (1 << k)], f[i][j] + a[k + 1]); else f[i + 1][j + (1 << k)] = min(f[i + 1][j + (1 << k)], a[k + 1]); } } } } for (int i = 0; i <= n; i++) if (f[i][(1 << n) - 1] != 0x3f3f3f3f) { cout << i << endl; break; } return 0; }\"]},\"281\":{\"h\":\"【模板】KMP\"},\"282\":{\"h\":\"合并在一起求\",\"t\":[\"#include <bits/stdc++.h> using namespace std; string s1, s2; string t; int nxt[2000000 + 5]; void gen_nxt(const string &t) { nxt[0] = 0; for (int i = 1; i < t.length(); i++) { int j = nxt[i - 1]; while (j && t[i] != t[j]) j = nxt[j - 1]; if (t[i] == t[j]) j++; nxt[i] = j; } } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> s1 >> s2; t = s2 + \\\"#\\\" + s1; gen_nxt(t); /* for (int i = 0; i < t.size(); i++) cout << t[i] << \\\" \\\"; cout << \\\"\\\\n\\\"; for (int i = 0; i < t.size(); i++) cout << nxt[i] << \\\" \\\"; cout << \\\"\\\\n\\\"; */ for (int i = 0; i < t.size(); i++) if (nxt[i] == s2.size()) cout << i - s2.size() - s2.size() + 1 << \\\"\\\\n\\\"; for (int i = 0; i < s2.size(); i++) cout << nxt[i] << \\\" \\\"; return 0; } /* 0 1 2 3 4 5 6 A B A # A B A B A B C 0 0 1 0 1 2 3 2 3 2 0 */\"]},\"283\":{\"h\":\"分离分别求（一般不常用）\",\"t\":[\"#include <bits/stdc++.h> using namespace std; string s1, s2; // p: 模式串、t：文本串 // 在文本中去找到所有和模式匹配的位置 int nxtP[2000000 + 5]; int nxtT[2000000 + 5]; void gen_nxt(const string &p, const string &t) { // 先对模式串本身求 nxtP nxtP[0] = 0; for (int i = 1; i < p.length(); i++) { int j = nxtP[i - 1]; while (j && p[i] != p[j]) j = nxtP[j - 1]; if (p[i] == p[j]) j++; nxtP[i] = j; } // 求 nxtT if (t[0] == p[0]) nxtT[0] = 1; else nxtT[0] = 0; for (int i = 1; i < t.length(); i++) { int j = nxtT[i - 1]; while (j && (j == p.size() || t[i] != p[j])) j = nxtP[j - 1]; if (t[i] == p[j]) j++; nxtT[i] = j; } } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> s1 >> s2; gen_nxt(s2, s1); for (int i = 0; i < s1.size(); i++) if (nxtT[i] == s2.size()) cout << i - s2.size() + 2 << \\\"\\\\n\\\"; for (int i = 0; i < s2.size(); i++) cout << nxtP[i] << \\\" \\\"; return 0; } /* 0 1 2 3 4 5 6 A B A # A B A B A B C 0 0 1 0 1 2 3 2 3 2 0 */\"]},\"284\":{\"h\":\"求模式串的，然后在文本串中匹配（常用）\",\"t\":[\"#include <bits/stdc++.h> using namespace std; string s1, s2; // 求模式串 s2 的 nxt int nxt[1000000 + 5]; void gen_nxt(const string &t) { nxt[0] = 0; for (int i = 1; i < t.length(); i++) { int j = nxt[i - 1]; while (j && t[i] != t[j]) j = nxt[j - 1]; if (t[i] == t[j]) j++; nxt[i] = j; } } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> s1 >> s2; gen_nxt(s2); int last = 0; for (int i = 0; i < s1.size(); i++) { while (last && s1[i] != s2[last]) last = nxt[last - 1]; if (s1[i] == s2[last]) last++; if (last == s2.size()) cout << i - s2.size() + 2 << \\\"\\\\n\\\"; } for (int i = 0; i < s2.size(); i++) cout << nxt[i] << \\\" \\\"; return 0; } /* 0 1 2 3 4 5 6 A B A # A B A B A B C 0 0 1 0 1 2 3 2 3 2 0 */\"]},\"285\":{\"h\":\"【模板】高斯消元法\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 100; int n; //------------高斯消元模板-Start------------ double a[MAXN + 5][MAXN + 5]; void gauss(int x) { for (int i = 0; i < x; ++i) { int row = i; // 接下来为了减小误差，找系数最大的一行 for (int j = i; j < x; ++j) { if (fabs(a[row][i]) < fabs(a[j][i])) row = j; } if (row != i) std::swap(a[row], a[i]); double div1 = a[i][i]; for (int j = 0; j <= x; ++j) a[i][j] /= div1; for (int j = i + 1; j < x; ++j) { double div2 = a[j][i]; for (int k = 0; k <= x; ++k) { a[j][k] -= a[i][k] * div2; } } } for (int i = x - 1; i >= 0; i--) { for (int j = i - 1; j >= 0; j--) { a[j][x] -= a[j][i] * a[i][x]; a[j][i] = 0; } } } //------------高斯消元模板-End-------------- int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 0; i <= n - 1; i++) for (int j = 0; j <= n; j++) cin >> a[i][j]; gauss(n); for (int i = 0; i <= n - 1; i++) { bool flag = true; // 一开始认为全都是 0 for (int j = 0; j <= n - 1; j++) if (fabs(a[i][j]) > 1e-8) flag = false; if (flag) { cout << \\\"No Solution\\\"; return 0; } } for (int i = 0; i <= n - 1; i++) cout << fixed << setprecision(2) << a[i][n] << \\\"\\\\n\\\"; return 0; }\"]},\"286\":{\"h\":\"[AHOI2017初中组] alter\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n, k; string s; // 检查能不能使不优美度小于等于 x（操作次数少于等于 k 次） bool check(int x) { if (x == 1) { // 检查变成 FNFNFNFN 需要多少次 int cnt = 0; for (int i = 0; i < s.size(); i++) { if (i % 2 == 0 && s[i] == 'N') cnt++; if (i % 2 == 1 && s[i] == 'F') cnt++; } // 检查变成 NFNFNFNF 需要多少次 // 前面要变的不变，不变的变一下 int cnt2 = n - cnt; return min(cnt, cnt2) <= k; } int len = 1; // 当前连续一样的长度 int cnt = 0; // 操作次数 for (int i = 1; i < s.size(); i++) { if (s[i] == s[i - 1]) len++; else { // 每 (x+1) 个相同的需要改一个位置 if (len > x) cnt += len / (x + 1); len = 1; } } // 每 (x+1) 个相同的需要改一个位置 if (len > x) cnt += len / (x + 1); return cnt <= k; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> k; cin >> s; int ans = 0; for (int i = 1; i <= n; i++) { if (check(i)) { ans = i; break; } } cout << ans; return 0; }\",\"#include <bits/stdc++.h> using namespace std; int n, k; string s; // 检查能不能使不优美度小于等于 x（操作次数少于等于 k 次） bool check(int x) { if (x == 1) { // 检查变成 FNFNFNFN 需要多少次 int cnt = 0; for (int i = 0; i < s.size(); i++) { if (i % 2 == 0 && s[i] == 'N') cnt++; if (i % 2 == 1 && s[i] == 'F') cnt++; } // 检查变成 NFNFNFNF 需要多少次 // 前面要变的不变，不变的变一下 int cnt2 = n - cnt; return min(cnt, cnt2) <= k; } int len = 1; // 当前连续一样的长度 int cnt = 0; // 操作次数 for (int i = 1; i < s.size(); i++) { if (s[i] == s[i - 1]) len++; else { // 每 (x+1) 个相同的需要改一个位置 if (len > x) cnt += len / (x + 1); len = 1; } } // 每 (x+1) 个相同的需要改一个位置 if (len > x) cnt += len / (x + 1); return cnt <= k; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> k; cin >> s; int ans = 0; int l = 1; int r = n; while (l <= r) { int mid = (l + r) / 2; if (check(mid)) { ans = mid; r = mid - 1; } else { l = mid + 1; } } cout << ans; return 0; }\"]},\"287\":{\"h\":\"[NOIP2017 提高组] 时间复杂度\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int t; int l; string tim; // 时间复杂度 int timInt; // n^timInt 时间复杂度 char op, ii; string x, y; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> t; while (t--) { cin >> l >> tim; timInt = 0; if (tim != \\\"O(1)\\\") { timInt = 0; for (int i = 4; i <= (int)tim.size() - 1; i++) if ('0' <= tim[i] && tim[i] <= '9') timInt = timInt * 10 + tim[i] - '0'; else break; } int cntN = 0; for (int i = 1; i <= l / 2; i++) { cin >> op >> ii >> x >> y; if (y == \\\"n\\\") cntN++; } for (int i = 1; i <= l / 2; i++) cin >> op; // 吃掉后面的 E; if (cntN == timInt) cout << \\\"Yes\\\\n\\\"; else cout << \\\"No\\\\n\\\"; } return 0; }\"]},\"288\":{\"h\":\"[NOIP2017 普及组] 图书管理员\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n, q; int book[1005]; int ten[15]; // 预处理 10^i int main() { ios::sync_with_stdio(false); cin.tie(0); ten[0] = 1; for (int i = 1; i <= 8; i++) ten[i] = ten[i - 1] * 10; cin >> n >> q; for (int i = 1; i <= n; i++) cin >> book[i]; while (q--) { int len, num; // 需求码长度和需求码 cin >> len >> num; int ans = -1; for (int i = 1; i <= n; i++) if (book[i] % ten[len] == num) { if (ans == -1 || book[i] < ans) ans = book[i]; } cout << ans << \\\"\\\\n\\\"; } return 0; }\"]},\"289\":{\"h\":\"奶酪\",\"t\":[\"#include <bits/stdc++.h> using namespace std; long long n, h, r; int t; int a[1005], b[1005]; // 分别记录和上下相连的点 bool flag; int a1, b1; int fa[1005]; long long x[1005], y[1005], z[1005]; int findfa(int x) { if (x == fa[x]) return x; return fa[x] = findfa(fa[x]); } void merge(int x, int y) { int fax = findfa(x); int fay = findfa(y); fa[fax] = fay; } bool query(int x, int y) { int fax = findfa(x); int fay = findfa(y); return fax == fay; } int main() { cin >> t; while (t--) { cin >> n >> h >> r; for (int i = 1; i <= n; i++) fa[i] = i; flag = false; a1 = b1 = 0; for (int i = 1; i <= n; i++) { cin >> x[i] >> y[i] >> z[i]; if (z[i] <= r) a[++a1] = i; if (h - z[i] <= r) b[++b1] = i; for (int j = 1; j < i; j++) if (!query(i, j) && (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]) + (z[i] - z[j]) * (z[i] - z[j]) <= (2 * r) * (2 * r)) merge(i, j); } for (int i = 1; i <= a1; i++) for (int j = 1; j <= b1; j++) if (query(a[i], b[j])) flag = true; if (flag) cout << \\\"Yes\\\\n\\\"; else cout << \\\"No\\\\n\\\"; } return 0; } ```--- title: \\\" P3958. 奶酪\\\" --- ```cpp #include <bits/stdc++.h> using namespace std; long long n, h, r; int t; int a[1005], b[1005]; // 分别记录和上下相连的点 bool flag; int a1, b1; int fa[1005]; long long x[1005], y[1005], z[1005]; int findfa(int x) { if (x == fa[x]) return x; return fa[x] = findfa(fa[x]); } void merge(int x, int y) { int fax = findfa(x); int fay = findfa(y); fa[fax] = fay; } bool query(int x, int y) { int fax = findfa(x); int fay = findfa(y); return fax == fay; } int main() { cin >> t; while (t--) { cin >> n >> h >> r; for (int i = 1; i <= n; i++) fa[i] = i; flag = false; a1 = b1 = 0; for (int i = 1; i <= n; i++) { cin >> x[i] >> y[i] >> z[i]; if (z[i] <= r) a[++a1] = i; if (h - z[i] <= r) b[++b1] = i; for (int j = 1; j < i; j++) if (!query(i, j) && (x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]) + (z[i] - z[j]) * (z[i] - z[j]) <= (2 * r) * (2 * r)) merge(i, j); } for (int i = 1; i <= a1; i++) for (int j = 1; j <= b1; j++) if (query(a[i], b[j])) flag = true; if (flag) cout << \\\"Yes\\\\n\\\"; else cout << \\\"No\\\\n\\\"; } return 0; }\"]},\"290\":{\"h\":\"上帝造题的七分钟 2 / 花神游历各国\"},\"291\":{\"h\":\"lazy 标记是否还要开方\",\"t\":[\"#include <bits/stdc++.h> #define int long long using namespace std; const int MAXN = 100000; int n, m, a[MAXN + 5]; int t[MAXN * 4 + 5]; bool lazy[MAXN * 4 + 5]; // 是否还需要开方 // 当前节点为 now，对应的线段为 [l,r] void build(int now, int l, int r) { lazy[now] = true; if (l == r) { t[now] = a[l]; return; } int mid = (l + r) / 2; build(now * 2, l, mid); build(now * 2 + 1, mid + 1, r); t[now] = t[now * 2] + t[now * 2 + 1]; } // 做到了 now 节点，对应区间为 [l,r] // 单点修改：a[x]~a[y] 开方 void update(int now, int l, int r, int x, int y) { if (lazy[now] == false) return; if (l == r) { t[now] = sqrt(t[now]); if (t[now] <= 1) lazy[now] = false; } else { int mid = (l + r) / 2; if (x <= mid) update(now * 2, l, mid, x, y); if (y >= mid + 1) update(now * 2 + 1, mid + 1, r, x, y); t[now] = t[now * 2] + t[now * 2 + 1]; lazy[now] = lazy[now * 2] || lazy[now * 2 + 1]; } } int query(int now, int l, int r, int x, int y) { if (x <= l && r <= y) return t[now]; int mid = (l + r) / 2; int res = 0; if (x <= mid) res += query(now * 2, l, mid, x, y); if (y >= mid + 1) res += query(now * 2 + 1, mid + 1, r, x, y); return res; } signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; build(1, 1, n); cin >> m; while (m--) { int op, x, y, z; cin >> op; if (op == 0) { cin >> x >> y; if (x > y) swap(x, y); update(1, 1, n, x, y); } else { cin >> x >> y; if (x > y) swap(x, y); cout << query(1, 1, n, x, y) << \\\"\\\\n\\\"; } } return 0; }\"]},\"292\":{\"h\":\"用区间和判断\",\"t\":[\"这题的数不会变为 0，所以不需要开方的条件就是区间和等于区间长度（全都是 1）\",\"#include <bits/stdc++.h> #define int long long using namespace std; const int MAXN = 100000; int n, m, a[MAXN + 5]; int t[MAXN * 4 + 5]; int lazy[MAXN * 4 + 5]; void build(int now, int l, int r) { if (l == r) { t[now] = a[l]; return; } int mid = (l + r) / 2; build(now * 2, l, mid); build(now * 2 + 1, mid + 1, r); t[now] = t[now * 2] + t[now * 2 + 1]; } void update(int now, int l, int r, int x, int y, int z) { if (t[now] == r - l + 1) return; if (l == r) { t[now] = sqrt(t[now]); return; } int mid = (l + r) / 2; if (x <= mid) update(now * 2, l, mid, x, y, z); if (y >= mid + 1) update(now * 2 + 1, mid + 1, r, x, y, z); t[now] = t[now * 2] + t[now * 2 + 1]; } int query(int now, int l, int r, int x, int y) { if (x <= l && r <= y) return t[now]; int mid = (l + r) / 2; int res = 0; if (x <= mid) res += query(now * 2, l, mid, x, y); if (y >= mid + 1) res += query(now * 2 + 1, mid + 1, r, x, y); return res; } signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; build(1, 1, n); cin >> m; while (m--) { int op, x, y, z; cin >> op; if (op == 0) { cin >> x >> y; if (x > y) swap(x, y); update(1, 1, n, x, y, z); } else { cin >> x >> y; if (x > y) swap(x, y); cout << query(1, 1, n, x, y) << \\\"\\\\n\\\"; } } return 0; }\"]},\"293\":{\"h\":\"[USACO18OPEN] Talent Show G\",\"t\":[\"#include <bits/stdc++.h> #define int long long using namespace std; int n, W; int w[255], t[255]; // w:重量 t:才艺 int v[255]; // 对应价值 int f[1005]; // f[i] 存 i 重量下的最大价值 bool check(int mid) { for (int i = 1; i <= n; i++) v[i] = (1000 * t[i] - mid * w[i]); for (int i = 0; i <= W; i++) f[i] = -1'000'000'000'000'000'000; f[0] = 0; for (int i = 1; i <= n; i++) for (int j = W; j >= 0; j--) { // j->j+v[i] int jj = min(W, j + w[i]); f[jj] = max(f[jj], f[j] + v[i]); } return f[W] >= 0; } signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> W; for (int i = 1; i <= n; i++) cin >> w[i] >> t[i]; int l = 1; int r = 1000000; int ans; while (l <= r) { int mid = (l + r) / 2; if (check(mid)) { ans = mid; l = mid + 1; } else r = mid - 1; } cout << ans; return 0; }\"]},\"294\":{\"h\":\"[BalticOI 2011 Day1] Switch the Lamp On 电路维修\"},\"295\":{\"h\":\"双端队列广搜\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n, m; char g[505][505]; int idx[505][505]; // 每个格点对应的编号 1~n+1,1~m+1 vector<pair<int, int>> e[501 * 501 + 5]; int dis[501 * 501 + 5]; deque<int> q; void bfs() { int tot = (n + 1) * (m + 1); // 点 1~tot for (int i = 1; i <= tot; i++) dis[i] = -1; q.push_back(1); dis[1] = 0; while (!q.empty() && dis[tot] == -1) { int u = q.front(); q.pop_front(); for (int i = 0; i < e[u].size(); i++) { int v = e[u][i].first; int w = e[u][i].second; if (dis[v] == -1 || dis[v] > dis[u] + w) { dis[v] = dis[u] + w; if (w == 0) q.push_front(v); else q.push_back(v); } } } } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m; for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) cin >> g[i][j]; // 格点编号 for (int i = 1; i <= n + 1; i++) for (int j = 1; j <= m + 1; j++) idx[i][j] = (i - 1) * (m + 1) + j; // 建图 for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) { int p1 = idx[i][j], p2 = idx[i][j + 1]; int p3 = idx[i + 1][j], p4 = idx[i + 1][j + 1]; if (g[i][j] == '\\\\\\\\') { e[p1].push_back(make_pair(p4, 0)); e[p4].push_back(make_pair(p1, 0)); e[p2].push_back(make_pair(p3, 1)); e[p3].push_back(make_pair(p2, 1)); } else { e[p1].push_back(make_pair(p4, 1)); e[p4].push_back(make_pair(p1, 1)); e[p2].push_back(make_pair(p3, 0)); e[p3].push_back(make_pair(p2, 0)); } } // bfs() bfs(); // 输出 if (dis[idx[n + 1][m + 1]] == -1) cout << \\\"NO SOLUTION\\\"; else cout << dis[idx[n + 1][m + 1]]; return 0; }\"]},\"296\":{\"h\":\"并查集缩点+广搜\"},\"297\":{\"h\":\"最短路\"},\"298\":{\"h\":\"[CEOI2015 Day2] 世界冰球锦标赛\",\"t\":[\"#include <bits/stdc++.h> #define int long long using namespace std; int n, nn, m; int a[25]; vector<int> x, y; // 当前考虑第 now 个数选不选 // 之前的所有数之和为 sum // 所有产生的数丢进 all void dfs(int now, int sum, vector<int> &all) { if (now > nn) return; // 选 all.push_back(sum + a[now]); dfs(now + 1, sum + a[now], all); // 不选 dfs(now + 1, sum, all); } signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m; nn = n / 2; for (int i = 1; i <= nn; i++) cin >> a[i]; x.push_back(0); dfs(1, 0, x); nn = n - nn; for (int i = 1; i <= nn; i++) cin >> a[i]; y.push_back(0); dfs(1, 0, y); // 算组合的方案 int ans = 0; // 一场都不看的特判 sort(y.begin(), y.end()); for (int i = 0; i < x.size(); i++) { // y[pos] 是第一个大于 m-x[i] 的数 // 前面刚好有 y[0]~y[pos-1] 共 pos 个小于等于 m-x[i] 的数 int pos = upper_bound(y.begin(), y.end(), m - x[i]) - y.begin(); ans += pos; } cout << ans; return 0; }\",\"#include <bits/stdc++.h> #define int long long using namespace std; int n, nn, m; int a[25]; int xTot, x[(1 << 20) + 5]; // x[1]~x[xTot] int yTot, y[(1 << 20) + 5]; // y[1]~y[yTot] void dfsX(int now, int sum) { if (now > nn) return; // 选 xTot++; x[xTot] = sum + a[now]; dfsX(now + 1, sum + a[now]); // 不选 dfsX(now + 1, sum); } void dfsY(int now, int sum) { if (now > nn) return; // 选 y[++yTot] = sum + a[now]; dfsY(now + 1, sum + a[now]); // 不选 dfsY(now + 1, sum); } signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m; nn = n / 2; for (int i = 1; i <= nn; i++) cin >> a[i]; xTot = 1; x[xTot] = 0; dfsX(1, 0); nn = n - nn; for (int i = 1; i <= nn; i++) cin >> a[i]; y[yTot = 1] = 0; dfsY(1, 0); // 算组合的方案 int ans = 0; // 一场都不看的特判 sort(y + 1, y + yTot + 1); for (int i = 1; i <= xTot; i++) { // y[pos] 是第一个大于 m-x[i] 的数 // 前面刚好有 y[1]~y[pos-1] 共 pos-1 个小于等于 m-x[i] 的数 int pos = upper_bound(y + 1, y + yTot + 1, m - x[i]) - y; ans += pos - 1; } cout << ans; return 0; }\"]},\"299\":{\"h\":\"[1007] 魔法少女小Scarlet\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n, m; int a[505][505]; int b[505][505]; void zhuan(int x, int y, int r) { for (int i = -r; i <= r; i++) for (int j = -r; j <= r; j++) b[x + j][y - i] = a[x + i][y + j]; for (int i = -r; i <= r; i++) for (int j = -r; j <= r; j++) a[x + i][y + j] = b[x + i][y + j]; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m; for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) a[i][j] = (i - 1) * n + j; while (m--) { int x, y, r, z; cin >> x >> y >> r >> z; if (z == 0) zhuan(x, y, r); else { zhuan(x, y, r); zhuan(x, y, r); zhuan(x, y, r); } } for (int i = 1; i <= n; i++) { for (int j = 1; j <= n; j++) cout << a[i][j] << \\\" \\\"; cout << \\\"\\\\n\\\"; } return 0; }\"]},\"300\":{\"h\":\"大师\"},\"301\":{\"h\":\"暴力枚举深搜\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n; int a[1005]; int ans; bool flag[1005]; void dfs(int now) { if (now > n) { // 检查选择的数 bool up = true; // 是否等差 int d; int last = -1; // 记录上一个选择的数 int cnt = 0; // 选了几个数 for (int i = 1; i <= n; i++) if (flag[i]) { cnt++; if (cnt == 2) d = a[i] - last; else if (cnt > 2 && a[i] - last != d) { up = false; break; } last = a[i]; } if (cnt > 0 && up) ans++; return; } // 不选第 now 个数 flag[now] = false; dfs(now + 1); flag[now] = false; // 选第 now 个数 flag[now] = true; dfs(now + 1); flag[now] = false; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; ans = 0; dfs(1); cout << ans; return 0; }\"]},\"302\":{\"h\":\"优化\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MOD = 998244353; int n; int a[1005]; int book[1005][40000 + 5]; // 返回从 now 往后，公差为 d 的子序列数量 // 包括只有 1 项 int dfs(int now, int d) { if (book[now][d + 20000] != 0) return book[now][d + 20000]; int res = 1; for (int i = now + 1; i <= n; i++) if (a[i] - a[now] == d) { // a[now],a[i],~~~~~ res += dfs(i, d); res %= MOD; } return book[now][d + 20000] = res; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; int ans = n; // 所有只有 1 项的 for (int d = -20000; d <= 20000; d++) for (int i = 1; i <= n; i++) { ans += dfs(i, d) - 1; // 去掉只有 1 项的 ans %= MOD; } cout << ans; return 0; }\"]},\"303\":{\"h\":\"dp\",\"t\":[\"#include <bits/stdc++.h> #define int long long using namespace std; const int MOD = 998244353; const int BASE = 20000 + 5; int n; int a[1005]; //以 a[i] 结尾，公差为 j 的等差子序列方案数 int dp[1005][20000 + BASE + 5]; signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; int ans = 0; for (int i = 1; i <= n; i++) { ans++; for (int j = i - 1; j >= 1; j--) { int d = a[i] - a[j] + BASE; dp[i][d] = (dp[i][d] + dp[j][d] + 1) % MOD; ans = (ans + dp[j][d] + 1) % MOD; } } cout << ans << \\\"\\\\n\\\"; return 0; }\"]},\"304\":{\"h\":\"中国象棋 - 摆上马\"},\"305\":{\"h\":\"爆搜\",\"t\":[\"#include <bits/stdc++.h> #define int long long using namespace std; const int MOD = 1'000'000'000 + 7; const int MAXN = 100; const int MAXM = 6; int n, m; // n 行 m 列 int ans; int vis[MAXN + 5][MAXM + 5]; int dx[] = {1, -1, 1, -1, 2, -2, 2, -2}; int dy[] = {2, 2, -2, -2, 1, 1, -1, -1}; void dfs(int x, int y) { if (y == m + 1) { x++; y = 1; } if (x == n + 1) { for (int a = 1; a <= n; a++) for (int b = 1; b <= m; b++) { if (!vis[a][b]) continue; for (int i = 0; i < 8; i++) { int aa = a + dx[i]; int bb = b + dy[i]; if (aa < 1 || n < aa || bb < 1 || m < bb) continue; if (!vis[aa][bb]) continue; if (dx[i] == 2 || dx[i] == -2) { aa = a + dx[i] / 2; bb = b; } else { aa = a; bb = b + dy[i] / 2; } if (!vis[aa][bb]) return; } } ans = (ans + 1) % MOD; return; } dfs(x, y + 1); vis[x][y] = true; dfs(x, y + 1); vis[x][y] = false; } signed main() { cin >> n >> m; ans = 0; dfs(1, 1); cout << ans; return 0; }\"]},\"306\":{\"h\":\"状压dp\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MOD = 1'000'000'000 + 7; int x, y; // dp[i][sta1][sta2] 前i行，第i行摆放方案为 sta1，第i-1行摆放方案为 sta2，的摆放方案数 int now, pre; // 当前是第now行，上一行是第 pre 行 int dp[2][(1 << 6) - 1 + 5][(1 << 6) - 1 + 5]; // 检查相邻两行是否有冲突 bool check1(int sta1, int sta2) { for (int i = 0; i <= y - 1; i++) // 枚举sta1的每个1 { if ((sta1 & (1 << i)) == 0) continue; for (int j = 0; j <= y - 1; j++) { if ((sta2 & (1 << j)) == 0) continue; // sta1 的 i 的位置有马、sta2 的 j 的位置有马 if (j == i + 2) { // sta2 xxjxxxx // sta1 xxxxixx if ((sta1 & (1 << i + 1)) && (sta2 & (1 << j - 1))) continue; return true; } if (j == i - 2) { // sta2 xxxxxxjxx // sta1 xxxxixxxx if ((sta1 & (1 << i - 1)) && (sta2 & (1 << j + 1))) continue; return true; } } } return false; } // 检查间隔一行的两行有没有冲突 bool check2(int sta1, int sta2, int sta3) { for (int i = 0; i <= y - 1; i++) // 枚举sta1的每个1 { if ((sta1 & (1 << i)) == 0) continue; for (int j = 0; j <= y - 1; j++) { if ((sta3 & (1 << j)) == 0) continue; // sta1 的 i 的位置有马、sta3 的 j 的位置有马 if (j == i + 1 || j == i - 1) { if ((sta2 & (1 << i)) && (sta2 & (1 << j))) continue; return true; } } } return false; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> x >> y; memset(dp, 0, sizeof(dp)); // 处理边界情况 前0行，啥都不摆的时候是一种合法方案 dp[0][0][0] = 1; pre = 0; now = 1; int ans = 0; for (int i = 1; i <= x; i++) { // 第i行 for (int sta1 = 0; sta1 <= (1 << y) - 1; sta1++) { // 第i-1行 for (int sta2 = 0; sta2 <= (1 << y) - 1; sta2++) { dp[now][sta1][sta2] = 0; if (check1(sta1, sta2)) continue; // 求 dp[i][sta1][sta2] // 枚举上上行（i-2）的状态 for (int sta3 = 0; sta3 <= (1 << y) - 1; sta3++) { if (check1(sta2, sta3)) continue; if (check2(sta1, sta2, sta3)) continue; dp[now][sta1][sta2] += dp[pre][sta2][sta3]; dp[now][sta1][sta2] %= MOD; } if (i == x) { ans += dp[now][sta1][sta2]; ans %= MOD; } } } now = 1 - now; pre = 1 - pre; } cout << ans << \\\"\\\\n\\\"; return 0; }\"]},\"307\":{\"h\":\"[NOIP2018 提高组] 货币系统\",\"t\":[\"检查多少个面值无法被其他面值组合出来\",\"#include <bits/stdc++.h> using namespace std; int T; int n; int a[105]; bool book[25000 + 5][105]; // 如果算过了，存值 bool vis[25000 + 5][105]; // 表示每个 num no 有没有被算过 // 不使用 a[no] 的情况下，能不能表示出来 num bool f(int num, int no) { if (vis[num][no]) return book[num][no]; vis[num][no] = true; if (num == 0) return book[num][no] = true; for (int i = 1; i <= n; i++) { // 不能用自己 if (i == no || a[i] > num) continue; // 检查 num-a[i] 能不能被表示出来 if (f(num - a[i], no)) return book[num][no] = true; } return book[num][no] = false; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> T; while (T--) { cin >> n; int maxAi = 0; for (int i = 1; i <= n; i++) { cin >> a[i]; maxAi = max(maxAi, a[i]); } for (int i = 0; i <= maxAi; i++) for (int j = 1; j <= n; j++) vis[i][j] = false; int ans = 0; for (int i = 1; i <= n; i++) if (!f(a[i], i)) ans++; cout << ans << \\\"\\\\n\\\"; } return 0; }\",\"#include <bits/stdc++.h> using namespace std; const int MAXN = 100; const int MAXAI = 25000; int t, n; int a[MAXN + 5]; bool dp[MAXAI + 5]; int main() { cin >> t; while (t--) { cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; sort(a + 1, a + n + 1); int maxAi = a[n]; // 记录最大的面额 int ans = 0; // 记录简化后的货币系统大小（面额的数量） // dp[x] 表示 x 能否凑出来 for (int i = 0; i <= maxAi; i++) dp[i] = false; dp[0] = true; // 从小到大枚举每个货币 for (int i = 1; i <= n; i++) { // 当前货币的面额为 a[i] if (dp[a[i]] == true) continue; // 选择当前货币 ans++; for (int j = a[i]; j <= maxAi; j++) dp[j] = dp[j] || dp[j - a[i]]; } cout << ans << \\\"\\\\n\\\"; } return 0; }\"]},\"308\":{\"h\":\"【深基17.例5】木材仓库\"},\"309\":{\"h\":\"里面遍历\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n; set<int> s; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; while (n--) { int op, x; cin >> op >> x; if (op == 1) { if (s.find(x) != s.end()) cout << \\\"Already Exist\\\\n\\\"; else s.insert(x); } else { // 暴力枚举 if (s.empty()) { cout << \\\"Empty\\\\n\\\"; continue; } set<int>::iterator ans = s.begin(); for (auto it = s.begin(); it != s.end(); it++) if (abs(*it - x) < abs(*ans - x)) ans = it; cout << *ans << \\\"\\\\n\\\"; s.erase(ans); } } return 0; }\"]},\"310\":{\"h\":\"标准做法\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n; set<int> s; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; while (n--) { int op, x; cin >> op >> x; if (op == 1) { if (s.find(x) != s.end()) cout << \\\"Already Exist\\\\n\\\"; else s.insert(x); } else { // 暴力枚举 if (s.empty()) { cout << \\\"Empty\\\\n\\\"; continue; } // 先放到备选答案上 set<int>::iterator ans = s.lower_bound(x); if (ans == s.end()) ans--; // 检查前一个位置会不会更好 if (ans == s.begin()) cout << *ans << \\\"\\\\n\\\"; else { auto it = ans; it--; if (abs(*it - x) <= abs(*ans - x)) ans = it; cout << *ans << \\\"\\\\n\\\"; } s.erase(ans); } } return 0; }\"]},\"311\":{\"h\":\"【模板】扫描线\"},\"312\":{\"h\":\"离散化+权值线段树做法\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 100000; // 矩形的数量 int n; int x[MAXN + 5], y[MAXN + 5], xx[MAXN + 5], yy[MAXN + 5]; // 离散化 vector<int> temp; // 存每条竖线 struct Line { // (x,y)~(x,yy) // typ == 1 矩形左边竖线 // typ == 2 矩形右边竖线 int x, y, yy, typ; }; vector<Line> line; // 存每条线段 bool cmp(Line a, Line b) { return a.x < b.x; } // 线段树 int t[MAXN * 2 * 4 + 5]; //(要维护的权值数组长度为 MAXN*2) int lazy[MAXN * 2 * 4 + 5]; // 重新计算当前的 t[now] void up(int now, int l, int r) { if (lazy[now] > 0) t[now] = temp[r + 1] - temp[l]; else if (l == r && lazy[now] == 0) t[now] = 0; else t[now] = t[now * 2] + t[now * 2 + 1]; } void update(int now, int l, int r, int x, int y, int z) { if (x <= l && r <= y) { lazy[now] += z; up(now, l, r); return; } int mid = (l + r) / 2; if (x <= mid) update(now * 2, l, mid, x, y, z); if (y > mid) update(now * 2 + 1, mid + 1, r, x, y, z); up(now, l, r); } // 返回总长度和 int query() { return t[1]; } int main() { ios::sync_with_stdio(false); cin.tie(0); // 输入、离散化、构建线段 cin >> n; for (int i = 1; i <= n; i++) { cin >> x[i] >> y[i] >> xx[i] >> yy[i]; temp.push_back(y[i]); temp.push_back(yy[i]); } sort(temp.begin(), temp.end()); for (int i = 1; i <= n; i++) { // 范围 0~2n-1 y[i] = lower_bound(temp.begin(), temp.end(), y[i]) - temp.begin(); yy[i] = lower_bound(temp.begin(), temp.end(), yy[i]) - temp.begin(); // 把每条线段放入 line line.push_back((Line){x[i], y[i], yy[i], +1}); line.push_back((Line){xx[i], y[i], yy[i], -1}); } sort(line.begin(), line.end(), cmp); // 从左往右扫描 long long ans = 0; // 记录总的面积并 int lastX = 0; // 记录上一条线段的 x 的位置 for (Line now : line) { ans += (long long)(now.x - lastX) * query(); lastX = now.x; update(1, 0, 2 * n - 1, now.y, now.yy - 1, now.typ); } cout << ans << \\\"\\\\n\\\"; return 0; }\"]},\"313\":{\"h\":\"动态开点权值线段树\",\"t\":[\"#include <bits/stdc++.h> #define int long long using namespace std; const int MAXN = 100000; const int MAXTOT = MAXN * 120; const int MAXXY = 1000000000; int n; int x[MAXN + 5], y[MAXN + 5], xx[MAXN + 5], yy[MAXN + 5]; struct Line { // (x,y)~(x,yy) typ:1 左边线，-1 右边线 int x, y, yy, typ; }; vector<Line> line; bool cmp(Line x, Line y) { return x.x < y.x; } // 动态开点权值线段树，区间修改，总和查询 int tot; // 当前用到的点数，编号从 1~tot int lson[MAXTOT + 5], rson[MAXTOT + 5]; int t[MAXTOT + 5], lazy[MAXTOT + 5]; void up(int now, int l, int r) { if (lazy[now] > 0) t[now] = r - l + 1; else if (l == r && lazy[now] == 0) t[now] = 0; else t[now] = t[lson[now]] + t[rson[now]]; } void update(int now, int l, int r, int x, int y, int z) { if (x <= l && r <= y) { lazy[now] += z; up(now, l, r); return; } int mid = (l + r) / 2; // 保证有左右子节点 if (lson[now] == 0) lson[now] = ++tot; if (rson[now] == 0) rson[now] = ++tot; // 分别尝试去两边修改 if (x <= mid) update(lson[now], l, mid, x, y, z); if (y > mid) update(rson[now], mid + 1, r, x, y, z); up(now, l, r); } int query() { return t[1]; } signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> x[i] >> y[i] >> xx[i] >> yy[i]; // 生成所有竖线/并排序 for (int i = 1; i <= n; i++) { line.push_back((Line){x[i], y[i], yy[i], 1}); line.push_back((Line){xx[i], y[i], yy[i], -1}); } sort(line.begin(), line.end(), cmp); // 动态开点线段树初始化 tot = 1; // 扫描线 int ans = 0; int lastX = 0; // 上一条线的 x 坐标 for (int i = 0; i < line.size(); i++) { ans += (line[i].x - lastX) * query(); lastX = line[i].x; update(1, 0, MAXXY, line[i].y, line[i].yy - 1, line[i].typ); } cout << ans; return 0; } ```--- title: \\\"P5490 【模板】扫描线\\\" --- ## 离散化+权值线段树做法 ```cpp #include <bits/stdc++.h> using namespace std; const int MAXN = 100000; // 矩形的数量 int n; int x[MAXN + 5], y[MAXN + 5], xx[MAXN + 5], yy[MAXN + 5]; // 离散化 vector<int> temp; // 存每条竖线 struct Line { // (x,y)~(x,yy) // typ == 1 矩形左边竖线 // typ == 2 矩形右边竖线 int x, y, yy, typ; }; vector<Line> line; // 存每条线段 bool cmp(Line a, Line b) { return a.x < b.x; } // 线段树 int t[MAXN * 2 * 4 + 5]; //(要维护的权值数组长度为 MAXN*2) int lazy[MAXN * 2 * 4 + 5]; // 重新计算当前的 t[now] void up(int now, int l, int r) { if (lazy[now] > 0) t[now] = temp[r + 1] - temp[l]; else if (l == r && lazy[now] == 0) t[now] = 0; else t[now] = t[now * 2] + t[now * 2 + 1]; } void update(int now, int l, int r, int x, int y, int z) { if (x <= l && r <= y) { lazy[now] += z; up(now, l, r); return; } int mid = (l + r) / 2; if (x <= mid) update(now * 2, l, mid, x, y, z); if (y > mid) update(now * 2 + 1, mid + 1, r, x, y, z); up(now, l, r); } // 返回总长度和 int query() { return t[1]; } int main() { ios::sync_with_stdio(false); cin.tie(0); // 输入、离散化、构建线段 cin >> n; for (int i = 1; i <= n; i++) { cin >> x[i] >> y[i] >> xx[i] >> yy[i]; temp.push_back(y[i]); temp.push_back(yy[i]); } sort(temp.begin(), temp.end()); for (int i = 1; i <= n; i++) { // 范围 0~2n-1 y[i] = lower_bound(temp.begin(), temp.end(), y[i]) - temp.begin(); yy[i] = lower_bound(temp.begin(), temp.end(), yy[i]) - temp.begin(); // 把每条线段放入 line line.push_back((Line){x[i], y[i], yy[i], +1}); line.push_back((Line){xx[i], y[i], yy[i], -1}); } sort(line.begin(), line.end(), cmp); // 从左往右扫描 long long ans = 0; // 记录总的面积并 int lastX = 0; // 记录上一条线段的 x 的位置 for (Line now : line) { ans += (long long)(now.x - lastX) * query(); lastX = now.x; update(1, 0, 2 * n - 1, now.y, now.yy - 1, now.typ); } cout << ans << \\\"\\\\n\\\"; return 0; }\"]},\"314\":{\"h\":\"动态开点权值线段树\",\"t\":[\"#include <bits/stdc++.h> #define int long long using namespace std; const int MAXN = 100000; const int MAXTOT = MAXN * 120; const int MAXXY = 1000000000; int n; int x[MAXN + 5], y[MAXN + 5], xx[MAXN + 5], yy[MAXN + 5]; struct Line { // (x,y)~(x,yy) typ:1 左边线，-1 右边线 int x, y, yy, typ; }; vector<Line> line; bool cmp(Line x, Line y) { return x.x < y.x; } // 动态开点权值线段树，区间修改，总和查询 int tot; // 当前用到的点数，编号从 1~tot int lson[MAXTOT + 5], rson[MAXTOT + 5]; int t[MAXTOT + 5], lazy[MAXTOT + 5]; void up(int now, int l, int r) { if (lazy[now] > 0) t[now] = r - l + 1; else if (l == r && lazy[now] == 0) t[now] = 0; else t[now] = t[lson[now]] + t[rson[now]]; } void update(int now, int l, int r, int x, int y, int z) { if (x <= l && r <= y) { lazy[now] += z; up(now, l, r); return; } int mid = (l + r) / 2; // 保证有左右子节点 if (lson[now] == 0) lson[now] = ++tot; if (rson[now] == 0) rson[now] = ++tot; // 分别尝试去两边修改 if (x <= mid) update(lson[now], l, mid, x, y, z); if (y > mid) update(rson[now], mid + 1, r, x, y, z); up(now, l, r); } int query() { return t[1]; } signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> x[i] >> y[i] >> xx[i] >> yy[i]; // 生成所有竖线/并排序 for (int i = 1; i <= n; i++) { line.push_back((Line){x[i], y[i], yy[i], 1}); line.push_back((Line){xx[i], y[i], yy[i], -1}); } sort(line.begin(), line.end(), cmp); // 动态开点线段树初始化 tot = 1; // 扫描线 int ans = 0; int lastX = 0; // 上一条线的 x 坐标 for (int i = 0; i < line.size(); i++) { ans += (line[i].x - lastX) * query(); lastX = line[i].x; update(1, 0, MAXXY, line[i].y, line[i].yy - 1, line[i].typ); } cout << ans; return 0; }\"]},\"315\":{\"h\":\"[CSP-S2019 江西] 和积和\"},\"316\":{\"h\":\"[COCI2006-2007#6] KAMEN\"},\"317\":{\"h\":\"60 分\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXR = 30000; const int MAXC = 30; int r, c, n; char g[MAXR + 5][MAXC + 5]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> r >> c; for (int i = 1; i <= r; i++) for (int j = 1; j <= c; j++) cin >> g[i][j]; cin >> n; while (n--) { int x, y; cin >> y; x = 1; if (g[x][y] == 'X' || g[x][y] == 'O') continue; while (x != r) { if (g[x + 1][y] == '.') x++; else if (g[x + 1][y] == 'X') break; else if (y != 1 && g[x][y - 1] == '.' && g[x + 1][y - 1] == '.') x++, y--; else if (y != c && g[x][y + 1] == '.' && g[x + 1][y + 1] == '.') x++, y++; else break; } g[x][y] = 'O'; } for (int i = 1; i <= r; i++) { for (int j = 1; j <= c; j++) cout << g[i][j]; cout << \\\"\\\\n\\\"; } return 0; }\"]},\"318\":{\"h\":\"100 分\",\"t\":[\"#include <bits/stdc++.h> using namespace std; typedef long long ll; int r, c, m; //存图 char g[30005][35]; //(1,i)为起点的路径，第j个点为(j,path[i][j]) int path[35][30005]; //(1,i)为起点的路径，最后一个点在第lastRow[i]行 int lastRow[35]; //维护路径 void run(int ith, int nowX, int nowY) { path[ith][nowX] = nowY; while (1) { if (g[nowX + 1][nowY] == 'X') break; if (g[nowX + 1][nowY] == '.') nowX++; else if (g[nowX][nowY - 1] == '.' && g[nowX + 1][nowY - 1] == '.') nowX++, nowY--; else if (g[nowX][nowY + 1] == '.' && g[nowX + 1][nowY + 1] == '.') nowX++, nowY++; else break; path[ith][nowX] = nowY; } lastRow[ith] = nowX; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> r >> c; memset(g, 'X', sizeof(g)); for (int i = 1; i <= r; i++) for (int j = 1; j <= c; j++) cin >> g[i][j]; for (int i = 1; i <= c; i++) run(i, 1, i); cin >> m; while (m--) { int nowC; cin >> nowC; int toX, toY; toX = lastRow[nowC]; toY = path[nowC][toX]; g[toX][toY] = 'O'; for (int i = 1; i <= c; i++) if (lastRow[i] == toX && path[i][toX] == toY) run(i, toX - 1, path[i][toX - 1]); } for (int i = 1; i <= r; i++) { for (int j = 1; j <= c; j++) cout << g[i][j]; cout << endl; } return 0; }\"]},\"319\":{\"h\":\"[CSP-J2020] 表达式\",\"t\":[\"#include <bits/stdc++.h> using namespace std; string s; stack<int> sta; int a[1000005]; int son[1000005][2], tot; int flag[1000005], c[1000005]; int n, q; int dfs(int u, int g) { a[u] ^= g; if (u <= n) { return a[u]; } int x = dfs(son[u][0], g ^ flag[son[u][0]]); int y = dfs(son[u][1], g ^ flag[son[u][1]]); if (a[u] == 2) { if (x == 0) c[son[u][1]] = 1; if (y == 0) c[son[u][0]] = 1; return x & y; } else { if (x == 1) c[son[u][1]] = 1; if (y == 1) c[son[u][0]] = 1; return x | y; } } void dfs2(int u) { if (u <= n) return; c[son[u][0]] |= c[u]; c[son[u][1]] |= c[u]; dfs2(son[u][0]); dfs2(son[u][1]); } int main() { ios::sync_with_stdio(false); cin.tie(0); getline(cin, s); cin >> n; tot = n; for (int i = 1; i <= n; i++) cin >> a[i]; for (int i = 0; i < s.length(); i += 2) { if (s[i] == 'x') { int x = 0; i++; while (s[i] != ' ') { x = x * 10 + s[i] - '0'; i++; } i--; sta.push(x); } else if (s[i] == '&') { int x = sta.top(); sta.pop(); int y = sta.top(); sta.pop(); sta.push(++tot); a[tot] = 2; son[tot][0] = x; son[tot][1] = y; } else if (s[i] == '|') { int x = sta.top(); sta.pop(); int y = sta.top(); sta.pop(); sta.push(++tot); a[tot] = 3; son[tot][0] = x; son[tot][1] = y; } else if (s[i] == '!') { flag[sta.top()] ^= 1; } } int ans = dfs(tot, flag[tot]); dfs2(tot); cin >> q; while (q--) { int x; cin >> x; if (c[x]) cout << ans << \\\"\\\\n\\\"; else cout << !ans << \\\"\\\\n\\\"; } return 0; }\"]},\"320\":{\"h\":\"[JOI 2021 Final] とてもたのしい家庭菜園 4\",\"t\":[\"// O(n^2) 超时代码 #include <bits/stdc++.h> using namespace std; int n; int a[200005]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; long long ans = -1; // 以 a[mid] 作为最高点 for (int mid = 1; mid <= n; mid++) { // left 次的左边某个数到 mid 的 +1 让左边递增 // right 次的右边某个数到 mid 的 +1 让右边递减 long long left = 0; long long right = 0; for (int i = 2; i <= mid; i++) if (a[i] <= a[i - 1]) left += a[i - 1] - a[i] + 1; for (int i = mid; i <= n - 1; i++) if (a[i] <= a[i + 1]) right += a[i + 1] - a[i] + 1; // 左右的区间 +1 可以衔接上 long long now = max(left, right); if (ans == -1 || now < ans) ans = now; } cout << ans; return 0; }\",\"// O(n)，预处理 left[],right[] #include <bits/stdc++.h> using namespace std; int n; int a[200005]; long long _left[200005]; long long _right[200005]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; // 预处理 left[],right[] _left[1] = 0; for (int i = 2; i <= n; i++) if (a[i] <= a[i - 1]) _left[i] = _left[i - 1] + (a[i - 1] - a[i] + 1); else _left[i] = _left[i - 1]; _right[n] = 0; for (int i = n - 1; i >= 1; i--) if (a[i] <= a[i + 1]) _right[i] = _right[i + 1] + (a[i + 1] - a[i] + 1); else _right[i] = _right[i + 1]; long long ans = -1; // 以 a[mid] 作为最高点 for (int mid = 1; mid <= n; mid++) { // left 次的左边某个数到 mid 的 +1 让左边递增 // right 次的右边某个数到 mid 的 +1 让右边递减 long long now = max(_left[mid], _right[mid]); if (ans == -1 || now < ans) ans = now; } cout << ans; return 0; }\",\"#include <bits/stdc++.h> using namespace std; long long n, a[200005]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; // a[1] 作为最高点的答案 long long left = 0; long long right = 0; for (int i = 2; i <= n; i++) if (a[i] >= a[i - 1]) right += a[i] - a[i - 1] + 1; // 记录最小的答案 long long ans = max(left, right); // 调整最高点，从 i-1 调整到 i for (int i = 2; i <= n; i++) { // 左边多了一个 a[i-1]~a[i] 需要递增 if (a[i] <= a[i - 1]) left += a[i - 1] - a[i] + 1; // 左边少了一个 a[i-1]~a[i] 递减的需求 if (a[i] >= a[i - 1]) right -= a[i] - a[i - 1] + 1; // 更新答案 ans = min(ans, max(left, right)); } cout << ans; return 0; }\"]},\"321\":{\"h\":\"[CSP-J 2021] 小熊的果篮\",\"t\":[\"#include<bits/stdc++.h> using namespace std; const int MAXN = 200000+5; int n; int a[MAXN]; int tot;//水果数量 int nxt[MAXN]; //下一个水果 int pre[MAXN]; //上一个水果 int tott;//块的数量 int firt;//第一块的块编号 int head[MAXN];//当前块的第一个水果 int tail[MAXN];//当前块的最后一个水果 int pret[MAXN];//上一块的编号 int nxtt[MAXN];//下一块的编号 int main(){ ios::sync_with_stdio(false); cin.tie(0); //freopen(\\\"fruit.in\\\",\\\"r\\\",stdin); //freopen(\\\"fruit.out\\\",\\\"w\\\",stdout); cin>>n; for(int i=1;i<=n;i++){ cin>>a[i]; nxt[i]=i+1; pre[i]=i-1; } nxt[n]=0; pre[1]=0; tot=n; //初始化分块 firt=1; tott=1; head[1]=1; tail[1]=1; nxtt[1]=0; pret[1]=0; for(int i=2;i<=n;i++){ if(a[i]==a[i-1]){ tail[tott]++; }else{ nxtt[tott]=tott+1; pret[tott+1]=tott; tott++; head[tott]=i; tail[tott]=i; nxtt[tott]=0; } } while(tot>0){ //输出每个块的第一个水果，修改水果数量 for(int i=firt;i!=0;i=nxtt[i]){ cout<<head[i]<<\\\" \\\"; tot--; } cout<<\\\"\\\\n\\\"; //修改水果连接关系，删除大小为1的块 for(int i=firt;i!=0;i=nxtt[i]) { pre[nxt[head[i]]]= pre[head[i]]; nxt[pre[head[i]]]= nxt[head[i]]; if(head[i]==tail[i]){ if(i==firt) firt=nxtt[i]; pret[nxtt[i]]=pret[i]; nxtt[pret[i]]=nxtt[i]; } else head[i]=nxt[head[i]]; } //合并同类块 for(int i=nxtt[firt];i!=0;i=nxtt[i]) { int j=pret[i]; if(a[head[i]]==a[head[j]]){ tail[j]=tail[i]; pret[nxtt[i]]=pret[i]; nxtt[pret[i]]=nxtt[i]; } } /* for(int i=firt;i!=0;i=nxtt[i]) cout<<i<<\\\" \\\"<<head[i]<<\\\"~\\\"<<tail[i]<< \\\" \\\"<<pret[i]<<\\\":\\\"<<nxtt[i]<<endl; cout<<\\\"-----------------\\\"<<endl; */ } return 0; }\"]},\"322\":{\"h\":\"上海月赛 24 年 12 月丙组\"},\"323\":{\"h\":\"你画我猜\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { int n; cin >> n; if (6 <= n && n <= 8) cout << \\\"Yes\\\\n\\\"; else cout << \\\"No\\\\n\\\"; return 0; }\"]},\"324\":{\"h\":\"最长连签\",\"t\":[\"算两次最长连续非零子串。\",\"基础做法就是记录当前连续长度和答案，遇到非零就加一，遇到零就说明上一段结束了。\",\"#include <bits/stdc++.h> using namespace std; int T; int n, x; int main() { cin >> T; while (T--) { cin >> n; int nowA, ansA, nowB, ansB; nowA = ansA = 0; for (int i = 1; i <= n; i++) { cin >> x; if (x) nowA++; else { ansA = max(ansA, nowA); nowA = 0; } } ansA = max(ansA, nowA); nowB = ansB = 0; for (int i = 1; i <= n; i++) { cin >> x; if (x) nowB++; else { ansB = max(ansB, nowB); nowB = 0; } } ansB = max(ansB, nowB); if (ansA > ansB) cout << \\\"Bob\\\\n\\\"; else if (ansB > ansA) cout << \\\"Bella\\\\n\\\"; else cout << \\\"Draw\\\\n\\\"; } return 0; }\"]},\"325\":{\"h\":\"充电问题\",\"t\":[\"这题读题容易读错导致觉得是很难的题。如果每个插座充完一辆车能继续下一辆的话，就会相对麻烦很多。但作为丙组第三题不可能那么难，所以仔细读题后会注意到只能配对一次。\",\"所以直接贪心充的快的充容量大的就好了。\",\"#include <bits/stdc++.h> using namespace std; const int MAXN = 100000; int T; int n, m, h; int a[MAXN + 5]; int b[MAXN + 5]; bool cmp(int x, int y) { return x > y; } int main() { cin >> T; while (T--) { cin >> n >> m >> h; for (int i = 1; i <= n; i++) cin >> a[i]; for (int i = 1; i <= m; i++) cin >> b[i]; sort(a + 1, a + n + 1, cmp); sort(b + 1, b + m + 1, cmp); int ans = 0; for (int i = 1; i <= min(n, m); i++) { ans += min(a[i], b[i] * h); } cout << ans << \\\"\\\\n\\\"; } return 0; }\"]},\"326\":{\"h\":\"找子序列\",\"t\":[\"因为希望按位与运算后为 ，所以所有 a[i] & m != a[i] 的 a[i] 都是不能选的，只要选了一个最后的与运算和就肯定得不到 。\",\"那满足条件的 中该选哪些呢？显然全都要选。满足条件的这些与在一起肯定还是包含 的，且数越多、与运算的结果越不会有多余的数位。\",\"#include <bits/stdc++.h> using namespace std; int T, n, m, ai; int main() { cin >> T; while (T--) { cin >> n >> m; int sum = -1; for (int i = 1; i <= n; i++) { cin >> ai; if ((ai & m) == m) sum = sum & ai; } if (sum == m) cout << \\\"Yes\\\\n\\\"; else cout << \\\"No\\\\n\\\"; } return 0; }\"]},\"327\":{\"h\":\"查找 404\"},\"328\":{\"h\":\"简化版问题的做法\",\"t\":[\"如果没有 * 那其实很简单，是一个经典的数数题。一般常见的思路是看结尾或者看中间的位置。如果看结尾，那遇到 时，前面有多少种 就能组成多少个 ，所以要统计前面 的总数，而 的总数就根据每个 前面 的总数即可。所以会有一个简单的做法：\",\"cnt4[i] = cnt4[i - 1]; cnt40[i] = cnt40[i - 1]; cnt404[i] = cnt404[i - 1]; if (s[i] == '4') { cnt4[i] ++; cnt404[i] += cnt40[i]; } else cnt40[i] += cnt4[i];\",\"当然也可以枚举中间的 ，每个 能构成的 的数量根据乘法原理就是它前面 的数量乘以后面 的数量。\"]},\"329\":{\"h\":\"本题思路\",\"t\":[\"和上面简化版题目的做法类似，无非是当前会出现 ，那就看 表示什么就好了。这就有了 时间复杂度的做法了，枚举所有可能性。\",\"实际上完全可以用和前面类似的方法。\",\"如果在 结尾时数，那 和 都可以结尾，仍然加前面的 的数量就好。唯一需要注意的时组成 后还要看看这个 在多少个序列中出现过，如果这个 没用到 ，那就出现了 次，如果用到了一个 ，那就出现了 次，以此类推。\",\"我的写法是在中间位置数，我觉得更清晰。每次遇到 时看前面多少种 ，后面多少种 乘起来，然后再看看用到了几个 即可。所以只需要统计前缀 的数量和后缀 的数量即可。\",\"其实 pre0[] nxt0[] 没必要算，但随手保留了。\",\"#include <bits/stdc++.h> #define int long long using namespace std; const int MOD = 1'000'000'000 + 7; const int MAXN = 100000; int T, n, cntStarAll, cntStar; string s; int two[MAXN + 5]; // pre4[i]: s[1]~s[i] 有几个 '4' // nxt4[i]: s[i]~s[n] 有几个 '4' int pre4[MAXN + 5], nxt4[MAXN + 5]; int pre0[MAXN + 5], nxt0[MAXN + 5]; int pre_[MAXN + 5], nxt_[MAXN + 5]; signed main() { two[0] = 1; for (int i = 1; i <= 100000; i++) two[i] = two[i - 1] * 2 % MOD; cin >> T; while (T--) { cin >> n; cin >> s; s = \\\"^\\\" + s; //---- init ---- cntStarAll = 0; for (int i = 1; i <= n; i++) if (s[i] == '*') cntStarAll++; pre4[0] = pre0[0] = pre_[0] = 0; for (int i = 1; i <= n; i++) { pre4[i] = pre4[i - 1] + (s[i] == '4'); pre0[i] = pre0[i - 1] + (s[i] == '0'); pre_[i] = pre_[i - 1] + (s[i] == '*'); } nxt4[n + 1] = nxt0[n + 1] = nxt_[n + 1] = 0; for (int i = n; i >= 1; i--) { nxt4[i] = nxt4[i + 1] + (s[i] == '4'); nxt0[i] = nxt0[i + 1] + (s[i] == '0'); nxt_[i] = nxt_[i + 1] + (s[i] == '*'); } //---- work ---- int ans = 0; for (int i = 2; i <= n - 1; i++) { if (s[i] == '4') continue; if (s[i] == '0') cntStar = cntStarAll; if (s[i] == '*') cntStar = cntStarAll - 1; if (s[i] == '0' || s[i] == '*') { // 404 ans += pre4[i - 1] * nxt4[i + 1] % MOD * two[cntStar] % MOD; ans %= MOD; // *04 or 40* if (cntStar == 0) continue; ans += pre_[i - 1] * nxt4[i + 1] % MOD * two[cntStar - 1] % MOD; ans %= MOD; ans += pre4[i - 1] * nxt_[i + 1] % MOD * two[cntStar - 1] % MOD; ans %= MOD; // *0* if (cntStar == 1) continue; ans += pre_[i - 1] * nxt_[i + 1] % MOD * two[cntStar - 2] % MOD; ans %= MOD; } } cout << ans << \\\"\\\\n\\\"; } return 0; }\"]},\"330\":{\"h\":\"ABC385\"},\"331\":{\"h\":\"D - Santa Claus 2\",\"t\":[\"#include <bits/stdc++.h> #define int long long using namespace std; int n, m, sx, sy; map<int, set<int>> xx, yy; int ans = 0; // 摧毁 (x,l~r) 上的房子，并计数 void checkX(int x, int l, int r) { while (1) { auto p = xx[x].lower_bound(l); if (p != xx[x].end() && *p <= r) { ans++; xx[x].erase(p); yy[*p].erase(x); } else { break; } } } // 摧毁 (l~r,y) 上的房子，并计数 void checkY(int y, int l, int r) { while (1) { auto p = yy[y].lower_bound(l); if (p != yy[y].end() && *p <= r) { ans++; yy[y].erase(p); xx[*p].erase(y); } else { break; } } } signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m >> sx >> sy; for (int i = 1; i <= n; i++) { int x, y; cin >> x >> y; xx[x].insert(y); yy[y].insert(x); } ans = 0; for (int i = 1; i <= m; i++) { char op; int len; cin >> op >> len; if (op == 'U') { checkX(sx, sy, sy + len); sy += len; } if (op == 'D') { checkX(sx, sy - len, sy); sy -= len; } if (op == 'L') { checkY(sy, sx - len, sx); sx -= len; } if (op == 'R') { checkY(sy, sx, sx + len); sx += len; } } cout << sx << \\\" \\\" << sy << \\\" \\\" << ans; return 0; }\"]},\"332\":{\"h\":\"ABC387\"},\"333\":{\"h\":\"A - Happy New Year 2025\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(0); int a, b; cin >> a >> b; cout << (a + b) * (a + b); return 0; }\"]},\"334\":{\"h\":\"B - 9x9 Sum\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int cnt[9 * 9 + 5]; int main() { ios::sync_with_stdio(false); cin.tie(0); int sum, n; sum = 0; for (int i = 1; i <= 9; i++) for (int j = 1; j <= 9; j++) { cnt[i * j]++; sum += i * j; } cin >> n; cout << sum - n * cnt[n]; return 0; }\"]},\"335\":{\"h\":\"C - Snake Numbers\",\"t\":[\"实际上可以套一个数位 DP 的板子。当然也可以按照我的方式，手动算。\",\"#include <bits/stdc++.h> #define int long long using namespace std; // f[i][j]: i 开头的 j 位数有多少个蛇数 // 实际上就是 j-1 位可以是 0~i-1，i^{j-1} int f[10][20]; // 返回 1~x 有多少个蛇数 int len, num[20]; int cal(int x) { len = 0; while (x > 0) { num[++len] = x % 10; x /= 10; } if (len < 2) return 0; int res = 0; // 所有小于 len 位的都行 for (int i = 1; i <= 9; i++) for (int j = 2; j <= len - 1; j++) res += f[i][j]; // 恰好 len 位且最高位小于 num[len] 的 for (int i = 1; i <= num[len] - 1; i++) res += f[i][len]; // 恰好 len 位且最高位就是 num[len] 的 for (int i = len - 1; i >= 1; i--) { // 此时后面的方案数，相当于第 i 位是 0~now 时后面随便填 0~num[len]-1 // 每种第 i 位的选择都恰好有 num[len]^(i-1) 这么多种方案 int now = min(num[i], num[len]); res += now * f[num[len]][i]; // 第 i 位能不能取到上限 num[i] if (num[i] >= num[len]) break; // 完整的自己本身 if (i == 1) res++; } return res; } signed main() { ios::sync_with_stdio(false); cin.tie(0); for (int i = 1; i <= 9; i++) for (int j = 1; j <= 19; j++) { f[i][j] = 1; for (int k = 1; k <= j - 1; k++) f[i][j] *= i; } int l, r; cin >> l >> r; cout << cal(r) - cal(l - 1) << \\\"\\\\n\\\"; return 0; }\"]},\"336\":{\"h\":\"D - Snaky Walk\",\"t\":[\"传统走迷宫的基础上，不允许同样的方向，那就多记录一下上一步的方向就好了。\",\"#include <bits/stdc++.h> using namespace std; const int MAXN = 1000; int h, w, sx, sy, ex, ey; char g[MAXN + 5][MAXN + 5]; int dx[] = {0, 1, 0, -1}; int dy[] = {1, 0, -1, 0}; int f[MAXN + 5][MAXN + 5][5]; queue<int> qx; queue<int> qy; queue<int> qt; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> h >> w; for (int i = 1; i <= h; i++) for (int j = 1; j <= w; j++) { cin >> g[i][j]; if (g[i][j] == 'S') sx = i, sy = j; if (g[i][j] == 'G') ex = i, ey = j; } for (int i = 0; i < 4; i++) { qx.push(sx); qy.push(sy); qt.push(i); f[sx][sy][i] = 1; } while (!qx.empty()) { int x = qx.front(); int y = qy.front(); int t = qt.front(); qx.pop(), qy.pop(), qt.pop(); for (int i = 0; i < 4; i++) { if (i % 2 == t % 2) continue; int nx = x + dx[i]; int ny = y + dy[i]; if (nx < 1 || nx > h || ny < 1 || ny > w || g[nx][ny] == '#' || f[nx][ny][i]) continue; f[nx][ny][i] = f[x][y][t] + 1; qx.push(nx); qy.push(ny); qt.push(i); } } int ans = 0; for (int i = 0; i < 4; i++) if (f[ex][ey][i] && (ans == 0 || f[ex][ey][i] < ans)) ans = f[ex][ey][i]; cout << ans - 1; return 0; }\"]},\"337\":{\"h\":\"ABC389\"},\"338\":{\"h\":\"D - Squares in Circle\",\"t\":[\"#include <bits/stdc++.h> #define int long long using namespace std; int R; signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> R; int h = R; int ans = 0; for (int i = 0; i < R; i++) { // / | // / | // R h+0.5 // / | // --0.5+i-- while (h > 0 && (h + 0.5) * (h + 0.5) + (i + 0.5) * (i + 0.5) > R * R) h--; ans += h; } cout << 4 * ans + 1; return 0; }\"]},\"339\":{\"h\":\"ABC390\"},\"340\":{\"h\":\"E - Vitamin Balance\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n, x; // <维生素量,卡路里量> // a[1] 存维生素 1，a[2] ~ vector<pair<int, int>> a[5]; // [typ][i][j] 第 typ 种维生素 // 前 i 个，在 j 的卡路里时，最多能拿到多少维生素量 int f[5][5005][5005]; // 三种维生素，都拿到 low 及以上的量，能否在 x 的卡路里以内完成 bool check(int low) { int sum = 0; for (int typ = 1; typ <= 3; typ++) { if (f[typ][a[typ].size()][x] < low) return false; int now; // 第 typ 中维生素达到 low 及以上的量的最小卡路里 int l = 0; int r = x; while (l <= r) { int mid = (l + r) / 2; if (f[typ][a[typ].size()][mid] >= low) { now = mid; r = mid - 1; } else l = mid + 1; } sum += now; } return sum <= x; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> x; for (int i = 1; i <= n; i++) { int vi, ai, ci; cin >> vi >> ai >> ci; a[vi].push_back(make_pair(ai, ci)); } for (int typ = 1; typ <= 3; typ++) { for (int i = 1; i <= a[typ].size(); i++) { int v = a[typ][i - 1].first; // typ 维生素的第 i 个的维生素量 int c = a[typ][i - 1].second; // ~ 卡路里量 for (int j = 0; j <= x; j++) { if (j < c) f[typ][i][j] = f[typ][i - 1][j]; else f[typ][i][j] = max(f[typ][i - 1][j], f[typ][i - 1][j - c] + v); } } } int l = 0; int r = 1'000'000'000; int ans = -1; while (l <= r) { int mid = (l + r) / 2; if (check(mid)) { ans = mid; l = mid + 1; } else r = mid - 1; } cout << ans; return 0; }\"]},\"341\":{\"h\":\"ABC391\"},\"342\":{\"h\":\"D - Gravity\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXW = 200000; const int MAXN = 200000; int n, w; // q[i] 存第 i 列的方块的行数的相反数（小根堆）以及编号 priority_queue<pair<int, int>> q[MAXW + 5]; // ans[i] 记录第 i 个方格的消失时间 int ans[MAXN + 5]; int main() { cin >> n >> w; for (int i = 1; i <= n; i++) { int xi, yi; // 列、行 cin >> xi >> yi; q[xi].push(make_pair(-yi, i)); ans[i] = 0; } for (bool flag = true; flag;) { // 找到当前最后一行啥时候能消除 int now = -1; for (int i = 1; i <= w; i++) { if (q[i].empty()) { now = -1; break; } now = max(now, -q[i].top().first); } if (now == -1) break; for (int i = 1; i <= w; i++) { pair<int, int> block = q[i].top(); q[i].pop(); ans[block.second] = now; } } int Q; cin >> Q; while (Q--) { int ti, ai; cin >> ti >> ai; if (ans[ai] != 0 && ans[ai] <= ti) cout << \\\"No\\\\n\\\"; else cout << \\\"Yes\\\\n\\\"; } return 0; }\"]},\"343\":{\"h\":\"E - Hierarchical Majority Vote\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n; string A; // <数字，几次能反转> queue<pair<int, int>> q, qq; // 三个数的计算，返回<变成了几，操作几次可以反转> pair<int, int> f(pair<int, int> a, pair<int, int> b, pair<int, int> c) { pair<int, int> res; int now = a.first + b.first + c.first; int cnt = a.second + b.second + c.second; res.first = (now >= 2); if (now == 3 || now == 0) { // 反转两个操作次数最少的（找到一个操作次数最多的） int maxSe = a.second; maxSe = max(maxSe, b.second); maxSe = max(maxSe, c.second); res.second = cnt - maxSe; } else { // 找一个最小的 x（0或1） 反转 int x = (now == 2); int minSe = cnt; if (a.first == x) minSe = min(minSe, a.second); if (b.first == x) minSe = min(minSe, b.second); if (c.first == x) minSe = min(minSe, c.second); res.second = minSe; } return res; } int main() { cin >> n; cin >> A; for (int i = 0; i < A.size(); i++) q.push(make_pair(A[i] - '0', 1)); for (int i = 1; i <= n; i++) { while (!q.empty()) { pair<int, int> a, b, c; a = q.front(); q.pop(); b = q.front(); q.pop(); c = q.front(); q.pop(); qq.push(f(a, b, c)); } swap(q, qq); } cout << q.front().second << \\\"\\\\n\\\"; return 0; }\"]},\"344\":{\"h\":\"ABC408\"},\"345\":{\"h\":\"A - Timeout\",\"t\":[\"简单的枚举\",\"#include <bits/stdc++.h> using namespace std; int n, s; int last, now; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> s; last = 0; for (int i = 1; i <= n; i++) { cin >> now; if (now - last > s) { cout << \\\"No\\\"; return 0; } last = now; } cout << \\\"Yes\\\"; return 0; }\"]},\"346\":{\"h\":\"B - Compression\",\"t\":[\"排序去重输出，经典的明明的随机数。这里数据范围也很友好，计数排序、其他排序以及 C++ 自带的去重都可以实现。这里把几种写法都给大家看看。\"]},\"347\":{\"h\":\"普通排序\",\"t\":[\"这题 其他排序方法都能做\",\"#include <bits/stdc++.h> using namespace std; const int MAXN = 100; int n; int a[MAXN + 5]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; sort(a + 1, a + n + 1); int nn = 1; for (int i = 2; i <= n; i++) if (a[i] != a[i - 1]) nn++; cout << nn << \\\"\\\\n\\\"; cout << a[1]; for (int i = 2; i <= n; i++) if (a[i] != a[i - 1]) cout << \\\" \\\" << a[i]; return 0; }\"]},\"348\":{\"h\":\"计数排序\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 100; const int MAXAI = 100; int n; int a[MAXN + 5]; int cnt[MAXAI + 5]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) { cin >> a[i]; cnt[a[i]]++; } int nn = 0; for (int i = 1; i <= MAXAI; i++) nn += (cnt[i] > 0); cout << nn << \\\"\\\\n\\\"; for (int i = 1; i <= MAXAI; i++) if (cnt[i] > 0) cout << i << \\\" \\\"; return 0; }\"]},\"349\":{\"h\":\"C++ 自带的去重\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 100; const int MAXAI = 100; int n; int a[MAXN + 5]; int cnt[MAXAI + 5]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; // unique 要求对有序数组操作 // 不会改变数组大小，而是返回去重后的结尾位置（去重后数组不包括结尾） // 减去 a 之后再减 1 就能转变为去重后最后一个元素位置的下标 sort(a + 1, a + n + 1); int nn = unique(a + 1, a + n + 1) - a - 1; // 简单的输出 cout << nn << \\\"\\\\n\\\"; for (int i = 1; i <= nn; i++) cout << a[i] << \\\" \\\"; return 0; }\"]},\"350\":{\"h\":\"C - Not All Covered\",\"t\":[\"显然就是看哪个城墙被覆盖的炮塔最少，直接暴力枚举去计算覆盖肯定是不行，实际上容易想到就是进行“区间加一”和最终“求解全局最小值”。使用差分数组就能快速搞定了。\",\"#include <bits/stdc++.h> using namespace std; const int MAXN = 1000000; int n, m; int d[MAXN + 5]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m; for (int i = 1; i <= m; i++) { int l, r; cin >> l >> r; d[l]++; d[r + 1]--; } for (int i = 1; i <= n; i++) d[i] = d[i - 1] + d[i]; int ans = m; // 炮塔全拆了肯定行 for (int i = 1; i <= n; i++) ans = min(ans, d[i]); cout << ans; return 0; }\"]},\"351\":{\"h\":\"D - Flip to Gather\",\"t\":[\"这题最大的难点在于题意容易理解错误，at most one interval 如果翻译为最多一个间隔，容易理解为是允许 00011011000 这样的中间留一个位置的。并且按照这个理解很多样例数据都能正确解释。\",\"但最后一组样例数据 00010101 的正确输出是 2，就能让我们知道实际的意思是 1 必须是连续的一段。\",\"那这题就没啥难的了。\",\"#include <bits/stdc++.h> using namespace std; const int MAXN = 200000; int n; string s; int cnt1[MAXN + 5], cnt0[MAXN + 5]; // f[i]：a[1]~a[i] 中只有右边有 1 最少花几次 int f[MAXN + 5]; void work() { cin >> n >> s; s = \\\"^\\\" + s; // 预处理 cnt* cnt1[0] = cnt0[0] = f[0] = 0; for (int i = 1; i <= n; i++) { cnt1[i] = cnt1[i - 1] + (s[i] == '1'); cnt0[i] = cnt0[i - 1] + (s[i] == '0'); // 左边位置要么 0 结尾、要么 1 结尾 f[i] = min(f[i - 1], cnt1[i - 1]) + (s[i] == '0'); } // 算答案 int ans = cnt1[n]; // 最坏情况，删掉所有 1 for (int i = 1; i <= n; i++) { // a[1]~a[i] 的右边堆积了 1，a[i] 的右边 0 全都删掉 ans = min(ans, f[i] + (cnt1[n] - cnt1[i])); } cout << ans << \\\"\\\\n\\\"; } int main() { ios::sync_with_stdio(false); cin.tie(0); int T; cin >> T; while (T--) work(); return 0; }\"]},\"352\":{\"h\":\"E - Minimum OR Path\",\"t\":[\"首先显然如果最高位为 能连通，我们就肯定会选择最高位为 的方案。因此容易想到位数从高到低贪心，看看在当前对边的要求下能否连通。\",\"判断连通性可以上并查集或者简单的搜索都行，反正最多只有 次检查。\",\"#include <bits/stdc++.h> using namespace std; const int MAXN = 200000; int n, m; vector<pair<int, int>> e[MAXN + 5]; // 检测当前 mask 下能否从 u 走到 n、也可以写 bfs 实现 int flag, vis[MAXN + 5]; // int 型 vis 配合 flag 避免每次都要重新清空 bool ok(int u, int mask) { vis[u] = flag; if (u == n) return true; for (int i = 0; i < e[u].size(); i++) { int v = e[u][i].first; int w = e[u][i].second; if (vis[v] == flag) continue; // 过滤做过的点 if ((w & mask) != w) continue; // 过滤非法的边 if (ok(v, mask)) return true; } return false; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m; for (int i = 1; i <= m; i++) { int u, v, w; cin >> u >> v >> w; e[u].push_back({v, w}); e[v].push_back({u, w}); } int ans = (1 << 30) - 1; for (int i = 29; i >= 0; i--) { // 检查去掉第 i 位的 1 能否从 1 走到 n flag++; if (ok(1, ans - (1 << i))) ans -= (1 << i); } cout << ans; return 0; }\"]},\"353\":{\"h\":\"AtCoder Educational DP Contest 题解\"},\"354\":{\"h\":\"A. Frog 1\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 100000 + 5; const int INF = 1000000000; int n; int h[MAXN + 5]; int f[MAXN + 5]; // f[i] 走到 i 的时候的最小代价 int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> h[i]; f[1] = 0; for (int i = 2; i <= n; i++) { f[i] = INF; if (i >= 2) f[i] = min(f[i], f[i - 1] + abs(h[i] - h[i - 1])); if (i >= 3) f[i] = min(f[i], f[i - 2] + abs(h[i] - h[i - 2])); } cout << f[n]; return 0; }\"]},\"355\":{\"h\":\"B. Frog 2\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 100000; const int INF = 1000000000; int n, k; int h[MAXN + 5]; int f[MAXN + 5]; // f[i] 走到 i 的时候的最小代价 int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> k; for (int i = 1; i <= n; i++) cin >> h[i]; f[1] = 0; for (int i = 2; i <= n; i++) { f[i] = INF; for (int j = i - 1; j >= max(1, i - k); j--) f[i] = min(f[i], f[j] + abs(h[i] - h[j])); } cout << f[n]; return 0; }\"]},\"356\":{\"h\":\"C. Vacation\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 100000; int n; int a[MAXN + 5], b[MAXN + 5], c[MAXN + 5]; int fa[MAXN + 5], fb[MAXN + 5], fc[MAXN + 5]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> a[i] >> b[i] >> c[i]; for (int i = 1; i <= n; i++) { fa[i] = max(fb[i - 1], fc[i - 1]) + a[i]; fb[i] = max(fa[i - 1], fc[i - 1]) + b[i]; fc[i] = max(fa[i - 1], fb[i - 1]) + c[i]; } cout << max(fa[n], max(fb[n], fc[n])); return 0; }\"]},\"357\":{\"h\":\"D. Knapsack 1\"},\"358\":{\"h\":\"递推\",\"t\":[\"#include <bits/stdc++.h> #define int long long using namespace std; const int MAXN = 100; const int MAXW = 100000; int n, W; // 物品数量、背包容量 int w[MAXN + 5], v[MAXN + 5]; // 重量、价值 int f[MAXW + 5]; // 每个容量下的最大价值 signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> W; for (int i = 1; i <= n; i++) cin >> w[i] >> v[i]; for (int i = 1; i <= n; i++) for (int j = W; j >= w[i]; j--) f[j] = max(f[j], f[j - w[i]] + v[i]); cout << f[W]; return 0; }\"]},\"359\":{\"h\":\"记忆化搜索\",\"t\":[\"#include <bits/stdc++.h> #define int long long using namespace std; int n, W; int w[105], v[105]; // 前 nn 件物品在 ww 重量限制下的最大价值 int book[105][100005]; int f(int nn, int ww) { if (book[nn][ww] != -1) return book[nn][ww]; if (nn == 0) return 0; int res = 0; // 不用第 nn 件物品 res = max(res, f(nn - 1, ww)); // 用第 nn 件物品 if (w[nn] <= ww) res = max(res, f(nn - 1, ww - w[nn]) + v[nn]); return book[nn][ww] = res; } signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> W; for (int i = 1; i <= n; i++) cin >> w[i] >> v[i]; for (int i = 0; i <= n; i++) for (int j = 0; j <= W; j++) book[i][j] = -1; cout << f(n, W); return 0; }\"]},\"360\":{\"h\":\"E. Knapsack 2\"},\"361\":{\"h\":\"二维形式\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n, W; int w[105], v[105]; // f[i][j]: 前 i 件物品，得到 j 的价值：需要的最少重量 int f[105][100005]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> W; for (int i = 1; i <= n; i++) cin >> w[i] >> v[i]; for (int j = 0; j <= 100000; j++) f[0][j] = W + 1; f[0][0] = 0; for (int i = 1; i <= n; i++) for (int j = 0; j <= 100000; j++) { if (j < v[i]) f[i][j] = f[i - 1][j]; else f[i][j] = min(f[i - 1][j], f[i - 1][j - v[i]] + w[i]); } int ans = 0; for (int i = 0; i <= 100000; i++) if (f[n][i] <= W) ans = i; cout << ans; return 0; }\"]},\"362\":{\"h\":\"化掉第一维\",\"t\":[\"#include <bits/stdc++.h> #define int long long using namespace std; const int MAXN = 100; const int MAXV = 100 * 1000; int n, W; // 物品数量、背包容量 int w[MAXN + 5], v[MAXN + 5]; // 重量、价值 int f[MAXV + 5]; // 每个价值的最小重量 signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> W; for (int i = 1; i <= n; i++) cin >> w[i] >> v[i]; // 初始化，只有 0 的价值不需要重量能达到 f[0] = 0; for (int i = 1; i <= MAXV; i++) f[i] = W + 1; // dp for (int i = 1; i <= n; i++) for (int j = MAXV; j >= v[i]; j--) f[j] = min(f[j], f[j - v[i]] + w[i]); // 检查可以在 W 容量下达到的最大价值 for (int i = MAXV; i >= 0; i--) if (f[i] <= W) { cout << i; break; } return 0; }\"]},\"363\":{\"h\":\"F. LCS\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXLEN = 3000; string s, t; int f[MAXLEN + 5][MAXLEN + 5]; string ans; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> s >> t; for (int i = 1; i <= (int)s.size(); i++) for (int j = 1; j <= (int)t.size(); j++) { if (s[i - 1] == t[j - 1]) f[i][j] = f[i - 1][j - 1] + 1; else f[i][j] = max(f[i - 1][j], f[i][j - 1]); } int i = (int)s.size(); int j = (int)t.size(); ans = \\\"\\\"; while (i != 0 && j != 0) { if (s[i - 1] == t[j - 1]) { ans = s[i - 1] + ans; i--; j--; } else if (f[i - 1][j] > f[i][j - 1]) i--; else j--; } cout << ans; return 0; }\"]},\"364\":{\"h\":\"G. Longest Path\"},\"365\":{\"h\":\"利用记忆化搜索\",\"t\":[\"不用手动维护求解顺序了\",\"#include <bits/stdc++.h> using namespace std; const int MAXN = 100000; const int MAXM = 100000; int n, m; vector<int> e[MAXN + 5]; // u 为起点能走的最长路径 int book[MAXN + 5]; int f(int u) { if (book[u] != -1) return book[u]; int res = 0; for (int v : e[u]) res = max(res, f(v) + 1); return book[u] = res; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m; for (int i = 1; i <= m; i++) { int u, v; cin >> u >> v; e[u].push_back(v); } for (int i = 1; i <= n; i++) book[i] = -1; int ans = 0; for (int i = 1; i <= n; i++) ans = max(ans, f(i)); cout << ans; return 0; }\"]},\"366\":{\"h\":\"利用拓扑排序\",\"t\":[\"解决先求谁在求谁的问题。\",\"#include <bits/stdc++.h> using namespace std; const int MAXN = 100000; const int MAXM = 100000; int n, m; vector<int> e[MAXN + 5]; vector<int> ee[MAXN + 5]; // 存反向边（用来求解 f） // 以 i 为终点的路径数量 // f[i] = max(f[前一个点]+1); int f[MAXN + 5]; int d[MAXN + 5]; // 当前入度，用来求拓扑序，按照拓扑顺序求解 f queue<int> zero; // 当前入度为 0 的点 int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m; for (int i = 1; i <= m; i++) { int u, v; cin >> u >> v; e[u].push_back(v); ee[v].push_back(u); d[v]++; } for (int i = 1; i <= n; i++) if (d[i] == 0) zero.push(i); while (!zero.empty()) { int u = zero.front(); zero.pop(); // 求 f f[u] = 0; for (int v : ee[u]) f[u] = max(f[u], f[v] + 1); // 维护拓扑序 for (int v : e[u]) { d[v]--; if (d[v] == 0) zero.push(v); } } int ans = 0; for (int i = 1; i <= n; i++) ans = max(ans, f[i]); cout << ans; return 0; }\"]},\"367\":{\"h\":\"H. Grid 1\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MOD = 1'000'000'000 + 7; int n, m; char g[1005][1005]; int f[1005][1005]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m; for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) cin >> g[i][j]; f[1][1] = 1; for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) { if (i == 1 && j == 1) continue; if (g[i][j] != '#') f[i][j] = (f[i - 1][j] + f[i][j - 1]) % MOD; else f[i][j] = 0; } cout << f[n][m]; return 0; }\"]},\"368\":{\"h\":\"I. Coins\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n; double p[3000]; // f[i][j+3000] // 前 i 个硬币，正面比反面多 j 个的概率 double f[3000][6000]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> p[i]; f[0][0 + 3000] = 1; for (int i = 1; i <= n; i++) for (int j = -i; j <= i; j++) f[i][j + 3000] = f[i - 1][j - 1 + 3000] * p[i] + f[i - 1][j + 1 + 3000] * (1 - p[i]); double ans = 0; for (int i = 1; i <= n; i++) ans += f[n][i + 3000]; cout << fixed << setprecision(10) << ans; return 0; }\"]},\"369\":{\"h\":\"J. Sushi\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n; int cnt[5]; double f[305][305][305]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) { int x; cin >> x; cnt[x]++; } for (int i = 0; i <= n; i++) for (int j = 0; j <= n; j++) for (int k = 0; k <= n; k++) { if (i == 0 && j == 0 && k == 0) { f[i][j][k] = 0; continue; } int o = n - i - j - k; // f[i][j][k] = 1+ // (o/n)*f[i][j][k]+ // (i/n)*f[i-1][j+1][k]+ // (j/n)*f[i][j-1][k+1]+ // (k/n)*f[i][j][k-1] f[i][j][k] = 1; if (i != 0) f[i][j][k] += ((double)i / n) * f[i - 1][j + 1][k]; if (j != 0) f[i][j][k] += ((double)j / n) * f[i][j - 1][k + 1]; if (k != 0) f[i][j][k] += ((double)k / n) * f[i][j][k - 1]; f[i][j][k] *= ((double)n / (n - o)); } cout << fixed << setprecision(10) << f[cnt[3]][cnt[2]][cnt[1]]; return 0; }\"]},\"370\":{\"h\":\"K. Stones\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n, k; int a[105]; bool f[100000 + 5]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> k; for (int i = 1; i <= n; i++) cin >> a[i]; for (int i = 1; i <= k; i++) for (int j = 1; j <= n; j++) if (i - a[j] >= 0 && f[i - a[j]] == false) { f[i] = true; break; } if (f[k]) cout << \\\"First\\\"; else cout << \\\"Second\\\"; return 0; }\"]},\"371\":{\"h\":\"L. Deque\",\"t\":[\"#include <bits/stdc++.h> #define int long long using namespace std; int n; int a[3005]; int maxAns[3005][3005], minAns[3005][3005]; signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; for (int len = 1; len <= n; len++) { for (int l = 1; l + len - 1 <= n; l++) { int r = l + len - 1; if (len == 1) { minAns[l][r] = -a[l]; maxAns[l][r] = a[l]; continue; } minAns[l][r] = min(maxAns[l][r - 1] - a[r], maxAns[l + 1][r] - a[l]); maxAns[l][r] = max(minAns[l][r - 1] + a[r], minAns[l + 1][r] + a[l]); } } cout << maxAns[1][n]; return 0; }\"]},\"372\":{\"h\":\"M. Candies\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MOD = 1'000'000'000 + 7; int n, k; int a[105]; int f[105][100000 + 5]; int sum[105][100000 + 5]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> k; for (int i = 1; i <= n; i++) cin >> a[i]; f[0][0] = 1; sum[0][0] = f[0][0]; for (int i = 1; i <= k; i++) sum[0][i] = sum[0][i - 1] + f[0][i]; for (int i = 1; i <= n; i++) { for (int j = 0; j <= k; j++) { // f[i][j] = sum(f[i-1][j-0 ~ j-a[i]]) int l = max(j - a[i], 0); int r = j - 0; if (l == 0) f[i][j] = sum[i - 1][r]; else { f[i][j] = sum[i - 1][r] + MOD - sum[i - 1][l - 1]; f[i][j] %= MOD; } } sum[i][0] = f[i][0]; for (int j = 1; j <= k; j++) sum[i][j] = (sum[i][j - 1] + f[i][j]) % MOD; } cout << f[n][k]; return 0; }\"]},\"373\":{\"h\":\"N. Slimes\",\"t\":[\"#include <bits/stdc++.h> #define int long long using namespace std; int n; int a[405]; int sum[405]; int f[405][405]; signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; sum[1] = a[1]; for (int i = 2; i <= n; i++) sum[i] = sum[i - 1] + a[i]; for (int len = 1; len <= n; len++) for (int l = 1; l + len - 1 <= n; l++) { int r = l + len - 1; if (len == 1) { f[l][r] = 0; continue; } f[l][r] = f[l][l] + f[l + 1][r] + sum[r] - sum[l - 1]; for (int mid = l + 1; mid <= r - 1; mid++) f[l][r] = min(f[l][r], f[l][mid] + f[mid + 1][r] + sum[r] - sum[l - 1]); } cout << f[1][n]; return 0; }\"]},\"374\":{\"h\":\"O. Matching\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MOD = 1000000000 + 7; int n; int a[25][25]; int book[25][(1 << 21) + 5]; // 男生前 x 个人和 sta 这些人匹配的方案数 int dfs(int x, int sta) { if (book[x][sta] != -1) return book[x][sta]; if (x == 0) return 1; int res = 0; // 第 x 个男生和谁组合 for (int i = 1; i <= n; i++) { // 是否存在第 i 个女生 if ((sta & (1 << (i - 1))) == 0) continue; if (a[x][i] == 0) continue; res = (res + dfs(x - 1, sta - (1 << (i - 1)))) % MOD; } return book[x][sta] = res; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) cin >> a[i][j]; for (int i = 0; i <= n; i++) for (int j = 0; j <= (1 << n) - 1; j++) book[i][j] = -1; cout << dfs(n, (1 << n) - 1); return 0; }\"]},\"375\":{\"h\":\"P. Independent Set\",\"t\":[\"#include <bits/stdc++.h> #define int long long using namespace std; const int MAXN = 100000; const int MOD = 1000000000 + 7; int n; vector<int> e[MAXN + 5]; int f[MAXN + 5][2]; void dfs(int u, int fa) { f[u][0] = f[u][1] = 1; for (int v : e[u]) { if (v == fa) continue; dfs(v, u); f[u][1] = f[u][1] * f[v][0] % MOD; f[u][0] = f[u][0] * (f[v][0] + f[v][1]) % MOD; } } signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n - 1; i++) { int u, v; cin >> u >> v; e[u].push_back(v); e[v].push_back(u); } dfs(1, 0); cout << (f[1][0] + f[1][1]) % MOD; return 0; }\"]},\"376\":{\"h\":\"Q. Flowers\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n; int a[200000 + 5]; int h[200000 + 5]; long long f[200000 + 5]; int lowbit(int x) { return x & -x; } long long t[200000 + 5]; void update(int x, long long y) { for (int i = x; i <= n; i += lowbit(i)) t[i] = max(t[i], y); } long long query(int x) { long long res = t[x]; for (int i = x; i >= 1; i -= lowbit(i)) res = max(res, t[i]); return res; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> h[i]; for (int i = 1; i <= n; i++) cin >> a[i]; for (int i = 1; i <= n; i++) { f[i] = query(h[i] - 1) + a[i]; update(h[i], f[i]); } long long ans = 0; for (int i = 1; i <= n; i++) ans = max(ans, f[i]); cout << ans; return 0; }\"]},\"377\":{\"h\":\"R. Walk\",\"t\":[\"#include <bits/stdc++.h> #define int long long using namespace std; const int MOD = 1000000000 + 7; const int MAXR = 50; // 矩阵最大行数 const int MAXC = 50; // 矩阵最大列数 struct Mat { int r, c; // 行数列数 int m[MAXR + 1][MAXC + 1]; Mat() { memset(m, 0, sizeof(m)); } }; Mat operator*(const Mat &a, const Mat &b) { assert(a.c == b.r); Mat res; res.r = a.r, res.c = b.c; for (int i = 1; i <= a.r; i++) for (int k = 1; k <= a.c; k++) { int temp = a.m[i][k]; for (int j = 1; j <= b.c; j++) res.m[i][j] = (res.m[i][j] + temp * b.m[k][j]) % MOD; } return res; } Mat quick_pow(Mat a, int b) { assert(a.r == a.c); Mat res; res.r = res.c = a.r; for (int i = 1; i <= res.r; i++) res.m[i][i] = 1; while (b > 0) { if (b % 2) res = res * a; a = a * a; b = b / 2; } return res; } signed main() { ios::sync_with_stdio(false); cin.tie(0); int n, k; cin >> n >> k; Mat g; g.r = g.c = n; for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) cin >> g.m[i][j]; // 计算答案 g = quick_pow(g, k); int ans = 0; for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) ans = (ans + g.m[i][j]) % MOD; cout << ans << \\\"\\\\n\\\"; return 0; }\"]},\"378\":{\"h\":\"S. Digit Sum\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXLEN = 10000; const int MAXD = 100; const int MOD = 1'000'000'000 + 7; string sk; int D; int K[MAXLEN + 5], len; int book[MAXLEN + 5][MAXD]; int dfs(int pos, int modd, bool zero, bool limit) { if (pos < 0) return !zero && modd == 0; if (!zero && !limit && book[pos][modd] != -1) return book[pos][modd]; int up = limit ? K[pos] : 9; int res = 0; for (int now = 0; now <= up; now++) { // 第 pos 位选 i res += dfs(pos - 1, ((modd - now) % D + D) % D, zero && now == 0, limit && now == K[pos]); res %= MOD; } if (!zero && !limit) book[pos][modd] = res; return res; } int main() { memset(book, -1, sizeof(book)); cin >> sk >> D; len = sk.size(); for (int i = 0; i < len; i++) K[i] = sk[len - 1 - i] - '0'; cout << dfs(len - 1, 0, true, true); return 0; }\"]},\"379\":{\"h\":\"T. Permutation\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MOD = 1'000'000'000 + 7; int n; string s; int f[3005][3005]; int main() { cin >> n; cin >> s; f[1][1] = 1; for (int i = 2; i <= n; i++) for (int j = 1; j <= i; j++) { f[i][j] = 0; if (s[i - 2] == '>') for (int k = j; k <= i - 1; k++) { f[i][j] += f[i - 1][k]; f[i][j] %= MOD; } else for (int k = 1; k <= j - 1; k++) { f[i][j] += f[i - 1][k]; f[i][j] %= MOD; } } int ans = 0; for (int i = 1; i <= n; i++) ans = (ans + f[n][i]) % MOD; cout << ans; return 0; }\"]},\"380\":{\"h\":\"满分\",\"t\":[\"前缀和优化\",\"#include <bits/stdc++.h> using namespace std; const int MOD = 1'000'000'000 + 7; int n; string s; int f[3005][3005]; int sum[3005][3005]; int main() { cin >> n; cin >> s; f[1][1] = 1; sum[1][1] = 1; for (int i = 2; i <= n; i++) { for (int j = 1; j <= i; j++) { f[i][j] = 0; if (s[i - 2] == '>') f[i][j] = (sum[i - 1][i - 1] - sum[i - 1][j - 1] + MOD) % MOD; else f[i][j] = sum[i - 1][j - 1]; } for (int j = 1; j <= i; j++) sum[i][j] = (sum[i][j - 1] + f[i][j]) % MOD; } int ans = 0; for (int i = 1; i <= n; i++) ans = (ans + f[n][i]) % MOD; cout << ans; return 0; }\"]},\"381\":{\"h\":\"U. Grouping\",\"t\":[\"#include <bits/stdc++.h> #define int long long using namespace std; const int INF = 1'000'000'000'000'000'000; int n; int a[20][20]; int book1[(1 << 16) + 5]; int book2[(1 << 16) + 5]; int cal(int sta) { if (book1[sta] != INF) return book1[sta]; int res = 0; for (int i = 1; i <= n; i++) for (int j = i + 1; j <= n; j++) { if ((sta & (1 << (i - 1))) && (sta & (1 << (j - 1)))) res += a[i][j]; } return book1[sta] = res; } int dfs(int sta) { if (book2[sta] != INF) return book2[sta]; if (sta == 0) return 0; int res = 0; for (int choose = sta; choose > 0; choose = (choose - 1) & sta) res = max(res, dfs(sta - choose) + cal(choose)); return book2[sta] = res; } signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 0; i <= (1 << n) - 1; i++) book1[i] = book2[i] = INF; for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) cin >> a[i][j]; cout << dfs((1 << n) - 1); return 0; }\"]},\"382\":{\"h\":\"V. Subtree\"},\"383\":{\"h\":\"不考虑取模的代码提供思路\",\"t\":[\"#include <bits/stdc++.h> #define int long long using namespace std; const int MAXN = 100000; int n, m; vector<int> e[MAXN + 5]; int f[MAXN + 5]; // 1 为根节点时，节点 i 为黑色，子树 i 的涂色方案数 int g[MAXN + 5]; // i 为根节点时，节点 i 为黑色的涂色方案数 void dfs(int u, int fa) { f[u] = 1; for (int i = 0; i < e[u].size(); i++) { int v = e[u][i]; if (v == fa) continue; dfs(v, u); f[u] = f[u] * (f[v] + 1); } } void dfsdfs(int u, int fa) { if (fa) g[u] = f[u] * (g[fa] / (f[u] + 1) + 1); for (int i = 0; i < e[u].size(); i++) { int v = e[u][i]; if (v == fa) continue; dfsdfs(v, u); } } signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m; for (int i = 1; i <= n - 1; i++) { int u, v; cin >> u >> v; e[u].push_back(v); e[v].push_back(u); } dfs(1, 0); g[1] = f[1]; dfsdfs(1, 0); for (int i = 1; i <= n; i++) cout << g[i] % m << \\\"\\\\n\\\"; return 0; }\"]},\"384\":{\"h\":\"满分代码\",\"t\":[\"#include <bits/stdc++.h> #define int long long using namespace std; const int MAXN = 100000; int n, m; vector<int> e[MAXN + 5]; int f[MAXN + 5]; // 1 为根节点时，节点 i 为黑色，子树 i 的涂色方案数 int g[MAXN + 5]; // i 为根节点时，节点 i 为黑色的涂色方案数 vector<int> mul[MAXN + 5]; vector<int> lum[MAXN + 5]; void dfs(int u, int fa) { f[u] = 1; for (int i = 0; i < e[u].size(); i++) { int v = e[u][i]; if (v == fa) continue; dfs(v, u); f[u] = f[u] * (f[v] + 1) % m; } } int cal(int u, int pos) { int l = 1; int r = 1; if (pos != 0) l = mul[u][pos - 1]; if (pos != (int)lum[u].size() - 1) r = lum[u][pos + 1]; return l * r % m; } // faW 父节点去掉 u 之后且父节点涂黑的方案数 void dfsdfs(int u, int fa, int faW) { g[u] = f[u] * (faW + 1) % m; for (int i = 0; i < e[u].size(); i++) { int v = e[u][i]; if (v == fa) { mul[u].push_back(faW + 1); lum[u].push_back(faW + 1); } else { mul[u].push_back(f[v] + 1); lum[u].push_back(f[v] + 1); } } for (int i = 0; i + 1 < mul[u].size(); i++) mul[u][i + 1] = mul[u][i + 1] * mul[u][i] % m; for (int i = (int)lum[u].size() - 1; i >= 1; i--) lum[u][i - 1] = lum[u][i - 1] * lum[u][i] % m; for (int i = 0; i < e[u].size(); i++) { int v = e[u][i]; if (v == fa) continue; dfsdfs(v, u, cal(u, i)); } } signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m; for (int i = 1; i <= n - 1; i++) { int u, v; cin >> u >> v; e[u].push_back(v); e[v].push_back(u); } dfs(1, 0); g[1] = f[1]; dfsdfs(1, 0, 0); for (int i = 1; i <= n; i++) cout << g[i] << \\\"\\\\n\\\"; return 0; }\"]},\"385\":{\"h\":\"代码源挑战赛R12\"},\"386\":{\"h\":\"R12A\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(0); int n; cin >> n; for (int i = 1; i <= n; i++) { for (int j = 1; j <= n - i; j++) cout << \\\" \\\"; for (int j = 1; j <= i * 2 - 1; j++) cout << \\\"#\\\"; cout << \\\"\\\\n\\\"; } for (int i = 1; i <= n; i++) { for (int j = 1; j <= n - 1; j++) cout << \\\" \\\"; cout << \\\"#\\\\n\\\"; } return 0; }\"]},\"387\":{\"h\":\"R12B\"},\"388\":{\"h\":\"辗转相减\",\"t\":[\"时间复杂度 ， 分\",\"#include <bits/stdc++.h> using namespace std; int a, b, x, y; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> a >> b; x = y = 0; while (a != b) { if (a > b) x++, a -= b; else y++, b -= a; } cout << x << \\\" \\\" << y << \\\"\\\\n\\\"; return 0; }\"]},\"389\":{\"h\":\"辗转相除\",\"t\":[\"时间复杂度 ， 分\",\"#include <bits/stdc++.h> using namespace std; int a, b, x, y; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> a >> b; x = y = 0; while (a != b && a && b) { if (a > b) { x += a / b; a %= b; } else { y += b / a; b %= a; } } if (a == 0) x--; if (b == 0) y--; cout << x << \\\" \\\" << y << \\\"\\\\n\\\"; return 0; }\"]},\"390\":{\"h\":\"R12C\"},\"391\":{\"h\":\"链表\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 300000; const int MAXM = 300000; int n, m; int pre[MAXN + 5]; int nxt[MAXN + 5]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m; for (int i = 1; i <= n; i++) { pre[i] = i - 1; nxt[i] = i + 1; } pre[1] = 0; nxt[n] = 0; int head = 1; for (int i = 1; i <= m; i++) { int xi; cin >> xi; if (xi == head) continue; // xi 从链表中删除 nxt[pre[xi]] = nxt[xi]; pre[nxt[xi]] = pre[xi]; // xi 放到链表头 pre[head] = xi; nxt[xi] = head; pre[xi] = 0; head = xi; } for (int i = head; i != 0; i = nxt[i]) cout << i << \\\" \\\"; return 0; }\"]},\"392\":{\"h\":\"标记权值重新排序\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 300000; const int MAXM = 300000; int n, m; pair<int, int> num[MAXN + 5]; int x[MAXM + 5]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m; for (int i = 1; i <= n; i++) num[i] = {i, i}; int now = 1; for (int i = 1; i <= m; i++) { cin >> x[i]; num[x[i]].first = --now; } sort(num + 1, num + n + 1); for (int i = 1; i <= n; i++) cout << num[i].second << \\\" \\\"; return 0; }\"]},\"393\":{\"h\":\"标记每个数还在不在\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 300000; const int MAXM = 300000; int n, m; int a[MAXN + MAXM + 5]; int pos[MAXN + MAXM + 5]; bool ok[MAXN + MAXM + 5]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m; int now = 1 + m; for (int i = 1; i <= n; i++) { a[i + m] = i; ok[i + m] = true; pos[i] = i + m; } for (int i = 1; i <= m; i++) { int xi; cin >> xi; ok[pos[xi]] = false; a[--now] = xi; ok[now] = true; pos[xi] = now; } for (int i = now; i <= n + m; i++) if (ok[i]) cout << a[i] << \\\" \\\"; return 0; }\"]},\"394\":{\"h\":\"离线处理\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 300000; const int MAXM = 300000; int n, m; int x[MAXM + 5]; bool flag[MAXN + 5]; // 每个数有没有输出 int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m; for (int i = 1; i <= m; i++) cin >> x[i]; for (int i = m; i >= 1; i--) { if (!flag[x[i]]) { cout << x[i] << \\\" \\\"; flag[x[i]] = true; } } for (int i = 1; i <= n; i++) if (!flag[i]) cout << i << \\\" \\\"; return 0; }\"]},\"395\":{\"h\":\"R12D\",\"t\":[\"枚举每种答案组合\",\"#include <bits/stdc++.h> #define int long long using namespace std; const int MOD = 998244353; const int MAXN = 3'000'000; int n; vector<int> d; int cnt[MAXN + 5]; int gcd(int a, int b) { if (b == 0) return a; return gcd(b, a % b); } signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) { int now = gcd(i, n); cnt[now]++; if (cnt[now] == 1) d.push_back(now); } int ans = 0; for (int i = 0; i < d.size(); i++) { int x = cnt[d[i]]; for (int j = 0; j < d.size(); j++) { int y = cnt[d[j]]; ans += x * y * gcd(d[i], d[j]); ans %= MOD; } } cout << ans; return 0; }\"]},\"396\":{\"h\":\"挖土机 CSP-J 模拟赛 ~ 第一场\"},\"397\":{\"h\":\"A. 不要三个一\",\"t\":[\"显然要尽可能把 往高位放，如果放了两个 就来一个 来避免非法，所以 应该放在从左往右第 个，这些除以 余 的位置中。所以可以根据是否还有 来决定怎么输出。\",\"子任务 1：只有一个 ，那直接输出 个 和 个 即可。\",\"子任务 2：显然这个子任务的输出是 这样的格式。\",\"子任务 3：凑数给愿意写 个 if 打表的同学送的分数。\",\"满分参考代码：\",\"#include <bits/stdc++.h> using namespace std; int n, m; int main() { freopen(\\\"three.in\\\", \\\"r\\\", stdin); freopen(\\\"three.out\\\", \\\"w\\\", stdout); cin >> n >> m; for (int i = 1; i <= n; i++) { if (m > 0) { if (i % 3 == 1 || i % 3 == 2) { cout << 1; m--; } else cout << 0; } else cout << 0; } return 0; }\"]},\"398\":{\"h\":\"B. 猜数字作弊\"},\"399\":{\"h\":\"60 分\",\"t\":[\"显然这是段二分的代码，输出的是在 中找几次能找到 （虽然这件事本身挺无聊）。\",\"题目问几个数可以得到最大的输出，显然一个暴力枚举的做法就是对 范围内的每个数都跑一遍这段代码看看输出是几。\",\"但有不少同学这个写错了，主要原因是这段代码会修改 的值，所以外面枚举 的时候不能也用变量 来做了。可以把题目描述给的代码打包成一个函数，或者备份一份即可。\",\"子任务 1,2 送了可以口算出来的 分。\",\"60 分参考代码：\",\"#include <bits/stdc++.h> using namespace std; int f(int l, int r, int x) { int cnt = 0; while (l <= r) { cnt++; int mid = (l + r) / 2; if (mid == x) return cnt; if (mid < x) l = mid + 1; if (mid > x) r = mid - 1; } } int main() { freopen(\\\"guess.in\\\", \\\"r\\\", stdin); freopen(\\\"guess.out\\\", \\\"w\\\", stdout); ios::sync_with_stdio(false); cin.tie(0); int l, r; cin >> l >> r; int maxX = 0; for (int i = l; i <= r; i++) maxX = max(maxX, f(l, r, i)); int ans = 0; for (int i = l; i <= r; i++) if (f(l, r, i) == maxX) ans++; cout << ans; return 0; }\"]},\"400\":{\"h\":\"满分\",\"t\":[\"实际上手动模拟一下，可以算出来每个数是第几次被 命中的。比如 时：\",\"第一次被 命中的是 \",\"然后第二次被 命中的有两个，左半边是 中间的 ，和右半边的 中间的 。\",\"这个过程显然可以用深搜或者广搜跑完，时间复杂度 。\",\"还有一个做法，实际上容易发现 的答案可以等价对应到 或者 。然后其实是可以数学方法, 算算哪些数字最后一次被命中。但我懒得推了，作为第二题直接爆搜就好了。\",\"参考代码：\",\"#include <bits/stdc++.h> using namespace std; int l, r, maxCnt; int f[100'000'000 + 5]; void dfs(int l, int r, int cnt) { if (l > r) return; int mid = (l + r) / 2; f[mid] = cnt; maxCnt = max(maxCnt, cnt); dfs(l, mid - 1, cnt + 1); dfs(mid + 1, r, cnt + 1); } int main() { freopen(\\\"guess.in\\\", \\\"r\\\", stdin); freopen(\\\"guess.out\\\", \\\"w\\\", stdout); ios::sync_with_stdio(false); cin.tie(0); int l, r; cin >> l >> r; maxCnt = 0; dfs(l, r, 1); int ans = 0; for (int i = l; i <= r; i++) if (f[i] == maxCnt) ans++; cout << ans; return 0; }\"]},\"401\":{\"h\":\"C. 再次抓住牛\",\"t\":[\"这道题我觉得最好的是我这个配图用 ppt 画得真好看。\"]},\"402\":{\"h\":\"60 分\",\"t\":[\"首先显然直接 dfs 爆搜能跑出来子任务 1，但大胆一点搜搜会发现子任务 3 的 的范围也跑的飞快，所以直接 dfs 是能拿到 分的。\",\"子任务 1、3 参考代码\",\"#include <bits/stdc++.h> using namespace std; const int MOD = 1'000'000'000 + 7; const int MAXN = 1'000'000; int n, a, b; int ans; bool vis[MAXN + 5]; int dx[] = {1, -1, 2, -2}; void dfs(int now) { if (now == b) { ans = (ans + 1) % MOD; return; } for (int i = 0; i < 4; i++) { int nxt = now + dx[i]; if (nxt < 0 || nxt > n || vis[nxt]) continue; vis[nxt] = true; dfs(nxt); vis[nxt] = false; } } int main() { freopen(\\\"cow.in\\\", \\\"r\\\", stdin); freopen(\\\"cow.out\\\", \\\"w\\\", stdout); ios::sync_with_stdio(false); cin.tie(0); cin >> n >> a >> b; ans = 0; vis[a] = true; dfs(a); vis[a] = false; cout << ans; return 0; }\",\"很多同学就止步于此了，实际上能拿到 分之后，子任务 2 的 分就在嘴边了。用这个代码来跑一跑 1 0 1、2 0 2、3 0 3 这些数据，会发现其实是有规律的，n 0 n 的答案等于前三个答案之和（实际上这个规律也是我出完题目之后才发现的）。所以子任务 1,2 直接一个递推就好了。两个代码总结在一起就是个 分了。\",\"子任务 1,2 参考代码\",\"#include <bits/stdc++.h> #define int long long using namespace std; const int MOD = 1'000'000'000 + 7; const int MAXN = 1'000'000; int n, a, b; int f[MAXN + 5]; signed main() { freopen(\\\"cow.in\\\", \\\"r\\\", stdin); freopen(\\\"cow.out\\\", \\\"w\\\", stdout); ios::sync_with_stdio(false); cin.tie(0); cin >> n >> a >> b; f[0] = 1; f[1] = 1; f[2] = 2; for (int i = 3; i <= n; i++) f[i] = (f[i - 1] + f[i - 2] + f[i - 3]) % MOD; cout << f[n]; return 0; }\"]},\"403\":{\"h\":\"100 分\",\"t\":[\"首先要注意到，n a b 和 n b a 的答案一样，所以可以先把人调整到左边，牛调整到右边。\",\"然后抓牛得情况看上去很多，但是仔细想想会发现一旦某个地方回头了，就不可能再折返回去了。所以只有三种情况：\",\"直接往右精准抵达\",\"往右跳过牛，然后回头精准抵达\",\"往左一段，然后往右精准抵达\",\"往左一段，然后往右跳过牛，再回头精准抵达\"]},\"404\":{\"h\":\"是否往左一段\",\"t\":[\"如果往左一段然后回头，那么必然是 -2 -2 -2 -2 -1 +2 +2 +2... 这样或者 -2 -2 -2 -2 +1 +2 +2 +2 ...。前面的两步走几次有多种情况，但是一旦开始回头了，就是唯一的一种走法了。\",\"所以从 走到 其实就看左边从哪儿开始往右走，一共有 这些折返点，共 个方案能“走到 这个位置且能继续往右”。\"]},\"405\":{\"h\":\"往右狂奔或者折返回到牛\",\"t\":[\"后半部分就两种结果了，要么精准往右到 ，要么跳过了 到达 再回头。我一开始没发现子任务 2 那个规律，所以我是 dp 写的。\",\" 表示往右走到了 且 被走过了， 表示往右走到了 且 没走（跳过去了）。然后状态转移方程其实很好退出来。\",\"那么精准抵达 的方案是就是 ，跳过 到达 的方案就是 。\",\"我们可以惊喜得发现，从 回头到 的方案数和前部分从 到 的计算方法一样。这道题就这么做完了。\",\"参考代码\",\"#include <bits/stdc++.h> #define int long long using namespace std; const int MOD = 1'000'000'000 + 7; const int MAXN = 1'000'000; int n, a, b; int f[MAXN + 5]; // 往右走到 i，且 i-1 走过了，i 右面都没走过 int g[MAXN + 5]; // 往右走到 i，且 i-1 没走过，i 右边都没走过 signed main() { freopen(\\\"cow.in\\\", \\\"r\\\", stdin); freopen(\\\"cow.out\\\", \\\"w\\\", stdout); ios::sync_with_stdio(false); cin.tie(0); cin >> n >> a >> b; if (a > b) swap(a, b); f[a] = 0, f[a + 1] = a + 1; g[a] = 1, g[a + 1] = 0; for (int i = a + 2; i <= n; i++) { // 左边走过 f[i] = (f[i - 1] + g[i - 1]) % MOD; // 直接左边往右走一步 f[i] = (f[i] + g[i - 1]) % MOD; // 左边回撤一步再往前 // 左边没走过 g[i] = (f[i - 2] + g[i - 2]) % MOD; // 只能从 i-2 一次两步过去 } int ans1 = (f[b] + g[b]) % MOD; // 左边直达 int ans2 = 0; if (b != n) ans2 = (g[b + 1] * (n - (b + 1) + 1)) % MOD; cout << (ans1 + ans2) % MOD; return 0; }\"]},\"406\":{\"h\":\"D. 合法哈夫曼\",\"t\":[\"其实这题是为了给初赛服务的。为了给大家科普下 J 组初赛常考的哈夫曼编码。\",\"所以可以先学学咋求哈夫曼编码。核心就是每次贪心选两个权值最小的节点，合到一个节点上。拿个优先队列建树就好，这题数据范围小也可以直接纯暴力找俩权值小的节点建树就好了。\",\"然后从根节点开始 dfs 往下跑就能得到每节点的编码了，这题我给的数据范围的编码直接用一个 long long 就能存，我用两个数组分别存了编码长度和编码，当然直接用字符串存左子树 +\\\"0\\\" 右子树 +\\\"1\\\" 也能造出来的。\"]},\"407\":{\"h\":\"子任务 1（10 分）\",\"t\":[\"就一个单词，直接给这个单词编码 0 或 1 就好了，文章长度就是单词数量乘以 了。很多同学这部分分数没拿到有点可惜。\"]},\"408\":{\"h\":\"子任务 2（20 分）\",\"t\":[\"既然给的就是个合法的哈夫曼编码，直接用这套编码算文章长度就好了。文章长度就是“每个单词数量乘以编码长度”之和。\"]},\"409\":{\"h\":\"子任务 3（30 分）\",\"t\":[\"只要长度合法就行，所以这里就需要把哈夫曼编码给先求出来。然后输入不合法就输出你的方案就好，合法就输出就直接算算文章长度输出就好。\",\"这个子任务保证了互不为前缀，所以只要文章长度对了就行。所以用自己的编码算一个文章长度，然后算算输入给的文章长度。如果一样就是 Yes，不一样就是 No。\"]},\"410\":{\"h\":\"子任务 4（40 分）\",\"t\":[\"前面的基础上再加一个判断是否有前缀关系就好。这题数据范围小，直接 的枚举单词对，然后检查两个单词是否满足其中一个是不是另一个的前缀就好。\",\"实际上也有更简单的方法。把所有单词按照字典序排序，那么如果存在前缀关系，必然存在相邻的前缀关系。且前一个是后一个的前缀。\",\"满分参考代码\",\"#include <bits/stdc++.h> #define int long long using namespace std; int n; int a[60 + 5]; string s[60 + 5]; // huffman 建树 priority_queue<pair<int, int>> q; int tot, l[60 * 2 + 5], r[60 * 2 + 5]; // 算 huffman 编码 int len[60 * 2 + 5], code[60 * 2 + 5]; void dfs(int x, int nowLen, int nowCode) { if (x <= n) { len[x] = nowLen; code[x] = nowCode; return; } dfs(l[x], nowLen + 1, nowCode * 2); dfs(r[x], nowLen + 1, nowCode * 2 + 1); } signed main() { freopen(\\\"huffman.in\\\", \\\"r\\\", stdin); freopen(\\\"huffman.out\\\", \\\"w\\\", stdout); ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; // 算输入的文章总长度 int inf_ans = 0; for (int i = 1; i <= n; i++) { cin >> s[i]; inf_ans += s[i].size() * a[i]; } // 特判 if (n == 1) { if (s[1].size() == 1) cout << \\\"Yes\\\\n\\\" << inf_ans << \\\"\\\\n\\\"; else cout << \\\"No\\\\n1\\\\n\\\"; return 0; } // 构建一个哈夫曼编码 tot = n; for (int i = 1; i <= n; i++) q.push(make_pair(-a[i], i)); while (q.size() > 1) { tot++; pair<int, int> x = q.top(); q.pop(); pair<int, int> y = q.top(); q.pop(); q.push(make_pair(x.first + y.first, tot)); l[tot] = x.second; r[tot] = y.second; } dfs(tot, 0, 0); // 检查 bool flag = true; // 检查文章总长度 int ans = 0; for (int i = 1; i <= n; i++) ans += a[i] * len[i]; if (inf_ans != ans) flag = false; // 检查前缀问题 sort(s + 1, s + n + 1); for (int i = 1; i <= n - 1; i++) { if (s[i] > s[i + 1]) continue; bool now = true; // 是否为前缀 for (int j = 0; j < s[i].size(); j++) if (s[i][j] != s[i + 1][j]) { now = false; break; } if (now) { flag = false; break; } } // 输出 if (flag) { cout << \\\"Yes\\\\n\\\"; cout << ans << \\\"\\\\n\\\"; } else { cout << \\\"No\\\\n\\\"; for (int i = 1; i <= n; i++) { for (int j = len[i] - 1; j >= 0; j--) cout << ((code[i] >> j) & 1); cout << \\\"\\\\n\\\"; } } return 0; }\"]},\"411\":{\"h\":\"挖土机 CSP-J 模拟赛 ~ 第十场\"},\"412\":{\"h\":\"打草惊蛇\",\"t\":[\"其实看看数据范围，就是个暴力枚举。\",\"出题时想的是凑数让后期选手写筛写 lcm 浪费点时间。\",\"#include <bits/stdc++.h> using namespace std; int n, m; int a[25]; int main() { freopen(\\\"da.in\\\", \\\"r\\\", stdin); freopen(\\\"da.out\\\", \\\"w\\\", stdout); ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m; for (int i = 1; i <= n; i++) cin >> a[i]; int ans = 0; for (int i = 1; i <= m; i++) { int now = 0; for (int j = 1; j <= n; j++) if (i % a[j] == 0) now++; ans = max(ans, now); } cout << ans; return 0; }\"]},\"413\":{\"h\":\"借尸还魂\",\"t\":[\"首先 这个应该都很好推。\",\"然后，应该很好想到 暴力枚举的代码。\",\"// O(n^2) 暴力枚举 #include <bits/stdc++.h> #define int long long using namespace std; int n; int a, b; signed main() { freopen(\\\"jie.in\\\", \\\"r\\\", stdin); freopen(\\\"jie.out\\\", \\\"w\\\", stdout); ios::sync_with_stdio(false); cin.tie(0); cin >> n; a = 1, b = 2; for (int i = 1; i <= n; i++) for (int j = i + 1; j <= n; j++) if (abs(n - 3 * i - 4 * j) < abs(n - 3 * a - 4 * b)) a = i, b = j; cout << a << \\\" \\\" << b << \\\" \\\" << a + b << \\\" \\\" << a + 2 * b << \\\"\\\\n\\\"; return 0; }\",\"接下来有两种常见满分路线\",\"一种是修改上面的代码套一层 for 循环枚举 的结果，容易发现 必然是 中的一个，此时就可以写出来 的代码了，然后进一步如果能推出 是大于 且最接近 的数，就能 做了\",\"还有一种是先推出 是大于 且最接近 的数，可以二分或者数学方法算出，这就是 或 。然后进一步数学推式子，发现 时，，所以 必然小于等于 是最优方案。\",\"有不少同学直接钦定 了，好一点的想到了偶数要求 。但实际上简单打个 的表就容易发现这个结论是错的了。\",\"// 满分 #include <bits/stdc++.h> #define int long long using namespace std; int n; // a,b,a+b,(b)+(a+b) // 3a+4b 接近 n int a, b, aa, bb; // 返回 res(res>a) 使得 4*res 尽可能接近 x int gen(int nowA, int x) { int res1 = max(nowA + 1, x / 4); int res2 = max(nowA + 1, x / 4 + 1); if (abs(x - res1 * 4) < abs(x - res2 * 4)) return res1; else return res2; } signed main() { freopen(\\\"jie.in\\\", \\\"r\\\", stdin); freopen(\\\"jie.out\\\", \\\"w\\\", stdout); ios::sync_with_stdio(false); cin.tie(0); cin >> n; int a = 1, b = 2; for (int i = 1; i <= 100; i++) // 实际上 4 就够了 { int j = gen(i, n - 3 * i); if (abs(n - 3 * i - 4 * j) < abs(n - 3 * a - 4 * b)) a = i, b = j; } cout << a << \\\" \\\" << b << \\\" \\\" << a + b << \\\" \\\" << a + 2 * b << \\\"\\\\n\\\"; return 0; }\"]},\"414\":{\"h\":\"调虎离山\",\"t\":[\"其实难度没有那么高，不知道有没有后期选手直接上来就 lca 的。\",\"实际上因为是在树上，所以路径是唯一的。就是先向父亲节点方向走到 1-3-7-15-31-... 这条路径上的点，然后往右下走到最终位置即可。发现了这个之后这题就没啥难度了。\",\"有一点容易出问题的地方，怎么判断节点 在不在那条路径上。如果直接用 看是不是 的整数次幂，那就可能超过 long long 了。我本来打算卡 unsigned long long，后来想想还是算了。\",\"实际上为了避免上溢出，比较好的做法可能会是像我标程一样直接生成那些位置，然后二分检查。或者直接检查这个数是不是二进制下全是 。\",\"#include <bits/stdc++.h> #define int long long using namespace std; int n, m, ans; int a[100000+5]; int R[64]; // 2^i-1 bool check2(int x) { return binary_search(R + 1, R + 63 + 1, x); } // 从 pos 到 2^m-1 的路程 int cal(int m, int pos) { int res = 0; // 检查 pos+1 是不是 2 的整数次幂 while (!check2(pos)) { pos /= 2; res++; } while (pos != (1LL << m) - 1) { pos = pos * 2 + 1; res++; } return res; } signed main() { ios::sync_with_stdio(false); cin.tie(0); R[0] = 0; for (int i = 1; i <= 63; i++) R[i] = R[i - 1] * 2 + 1; cin >> n >> m; for (int i = 1; i <= n; i++) cin >> a[i]; ans = 0; for (int i = 1; i <= n; i++) ans = max(ans, cal(m, a[i])); cout << ans; return 0; }\"]},\"415\":{\"h\":\"欲擒姑纵\",\"t\":[\"看懂了程序之后，容易发现 时，。所以 分很简单。\",\"// 10 分 #include <bits/stdc++.h> #define int long long using namespace std; const int MOD = 1'000'000'000 + 7; signed main() { freopen(\\\"yu.in\\\", \\\"r\\\", stdin); freopen(\\\"yu.out\\\", \\\"w\\\", stdout); int m, k; cin >> m >> k; int ans = 0; for (int i = 1; i <= m; i++) ans = ans ^ i; cout << ans; return 0; }\",\"然后很容易发现题面那个代码已经有不少可以优化的地方了。优化后就能拿到不少分数。\",\"// 题面代码优化 #include <bits/stdc++.h> #define int long long using namespace std; const int MOD = 1'000'000'000 + 7; int f(int n, int k) { if (n == 1) return 1; for (int x = 2; x <= n; x++) // x>1 if (n % x == 0) // x 是 n 的因子 return f(n / x, k) * x % MOD * k % MOD; } signed main() { freopen(\\\"yu.in\\\", \\\"r\\\", stdin); freopen(\\\"yu.out\\\", \\\"w\\\", stdout); int m, k; cin >> m >> k; int ans = 0; for (int i = 1; i <= m; i++) ans = ans ^ f(i, k); cout << ans; return 0; }\",\"然后有一个比较难的小台阶。需要进一步推，可以得到两种结论（不考虑取模）：\",\"。 \",\"接着可能能想到用埃筛处理出来最小质因子来加速分解质因子，然后 分解质因子，来拿到 分\",\"对于质数 有 。对于其他的 。（学到后期的同学会知道这是完全积性函数） \",\"那就可以直接在埃筛的同时算出每个数对应的 值。\",\"//埃筛 #include <bits/stdc++.h> #define int long long using namespace std; const int MOD = 1'000'000'000 + 7; const int MAXM = 20'000'000; int m, k; int ans[MAXM + 5]; bool notP[MAXM + 5]; void init() { ans[1] = 1; for (int i = 2; i <= m; i++) { if (notP[i]) continue; ans[i] = i * k % MOD; for (int j = 2; j * i <= m; j++) { ans[j * i] = ans[i] * ans[j] % MOD; notP[j * i] = true; } } } signed main() { freopen(\\\"yu.in\\\", \\\"r\\\", stdin); freopen(\\\"yu.out\\\", \\\"w\\\", stdout); cin >> m >> k; init(); int sum = 0; for (int i = 1; i <= m; i++) sum = sum ^ ans[i]; cout << sum; return 0; }\",\"当然满分是个线性筛的做法，其实这道题出题时我是翻 NOI 大纲，发现线性筛能考，为了考线性筛来构造的函数。\",\"// std #include <bits/stdc++.h> #define int long long using namespace std; const int MOD = 1'000'000'000 + 7; const int MAXM = 20'000'000; int m, k; int ans[MAXM + 5]; // 质数数量大概是 n/ln(n) int tot, p[MAXM / 15 + 5]; bool notP[MAXM + 5]; void init() { tot = 0; ans[1] = 1; for (int i = 2; i <= m; i++) { if (!notP[i]) { p[++tot] = i; ans[i] = i * k % MOD; } for (int j = 1; j <= tot && i * p[j] <= m; j++) { notP[i * p[j]] = true; ans[i * p[j]] = ans[i] * ans[p[j]] % MOD; if (i % p[j] == 0) break; } } } signed main() { freopen(\\\"yu.in\\\", \\\"r\\\", stdin); freopen(\\\"yu.out\\\", \\\"w\\\", stdout); cin >> m >> k; init(); int sum = 0; for (int i = 1; i <= m; i++) sum = sum ^ ans[i]; cout << sum; return 0; }\"]},\"416\":{\"h\":\"挖土机 CSP-J 模拟赛 ~ 第十一场\"},\"417\":{\"h\":\"抛砖引玉\",\"t\":[\" 分就不多说了，这里给个满分代码。\",\"#include <bits/stdc++.h> using namespace std; int n; string s; int gen(string &s) { int res = 0; for (int i = 0; i < s.size(); i++) res = res * 10 + s[i] - '0'; return res; } bool p(int x) { if (x < 2) return false; for (int i = 2; i * i <= x; i++) if (x % i == 0) return false; return true; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> s; sort(s.begin(), s.end()); do { if (p(gen(s))) { cout << s << \\\"\\\\n\\\"; return 0; } } while (next_permutation(s.begin(), s.end())); cout << \\\"-1\\\\n\\\"; return 0; }\"]},\"418\":{\"h\":\"擒贼擒王\",\"t\":[\"显然不停减 可以通过 来加速。有一些经典的错误是没注意到小于等于 得数不能处理。\",\"#include <bits/stdc++.h> #define int long long using namespace std; int n, k; pair<int, int> a[100000 + 5]; // ai,i signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> k; for (int i = 1; i <= n; i++) cin >> a[i].first; for (int i = 1; i <= n; i++) { a[i].second = i; if (a[i].first <= 0) continue; a[i].first %= k; if (a[i].first) a[i].first -= k; } sort(a + 1, a + n + 1); int cnt = 1; for (int i = 2; i <= n; i++) if (a[i].first != a[i - 1].first) cnt++; cout << a[n].second << \\\" \\\" << cnt; return 0; }\"]},\"419\":{\"h\":\"釜底抽薪\",\"t\":[\"原题是：https://codeforces.com/problemset/problem/939/D\",\"首先要想清楚，当两个数不一样时，把所有 变成 和把所有的 变成 是没区别的。然后就一个个看过去不一样就变就好。因为并查集是提高组考点，所以这题给的是染色做法的标程。\",\"#include <bits/stdc++.h> using namespace std; int n, ans; long long a[5005]; long long b[5005]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; for (int i = 1; i <= n; i++) cin >> b[i]; ans = 0; for (int i = 1; i <= n; i++) { if (a[i] == b[i]) continue; ans++; long long x = a[i]; long long y = b[i]; for (int j = 1; j <= n; j++) { if (a[j] == x) a[j] = y; if (b[j] == x) b[j] = y; } } cout << ans; return 0; }\"]},\"420\":{\"h\":\"混水摸鱼\",\"t\":[\"原题：https://atcoder.jp/contests/abc170/tasks/abc170_f\"]},\"421\":{\"h\":\"子任务 2\",\"t\":[\"经典广搜\",\"// subtask 2 #include <bits/stdc++.h> using namespace std; int n, m, k; int x, y, xx, yy; char g[1005][1005]; int dis[1005][1005]; queue<pair<int, int>> q; int dx[] = {0, 0, 1, -1}; int dy[] = {-1, 1, 0, 0}; int main() { freopen(\\\"hun.in\\\", \\\"r\\\", stdin); freopen(\\\"hun.out\\\", \\\"w\\\", stdout); ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m >> k; cin >> x >> y >> xx >> yy; for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) cin >> g[i][j]; assert(g[x][y] != '@' && g[xx][yy] != '@'); q.push(make_pair(x, y)); dis[x][y] = 1; while (!q.empty() && !dis[xx][yy]) { pair<int, int> now = q.front(); q.pop(); for (int i = 0; i < 4; i++) { for (int j = 1; j <= k; j++) { int nx = now.first + dx[i] * j; int ny = now.second + dy[i] * j; if (nx < 1 || nx > n || ny < 1 || ny > m || g[nx][ny] == '@') break; if (dis[nx][ny]) continue; dis[nx][ny] = dis[now.first][now.second] + 1; q.push(make_pair(nx, ny)); } } } if (dis[xx][yy]) cout << dis[xx][yy] - 1 << \\\"\\\\n\\\"; else cout << -1 << \\\"\\\\n\\\"; return 0; }\"]},\"422\":{\"h\":\"60 分\",\"t\":[\"显然开不下 的数组。可以用动态数组或者字符串的形式，用多少开多少。\",\"// 暴力 #include <bits/stdc++.h> using namespace std; const int MAXN = 1'000'000; int n, m, k; int x, y, xx, yy; char temp; vector<char> g[MAXN + 5]; vector<int> dis[MAXN + 5]; queue<pair<int, int>> q; int dx[] = {0, 0, 1, -1}; int dy[] = {-1, 1, 0, 0}; int main() { freopen(\\\"hun.in\\\", \\\"r\\\", stdin); freopen(\\\"hun.out\\\", \\\"w\\\", stdout); ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m >> k; cin >> x >> y >> xx >> yy; for (int i = 1; i <= n; i++) { g[i].push_back('@'); dis[i].push_back(0); for (int j = 1; j <= m; j++) { cin >> temp; g[i].push_back(temp); dis[i].push_back(0); } } assert(g[x][y] != '@' && g[xx][yy] != '@'); q.push(make_pair(x, y)); dis[x][y] = 1; while (!q.empty() && !dis[xx][yy]) { pair<int, int> now = q.front(); q.pop(); for (int i = 0; i < 4; i++) { for (int j = 1; j <= k; j++) { int nx = now.first + dx[i] * j; int ny = now.second + dy[i] * j; if (nx < 1 || nx > n || ny < 1 || ny > m || g[nx][ny] == '@') break; if (dis[nx][ny]) continue; dis[nx][ny] = dis[now.first][now.second] + 1; q.push(make_pair(nx, ny)); } } } if (dis[xx][yy]) cout << dis[xx][yy] - 1 << \\\"\\\\n\\\"; else cout << -1 << \\\"\\\\n\\\"; return 0; }\"]},\"423\":{\"h\":\"100 分\",\"t\":[\"满分只需要注意本来要走 步，但是如果路途中间遇到了一样近或更近的点就可以停了，后面没走的那些位置显然可以通过这个点走过去而不会更劣。\",\"#include <bits/stdc++.h> using namespace std; const int MAXN = 1'000'000; int n, m, k; int x, y, xx, yy; char temp; vector<char> g[MAXN + 5]; vector<int> dis[MAXN + 5]; queue<pair<int, int>> q; int dx[] = {0, 0, 1, -1}; int dy[] = {-1, 1, 0, 0}; int main() { freopen(\\\"hun.in\\\", \\\"r\\\", stdin); freopen(\\\"hun.out\\\", \\\"w\\\", stdout); ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m >> k; cin >> x >> y >> xx >> yy; for (int i = 1; i <= n; i++) { g[i].push_back('@'); dis[i].push_back(0); for (int j = 1; j <= m; j++) { cin >> temp; g[i].push_back(temp); dis[i].push_back(0); } } assert(g[x][y] != '@' && g[xx][yy] != '@'); q.push(make_pair(x, y)); dis[x][y] = 1; while (!q.empty() && !dis[xx][yy]) { pair<int, int> now = q.front(); q.pop(); for (int i = 0; i < 4; i++) { for (int j = 1; j <= k; j++) { int nx = now.first + dx[i] * j; int ny = now.second + dy[i] * j; if (nx < 1 || nx > n || ny < 1 || ny > m || g[nx][ny] == '@') break; // 40 分来自这一句 if if (dis[nx][ny] && dis[nx][ny] <= dis[now.first][now.second]) break; if (dis[nx][ny]) continue; dis[nx][ny] = dis[now.first][now.second] + 1; q.push(make_pair(nx, ny)); } } } if (dis[xx][yy]) cout << dis[xx][yy] - 1 << \\\"\\\\n\\\"; else cout << -1 << \\\"\\\\n\\\"; return 0; }\"]},\"424\":{\"h\":\"挖土机 CSP-J 模拟赛 ~ 第十二场\"},\"425\":{\"h\":\"金蝉脱壳\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n, a, b, c; int main() { freopen(\\\"jin.in\\\", \\\"r\\\", stdin); freopen(\\\"jin.out\\\", \\\"w\\\", stdout); ios::sync_with_stdio(false); cin.tie(0); cin >> n; a = n % 10; b = n / 10 % 10; c = n / 100 % 10; int ans = 0; for (int x = 0; x <= 9; x++) for (int y = 0; y <= 9; y++) for (int z = 0; z <= 9; z++) if (x - y == a - b && b - c == y - z && z != 0) ans++; cout << ans; return 0; }\"]},\"426\":{\"h\":\"关门捉贼\",\"t\":[\"注意到题目没有要求放最少的稻草人，所以给一个合法方案就好。那么稻草人放在第一行、最后一行、第一列、最后一列是最方便的，不用担心和猫的位置冲突。\",\"显然因为还有稻草人数量要求，所以只给有猫的那些行列放稻草人即可。\",\"#include <bits/stdc++.h> using namespace std; int n, m; int x[505], y[505]; int main() { freopen(\\\"guan.in\\\", \\\"r\\\", stdin); freopen(\\\"guan.out\\\", \\\"w\\\", stdout); ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m; for (int i = 1; i <= n; i++) cin >> x[i] >> y[i]; sort(x + 1, x + n + 1); sort(y + 1, y + n + 1); // 计数 int cnt = 2; for (int i = 2; i <= n; i++) if (x[i] != x[i - 1]) cnt += 2; cnt += 2; for (int i = 2; i <= n; i++) if (y[i] != y[i - 1]) cnt += 2; cout << cnt << \\\"\\\\n\\\"; // 输出 cout << x[1] << \\\" \\\" << 1 << \\\"\\\\n\\\"; cout << x[1] << \\\" \\\" << m << \\\"\\\\n\\\"; for (int i = 2; i <= n; i++) if (x[i] != x[i - 1]) { cout << x[i] << \\\" \\\" << 1 << \\\"\\\\n\\\"; cout << x[i] << \\\" \\\" << m << \\\"\\\\n\\\"; } cout << 1 << \\\" \\\" << y[1] << \\\"\\\\n\\\"; cout << m << \\\" \\\" << y[1] << \\\"\\\\n\\\"; for (int i = 2; i <= n; i++) if (y[i] != y[i - 1]) { cout << 1 << \\\" \\\" << y[i] << \\\"\\\\n\\\"; cout << m << \\\" \\\" << y[i] << \\\"\\\\n\\\"; } return 0; }\"]},\"427\":{\"h\":\"远交近攻\",\"t\":[\"首先显然二叉搜索树的中序遍历就是完整的顺序，所以可以生成中序遍历后拿最远的 个点。\",\"我这里给另一个做法，直接在 dfs 的过程中，得到每个结点的排名。\",\"#include <bits/stdc++.h> using namespace std; const int MAXN = 100000; int n, ans; int a[MAXN + 5]; int l[MAXN + 5], r[MAXN + 5]; int rnk[MAXN + 5]; // i 号点排名 rnk[i] // 到了 u 这个点，父节点方向小于它的有 cnt 个 // 返回子树大小 int dfs(int u, int cnt) { int siz = 0; if (l[u] != 0) { siz += dfs(l[u], cnt); cnt += siz; } siz += 1; rnk[u] = cnt + 1; if (r[u] != 0) siz += dfs(r[u], cnt + 1); return siz; } int main() { freopen(\\\"yuan.in\\\", \\\"r\\\", stdin); freopen(\\\"yuan.out\\\", \\\"w\\\", stdout); ios::sync_with_stdio(false); cin.tie(0); cin >> n; int root = 0; for (int i = 1; i <= n; i++) { cin >> a[i]; root = root ^ i; } for (int i = 1; i <= n; i++) { cin >> l[i] >> r[i]; root = root ^ l[i]; root = root ^ r[i]; } dfs(root, 0); ans = 0; for (int i = 1; i <= n; i++) if (n - rnk[i] + 1 <= n / 2) { ans += a[i]; } cout << ans; return 0; }\"]},\"428\":{\"h\":\"假道伐虢\",\"t\":[\"显然每次走能走到的点中最小的那个是最有选项。这题给的数据范围直接暴力找就好。\",\"如果你想到了用个优先队列优化这个查找，那么很好，你将很快学会 Prim 最小生成树算法。\",\"#include <bits/stdc++.h> #define int long long using namespace std; const int MAXN = 1000; const int MAXM = MAXN * (MAXN - 1) / 2; int n, m, power; int a[MAXN + 5]; bool vis[MAXN + 5]; // 走没走过 bool can[MAXN + 5]; // 能不能走到 bool e[MAXN + 5][MAXN + 5]; // 是否相连 signed main() { freopen(\\\"jia.in\\\", \\\"r\\\", stdin); freopen(\\\"jia.out\\\", \\\"w\\\", stdout); ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m; for (int i = 1; i <= n; i++) cin >> a[i]; for (int i = 1; i <= m; i++) { int u, v; cin >> u >> v; e[u][v] = e[v][u] = true; } can[1] = true; power = 0; bool flag = true; // 还要不要找 int cnt = 0; // test while (flag) { flag = false; for (int i = 1; i <= n; i++) { if (!vis[i] && can[i] && (i == 1 || power >= a[i])) { vis[i] = true; power += a[i]; cnt++; // 相连的都能走了 for (int j = 1; j <= n; j++) if (e[i][j]) can[j] = true; flag = true; // 可能还要找 } } } cout << power << \\\"\\\\n\\\"; return 0; }\"]},\"429\":{\"h\":\"挖土机 CSP-J 模拟赛 ~ 第十三场\"},\"430\":{\"h\":\"偷梁换柱\",\"t\":[\"注意数据范围，就是简单的模拟即可。\",\"#include <bits/stdc++.h> using namespace std; int n, m; int l[5005], r[5005]; int typ[5005]; int main() { freopen(\\\"tou.in\\\", \\\"r\\\", stdin); freopen(\\\"tou.out\\\", \\\"w\\\", stdout); cin >> n >> m; for (int i = 1; i <= m; i++) cin >> l[i] >> r[i]; for (int i = 1; i <= n; i++) typ[i] = 0; for (int i = 1; i <= m; i++) for (int j = l[i]; j <= r[i]; j++) typ[j] = i; sort(typ + 1, typ + n + 1); /* for (int i = 1; i <= n; i++) cout << typ[i]; cout << \\\"\\\\n\\\"; */ int ans = (typ[1] != 0); for (int i = 2; i <= n; i++) if (typ[i] != typ[i - 1]) ans++; cout << ans; return 0; }\"]},\"431\":{\"h\":\"指桑骂槐\",\"t\":[\"手推几个例子，很容易推出来标程这个结论。\",\"#include <bits/stdc++.h> using namespace std; int n; int a, b, c, d; int A, B, C, D; string s; int main() { freopen(\\\"zhi.in\\\", \\\"r\\\", stdin); freopen(\\\"zhi.out\\\", \\\"w\\\", stdout); cin >> n; cin >> a >> b >> c >> d; cin >> s; A = B = C = D = 0; for (int i = 0; i < s.size(); i++) if (s[i] == 'A') A++; else if (s[i] == 'B') B++; else if (s[i] == 'C') C++; else if (s[i] == 'D') D++; cout << min(a, A) + min(b, B) + min(c, C) + min(d, D); return 0; }\"]},\"432\":{\"h\":\"假痴不癫\",\"t\":[\"有一点点简单的博弈。首先所有质数局面以及小于 时都是先手必胜的。\",\"否则就需要看后续能不能变为一个先手必败的状态。如果当前局面操作完只能变为先手必胜的状态，那么当前就是先手必败的。否则只要当前局面能操作到一个先手必败的状态，那么当前操作的人就会这么做，来让自己必胜。\",\"#include <bits/stdc++.h> using namespace std; int n, k; bool flag[5005]; int main() { freopen(\\\"jia.in\\\", \\\"r\\\", stdin); freopen(\\\"jia.out\\\", \\\"w\\\", stdout); flag[0] = flag[1] = true; for (int i = 2; i <= 5000; i++) { bool now = true; for (int j = 2; j < i; j++) if (i % j == 0) now = false; flag[i] = now; } cin >> n >> k; for (int i = 1; i <= n; i++) { if (flag[i]) continue; for (int j = i - 1; j >= max(1, i - k); j--) if (!flag[j]) flag[i] = true; } if (flag[n]) cout << \\\"33DAI\\\"; else cout << \\\"Kitten\\\"; return 0; }\"]},\"433\":{\"h\":\"上屋抽梯\",\"t\":[\"一个简单的树上搜索。显然如果要断开子树 ，要么断开 到父节点那条边，要么断掉所有 的子节点。\",\"#include <bits/stdc++.h> using namespace std; const int INF = 5000 * 5000 + 5; int n; vector<pair<int, int>> e[5005]; int dis[5005]; void dfs(int u, int fa) { int sum = 0; for (int i = 0; i < e[u].size(); i++) { int v = e[u][i].first; int w = e[u][i].second; if (v == fa) continue; dis[v] = w; dfs(v, u); sum += dis[v]; } if (sum != 0) dis[u] = min(dis[u], sum); } int main() { freopen(\\\"shang.in\\\", \\\"r\\\", stdin); freopen(\\\"shang.out\\\", \\\"w\\\", stdout); cin >> n; for (int i = 1; i <= n - 1; i++) { int u, v, w; cin >> u >> v >> w; e[u].push_back(make_pair(v, w)); e[v].push_back(make_pair(u, w)); } dis[1] = INF; dfs(1, 0); cout << dis[1]; return 0; }\"]},\"434\":{\"h\":\"挖土机 CSP-J 模拟赛 ~ 第十四场\"},\"435\":{\"h\":\"树上开花\",\"t\":[\"首先还原时显然每次都只有一种可能的操作，就是把较大的数变为两个数的差。直接一步步模拟然后特判一下 的情况（不特判的话会超时）就能拿到 分了。\",\"这个过程其实比较容易想到就是辗转相减法。那么其实中间可以用取模优化来加速，其实也就是辗转相除法。唯一的小麻烦就是可能最后一步取模会变得比原本的数更小，特判一下不要除多了即可。\",\"#include <bits/stdc++.h> #define int long long using namespace std; int a, b, x, y; int ans; signed main() { freopen(\\\"shu.in\\\", \\\"r\\\", stdin); freopen(\\\"shu.out\\\", \\\"w\\\", stdout); cin >> a >> b >> x >> y; while (x != a || y != b) { if (x > y) { int nxt = x % y; if (nxt < a) nxt = a; ans += (x - nxt) / y; x = nxt; } else { int nxt = y % x; if (nxt < b) nxt = b; ans += (y - nxt) / x; y = nxt; } } cout << ans; return 0; }\"]},\"436\":{\"h\":\"反客为主\",\"t\":[\"其实容易发现，就是所有大于等于 的位置 都可以变为 。那么直接广度优先搜索是最稳妥的方法。\",\"当然 dp 学的好的同学很容易发现可以直接用类似于背包的方法搞定。\",\"// dp #include <bits/stdc++.h> using namespace std; int main() { freopen(\\\"fan.in\\\", \\\"r\\\", stdin); freopen(\\\"fan.out\\\", \\\"w\\\", stdout); int n, m; cin >> n >> m; vector<int> a(m), b(m); for (int i = 0; i < m; i++) { cin >> a[i] >> b[i]; } vector<int> dp(n + 1, 0); for (int i = 1; i <= n; i++) { for (int j = 0; j < m; j++) { if (i >= a[j]) { dp[i] = max(dp[i], dp[i - a[j] + b[j]] + a[j] - b[j]); } } } cout << n - dp[n]; return 0; }\",\"// bfs #include <bits/stdc++.h> using namespace std; int n, m; vector<int> e[5005]; queue<int> q; bool f[5005]; int main() { freopen(\\\"fan.in\\\", \\\"r\\\", stdin); freopen(\\\"fan.out\\\", \\\"w\\\", stdout); cin >> n >> m; for (int i = 1; i <= m; i++) { int ai, bi; cin >> ai >> bi; for (int j = ai; j <= n; j++) e[j].push_back(j - ai + bi); } q.push(n); f[n] = true; while (!q.empty()) { int u = q.front(); q.pop(); for (int v : e[u]) { if (!f[v]) { f[v] = true; q.push(v); } } } for (int i = 0; i <= n; i++) if (f[i]) { cout << i; return 0; } return 0; }\"]},\"437\":{\"h\":\"美人计\",\"t\":[\"来源：https://www.luogu.com.cn/problem/AT_abc341_d\",\"这题是在原题的基础上做了一点点小加强，增加了一个数的送分情况和三个数的更复杂的容斥。\",\"首先写完暴力枚举的代码后，容易想到可以二分处理，判断小于等于 mid 的数中，被保留的是否大于等于 个。这样问题就转换成了 以内最多有多少个数恰好是 中的一个的倍数。\",\"这个就可以容斥处理了， 的倍数有 个， 的倍数有 个。显然这两个数的公倍数不能要，这些公倍数都是 的倍数，这些公倍数都被多加了两次，所以去掉两倍的即可。\",\"三个数时用类似的方法容斥即可。\",\"#include <bits/stdc++.h> #define int long long using namespace std; const int INF = 1'000'000'000'000'000'000; int n, k; int a[5]; int lcm12, lcm23, lcm13, lcm123; int gcd(int a, int b) { if (!b) return a; return gcd(b, a % b); } int lcm(int a, int b) { return a / gcd(a, b) * b; } // 小于等于 mid 的数中，被保留的是否大于等于 k bool check(int mid) { int cnt = 0; if (n == 1) cnt += mid / a[1]; else if (n == 2) { cnt += mid / a[1]; cnt += mid / a[2]; cnt -= 2 * (mid / lcm12); } else { cnt += mid / a[1]; cnt += mid / a[2]; cnt += mid / a[3]; cnt -= 2 * (mid / lcm12); cnt -= 2 * (mid / lcm23); cnt -= 2 * (mid / lcm13); cnt += 3 * (mid / lcm123); } return cnt >= k; } signed main() { freopen(\\\"mei.in\\\", \\\"r\\\", stdin); freopen(\\\"mei.out\\\", \\\"w\\\", stdout); cin >> n >> k; for (int i = 1; i <= n; i++) cin >> a[i]; if (n == 2) lcm12 = lcm(a[1], a[2]); else if (n == 3) { lcm12 = lcm(a[1], a[2]); lcm23 = lcm(a[2], a[3]); lcm13 = lcm(a[1], a[3]); lcm123 = lcm(lcm12, lcm23); } int l = 1; int r = INF; int ans = -1; while (l <= r) { int mid = (l + r) / 2; if (check(mid)) { ans = mid; r = mid - 1; } else l = mid + 1; } cout << ans; return 0; }\"]},\"438\":{\"h\":\"空城计\",\"t\":[\"其实第四题是比较简单的，这样安排是为了在考前提醒大家不要被前面题目卡到，一开始就要看完四道题目再来决定时间分配。真实比赛中第四题可能是最难的，但是也要一开始就看看有没有简单的子任务可以做，需要留充足时间把送的分拿满。\",\"#include <bits/stdc++.h> using namespace std; int n; char g[505][505]; bool vis[505][505]; // @ 数量 . 数量 vector<pair<int, int>> v; bool cmp(pair<int, int> x, pair<int, int> y) { // x.first/(x.first+x.second) < y.first/(y.first+y.second) int xy = x.first * (y.first + y.second); int yx = y.first * (x.first + x.second); if (xy != yx) return xy < yx; return x.first < y.first; } queue<pair<int, int>> q; int dx[] = {0, 0, 1, -1, 1, -1, 1, -1}; int dy[] = {1, -1, 0, 0, 1, 1, -1, -1}; pair<int, int> bfs(int x, int y) { // @ . pair<int, int> res = make_pair(0, 0); // 起点入队 q.push(make_pair(x, y)); vis[x][y] = true; if (g[x][y] == '@') res.first++; else res.second++; // bfs while (!q.empty()) { pair<int, int> pos = q.front(); q.pop(); for (int i = 0; i < 8; i++) { int nx = pos.first + dx[i]; int ny = pos.second + dy[i]; if (!vis[nx][ny] && g[nx][ny] != '#') { q.push(make_pair(nx, ny)); vis[nx][ny] = true; if (g[nx][ny] == '@') res.first++; else res.second++; } } } return res; } int main() { freopen(\\\"kong.in\\\", \\\"r\\\", stdin); freopen(\\\"kong.out\\\", \\\"w\\\", stdout); cin >> n; for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) cin >> g[i][j]; for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) vis[i][j] = false; for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) if (!vis[i][j] && g[i][j] != '#') v.push_back(bfs(i, j)); sort(v.begin(), v.end(), cmp); cout << v.size() << \\\" \\\" << v[0].first; return 0; }\"]},\"439\":{\"h\":\"挖土机 CSP-J 模拟赛 ~ 第十五场\"},\"440\":{\"h\":\"反间计\",\"t\":[\"找到所有每两个 0 之间 1 的数量，记住最大和次大的。答案就只 \",\"#include <bits/stdc++.h> using namespace std; string s; int ans1 = 0; // 最大 int ans2 = 0; // 次大 // 用 now 更新最大次大 void freshAns(int now) { if (now >= ans1) { ans2 = ans1; ans1 = now; } else if (now >= ans2) ans2 = now; } int main() { cin >> s; int now = 0; for (int i = 0; i < s.size(); i++) { if (s[i] == '0') { freshAns(now); now = 0; continue; } // 此时 s[i] 必然是 1 if (i == 0 || s[i - 1] == '0') now = 1; else now++; } freshAns(now); cout << max(ans2, ans1 / 2); return 0; }\"]},\"441\":{\"h\":\"苦肉计\",\"t\":[\"排序，从大到小。如果与前一个不相等，必然要花差那么多次变成相等的。这样就变成了和前一个相等，然后显然花一次去掉所有相等的，此时如果至少有三个（和前前一个也相等）就免费，否则就需要花费一次。\",\"#include <bits/stdc++.h> using namespace std; int n; int a[500000 + 5]; int main() { cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; sort(a + 1, a + n + 1); int ans = 0; for (int i = n; i >= 2; i--) { // 不相等时肯定要变为相等 if (a[i] != a[i - 1]) { ans += a[i] - a[i - 1]; a[i] = a[i - 1]; } // 相等之后，所有相等的只要减一次即可 // 所以三连的不管，只有二连的才去减少一次 if (i >= 3 && a[i] == a[i - 2]) ans += 0; else ans++; } ans += a[1]; cout << ans; return 0; }\"]},\"442\":{\"h\":\"连环计\",\"t\":[\"60 分纯暴力广搜深搜都可以。每个点为起点检查能走多少个点。\",\"满分超纲，需要先建图、然后缩点、然后在 DAG 上跑个拓扑序，用 bitset 优化合并得到每个点能到哪些点。\"]},\"443\":{\"h\":\"60 分搜索\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 500; int n; int a[MAXN + 5][MAXN + 5]; // vis[i][j] 为 idx 的时候表示当前这轮访问过了 int idx, vis[MAXN + 5][MAXN + 5]; queue<pair<int, int>> q; int bfs(int x, int y) { int res = 1; q.push(make_pair(x, y)); vis[x][y] = idx; while (!q.empty()) { pair<int, int> now = q.front(); q.pop(); x = now.first; y = now.second; for (int i = -a[x][y]; i <= a[x][y]; i++) { // (x-a[x][y],i) (x+a[x][y],j) // (i,y-a[x][y]) (i,y+a[x][y]) int xx, yy; xx = x - a[x][y]; yy = y + i; if (1 <= xx && xx <= n && 1 <= yy && yy <= n && vis[xx][yy] != idx) { res++; q.push(make_pair(xx, yy)); vis[xx][yy] = idx; } xx = x + a[x][y]; yy = y + i; if (1 <= xx && xx <= n && 1 <= yy && yy <= n && vis[xx][yy] != idx) { res++; q.push(make_pair(xx, yy)); vis[xx][yy] = idx; } xx = x + i; yy = y - a[x][y]; if (1 <= xx && xx <= n && 1 <= yy && yy <= n && vis[xx][yy] != idx) { res++; q.push(make_pair(xx, yy)); vis[xx][yy] = idx; } xx = x + i; yy = y + a[x][y]; if (1 <= xx && xx <= n && 1 <= yy && yy <= n && vis[xx][yy] != idx) { res++; q.push(make_pair(xx, yy)); vis[xx][yy] = idx; } } } return res; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) { cin >> a[i][j]; // 大于等于 n 的都等价于 n，都是访问不到任意位置 a[i][j] = min(a[i][j], n); } idx = 0; int ans = 0; for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) { idx++; ans = max(ans, bfs(i, j)); } cout << ans; return 0; }\"]},\"444\":{\"h\":\"100 分\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 100; const int MAXTOT = MAXN * MAXN; int n, tot; int a[MAXN + 5][MAXN + 5]; int getId(int x, int y) { return (x - 1) * n + y; } vector<int> e[MAXTOT + 5]; // tarjan int idx, dfn[MAXTOT + 5], low[MAXTOT + 5]; stack<int> s; bool inS[MAXTOT + 5]; // 新图 int id[MAXTOT + 5]; // 原图点 i 缩到了新图的哪个点 int w[MAXTOT + 5]; // 新图一个点是之前多少个点 vector<int> ee[MAXTOT + 5]; // 新图存边 // 存 SCC // int sccCnt; // vector<int> scc[MAXTOT + 5]; void dfs(int u) { dfn[u] = low[u] = ++idx; s.push(u); inS[u] = true; for (int v : e[u]) { if (dfn[v] == 0) { dfs(v); low[u] = min(low[u], low[v]); } else if (inS[v]) low[u] = min(low[u], dfn[v]); } // 当前点是某个 scc 的根 if (dfn[u] == low[u]) { //++sccCnt; while (s.top() != u) { id[s.top()] = u; // 缩到 u 上 w[u]++; inS[s.top()] = false; // scc[sccCnt].push_back(s.top()); s.pop(); } // 处理 u id[s.top()] = u; // 缩点 w[u]++; inS[s.top()] = false; // scc[sccCnt].push_back(s.top()); s.pop(); } } // 新图的 DAG 上 DP 的拓扑排序 int d[MAXTOT + 5]; // 新图每个点的入度 queue<int> q; // 拓扑排序广搜的队列 vector<int> order; // 拓扑序 bitset<MAXTOT + 5> can[MAXTOT + 5]; // 每个点能到哪些点 int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) cin >> a[i][j]; // 建图 tot = n * n; for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) { int id = getId(i, j); if (a[i][j] == 0) continue; // (i,j) -> (x,y) if (i - a[i][j] >= 1) { int x = i - a[i][j]; for (int y = max(1, j - a[i][j]); y <= min(n, j + a[i][j]); y++) e[id].push_back(getId(x, y)); } if (i + a[i][j] <= n) { int x = i + a[i][j]; for (int y = max(1, j - a[i][j]); y <= min(n, j + a[i][j]); y++) e[id].push_back(getId(x, y)); } if (j - a[i][j] >= 1) { int y = j - a[i][j]; for (int x = max(1, i - a[i][j]); x <= min(n, i + a[i][j]); x++) e[id].push_back(getId(x, y)); } if (j + a[i][j] <= n) { int y = j + a[i][j]; for (int x = max(1, i - a[i][j]); x <= min(n, i + a[i][j]); x++) e[id].push_back(getId(x, y)); } } // 缩点 for (int i = 1; i <= tot; i++) if (dfn[i] == 0) dfs(i); // 建新图（反图） for (int u = 1; u <= tot; u++) { if (id[u] == u) can[u][u] = 1; for (int v : e[u]) { if (id[u] != id[v]) { ee[id[v]].push_back(id[u]); d[id[u]]++; } } } // 拓扑排序 for (int i = 1; i <= tot; i++) if (id[i] == i && d[i] == 0) q.push(i); while (!q.empty()) { int u = q.front(); q.pop(); order.push_back(u); for (int v : ee[u]) { d[v]--; if (d[v] == 0) q.push(v); } } // 调试 /* cout << \\\"缩点后 id\\\" << \\\"\\\\n\\\"; for (int i = 1; i <= n; i++) { for (int j = 1; j <= n; j++) cout << id[getId(i, j)] << \\\" \\\"; cout << \\\"\\\\n\\\"; } cout << \\\"缩点后 w\\\" << \\\"\\\\n\\\"; for (int i = 1; i <= n; i++) { for (int j = 1; j <= n; j++) cout << w[getId(i, j)] << \\\" \\\"; cout << \\\"\\\\n\\\"; } cout << \\\"缩点后边\\\" << \\\"\\\\n\\\"; for (int i = 1; i <= tot; i++) for (int j : ee[i]) cout << i << \\\" \\\" << j << \\\"\\\\n\\\"; */ // 合并每个点能到的点 for (int u : order) { for (int v : ee[u]) can[v] |= can[u]; } // 找最大值 int ans = 0; for (int i = 1; i <= tot; i++) { int now = 0; for (int j = 1; j <= tot; j++) if (can[i][j]) { now += w[j]; } ans = max(ans, now); } cout << ans << \\\"\\\\n\\\"; return 0; }\"]},\"445\":{\"h\":\"走为上\",\"t\":[\"来源：https://codeforces.com/problemset/problem/1486/C2\",\" 分在题目描述送了，需要注意交互题不能些输入输出优化那两行代码，输入输出优化的 ios::sync_with_stdio(false); 会解除掉 cout 缓冲区和 printf 缓冲区的关联，导致 fflush(stdout) 无法刷新 cout 的缓冲区。如果写了 ios::sync_with_stdio(false); 那么 cout 只能用 cout.flush() 刷新缓冲区。直接不写输入输出优化是最方便的。\"]},\"446\":{\"h\":\"子任务 2\",\"t\":[\"保证了次大值在最左边，所以可以直接二分，每次问 ? 1 mid 时，如果答案是 1 就说明最大值在左半边，否则说明最大值在右半边。\",\"#include <bits/stdc++.h> using namespace std; int query(int l, int r) { if (l == r) return l; int res; cout << \\\"? \\\" << l << \\\" \\\" << r << \\\"\\\\n\\\"; cout.flush(); cin >> res; return res; } int main() { ios::sync_with_stdio(false); cin.tie(0); int n; cin >> n; int l = 1; int r = n; int ans = 0; while (l <= r) { int mid = (l + r) / 2; if (query(1, mid) == 1) { ans = mid; r = mid - 1; } else { l = mid + 1; } } cout << \\\"! \\\" << ans << \\\"\\\\n\\\"; cout.flush(); return 0; }\"]},\"447\":{\"h\":\"子任务 3\",\"t\":[\"对于区间 l r，先问 ? l r 得到次大值位置，然后问一下次大值那半边的次大值。就可以分析出最大值在左半边还是右半边了，所以两次询问就可以把区间二分了。这样一共需要 的询问次数。\",\"#include <bits/stdc++.h> using namespace std; int query(int l, int r) { if (l == r) return l; int res; cout << \\\"? \\\" << l << \\\" \\\" << r << \\\"\\\\n\\\"; cout.flush(); cin >> res; return res; } void outAns(int ans) { cout << \\\"! \\\" << ans << \\\"\\\\n\\\"; cout.flush(); exit(0); } int main() { ios::sync_with_stdio(false); cin.tie(0); int n; cin >> n; int l = 1; int r = n; // 这个二分保证答案在区间中 while (l <= r) { int len = r - l + 1; if (len == 1) outAns(l); int pos = query(l, r); // 区间次大值位置 if (len == 2) { if (pos == l) outAns(r); else outAns(l); } int mid = (l + r) / 2; if (pos <= mid) { // 次大值在左半边 if (mid - l + 1 >= 2) { // 左边除了次大值还有其他的，判断最大值在不在左边 int leftPos = query(l, mid); if (leftPos == pos) r = mid; else l = mid + 1; } else { // 左边只有次大值 l = mid + 1; } } else { // 次大值在右半边 if (r - mid >= 2) { // 右边除了次大值还有其他的，判断最大值在不在右边 int rightPos = query(mid + 1, r); if (rightPos == pos) l = mid + 1; else r = mid; } else { // 右边只有次大值 r = mid; } } } return 0; }\"]},\"448\":{\"h\":\"100 分\",\"t\":[\"先问一次 ? 1 n 确定最次值的位置 pos，然后问 ? 1 pos 确定最大值在 还是 这就变成了子任务 2 的模式，直接每次包上 pos 来二分即可。\",\"参考代码（原题官方题解代码）：\",\"#include <bits/stdc++.h> using namespace std; int ask(int l, int r) { if (l >= r) return -1; cout << \\\"? \\\" << l + 1 << ' ' << r + 1 << endl; int ans; cin >> ans; return ans - 1; } int main() { int n; cin >> n; int smax = ask(0, n - 1); if (smax == 0 || ask(0, smax) != smax) { int l = smax, r = n - 1; while (r - l > 1) { int m = (l + r) / 2; if (ask(smax, m) == smax) { r = m; } else { l = m; } } cout << \\\"! \\\" << r + 1 << endl; } else { int l = 0, r = smax; while (r - l > 1) { int m = (l + r) / 2; if (ask(m, smax) == smax) { l = m; } else { r = m; } } cout << \\\"! \\\" << l + 1 << endl; } return 0; }\"]},\"449\":{\"h\":\"挖土机 CSP-J 模拟赛 ~ 第十六场\",\"t\":[\"先给个简易题解，完整题解标程晚些给出\"]},\"450\":{\"h\":\"水浒\",\"t\":[\"显然答案为 ，为了避免细节推错了，更好的做法是在 周边看看要不要调整。\",\"#include <bits/stdc++.h> using namespace std; double a, b; int main() { freopen(\\\"shui.in\\\", \\\"r\\\", stdin); freopen(\\\"shui.out\\\", \\\"w\\\", stdout); cin >> a >> b; double k = floor(a / b); while (a <= k * b) k -= 1; while (a > (k + 1) * b) k += 1; cout << fixed << setprecision(12) << a - k * b; return 0; }\"]},\"451\":{\"h\":\"三国\",\"t\":[\"本身是个简单的模拟题，但要注意 最后可以到 ，所以要用 unsigned long long，假设数组空间大小为 ，显然 也能到这个级别，那直接乘以 是有可能超过 unsigned long long 的范围的，所以可以把 和 的比较改为 和 的比较\",\"#include <bits/stdc++.h> using namespace std; int n; unsigned long long m; int main() { cin >> n >> m; m = m * 1024 * 512; // 一半的空间Byte unsigned long long sum = 0; for (int i = 1; i <= n; i++) { int ri; cin >> ri; unsigned long long now = 1; for (int j = 1; j <= ri; j++) { unsigned long long aij; cin >> aij; now = now * aij; } sum += now * 4; } if (sum <= m) cout << \\\"No\\\\n\\\"; else cout << \\\"Yes\\\\n\\\"; return 0; }\"]},\"452\":{\"h\":\"西游\",\"t\":[\"第一题给两个奇数即可\",\"第二题需要输出两个相加会炸 int 的数据，输出两个 就好了\",\"第三题没有考虑 的情况，输出 即可\",\"第四题主要没考虑输入数据的类型可能会超 int，以及朴素的质数判断会不会超时的问题，给个很大的质数就好\",\"#include <bits/stdc++.h> using namespace std; int main() { freopen(\\\"xi.in\\\", \\\"r\\\", stdin); freopen(\\\"xi.out\\\", \\\"w\\\", stdout); int n; cin >> n; if (n == 1) cout << \\\"1 1\\\"; if (n == 2) cout << \\\"1000000000000000000 1\\\"; if (n == 3) cout << \\\"1\\\"; if (n == 4) cout << \\\"2147483648\\\"; return 0; }\"]},\"453\":{\"h\":\"红楼\",\"t\":[\"看完题后容易发现，直接输出 个 Miao; 就能拿到 分了。\",\"满分的 比较大，我想的做法是找到一个倍增的构造方法，即 类似的方式，显然只需要 层就能完成，可以用一个位置存当前的数，然后把他放两次到末尾，再执行一次 ADD，再放回来，再 POP 就完成了 了。 不用管， 就再放回来之前再放个 过去 ADD 就好了。\",\"还有更多别的构造方法，比如初始允许 个 和最多 项，因此可以给个 然后输出多次 （显然最多 次），然后剩下的部分再来给一个固定的哪个数字就可以了。\",\"当然你也可以利用减法和 JE 实现一个循环，但是这个就有点麻烦了。大家可以想想怎么实现循环。这实际上就是一个简陋的汇编语言了。如果列表可以无限长，那么是图灵完备的。\",\"下面给出倍增的构造方法。\",\"#include <bits/stdc++.h> using namespace std; // 1: +1 // 2: *2 string ops; string ans_num; int main() { freopen(\\\"hong.in\\\", \\\"r\\\", stdin); freopen(\\\"hong.out\\\", \\\"w\\\", stdout); int n; cin >> n; while (n > 1) { if (n % 2 == 1) ops += \\\"1\\\"; ops += \\\"2\\\"; n /= 2; } // 跳转到程序部分 ans_num += \\\"83\\\"; // 数据初始是 1 ans_num += \\\"1\\\"; // 开始程序，若干个 E[2]*=2 和 E[2]+=1 for (int i = (int)ops.size() - 1; i >= 0; i--) { if (ops[i] == '2') ans_num += \\\"42426523\\\"; if (ops[i] == '1') ans_num += \\\"42216523\\\"; } ans_num += \\\"4213\\\"; for (int i = 0; i < ans_num.size(); i++) { for (int j = 0; j < ans_num[i] - '0'; j++) cout << \\\"Miao\\\"; cout << \\\";\\\"; } return 0; } /* 程序规划 E[0],E[1] 用来跳转到程序的部分 (JMP 3) E[2] 来存储当前的数 E[3] 开始存储程序部分 翻倍操作：LOAD E[2] LOAD E[2] ADD SAVE E[2] POP 4 2 4 2 6 5 2 3 加1操作：LOAD E[2] PUSH 1 ADD SAVE E[2] POP 4 2 2 1 6 5 2 3 打印 E[2]: LOAD E[2] MEOW POP 4 2 1 3 */\"]},\"454\":{\"h\":\"挖土机 CSP-J 模拟赛 ~ 第二场\",\"t\":[\"这场其实难度很低，主要考查一个细心和阅读能力。\",\"我题解先只给个简单的，如果哪题反馈比较多看不懂我的代码、不会的话，我再抽空补一个视频题解。\"]},\"455\":{\"h\":\"月名排序\",\"t\":[\"题目怎么说，我们就怎么做。\",\"#include <bits/stdc++.h> using namespace std; string month[13] = { \\\"\\\", \\\"January\\\", \\\"February\\\", \\\"March\\\", \\\"April\\\", \\\"May\\\", \\\"June\\\", \\\"July\\\", \\\"August\\\", \\\"September\\\", \\\"October\\\", \\\"November\\\", \\\"December\\\"}; string new_month[13]; string in_month; int main() { freopen(\\\"month.in\\\", \\\"r\\\", stdin); freopen(\\\"month.out\\\", \\\"w\\\", stdout); for (int i = 1; i <= 12; i++) new_month[i] = month[i]; sort(new_month + 1, new_month + 12 + 1); cin >> in_month; for (int i = 1; i <= 12; i++) if (in_month == new_month[i]) cout << month[i]; return 0; }\"]},\"456\":{\"h\":\"第一是谁\",\"t\":[\"题目怎么说，我们就怎么做。因为数据范围给得很小，所以完全不用什么 map 呀或者优先队列啊啥的。咱老老实实好好写好暴力就好了。\",\"#include <bits/stdc++.h> using namespace std; int n, m; string nam[1005]; int score[1005][5]; int main() { freopen(\\\"top.in\\\", \\\"r\\\", stdin); freopen(\\\"top.out\\\", \\\"w\\\", stdout); cin >> n >> m; for (int i = 1; i <= n; i++) cin >> nam[i]; sort(nam + 1, nam + n + 1); while (m--) { int op, a, b; string s; cin >> op; if (op == 1) { cin >> s >> a >> b; for (int i = 1; i <= n; i++) if (s == nam[i]) score[i][a] = b; } if (op == 2) { s = nam[1]; a = score[1][1] + score[1][2] + score[1][3] + score[1][4]; for (int i = 2; i <= n; i++) { if (score[i][1] + score[i][2] + score[i][3] + score[i][4] > a) { s = nam[i]; a = score[i][1] + score[i][2] + score[i][3] + score[i][4]; } } cout << s << \\\"\\\\n\\\"; } } return 0; }\"]},\"457\":{\"h\":\"随机重复\",\"t\":[\"出题时突然想到之前 30 场语法周赛似乎都没有卡过空间。于是想出一道卡空间限制的题，就有了这道题。\",\"注意到这题空间限制只有 MiB，开 个 unsigned long long 就 MiB 了。所以不能存下来每个随机数。很多同学被我卡到了。\",\"注意到了这个就很容易想到每个随机数都去看看再 中有没有出现过就可以了。时间复杂度 我给了标程两倍以上的时间，足够了。\",\"#include <bits/stdc++.h> using namespace std; unsigned long long seed; unsigned long long rnd() { seed = seed * seed + seed + 30ull; return seed; } int n, m; unsigned long long a[100000 + 5]; bool vis[100000 + 5]; int main() { freopen(\\\"random.in\\\", \\\"r\\\", stdin); freopen(\\\"random.out\\\", \\\"w\\\", stdout); cin >> seed >> n >> m; for (int i = 1; i <= m; i++) cin >> a[i]; sort(a + 1, a + m + 1); for (int i = 1; i <= n; i++) { unsigned long long now = rnd(); int pos = lower_bound(a + 1, a + m + 1, now) - a; if (pos == m + 1) continue; if (a[pos] == now) vis[pos] = true; } int ans = 0; for (int i = 1; i <= m; i++) { if (vis[i]) ans++; if (i != m && a[i] == a[i + 1]) vis[i + 1] = vis[i]; } cout << ans; return 0; }\"]},\"458\":{\"h\":\"三三音乐\",\"t\":[\"读懂题意后，按题意模拟就好了。只有一个坑点，直接套数学式子算的话，万一有 这个浮点数会量化编码为 ，而根据题意只能量化编码为 。\",\"我比较仁慈，这块没有绑定子任务依赖，所以没有注意到这个的应该也只会丢 分。\",\"最后代码非常短。\",\"#include <bits/stdc++.h> using namespace std; const double L = 16; const double R = 20000; int a, t, b, n; double info[100000 + 5]; int info_int[100000 + 5]; int main() { freopen(\\\"music.in\\\", \\\"r\\\", stdin); freopen(\\\"music.out\\\", \\\"w\\\", stdout); ios::sync_with_stdio(false); cin.tie(0); cin >> a >> t >> b; n = a * t; for (int i = 1; i <= n; i++) cin >> info[i]; // 这一部分也可以直接生成 2^b 个分界点然后二分 // 我直接数学方法算了 double p = (R - L) / (1 << b); for (int i = 1; i <= n; i++) { info_int[i] = (info[i] - 16) / p; if (info_int[i] == (1 << b)) info_int[i]--; } // 可以转为二进制输出 // 我直接位运算处理了 for (int i = 1; i <= n; i++) for (int j = b - 1; j >= 0; j--) cout << ((info_int[i] >> j) & 1); return 0; }\"]},\"459\":{\"h\":\"挖土机 CSP-J 模拟赛 ~ 第三场\"},\"460\":{\"h\":\"神好清，而心扰之\",\"t\":[\"题目怎么说，我们就怎么做。我给个只学过条件判断的做法。有些同学会在 这样的两个对子的数据点挂掉。\",\"#include <bits/stdc++.h> using namespace std; char temp; int a, b, c, d; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> temp; a = temp - '0'; cin >> temp; b = temp - '0'; cin >> temp; c = temp - '0'; cin >> temp; d = temp - '0'; int ans = a + b + c + d; if (a == b && b == c && c == d) ans += b * b * b * b; else if (a == b && b == c || b == c && c == d) ans += b * b * b; else if (a == b && c == d) ans += a * a + c * c; else if (a == b || b == c) ans += b * b; else if (c == d) ans += c * c; if (a == 8 || a == 6) ans *= 2; if (b == 8 || b == 6) ans *= 2; if (c == 8 || c == 6) ans *= 2; if (d == 8 || d == 6) ans *= 2; cout << ans; return 0; }\"]},\"461\":{\"h\":\"心好静，而欲牵之\",\"t\":[\"诈骗题。由这题大家也能感受到并查集用了路径压缩和按秩合并之后，在信息学竞赛中几乎可以当作是 用了。\",\" 远超 ，所以答案只有 四种。\",\"很多同学这题没注意输入输出优化挂掉。很容易忽视掉非常多行输出时的 endl 会刷新缓冲区导致超时。\",\"#include <bits/stdc++.h> using namespace std; int f[] = {1, 3, 7, 61}; signed main() { ios::sync_with_stdio(false); cin.tie(0); int T; cin >> T; while (T--) { long long n; cin >> n; if (1 <= n && n < 3) cout << 0 << \\\"\\\\n\\\"; else if (3 <= n && n < 7) cout << 1 << \\\"\\\\n\\\"; else if (7 <= n && n < 61) cout << 2 << \\\"\\\\n\\\"; else if (61 <= n) cout << 3 << \\\"\\\\n\\\"; } return 0; }\"]},\"462\":{\"h\":\"遣其欲，而心自静\",\"t\":[\"显然只有两种情况： 或者 （ 为质数）。所以可以先打个质数表（用埃氏筛就够了），然后枚举 算算有多少个 满足 （二分或者双指针都可以）。\",\"当然如果你记得唯一分解定理，那么也可以直接快速求出来每个数的因子个数，搭配欧拉筛甚至能做到 处理出来 每个数的因子个数，就更简单了。\",\"#include <bits/stdc++.h> using namespace std; int n; bool f[10000000 + 5]; vector<int> p; int main() { cin >> n; f[0] = f[1] = true; for (int i = 2; i <= n; i++) { if (!f[i]) { p.push_back(i); for (int j = i + i; j <= n; j += i) f[j] = true; } } // p1*p2 <= n int ans = 0; for (int i = 0; i < p.size(); i++) { // 最后一个小于等于 n/p[1] 的数 int pos = upper_bound(p.begin(), p.end(), n / p[i]) - p.begin() - 1; if (pos <= i) break; ans += pos - i; } // p1 * p1 * p1 for (int i = 0; i < p.size(); i++) if (p[i] * p[i] * p[i] > n) { ans += i; break; } cout << ans; return 0; }\"]},\"463\":{\"h\":\"澄其心，而神自清\"},\"464\":{\"h\":\"10 分\",\"t\":[\"每个词都没有含义，直接输出原文的值即可。\",\"#include <bits/stdc++.h> using namespace std; const int MOD = 1'000'000'000 + 7; int n, m; string seq[100005]; map<string, vector<string>> e; int cal(string &s) { int a = s[0]; int b = s[1]; int c = s[2]; int d = s[3]; return a + b + c + d; } int main() { cin >> n >> m; for (int i = 1; i <= n; i++) cin >> seq[i]; for (int i = 1; i <= m; i++) { string s, t; int num; cin >> s; cin >> num; while (num--) { cin >> t; e[s].push_back(t); } } int ans = 0; for (int i = 1; i <= n; i++) { ans += cal(seq[i]); ans %= MOD; } cout << ans; return 0; }\"]},\"465\":{\"h\":\"30 分\",\"t\":[\"其实可以先把字符串对应到一个 进制整数再处理（如果不是定长的字符串就需要 进制）。但反正不超时，我给一个 map<string, vector<string>> 的代码。注意这样写的话查 e[\\\"xxxx\\\"] 就自带一个 了。\",\"30 分只有一层含义，直接有含义就做一层就好了。\",\"#include <bits/stdc++.h> using namespace std; const int MOD = 1'000'000'000 + 7; int n, m; string seq[100005]; map<string, vector<string>> e; int cal(string &s) { int a = s[0]; int b = s[1]; int c = s[2]; int d = s[3]; return a + b + c + d; } int main() { cin >> n >> m; for (int i = 1; i <= n; i++) cin >> seq[i]; for (int i = 1; i <= m; i++) { string s, t; int num; cin >> s; cin >> num; while (num--) { cin >> t; e[s].push_back(t); } } int ans = 0; for (int i = 1; i <= n; i++) { if (e.find(seq[i]) == e.end()) { ans += cal(seq[i]); ans %= MOD; } else { for (auto x : e[seq[i]]) { ans += cal(x); ans %= MOD; } } } cout << ans; return 0; }\"]},\"466\":{\"h\":\"60 分\",\"t\":[\"虽然有多层含义，但是最终文章也不长，所以直接暴力递归算就好了。\",\"#include <bits/stdc++.h> using namespace std; const int MOD = 1'000'000'000 + 7; int n, m; string seq[100005]; map<string, vector<string>> e; int cal(string &s) { // 没有额外含义 if (e.find(s) == e.end()) { int res = 0; for (char x : s) res += (int)x; return res; } // 算出来每个含义的值，求和 int res = 0; for (string &x : e[s]) { res += cal(x); res %= MOD; } return res; } int main() { cin >> n >> m; for (int i = 1; i <= n; i++) cin >> seq[i]; for (int i = 1; i <= m; i++) { string s, t; int num; cin >> s; cin >> num; while (num--) { cin >> t; e[s].push_back(t); } } int ans = 0; for (int i = 1; i <= n; i++) { ans += cal(seq[i]); ans %= MOD; } cout << ans; return 0; }\"]},\"467\":{\"h\":\"100 分\",\"t\":[\"显然每次算某个词的时候，最终展开求出来的值是一样的，记忆化加上就好了。\",\"#include <bits/stdc++.h> using namespace std; const int MOD = 1'000'000'000 + 7; int n, m; string seq[100005]; map<string, vector<string>> e; map<string, int> rnk; int cal(string &s) { if (rnk.find(s) != rnk.end()) return rnk[s]; // 没有额外含义 if (e.find(s) == e.end()) { int res = 0; for (char x : s) res += (int)x; return rnk[s] = res; } // 算出来每个含义的值，求和 int res = 0; for (string &x : e[s]) { res += cal(x); res %= MOD; } return rnk[s] = res; } int main() { cin >> n >> m; for (int i = 1; i <= n; i++) cin >> seq[i]; for (int i = 1; i <= m; i++) { string s, t; int num; cin >> s; cin >> num; while (num--) { cin >> t; e[s].push_back(t); } } int ans = 0; for (int i = 1; i <= n; i++) { ans += cal(seq[i]); ans %= MOD; } cout << ans; return 0; }\"]},\"468\":{\"h\":\"挖土机 CSP-J 模拟赛 ~ 第四场\"},\"469\":{\"h\":\"延迟罐罐\",\"t\":[\"显然直接枚举找个答案就好。\",\"#include <bits/stdc++.h> using namespace std; int main() { int n, m; cin >> n >> m; for (int x = 1;; x++) { if (n + x == min(756, m + x / 4)) { cout << n + x; return 0; } } return 0; }\"]},\"470\":{\"h\":\"圈个矩形\",\"t\":[\"很多后期选手一看就二分，但是没有注意到 会超 long long 直接就没了。\",\"实际上因为最终乘积的小于 ，所以较短的那条边必然小于 ，所以直接枚举就好了。\",\"#include <bits/stdc++.h> #define int long long using namespace std; int n, L, R; signed main() { cin >> n >> L >> R; for (int i = 1; i <= n / 2; i++) { int j = n - i; if (i * j > R) break; if (L <= i * j && i * j <= R) { cout << i << \\\" \\\" << j << \\\"\\\\n\\\"; return 0; } } cout << \\\"-1\\\\n\\\"; return 0; }\"]},\"471\":{\"h\":\"因式分解\",\"t\":[\"有三个小考点，怎么输入，怎么输出第一行，怎么输出第二行。\",\"输入可以用 char 吃掉多余单个字符，然后读整数的方法读每个整数。也可以直接不停读字符然后处理。\",\"第一行的内容就是要细致，按题目要求一点点处理。\",\"第二行很多同学会用一元二次方程求根公式。但实际先排除无解和都是解之后，可以看最初给的形式 ，就确定了根就两个 。\",\"#include <bits/stdc++.h> #define int long long using namespace std; char t; int i, n, j, m; signed main() { cin >> t >> i >> t >> t >> n >> t; // (ix+n) cin >> t >> j >> t >> t >> m >> t; // (jx+m) int a = i * j; int b = i * m + j * n; int c = n * m; if (a != 0) { if (a != 1) cout << a; cout << \\\"x^2\\\"; } if (b != 0) { if (a != 0) cout << \\\"+\\\"; if (b != 1) cout << b; cout << \\\"x\\\"; } if (c != 0) { if (a != 0 || b != 0) cout << \\\"+\\\"; cout << c; } cout << \\\"\\\\n\\\"; bool flag = false; int ans; if (a == 0 && b == 0) { if (c == 0) flag = true, ans = 33; } else if (a == 0) { if (c % b == 0) flag = true, ans = -c / b; } else { // (ix+n)(jx+m) if (n % i == 0) flag = true, ans = -n / i; if (m % j == 0) flag = true, ans = -m / j; } if (flag) cout << ans << \\\"\\\\n\\\"; else cout << \\\"No\\\\n\\\"; return 0; }\"]},\"472\":{\"h\":\"无敌闯关\",\"t\":[\"这题的原题是我收藏已久的 P7167 [eJOI2020 Day1] Fountain\"]},\"473\":{\"h\":\"30 分\",\"t\":[\"直接暴力枚举就好。\",\"#include <bits/stdc++.h> using namespace std; int n, m, T, k; // 敌人战斗力，敌人胆量 int a[100000 + 5], b[100000 + 5]; // 返回从 pos 开始的游戏结局 int f(int pos) { //cout << \\\"====\\\" << pos << \\\"====\\\\n\\\"; int health = n; int power = 0; while (pos <= m) { // 吓跑直接不战斗 if (b[pos] <= power) { pos++; continue; } // 战斗结算 health -= a[pos]; power = b[pos]; //cout << pos << \\\":\\\" << health << \\\",\\\" << power << \\\"\\\\n\\\"; if (health <= 0) return pos; pos++; } return 0; } int main() { cin >> n >> m >> T; for (int i = 1; i <= m; i++) cin >> a[i] >> b[i]; for (int i = 1; i <= T; i++) { int k; cin >> k; cout << f(k) << \\\"\\\\n\\\"; } return 0; }\"]},\"474\":{\"h\":\"60 分\",\"t\":[\"因为此时肯定是一个个打过去，所以可以直接处理个前缀和，然后二分就能找到结束位置了。\"]},\"475\":{\"h\":\"100 分\",\"t\":[\"都在注释里了。也可以去原题看看题解。\",\"#include <bits/stdc++.h> #define int long long using namespace std; int n, m, T, k; const int MAXN = 100000; // 敌人战斗力，敌人胆量 int a[MAXN + 5], b[MAXN + 5]; // f[i][j] 记录 i 后面第 2^j 个是谁 // g[i][j] 记录 i 开始后面的 2^j 个敌人的战斗力之和 int f[MAXN + 5][25]; int g[MAXN + 5][25]; // 单调栈计算每个敌人下一个胆量大于他的在哪儿 stack<int> s; void init() { // 预处理 2^0 层 for (int i = m; i >= 1; i--) { // 去掉栈顶小于等于 b[i] 的 while (!s.empty() && b[s.top()] <= b[i]) s.pop(); // 现在的栈顶就是下一个大于 b[i] 的位置 g[i][0] = a[i]; if (s.empty()) f[i][0] = 0; else f[i][0] = s.top(); // 当前编号放入单调栈 s.push(i); } // 处理 2^k 层 for (int k = 1; k <= 20; k++) for (int i = 1; i <= m; i++) { int ii = f[i][k - 1]; // 往后 2^{k-1} 层的位置 f[i][k] = f[ii][k - 1]; g[i][k] = g[i][k - 1] + g[ii][k - 1]; } } // 计算从 pos 位置开始，初始血量为 n，最终打败的是谁 int cal(int pos) { int health = n; for (int k = 20; k >= 0; k--) { if (g[pos][k] < health) { health -= g[pos][k]; pos = f[pos][k]; } } return pos; } signed main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; cin >> m >> T; for (int i = 1; i <= m; i++) cin >> a[i] >> b[i]; init(); // 预处理 f,g for (int i = 1; i <= T; i++) { int k; cin >> k; cout << cal(k) << \\\"\\\\n\\\"; } return 0; }\"]},\"476\":{\"h\":\"挖土机 CSP-J 模拟赛 ~ 第五场\"},\"477\":{\"h\":\"达标率比拼\",\"t\":[\"这题似乎有同学因为使用了 y1 作为全局变量挂掉了。\",\"大家可以看看 首次参赛手册 最下面的“其他常见的代码错误”。\",\"j0 j1 jn y0 y1 yn 在 <cmath> 中有定义，是贝塞尔函数的解。不要在全局变量用这些变量名。\",\"#include <bits/stdc++.h> using namespace std; int main() { int a1, a2, a3, a4; int x1, x2, x3, x4; int b1, b2, b3, b4; int y1, y2, y3, y4; cin >> a1 >> a2 >> a3 >> a4; cin >> x1 >> x2 >> x3 >> x4; cin >> b1 >> b2 >> b3 >> b4; cin >> y1 >> y2 >> y3 >> y4; int a = a1 + a2 + a3 + a4; int x = x1 + x2 + x3 + x4; int b = b1 + b2 + b3 + b4; int y = y1 + y2 + y3 + y4; if (x * b > y * a) cout << \\\"A\\\"; else if (x * b < y * a) cout << \\\"B\\\"; else cout << \\\"33DAI\\\"; return 0; }\"]},\"478\":{\"h\":\"区间开方和\",\"t\":[\"90 分就不多说了。满分除了做法本身之外还有两个问题：\",\"一个是要用 __int128 或者高精度。这题最后 主要就是为了科普一下 __int128 的用法。__int128 是 128 位二进制数，也就是能存得下 long long * long long，运算速度会稍微的慢一丢丢，然后不能直接用 cin/cout 读写。一般会直接读进来一个 long long 然后赋值过去，或者逐个读字符类似快读的方法拼凑。输出时可以像我下面代码一样递归一位位转成可以输出的类型输出即可。\",\"另一个是直接用 sqrt 的精度不够，一定要注意 sqrt 默认参数和返回值都是 double 类型，对 int 以上的数据范围开方时精度很大概率不够。当然这题也不能手写二分，时间复杂度会不够，我看有一位同学就是用了 __int128 但是每个算术平方根都是用二分求的出的问题。\",\"那满分怎么做呢？暴力枚举 1e14 肯定超呀。其实我们会发现算术平方根只有 1e8 种，可以反向求解每个算术平方根对应的数有几个来计算即可。\",\"#include <bits/stdc++.h> #define int long long using namespace std; void outInt128(__int128 x) { int num = x % 10; if (x / 10 > 0) outInt128(x / 10); cout << num; } signed main() { int l, r; cin >> l >> r; __int128 sum = 0; for (int i = 1; i <= 10000000; i++) { __int128 L = i * i; __int128 R = (i + 1) * (i + 1) - 1; if (R < l) continue; if (L > r) break; if (R > r) R = r; if (L < l) L = l; sum += i * (R - L + 1); } outInt128(sum); return 0; }\"]},\"479\":{\"h\":\"多少种得分\",\"t\":[\"部分分给了很多爆搜的分，满分就是个分组背包的小变种，没啥好说的。\",\"#include <bits/stdc++.h> using namespace std; int n; vector<int> e[105]; bool f[105][10000 + 5]; int main() { cin >> n; for (int i = 1; i <= n; i++) { int num, x; cin >> num; for (int j = 1; j <= num; j++) { cin >> x; e[i].push_back(x); } } f[0][0] = true; for (int i = 1; i <= n; i++) for (int v = 10000; v >= 0; v--) for (int j = 0; j < e[i].size(); j++) { int now = e[i][j]; if (v >= now) f[i][v] = f[i][v] | f[i - 1][v - now]; } int ans = 0; for (int i = 0; i <= 10000; i++) if (f[n][i]) ans++; cout << ans; return 0; }\"]},\"480\":{\"h\":\"拉多少个群\",\"t\":[\"想想好久没出麻烦一点的构造题了，其实这题想清楚后就很简单。\",\"子任务 1：就两个人，可以拉 个群，直接第一个群有两个人你，然后两个人分别自己待一个单人群就好了。\",\"子任务 2：每个群都能放进去所有人，能拉 个群。通过第一个子任务的经验，显然发现可以直接先拉 个单人群就搞定了后两个规则。然后还有一个群直接拉一个所有人的群就好了。\",\"子任务 3：每个群两个人，那直接任意两个人之间拉一个群就好了。\",\"子任务 4：因为 这个限制，显然第一个人需要 个群才能和其他人建立联系，所以 的数据范围就给了那么宽松的范围（其实本来准备给 然后写错了）。显然只要每个人都和所有没有同群的人拉个群就好了。\",\"#include <bits/stdc++.h> using namespace std; int n, m, k; int tot; vector<int> e[105]; set<int> ee[105]; // ee[1] 存 1 和哪些人已经在一个群了 int main() { freopen(\\\"group.in\\\", \\\"r\\\", stdin); freopen(\\\"group.out\\\", \\\"w\\\", stdout); cin >> n >> m >> k; // 子任务 1 if (n == 2) { cout << \\\"3\\\\n\\\"; cout << \\\"2 1 2\\\\n\\\"; cout << \\\"1 1\\\\n\\\"; cout << \\\"1 2\\\\n\\\"; return 0; } // 子任务 2 if (m == n) { cout << n + 1 << \\\"\\\\n\\\"; cout << n << \\\" \\\"; for (int i = 1; i <= n; i++) cout << i << \\\" \\\"; cout << \\\"\\\\n\\\"; for (int i = 1; i <= n; i++) cout << \\\"1 \\\" << i << \\\"\\\\n\\\"; return 0; } // 子任务 3 if (m == 2) { cout << n * (n - 1) / 2 << \\\"\\\\n\\\"; for (int i = 1; i <= n; i++) for (int j = i + 1; j <= n; j++) cout << \\\"2 \\\" << i << \\\" \\\" << j << \\\"\\\\n\\\"; return 0; } // 子任务 4 for (int i = 1; i <= n; i++) { tot++; ee[i].insert(i); e[tot].push_back(i); for (int j = 1; j <= n; j++) { if (ee[i].count(j)) continue; if (e[tot].size() < m) { for (int k = 0; k < e[tot].size(); k++) { ee[j].insert(e[tot][k]); ee[e[tot][k]].insert(j); } e[tot].push_back(j); } else { tot++; e[tot].push_back(i); e[tot].push_back(j); ee[i].insert(j); ee[j].insert(i); } } } cout << tot << \\\"\\\\n\\\"; for (int i = 1; i <= tot; i++) { cout << e[i].size() << \\\" \\\"; for (int j = 0; j < e[i].size(); j++) cout << e[i][j] << \\\" \\\"; cout << \\\"\\\\n\\\"; } return 0; }\"]},\"481\":{\"h\":\"挖土机 CSP-J 模拟赛 ~ 第六场\"},\"482\":{\"h\":\"猫咪几岁\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { freopen(\\\"age.in\\\", \\\"r\\\", stdin); freopen(\\\"age.out\\\", \\\"w\\\", stdout); int x; cin >> x; if (x < 15) cout << 0; else if (x < 23) cout << 1; else cout << (x - 24) / 4 + 2; return 0; }\"]},\"483\":{\"h\":\"不进位加\",\"t\":[\"有很多同学错在了 以及 。我也比较残忍，没注意到这个直接 10 分哈哈哈。\",\"#include <bits/stdc++.h> #define int long long using namespace std; int a, b; signed main() { freopen(\\\"add.in\\\", \\\"r\\\", stdin); freopen(\\\"add.out\\\", \\\"w\\\", stdout); cin >> a >> b; // 调整为 a>=b if (b > a) swap(a, b); // 输出每一位 bool zero = true; for (int i = 1'000'000'000'000'000'000; i; i /= 10) { int x = a / i % 10; int y = b / i % 10; int z = (x + y) % 10; if (z != 0) zero = false; if (z || !zero) // z>0 || (z==0 && zero==false) cout << z; } if (zero) cout << 0; return 0; }\"]},\"484\":{\"h\":\"逢七上学\",\"t\":[\"这题其实是作为教学题出的。首先简单的暴力枚举就不说了。\",\"所有的枚举优化第一个要找的突破口就是限制条件，比较好想到根据回文数这个限制，可以通过枚举左半边，构造右半边的形式，来把枚举规模降低到 。很轻松能写出 60 分的代码.\",\"#include <bits/stdc++.h> #define int long long using namespace std; bool p(int x) { if (x < 2) return false; for (int i = 2; i * i <= x; i++) if (x % i == 0) return false; return true; } int gen(int x) { int xx = x; x /= 10; while (x > 0) { xx = xx * 10 + x % 10; x /= 10; } return xx; } bool test7(int x) { while (x > 0) { if (x % 10 == 7) return true; x /= 10; } return false; } int n, cnt; signed main() { cin >> n; cnt = 0; for (int i = 1;; i++) { int x = gen(i); if (x > n) break; if (!test7(x)) continue; if (!p(x)) continue; cnt++; } cout << cnt; return 0; }\",\"本地跑完会发现极限数据有 多个解，达标的话只记半边 也写不下呀。那满分怎么看都超，怎么办呢？\",\"实际上可以考虑分段达标， 个 的枚举，每 个记一下当前的 就好。\",\"... int n, cnt; vector<int> a; signed main() { freopen(\\\"a.txt\\\", \\\"w\\\", stdout); n = 1'000'000'000'000; cnt = 0; for (int i = 1;; i++) { int x = gen(i); if (i % 1000 == 1) cout << cnt << \\\",\\\"; if (x > n) break; if (!test7(x)) continue; if (!p(x)) continue; cnt++; } return 0; }\",\"最后满分代码就好写了：\",\"#include <bits/stdc++.h> #define int long long using namespace std; bool p(int x) { if (x < 2) return false; for (int i = 2; i * i <= x; i++) if (x % i == 0) return false; return true; } int gen(int x) { int xx = x; x /= 10; while (x > 0) { xx = xx * 10 + x % 10; x /= 10; } return xx; } bool test7(int x) { while (x > 0) { if (x % 10 == 7) return true; x /= 10; } return false; } int n, cnt; int half1000[] = {0, 45, 89, 89, 138, 138, 138, 138, 293, 293, 344, 390, 427, 466, 508, 542, 580, 614, 755, 790, 829, 829, 829, 829, 829, 829, 829, 829, 829, 829, 829, 859, 902, 938, 981, 1018, 1051, 1087, 1209, 1235, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1265, 1392, 1523, 1663, 1781, 1915, 2045, 2154, 2264, 2379, 2508, 2508, 2508, 2508, 2508, 2508, 2508, 2508, 2508, 2508, 2508, 2549, 2589, 2618, 2650, 2684, 2719, 2756, 2883, 2920, 2955, 2995, 3036, 3063, 3095, 3130, 3163, 3194, 3306, 3343, 3375, 3411, 3439, 3469, 3501, 3540, 3570, 3597, 3701, 3738, 3771, 3802, 3825, 3848, 3883, 3923, 3958, 3985, 4095, 4119, 4155, 4194, 4219, 4250, 4282, 4308, 4336, 4363, 4470, 4499, 4528, 4559, 4594, 4626, 4663, 4694, 4728, 4751, 4845, 4879, 4905, 4925, 4956, 4983, 5005, 5039, 5069, 5094, 5203, 5228, 5258, 5292, 5327, 5356, 5388, 5415, 5447, 5474, 5591, 5615, 5639, 5750, 5861, 5972, 6099, 6218, 6316, 6420, 6528, 6630, 6746, 6777, 6808, 6835, 6858, 6879, 6917, 6951, 7061, 7089, 7121, 7149, 7174, 7202, 7233, 7265, 7287, 7312, 7428, 7458, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7481, 7516, 7535, 7569, 7605, 7628, 7665, 7695, 7803, 7833, 7866, 7897, 7930, 7952, 7981, 8004, 8037, 8060, 8161, 8193, 8229, 8258, 8286, 8319, 8349, 8375, 8408, 8435, 8531, 8562, 8585, 8611, 8636, 8666, 8694, 8718, 8751, 8784, 8890, 8922, 8942, 8978, 9013, 9044, 9070, 9095, 9127, 9153, 9257, 9283, 9314, 9348, 9381, 9410, 9440, 9465, 9500, 9527, 9621, 9651, 9679, 9704, 9739, 9766, 9790, 9828, 9860, 9893, 9987, 10014, 10047, 10160, 10291, 10405, 10509, 10613, 10710, 10807, 10906, 11011, 11115, 11147, 11180, 11207, 11232, 11263, 11286, 11306, 11409, 11438, 11466, 11499, 11530, 11555, 11590, 11622, 11646, 11674, 11773, 11803, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11826, 11922, 12018, 12129, 12228, 12344, 12449, 12548, 12656, 12753, 12862, 12951, 13059, 13165, 13280, 13387, 13511, 13607, 13705, 13812, 13925, 14030, 14148, 14271, 14376, 14487, 14591, 14701, 14795, 14894, 14992, 15088, 15207, 15315, 15400, 15504, 15604, 15691, 15798, 15911, 16017, 16103, 16205, 16305, 16395, 16506, 16622, 16719, 16819, 16915, 17010, 17124, 17230, 17335, 17442, 17545, 17640, 17745, 17844, 17948, 18030, 18142, 18250, 18360, 18466, 18574, 18675, 18775, 18892, 18987, 19095, 19203, 19318, 19417, 19533, 19624, 19731, 19831, 19925, 20023, 20120, 20225, 20336, 20446, 20553, 20656, 20764, 20870, 20964, 21057, 21156, 21259, 21389, 21510, 21613, 21728, 21820, 21908, 22025, 22116, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22225, 22255, 22292, 22313, 22339, 22375, 22402, 22436, 22535, 22561, 22594, 22624, 22654, 22682, 22711, 22734, 22767, 22797, 22893, 22930, 22957, 22983, 23009, 23037, 23071, 23099, 23124, 23154, 23272, 23298, 23324, 23338, 23368, 23392, 23421, 23444, 23478, 23498, 23604, 23632, 23660, 23681, 23704, 23734, 23768, 23800, 23826, 23858, 23945, 23978, 24006, 24030, 24058, 24094, 24124, 24150, 24185, 24213, 24322, 24355, 24379, 24408, 24438, 24467, 24487, 24516, 24545, 24570, 24665, 24688, 24709, 24819, 24935, 25032, 25144, 25254, 25353, 25458, 25559, 25650, 25727, 25751, 25785, 25813, 25837, 25862, 25895, 25916, 26024, 26048, 26075, 26106, 26142, 26169, 26196, 26222, 26254, 26285, 26383, 26409}; signed main() { freopen(\\\"seven.in\\\", \\\"r\\\", stdin); freopen(\\\"seven.out\\\", \\\"w\\\", stdout); cin >> n; int l = 0; int r = 999; int st = 0; while (l <= r) { int mid = (l + r) / 2; int x = gen(mid * 1000); if (x <= n) { st = mid * 1000; cnt = half1000[mid]; l = mid + 1; } else r = mid - 1; } for (int i = st;; i++) { int x = gen(i); if (x > n) break; if (!test7(x)) continue; if (!p(x)) continue; cnt++; } cout << cnt; return 0; }\"]},\"485\":{\"h\":\"踏遍线段\",\"t\":[\"前两个子任务就不说了，有些同学没注意到第二个子任务有四种情况。\",\"满分做法首先要能看出来先二分答案，把构造转换成检验。然后怎么检查 秒能不能踏遍呢？\",\"显然最左边的人需要负责把左边的踏满，那有两种方案，先左再右还是先右再左。显然哪种能覆盖更多就选哪种即可。后面每个人依次看看怎么在上一次的基础上能多覆盖就好。\",\"（这题最高 10 分数据可能会有问题，但是 OI 赛制题面没问题就还好，回头如果发现了数据问题重测一下就好了。）\",\"#include <bits/stdc++.h> #define int long long using namespace std; int n, m; int a[1000000 + 5]; bool check(int x) { // 从前往后 int last = -1; for (int i = 1; i <= m; i++) { int now = a[i]; // 要回头 if (now >= last + 2) { // 能不能接上，last 和 now 中间有 now - last - 1 个数 if (now - last - 1 > x) return false; // 可以先左再右，也可以先右再左 int max1 = now + max(0LL, x - (now - last - 1) * 2); int max2 = now + max(0LL, (x - (now - last - 1)) / 2); last = max(max1, max2); } // 继续往前 else if (now <= last + 2) last = max(last, now + x); } return last >= n; } signed main() { cin >> n >> m; for (int i = 1; i <= m; i++) cin >> a[i]; sort(a + 1, a + m + 1); int l = 0; int r = n * 2; int ans; while (l <= r) { int mid = (l + r) / 2; if (check(mid)) { ans = mid; r = mid - 1; } else l = mid + 1; } cout << ans; return 0; }\"]},\"486\":{\"h\":\"挖土机 CSP-J 模拟赛 ~ 第七场\"},\"487\":{\"h\":\"瞒天过海\",\"t\":[\"简单替换，这边给一个类似于“位运算遍历二进制每一位”的遍历十进制每一位的小技巧。直接数位分解当然没什么问题。直接读一个字符串自然也更没什么问题了。\",\"#include <bits/stdc++.h> using namespace std; string t = \\\"olz34sb78q\\\"; int a; int main() { freopen(\\\"man.in\\\", \\\"r\\\", stdin); freopen(\\\"man.out\\\", \\\"w\\\", stdout); cin >> a; bool zero = true; for (int i = 1000000000; i >= 1; i /= 10) { int now = a / i % 10; if (now > 0 || !zero) { cout << t[a / i % 10]; zero = false; } } return 0; }\"]},\"488\":{\"h\":\"围魏救赵\",\"t\":[\"其实就是贪心先用 大的去消耗 就好。但细节有点多，可以多想想再写。\",\"#include <bits/stdc++.h> #define int long long using namespace std; int n, m, k; int a[1005]; int b[1005]; signed main() { freopen(\\\"wei.in\\\", \\\"r\\\", stdin); freopen(\\\"wei.out\\\", \\\"w\\\", stdout); cin >> n >> m >> k; for (int i = 1; i <= k; i++) cin >> a[i]; for (int i = 1; i <= k; i++) cin >> b[i]; for (int i = 1; i <= k; i++) for (int j = i + 1; j <= k; j++) if (a[j] > a[i]) { swap(a[i], a[j]); swap(b[i], b[j]); } for (int i = 1; i <= k; i++) { // cout << a[i] << \\\" \\\" << b[i] << \\\"\\\\n\\\"; if (a[i] == 1 || m == 0 || n == 0) break; // 尽可能消耗 n, num 为能消耗多少 n int num = min(b[i], (m + (a[i] - 1)) / a[i]); n = max(0LL, n - num); m = max(0LL, m - num * a[i]); } if (n > m) cout << n - m; else cout << \\\"No\\\"; return 0; }\"]},\"489\":{\"h\":\"借刀杀人\",\"t\":[\"题目来源：https://www.luogu.com.cn/problem/CF900B\",\"显然就是模拟看每一位，遇到循环了还没找到就停。但是需要注意，可以手算一下除法什么时候出现循环节，容易发现是当余数出现过了，或者说当前被除数已经出现过了就循环了。\",\"或者直接暴力做 次，因为余数最多就 种可能，直接多做几次可以保证没错也不用想那么多。\",\"#include <bits/stdc++.h> using namespace std; int a, b, c, now; bool f[100000 + 5]; int main() { freopen(\\\"jie.in\\\", \\\"r\\\", stdin); freopen(\\\"jie.out\\\", \\\"w\\\", stdout); cin >> a >> b >> c; int cnt = 1; while (!f[a]) { f[a] = true; a = a * 10; now = a / b; if (now == c) { cout << cnt; return 0; } a = a % b; cnt++; } cout << 0; return 0; }\"]},\"490\":{\"h\":\"以逸待劳\",\"t\":[\"最暴力的做法显然是直接枚举所有选择方案，再来一个个用户检查是否符合条件，时间复杂度 。能拿不少分。\",\"此时我们可以简单想想什么情况下是不行的。对于每个人来说，就是所有他做过的题只能出现一个，反向想想，也就是他做过的题之间任意两个都是冲突的。可以直接 预处理出冲突数组（描述任意两道题是否冲突）。这样 枚举后就只要 检查是否有冲突。总体来说就是道数据范围题，不是很难。\",\"#include <bits/stdc++.h> using namespace std; int n, m; int a[1000 + 5][88 + 5]; bool b[88 + 5][88 + 5]; int cnt, ans[4 + 5]; void dfs(int now, int st) { if (now == 5) { for (int i = 1; i <= 4; i++) for (int j = i + 1; j <= 4; j++) if (b[ans[i]][ans[j]]) return; // for (int i = 1; i <= 4; i++) // cout << ans[i] << \\\" \\\"; // cout << \\\"\\\\n\\\"; cnt++; return; } for (int i = st; i <= n; i++) { ans[now] = i; dfs(now + 1, i + 1); } } int main() { freopen(\\\"yi.in\\\", \\\"r\\\", stdin); freopen(\\\"yi.out\\\", \\\"w\\\", stdout); cin >> n >> m; for (int i = 1; i <= m; i++) { for (int j = 1; j <= n; j++) cin >> a[i][j]; for (int j = 1; j <= n; j++) for (int k = j + 1; k <= n; k++) if (a[i][j] && a[i][k]) b[j][k] = b[k][j] = 1; } cnt = 0; dfs(1, 1); cout << cnt; return 0; }\"]},\"491\":{\"h\":\"挖土机 CSP-J 模拟赛 ~ 第八场\"},\"492\":{\"h\":\"趁火打劫\",\"t\":[\"这题我有一点点锅，题面写得没有特别清楚，容易被误解为只有直接依赖会得不到分，实际上间接的依赖也会丢分。\",\"比如子任务 2 依赖子任务 1，子任务 3 依赖子任务 2。那么子任务 1 如果错了，子任务 3 也拿不到分。\",\"#include <bits/stdc++.h> using namespace std; int a[5][5]; int score[5]; int main() { freopen(\\\"chen.in\\\", \\\"r\\\", stdin); freopen(\\\"chen.out\\\", \\\"w\\\", stdout); for (int i = 1; i <= 4; i++) for (int j = 1; j <= 4; j++) cin >> a[i][j]; for (int no = 1; no <= 4; no++) { for (int i = 1; i <= 4; i++) score[i] = i * 10; score[no] = 0; if (score[1] == 0 && a[1][2] == 1) score[2] = 0; if (score[1] == 0 && a[1][3] == 1) score[3] = 0; if (score[1] == 0 && a[1][4] == 1) score[4] = 0; if (score[2] == 0 && a[2][3] == 1) score[3] = 0; if (score[2] == 0 && a[2][4] == 1) score[4] = 0; if (score[3] == 0 && a[3][4] == 1) score[4] = 0; cout << score[1] + score[2] + score[3] + score[4] << \\\" \\\"; } return 0; }\"]},\"493\":{\"h\":\"声东击西\",\"t\":[\"诈骗题。实际上答案就是长度大于等于 的最大子段和。\",\"首先容易发现 Kitten 到过的城市必然是某段子段，并且不可能只待在一个城市，因为 33DAI 后面来了会让他输掉游戏。\",\"所以如果能达成“长度大于等于 的最大子段和”必然就是最优解，而这必然能达成。对于区间 ，它只需要在某个端点声东击西，然后往另一个端点走就可以了。\",\"#include <bits/stdc++.h> #define int long long using namespace std; const int MAXN = 1000000; int n; int a[MAXN + 5]; int sum[MAXN + 5]; signed main() { freopen(\\\"sheng.in\\\", \\\"r\\\", stdin); freopen(\\\"sheng.out\\\", \\\"w\\\", stdout); cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; for (int i = 1; i <= n; i++) sum[i] = sum[i - 1] + a[i]; int ans = sum[2]; int minSum = 0; for (int i = 3; i <= n; i++) { minSum = min(minSum, sum[i - 2]); ans = max(ans, sum[i] - minSum); } cout << ans; return 0; }\"]},\"494\":{\"h\":\"无中生有\",\"t\":[\"灵感来源：https://www.luogu.com.cn/problem/CF902B\",\"实际上这道题我们可以把每个数字 和他去掉了最高位之后的剩余部分 ，建立一个 到 的父子关系，从而构建一棵树。比如假设有 ，就可以构建下面这棵树。\",\"2 -> 12 -> 312 \\\\ \\\\-> 412 \\\\->32\",\"这样这题就转换成了灵感来源那道题了，给一个点染色就会给整个子树染色。容易发现不可能先染色子节点再染色它的某个祖先节点。所以可以从根节点开始，如果和目标不一样就变颜色，并给子节点改成对应的颜色。\",\"当然进一步总结会发现，也就是每个节点如果和父节点颜色不一样，操作次数就要加 。\",\"另外这题还给了一些部分分，子任务 1,3 只需要输出 即可。因为 是 的时候只要给 染色就好了。\",\"#include <bits/stdc++.h> using namespace std; const int N = 1000000; int n; int a[N + 5]; // 目标颜色 int b[N + 5]; // 当前颜色 vector<int> e[N + 5]; // 去掉最高位 int fa(int x) { for (int i = 1000000; i >= 10; i /= 10) if (x >= i) return x % i; return x; } int main() { freopen(\\\"wu.in\\\", \\\"r\\\", stdin); freopen(\\\"wu.out\\\", \\\"w\\\", stdout); cin >> n; for (int i = 0; i <= n; i++) { cin >> a[i]; e[fa(i)].push_back(i); } int ans = 0; for (int u = 0; u <= n; u++) { if (b[u] == 0 || b[u] != a[u]) { ans++; b[u] = a[u]; } for (int v : e[u]) b[v] = a[u]; } cout << ans; return 0; }\"]},\"495\":{\"h\":\"暗渡陈仓\",\"t\":[\"首先子任务 1 送了 10 分，特判所有结果就好。\",\"实际上这题的 dp 属性很容易被发现。两个人都是用最有走法，所以当你求 ，左边先走的最大得分，第一步只有两种情况：\",\"走到 ：最后得分为 右边先走的最小的分加 \",\"走到 ：最后得分为 右边先走的最小的分加 \",\"而当你求 ，右边先走的最小得分，第一步也是两种情况：\",\"走到 ：最后得分为 左边先走的最大的分减去 \",\"走到 ：最后得分为 左边先走的最大的分减去 \",\"由此直接记忆化搜索就好了，当然熟悉的同学也会发现这就是个简单的区间 dp 问题，并且还是个转移只要 的区间 dp。状态定义和转移方程看下面的代码吧。\",\"#include <bits/stdc++.h> #define int long long using namespace std; const int MAXN = 5000; int n; int a[MAXN + 5]; int f[MAXN + 5][MAXN + 5]; // l~r 33DAI 先手的得分 int g[MAXN + 5][MAXN + 5]; // l~r kitten 先手的得分 signed main() { freopen(\\\"an.in\\\", \\\"r\\\", stdin); freopen(\\\"an.out\\\", \\\"w\\\", stdout); cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; for (int len = 2; len <= n; len++) { for (int l = 1; l + len - 1 <= n; l++) { int r = l + len - 1; // 不能走 if (len == 2) { f[l][r] = g[l][r] = a[l] - a[r]; continue; } // 走一步 f[l][r] = g[l + 1][r] + a[l]; g[l][r] = f[l][r - 1] - a[r]; // 可以走两步 if (len > 3) { f[l][r] = max(f[l][r], g[l + 2][r] + a[l]); g[l][r] = min(g[l][r], f[l][r - 2] - a[r]); } } } cout << f[1][n]; return 0; }\"]},\"496\":{\"h\":\"挖土机 CSP-J 模拟赛 ~ 第九场\"},\"497\":{\"h\":\"隔岸观火\",\"t\":[\"假设我们肯定希望每只猫咪的救火时间越短越好，假设救火时间是 ，那么 共 个位置就可以由一只猫咪监控到。\",\"总共有 个位置，所以需要满足 ，由此可以数学方式或者二分算出 的最小值。\",\"然后用这个最小值来放置猫咪就好。\",\"#include <bits/stdc++.h> using namespace std; int n, k; int len; int main() { freopen(\\\"ge.in\\\", \\\"r\\\", stdin); freopen(\\\"ge.out\\\", \\\"w\\\", stdout); cin >> n >> k; // (len*2+1)*k >= n // len >= (n/k-1)/2 // len >= (n-k)/(k*2) len = (n - k) / (k * 2); if ((n - k) % (k * 2) != 0) len++; int pos = 1; for (int i = 1; i <= k; i++) { // len len // pre_pos xxxxxxx pos xxxxxxx pos = min(n, pos + len); cout << pos << \\\"\\\\n\\\"; pos = min(n, pos + len + 1); } return 0; }\"]},\"498\":{\"h\":\"笑里藏刀\",\"t\":[\"每个 v 为右下角的刀的方案数为上方连续 v 的数量乘以左边连续 v 的数量（乘法原理）。\",\"而这个子问题是个非常经典的递推了。\",\"#include <bits/stdc++.h> using namespace std; int n, m; char a[2005][2005]; int up[2005][2005]; int le[2005][2005]; int main() { freopen(\\\"xiao.in\\\", \\\"r\\\", stdin); freopen(\\\"xiao.out\\\", \\\"w\\\", stdout); cin >> n >> m; for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) cin >> a[i][j]; for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) if (a[i][j] == 'v') up[i][j] = le[i][j] = 1; for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) { if (up[i][j]) up[i][j] += up[i - 1][j]; if (le[i][j]) le[i][j] += le[i][j - 1]; } long long res = 0; for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) if (up[i][j] && le[i][j]) res += (up[i][j] - 1) * (le[i][j] - 1); cout << res; return 0; }\"]},\"499\":{\"h\":\"李代桃僵\",\"t\":[\"其实比较容易想到用 dp 做，但是如果状态定义为 表示前 个人选 个，那么是有后效性的，选不选第 个人会影响到 那个人的贡献。所以这样显然不好做。\",\"此时考虑把朋友打包，状态定义为前 对朋友选 个人，这就很好做了。第 对显然就四种情况，不选或者选第一个人或者选第二个人或者都选。\",\"#include <bits/stdc++.h> using namespace std; int n, k; int a[5005]; int b[5005]; int f[2505][5005]; int main() { freopen(\\\"li.in\\\", \\\"r\\\", stdin); freopen(\\\"li.out\\\", \\\"w\\\", stdout); cin >> n >> k; for (int i = 1; i <= n; i++) cin >> a[i]; for (int i = 1; i <= n; i++) cin >> b[i]; int nn = n / 2; for (int i = 0; i <= nn; i++) for (int j = 0; j <= k; j++) f[i][j] = -1; f[0][0] = 0; for (int i = 1; i <= nn; i++) { for (int j = 0; j <= k; j++) { f[i][j] = f[i - 1][j]; if (j >= 1 && f[i - 1][j - 1] != -1) { int nxt = f[i - 1][j - 1] + max(a[i], a[i + nn]); if (f[i][j] == -1 || f[i][j] < nxt) f[i][j] = nxt; } if (j >= 2 && f[i - 1][j - 2] != -1) { int nxt = f[i - 1][j - 2] + b[i] + b[i + nn]; if (f[i][j] == -1 || f[i][j] < nxt) f[i][j] = nxt; } } } cout << f[nn][k]; return 0; }\"]},\"500\":{\"h\":\"顺手牵羊\",\"t\":[\"一个比较经典的二分套路。如果 check(mid) 是检查 mid 能不能做第 k 名，那显然不具有单调性，可以做第 k 名的位置是离散的。\",\"可以考虑 check(mid) 检查答案是否大于等于 mid。那就只需要检查是否存在一条路劲使得大于等于 mid 的数不少于 k 个了。此时就有单调性了，答案就是符合条件的 mid 中最大的一个。\",\"这个检查也是个经典的套路，显然只有 的数有贡献，那么可以把所有 的数看作 ，所有 的数看作 0。然后看看左上到右下的最大路径和。此时就是最多路上能经过的 的数的数量了。如果大于等于 ，那么 check 就是真。\",\"#include <bits/stdc++.h> using namespace std; int n, k; int a[1005][1005]; int f[1005][1005]; bool check(int x) { for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) { bool now = a[i][j] >= x; f[i][j] = max(f[i - 1][j], f[i][j - 1]) + now; } return f[n][n] >= k; } int main() { freopen(\\\"shun.in\\\", \\\"r\\\", stdin); freopen(\\\"shun.out\\\", \\\"w\\\", stdout); cin >> n >> k; for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) cin >> a[i][j]; int l = 1; int r = 1'000'000'000; int ans; while (l <= r) { int mid = (l + r) / 2; if (check(mid)) { ans = mid; l = mid + 1; } else r = mid - 1; } cout << ans; return 0; }\"]},\"501\":{\"h\":\"语法周赛 Round 0 题解\"},\"502\":{\"h\":\"卖水果\",\"t\":[\"难度：学过分支就能拿到满分，刚入门学过输入输出也可以得到 分。\",\"30 分做法：根据数据范围，有 数据“保证做成果酱收益最高”，直接输出 n / 10 * x * 4 即可完成。或者依据另外 数据“保证做成沙拉收益最高”，直接输出 n / 2 * y 也可获得 分。\",\"满分做法：题目中一共有三种售卖方式，分别计算出三种方式的收益同时记录最大值输出即可，且 一定是 的倍数，因此也无需考虑不能整除的情况，标程如下：\",\"#include <bits/stdc++.h> using namespace std; int n, x, y; int a1, a2, a3, a4; int main() { cin >> n >> x >> y; cin >> a1 >> a2 >> a3 >> a4; int plan1 = (n / 10) * 4 * x; int plan2 = (n / 2) * y; int plan3 = (a1 + a2 + a3 + a4) * n; if (plan1 > plan2 && plan1 > plan3){ cout << plan1 << \\\"\\\\n\\\"; } else if (plan2 > plan3){ cout << plan2 << \\\"\\\\n\\\"; } else{ cout << plan3 << \\\"\\\\n\\\"; } return 0; }\"]},\"503\":{\"h\":\"算得分\",\"t\":[\"难度：使用简单的嵌套循环，并会使用循环求解次方以及寻找最值就能拿到满分。仅仅会使用分支和单层循环可以拿到 分。\",\"60 分做法：数据中有 保证 ，这种情况说明仅仅提交了当前这次，直接将 加入总分即可；还有 保证 ，则可以直接按照 计算并加入总分。综上，在完成输入的同时去判断 的是 还是 并计算对应结果计入总分，最终输出总分，便可得到 分。\",\"满分做法：首先循环 次完成输入，对于每一组 和 ，将 的结果与通过循环 次 算出的结果作比较，其中较大值计入总分即可，标程如下：\",\"#include <bits/stdc++.h> using namespace std; int T, s, n, sum; int main() { cin >> T; while (T--) { cin >> s >> n; int base = s * 7 / 10; for (int i = 1; i <= n; i++) s = s * 95 / 100; sum += max(s, base); } cout << sum << \\\"\\\\n\\\"; return 0; }\"]},\"504\":{\"h\":\"WOTOJO\",\"t\":[\"难度：需要学过字符串并找到正确的枚举策略可以拿到满分。\",\"30 分做法：依据数据中的子任务 2，有 的数据保证 中仅有一个子序列是 wotojo，因此我们只需要找到第一个 w 的位置和最后一个 o 的位置便能求得答案。\",\"满分做法：枚举策略为遍历字符串，枚举出每一个 w 为开头的包含wotojo 子序列的最短子串长度，同时记录最小值。具体做法如下：\",\"#include <bits/stdc++.h> using namespace std; string s , t = \\\"wotojo\\\"; int main() { cin >> s; int ans = s.size(); for (int i = 0; i < s.size(); i++)// 注意字符串下标从0开始 { if (s[i] != 'w') // 找到 w 才开始往后扫 continue; int now = 1; // 下一个要查询的字符为 t[now] for (int j = i + 1; j < s.size(); j++) { // 匹配上最近的一个 if (s[j] == t[now]) //当前字符匹配上之后寻找下一个字符 now++; if (now == 6) { // 到 j 的位置时六个字符都找到了 // 即 s[i] ~ s[j] 这个子串中存在子序列 wotojo // 显然这是 i 开头最短的子串 ans = min(ans, j - i + 1); break; } } } cout << ans << \\\"\\\\n\\\"; return 0; }\"]},\"505\":{\"h\":\"三子棋\",\"t\":[\"难度：需要熟练掌握二维数组以及枚举思想并有一定的程序优化能力。\",\"满分做法：首先需要确定枚举的策略来确保不会重复或遗漏，对于每一个三连来说都有三个位置的棋子，即两个端点和一个中间点，那么我们可以枚举当前这个没有放棋子的位置作为端点或作为中间点能否横着、竖着或斜着构成三连。作为端点一共有 个方向可以延伸出去，即上、右上、右、右下、下、左下、左、左上，而作为中间点有 个方向可以延伸，即横、竖、左斜、右斜。对于每种情况通过下标的改变和数组调用，判断对应位置是否已落子即可记录出最终的解。标程如下：\",\"#include <bits/stdc++.h> using namespace std; int n, m; char g[55][55]; // 从下标为 1 开始，分别记录 8 个方向的下标变化。 // 左上、上、右上、左、右、左下、下、右下。 int dx[] = {0, -1, -1, -1, 0, 0, 1, 1, 1}; int dy[] = {0, -1, 0, 1, -1, 1, -1, 0, 1}; int main() { cin >> n >> m; // 为了避免减 2 造成数组越界，下标从 2 开始输入 for (int i = 2; i <= n + 1; i++) for (int j = 2; j <= m + 1; j++) cin >> g[i][j]; int ans = 0; for (int i = 2; i <= n + 1; i++) for (int j = 2; j <= m + 1; j++) { if (g[i][j] == '#') continue; bool flag = false; // 作为端点的八个方向 for (int k = 1; k <= 8; k++) { int x = i + dx[k]; int y = j + dy[k]; int xx = i + 2 * dx[k]; int yy = j + 2 * dy[k]; if (g[x][y] == '#' && g[xx][yy] == '#') { flag = true; break; } } if (flag) { ans++; continue; } // 作为中间点的四个方向 for (int k = 1; k <= 4; k++) { // 两个棋子方向正相反 int x = i + dx[k]; int y = j + dy[k]; int xx = i - dx[k]; int yy = j - dy[k]; if (g[x][y] == '#' && g[xx][yy] == '#') { flag = true; break; } } if (flag) ans++; } cout << ans << \\\"\\\\n\\\"; return 0; }\"]},\"506\":{\"h\":\"语法周赛 Round 1 题解\"},\"507\":{\"h\":\"A+B=B\",\"t\":[\"难度：需要掌握分支以及字符和数字之间的转换。\",\"30 分做法：由于数据中 的数据能保证 为 ，所以直接输出 即可。\",\"满分做法：由于数据比较小，只有 ，所以计算结果会在 ，转换为字符是 。将两个字符转换为数字相加，再判断结果是否小于 ，小于 就将结果直接换为字符；否则将十位数和个位数分别算出来，输出两个字符。\",\"#include<bits/stdc++.h> using namespace std; int main(){ char x,y; cin>>x>>y; int a=x-'A'; int b=y-'A'; int z=a+b; if(z<10) cout<<char(z+'A'); else{ int g=z%10;//个位 int s=z/10;//十位 cout<<char(s+'A')<<char(g+'A'); } return 0; }\"]},\"508\":{\"h\":\"ABBA\",\"t\":[\"难度：直接使用循环解决。\",\"满分做法： 的 次方，用循环计算 次乘以 的结果；的 次方，用循环计算 次乘以 的结果，变量记得开 long long（最后计算出来的数据量会超出 int 范围）。计算出结果后直接判断即可（用到了 else if，或者只用 if 语句也可以）。\",\"#include<bits/stdc++.h> using namespace std; int main(){ int a,b; cin>>a>>b; long long c=1,d=1; for(int i=1;i<=b;i++) { c=c*a; } for(int i=1;i<=a;i++) { d=d*b; } if(c>d) cout<<\\\"first\\\"; else if(c<d) cout<<\\\"second\\\"; else cout<<\\\"same\\\"; }\"]},\"509\":{\"h\":\"环状字符串\",\"t\":[\"难度：能正确使用字符串即可。\",\"30 分做法：数据的开始和结束在 之间，直接输出字符串中的第 个字符到 个字符。字符串下标是从 开始的。\",\"满分做法：循环从第 个字符到 个字符，如果 大于字符串长度，以字符串环状的规律来看，要输出的是 的字符。\",\"#include <bits/stdc++.h> using namespace std; int main(){ string s; cin>>s; int len=s.length(); int n,m; cin>>n>>m; n=n-1; for(int i=n;i<=n+m-1;i++) { cout<<s[i%len]; } } T4 照明 难度：需要熟练掌握二维数组以及嵌套循环的使用。 满分做法：首先在二维数组中找出灯所在的位置，并在此位置进行操作，将上下左右都照亮并标记，但是根据题目要求，一旦碰到墙就停止，所以四个方向上都要进行判断，碰到墙或者到达二维数组的边缘就停下来。最后在二维数组中判断有多少点被标记了。 #include <bits/stdc++.h> using namespace std; char Map[31][31]; int n,cnt=0,x[901],y[901],cur=0; bool vis[31][31]={}; int main() { cin>>n; for(int i=1;i<=n;i++) { for(int j=1;j<=n;j++) { cin>>Map[i][j]; if(Map[i][j]=='*') { x[++cur]=i; y[cur]=j; } } } for(int i=1;i<=cur;i++) { int h=x[i],z=y[i]; for(int j=h;j>=1;j--) { if(Map[j][z]=='#') { break; } else { vis[j][z]=1; } } for(int j=h;j<=n;j++) { if(Map[j][z]=='#') { break; } else { vis[j][z]=1; } } for(int j=z;j>=1;j--) { if(Map[h][j]=='#') { break; } else { vis[h][j]=1; } } for(int j=z;j<=n;j++) { if(Map[h][j]=='#') { break; } else { vis[h][j]=1; } } } for(int i=1;i<=n;i++) { for(int j=1;j<=n;j++) { if(vis[i][j]==true) { cnt++; } } } cout<<cnt; return 0; }\"]},\"510\":{\"h\":\"语法周赛 Round 10 题解\"},\"511\":{\"h\":\"A.骰子比大小\"},\"512\":{\"h\":\"分析\",\"t\":[\"难度：基础条件条件判断\",\"子任务 1（30 分）：保证了两个人的组合类型都是“三个一样的点数”，只需要比较 与 的大小关系就好。\",\"子任务 2（30 分）：保证了类型一致，只需要比较 与 的大小关系就好。\",\"子任务 3（40 分）：按照题意比较即可，如果直接列举所有情况显然要写很多 if。可以考虑先整理一下每个人的点数，然后分别判断好两个人的类型，最后比较起来就很简单了。详细可以参考下面的代码。\"]},\"513\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { int x, y, z, typA, sumA; int a, b, c, typB, sumB; cin >> x >> y >> z; cin >> a >> b >> c; // 先排个序方便后续操作 if (x > y) swap(x, y); if (x > z) swap(x, z); if (y > z) swap(y, z); if (a > b) swap(a, b); if (a > c) swap(a, c); if (b > c) swap(b, c); // 判断类型与计算数字和 sumA = x + y + z; if (x == y && y == z) typA = 1; else if (x + 1 == y && y + 1 == z) typA = 2; else if (x == y || y == z || x == z) typA = 3; else typA = 4; sumB = a + b + c; if (a == b && b == c) typB = 1; else if (a + 1 == b && b + 1 == c) typB = 2; else if (a == b || b == c || a == c) typB = 3; else typB = 4; // 判断胜负 if (typA == 1 && a == 2 && b == 3 && c == 5) cout << \\\"B\\\"; // 特殊情况 1 else if (typB == 1 && x == 2 && y == 3 && z == 5) cout << \\\"A\\\"; // 特殊情况 2 else if (typA == typB && sumA == sumB) cout << \\\"B\\\"; // 平局 else if (typA < typB || (typA == typB && sumA > sumB)) cout << \\\"A\\\"; // A 常规获胜规则 else cout << \\\"B\\\"; // A 没获胜的情况 return 0; }\"]},\"514\":{\"h\":\"B.停车场收费\"},\"515\":{\"h\":\"分析\",\"t\":[\"难度：基础循环模拟，涉及一点点数学技巧\",\"子任务 1（30 分）：保证了是同一天，只需要先判断是否为周末，然后一个小时一个小时模拟就好。\",\"子任务 2（30 分）：保证了第一天和最后一天都包括了完整的一天，因此不用管小时了，每个非周末的天都需要收费 元，但是如果一天天模拟显然会超时，容易发现每七天的收费一样，所以可以先算出一共多少天，有几个完整周和几天零散的。\",\"子任务 3（40 分）：先把中间的完整周用数学方法快速计算，然后前后一个小时一个小时模拟就好。这里细节比较多，可以参考我的代码，没必要写得那么精细，可以提前预留多一些天来暴力枚举，就不需要想那么多了。\",\"考虑到第二题可能会花费一些同学比较多的时间，因此后两题稍微出得简单了一点。\"]},\"516\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; signed main() { long long x, y, l, s, r, e; cin >> x >> y >> l >> s >> r >> e; long long weekPri = 5 * (2 * x + 11 * y); // 完整一周的价格 long long ans = 0; long long len = r - l + 1; // 总天数 if (len >= 100) { long long partA = 14; // 留 14 天容错 long long partB = len - partA; ans += partB / 7 * weekPri; // partB中的完整周快速计算总价格 partA += partB % 7; // partA为中间剩余的天数 r = l + partA - 1; // 更新新的右端点天数 } long long day = l; long long hour = s; while (day < r || hour < e) { // 计算当前小时的收费 if (day % 7 != 6 && day % 7 != 0) // 非周末 { if (17 <= hour && hour < 19) { ans += x; //cout << day << \\\" \\\" << hour << \\\" +\\\" << x << \\\" = \\\" << ans << \\\"\\\\n\\\"; } else if (8 <= hour && hour < 21) { ans += y; //cout << day << \\\" \\\" << hour << \\\" +\\\" << y << \\\" = \\\" << ans << \\\"\\\\n\\\"; } } hour++; if (hour == 24) { day++; hour = 1; } } cout << ans; return 0; }\"]},\"517\":{\"h\":\"C.单词排排序\"},\"518\":{\"h\":\"分析\",\"t\":[\"难度：简单字符串中的字符统计+排序\",\"子任务 1（30 分）：统计每个小写英文字母的出现次数，然后按照出现次数排序输出即可。\",\"子任务 2（30 分）：因为不包含标点符号。所以只需要统计英文字母和数字即可，需要注意空格在这题不属于标点符号，所以子任务 2 就需要使用 getline 来输入了。\",\"子任务 3（40 分）：那些特殊的标点符号写起来比较麻烦，但实际上可以直接利用每个字符对应的整数值，也就是字符的 ascii 码就好，直接 cnt[s[i]]++; 来统计就很方便了。这里我采用了更暴力的直接把每个字符和对应的次数构建了一个结构体，然后进行结构体排序。\"]},\"519\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; struct C { char c; int cnt; }; int tot = 0; C a[256]; bool cmp(C a, C b) { if (a.cnt != b.cnt) return a.cnt > b.cnt; return a.c < b.c; } int main() { string s; getline(cin, s); int cnt[300] = {}; for (int i = 0; i < s.size(); i++) cnt[s[i]]++; for (int i = 0; i < 256; i++) if (cnt[i] > 0 && (char)i != ' ') { tot++; a[tot] = (C){(char)i, cnt[i]}; } sort(a + 1, a + tot + 1, cmp); for (int i = 1; i <= tot; i++) { cout << a[i].c; //cout << \\\"(\\\" << a[i].cnt << \\\")\\\"; } //cout << \\\"#\\\"; return 0; } // I have a apple, I have a pen, Uh, applepen!\"]},\"520\":{\"h\":\"D.登记排行榜\"},\"521\":{\"h\":\"分析\",\"t\":[\"难度：数组、字符串、排序\",\"子任务 1（30 分）：保证了只有女生，直接输出 数组即可。\",\"子任务 2（30 分）：保证了过线顺序就是编号顺序，检查每个人的性别，先一个个输出男生，然后一个个输出女生即可。\",\"子任务 3（40 分）：有多种做法，可以直接枚举两次 数组，第一次输出所有男生，第二次输出所有女生即可。我这里直接统计了每个人的排名，然后把男生女生放到了不同的数组，然后对两个数组种存储的编号按照排名为依据排序。\"]},\"522\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int rnk[1005]; int boyTot = 0, boy[1005]; int girlTot = 0, girl[1005]; bool cmp(int a, int b) { return rnk[a] < rnk[b]; } int main() { int n; string s; int a[1005]; cin >> n; cin >> s; for (int i = 1; i <= n; i++) { cin >> a[i]; rnk[a[i]] = i; if (s[i - 1] == 'm') boy[++boyTot] = i; else girl[++girlTot] = i; } sort(boy + 1, boy + boyTot + 1, cmp); sort(girl + 1, girl + girlTot + 1, cmp); for (int i = 1; i <= boyTot; i++) cout << boy[i] << \\\" \\\"; cout << \\\"\\\\n\\\"; for (int i = 1; i <= girlTot; i++) cout << girl[i] << \\\" \\\"; cout << \\\"\\\\n\\\"; return 0; }\"]},\"523\":{\"h\":\"语法周赛 Round 11 题解\"},\"524\":{\"h\":\"温暖的签到题001\",\"t\":[\"子任务 1（30 分）：由于 ，所以要么不额外开销，要么只额外开销一次，随便判断一下即可。\",\"子任务 2（30 分）：保证了 ，所以直接计算 即可，需要注意 int 类型存储不下，需要使用 long long。\",\"子任务 3（40 分）：此时 的大小不一定，显然要花的钱有 ，算一下多少天花额外的 即可，额外花钱的天数显然是 。\",\"#include<bits/stdc++.h> #define ll long long using namespace std; ll n, x, y, t = 1; int main() { cin >> n >> x >> y; cout << n * x + (n / 7) * y << '\\\\n'; return 0; }\"]},\"525\":{\"h\":\"温暖的签到题002\",\"t\":[\"子任务 1（30 分）：由于 ，只要判断 是不是最小值即可，用 和后面每组的 比较。\",\"子任务 2（30 分）：保证了 ，所以直接比较 TooY0ung 和其唯一的对手谁更小即可。\",\"子任务 3（40 分）：如果会写子任务 1，写出来子任务 3 应该也没什么难度，循环求 和 的最小值 ，最后判断 是否等于 即可。\",\"#include<bits/stdc++.h> #define ll long long using namespace std; int a, b, c, minn, x, y, n; int main() { cin >> x >> y; cin >> n; minn = x + y; for(int i = 1; i <= n; i++) { cin >> a >> b >> c; minn = min(minn , a + b + c); } if(minn == x + y) cout << \\\"Yes\\\" << '\\\\n'; else cout << \\\"No\\\" << '\\\\n'; return 0; }\"]},\"526\":{\"h\":\"温暖的签到题003\",\"t\":[\"子任务 1（30 分）：保证以<开始和保证>结束，子任务其实是主要为了读错题的同学设置的，有的同学以为是自己曾经做过这个题，然后代码中会直接判断中间是否都是=，这样代码就大错特错了，如果发现子任务1无法通过，再次仔细读题就可以发现题目没有读对。\",\"子任务 2（30 分）：保证了没有字符 '='，那么就直接输出 'No' 好了。\",\"子任务 3（40 分）：如果会写子任务1，写出来子任务3应该没有什么难度，可以先找 '<'，找到后判断其下一个是否为 '='，然后再用循环去找是否存在一些个连续的 '='，在最后一个 '=' 下一个又出现 '>' 即可。\",\"#include<bits/stdc++.h> #define ll long long using namespace std; string s; int main() { cin >> s; int len = (int) s.size(); for(int i = 0; i < len; i++) { if(s[i] == '<' && s[i+1] == '=') { for(int j = i + 1; j < len - 1; j++) { if(s[j] == '=' && s[j+1] == '>') { cout << \\\"Yes\\\" << '\\\\n'; return 0; } if(s[j+1] != '=') break; } } } cout << \\\"No\\\" << '\\\\n'; return 0; }\"]},\"527\":{\"h\":\"温暖的签到题004\",\"t\":[\"子任务 1（30 分）：保证了是 年，就不需要判断闰年了， 年一定是闰年。\",\"子任务 2（30 分）：保证了不存在跨天，就不需要判断跨天了。\",\"子任务 3（40 分）：正解其实就是分类讨论。 \",\"当前时间大于等于开始营业时间并小于结束时间，答案显然就是输出现在的日期和时间。\",\"当前时间大于等于开始营业时间并且结束时间小于开始时间，答案显然还是现在的日期和时间。\",\"结束时间小于开始时间并且当前时间小于结束时间，答案显然还是现在的日期和时间。\",\"现在时间小于开始时间，答案显然就是现在的日期和开始时间。\",\"其余情况需要第二天开始时间再来，进行第二天的日期计算即可。\",\"其中，第二天的日期计算，涉及到月份和闰年的计算，只要把细节都注意就行了，主要的坑点有，跨月份的情况，跨年份的情况，注意用 补齐两位数。\",\"#include<bits/stdc++.h> #define ll long long int dy[2][12]={{31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}, {31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}}; int judge(int y) { if(y % 4 == 0 && y % 100 != 0) return 1; if(y % 400 == 0) return 1; return 0; } int yy, mo, dd, hh, mm, ss, a, b, c, d, e, f; int main() { scanf(\\\"%d-%d-%d\\\", &yy, &mo, &dd); scanf(\\\"%d:%d:%d\\\", &hh, &mm, &ss); scanf(\\\"%d:%d:%d\\\", &a, &b, &c); scanf(\\\"%d:%d:%d\\\", &d, &e, &f); int now = ss + 60 * mm + 3600 * hh; int st = c + 60 * b + 3600 * a; int ed = f + 60 * e + 3600 * d; if((now >= st && now < ed)||(now >= st && ed <= st)||(ed <= st && now < ed)) { printf(\\\"%d-%02d-%02d %02d:%02d:%02d\\\\n\\\", yy, mo, dd, hh, mm, ss); } else if(now < st) { printf(\\\"%d-%02d-%02d %02d:%02d:%02d\\\\n\\\", yy, mo, dd, a, b, c); } else { int t = dy[judge(yy)][mo - 1]; dd++; if(dd > t) { mo++; dd = 1; if(mo > 12) { yy++; mo = 1; } } printf(\\\"%d-%02d-%02d %02d:%02d:%02d\\\\n\\\", yy, mo, dd, a, b, c); } return 0; }\"]},\"528\":{\"h\":\"语法周赛 Round 12 题解\"},\"529\":{\"h\":\"A.时区转换\"},\"530\":{\"h\":\"分析\",\"t\":[\"难度：简单条件判断，输入时有一些小技巧\",\"子任务 1（30 分）：口算出答案后直接输出对应的结果即可。\",\"子任务 2（30 分）：此时需要输入正确的时间，有同学可能会以为需要字符串处理，实际上可以考虑用五个字符，或者直接定义 int a, b; char c; 然后 cin >> a >> c >> b; 即可。在输入整数时，程序会读取直到非数字字符为止，前导 0 也不会影响正确的数值。然后用一个字符型变量吃掉中间的冒号再输入第二个整数即可。输入完成之后因为保证了时间不会跨越一天，直接输出 a - 15 和 b 即可，但要注意根据格式给出多余的 0。\",\"子任务 3（40 分）：有可能会跨越一天时，根据 a 的值确认是否要 + 24 就好。\"]},\"531\":{\"h\":\"满分参考代码\",\"t\":[\"此处我还是按照我个人的习惯，对于时间类的问题转换为最小单位后在处理。显然在本题中，“转换为分钟”、“往前数 15 小时”、“转换回小时” 可以直接用 a -= 15; if (a < 0) a += 24; 代替。\",\"#include <bits/stdc++.h> using namespace std; int main() { int a, b; char c; cin >> a >> c >> b; // 转换为分钟 int t = a * 60 + b; // 往前数 15 小时 t -= 15 * 60; if (t < 0) t += 24 * 60; // 转换回小时 a = t / 60; b = t % 60; // 按格式输出 if (a < 10) cout << \\\"0\\\" << a; else cout << a; cout << \\\":\\\"; if (b < 10) cout << \\\"0\\\" << b; else cout << b; return 0; }\"]},\"532\":{\"h\":\"B.每数一位\"},\"533\":{\"h\":\"分析\",\"t\":[\"难度：基础循环嵌套及数学找规律\",\"子任务 1（30 分）：当 为一位数时，直接输入 之和即可。\",\"子任务 2（30 分）：数据范围很小，直接用 暴力枚举 之内的每个整数，使用题目给出的“求数位和”的代码求出“一位数位和”然后求和即可。\",\"子任务 3（40 分）：容易发现当数据范围很大时上面的思路会超时，可以考虑先打印出每个数的一位数位和看看规律，很容易发现就是 的循环，直接根据数学规律算出答案即可。注意要用 long long。\"]},\"534\":{\"h\":\"分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { long long n; long long ans; cin >> n; ans = 0; for (long long i = 1; i <= n; i++) { // 将 i 变为一位数 long long now = i; while (now > 9) { long long num = 0; // 计算 now 的数位和 while (now > 0) { num += now % 10; now /= 10; } now = num; } // 算入答案 ans += now; // cout << i << \\\":\\\" << now << '\\\\n'; } cout << ans; return 0; }\"]},\"535\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { long long n; cin >> n; long long a = n / 9; long long b = n % 9; cout << (a * 45) + (1 + b) * b / 2; return 0; }\"]},\"536\":{\"h\":\"C.数串质数\"},\"537\":{\"h\":\"分析\",\"t\":[\"难度：简单字符串处理及质数判断\",\"子任务 1（30 分）：此时数串只有三种可能性 10、1011、101112，根据题目描述容易发现答案都是 。\",\"子任务 2（30 分）：根据题目描述，容易发现 为 时答案为 ，为 时答案为 ，为 时答案都为 ， 时答案为 。这题的 分就是一个条件判断的题目。\",\"子任务 3（40 分）：通过加号把几个数组合成一个字符串后处理即可。也可以用整数的方式，（四位质数必然为一个数的十位开头或者一个数的个位开头，和后面的数字组合形成的）。\"]},\"538\":{\"h\":\"满分参考代码 1\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n; string s; bool isPrime(int x) { if (x < 2) return false; for (int i = 2; i * i <= x; i++) if (x % i == 0) return false; return true; } int main() { cin >> n; for (int i = 10; i <= n; i++) { s += (char)(i / 10 + '0'); s += (char)(i % 10 + '0'); } //cout << s << \\\"\\\\n\\\"; int cnt = 0; for (int i = 0; i + 4 - 1 < s.size(); i++) { if (s[i] == '0') continue; int now = (s[i] - '0') * 1000 + (s[i + 1] - '0') * 100 + (s[i + 2] - '0') * 10 + (s[i + 3] - '0'); if (isPrime(now)) { cnt++; //cout << now << \\\"\\\\n\\\"; } } cout << cnt << \\\"\\\\n\\\"; return 0; }\"]},\"539\":{\"h\":\"满分参考代码 2\",\"t\":[\"#include<bits/stdc++.h> using namespace std; bool prime(int x){ if (x < 2) return false; for (int i = 2; i * i <= x; i++) if (x % i == 0) return false; return true; } int n,s; int main(){ cin>>n; for(int i=10;i<=n-1;i++){ int a = (i/10)*1000+(i%10)*100+((i+1)/10)*10+((i+1)%10)*1; int b = (i%10)*1000+((i+1)/10)*100+((i+1)%10)*10+((i+2)/10)*1; if(1000 <= a && a <= 9999 && prime(a)) s++; if(i+2<=n && 1000 <= b && b <= 9999 && prime(b)){ s++; } } cout<<s; }\"]},\"540\":{\"h\":\"D.四数转盘\"},\"541\":{\"h\":\"分析\",\"t\":[\"难度：简单模拟\",\"子任务 1（30 分）：保证了两个字符串长度都为 ，又至少有一个 o，所以直接根据 op[0] 的值决定输出 B 还是 D 即可。\",\"子任务 2（30 分）：保证了每个字符都要输出，直接专心模拟旋转即可。\",\"子任务 3（40 分）：在 分的基础上，根据 的值决定是否输出即可。容易发现除了真的去模拟转盘旋转之外，如果把 ABCD 对应到 0123，左转右转就是 +1/-1 然后对 取余了。\"]},\"542\":{\"h\":\"满分参考代码\",\"t\":[\"此处给出真的模拟旋转的代码。\",\"#include <bits/stdc++.h> using namespace std; char a[2][2]; string op; string s; string ans; int main() { ios::sync_with_stdio(false); cin.tie(0); a[0][0] = 'A', a[0][1] = 'B'; a[1][0] = 'D', a[1][1] = 'C'; cin >> op; cin >> s; for (int i = 0; i < op.size(); i++) { if (op[i] == 'L') { // 逆时针 int temp = a[0][0]; a[0][0] = a[0][1]; a[0][1] = a[1][1]; a[1][1] = a[1][0]; a[1][0] = temp; } else if (op[i] == 'R') { // 顺时针 int temp = a[0][0]; a[0][0] = a[1][0]; a[1][0] = a[1][1]; a[1][1] = a[0][1]; a[0][1] = temp; } if (s[i] == 'o') ans += a[0][0]; } cout << ans << \\\"\\\\n\\\"; return 0; }\"]},\"543\":{\"h\":\"语法周赛 Round 13 题解\"},\"544\":{\"h\":\"TooY0ung 的数字游戏\",\"t\":[\"子任务 1（30 分）：由于 ，题目中又保证了 ，所以 TooY0ung 的数字永远无法超过 TooSimple ，输出 -1 即可。\",\"子任务 2（30 分）：保证了 ，所以直接计算 即可。\",\"子任务 3（40 分）：满分做法除了无解情况，其实就是计算 ，需要注意如果可以整除，答案要 ，不能整除向上取整就好。\",\"#include<bits/stdc++.h> using namespace std; int x,y,a,b; int main() { cin>>x>>y>>a>>b; if(a<=b) puts(\\\"-1\\\"); else { if((y-x)%(a-b)==0) cout<<(y-x)/(a-b)+1<<\\\"\\\\n\\\"; else cout<<(y-x+a-b-1)/(a-b)<<\\\"\\\\n\\\"; } return 0; }\"]},\"545\":{\"h\":\"TooY0ung 的美食之旅\",\"t\":[\"子任务 1（30 分）：由于输入的全部都是 ，所以输出 就好了。\",\"子任务 2（30 分）：没有 的话只需要关注数字发生了几次改变即可。\",\"子任务 3（40 分）：其实只要在代码中统计有没有 出现，记录开心不开心即可，用一些变量存储以上各种情况，很容易实现代码。\",\"#include<bits/stdc++.h> using namespace std; int n,x,no2,happy,unhappy,ans; int main() { cin>>n; for(int i=1;i<=n;i++) { cin>>x; if(x!=2&&no2==0) { no2=1; if(x==1) unhappy=1; else happy=1; } if(no2==1&&x==2) continue; if(no2==1&&happy==1&&x==1&&unhappy==0) { happy=0,unhappy=1,ans++; } else if(no2==1&&unhappy==1&&x==3&&happy==0) { unhappy=0,happy=1,ans++; } } cout<<ans<<\\\"\\\\n\\\"; return 0; }\"]},\"546\":{\"h\":\"TooY0ung 的 WrongAnswer\",\"t\":[\"子任务 1（30 分）：只有小写字母只要查找是否有小写的 wronganswer 就行了，这里可以直接用 find 函数就行。\",\"子任务 2（30 分）：只有大写字母就需要找一下 WRONGANSWER 。\",\"子任务 3（40 分）：满分做法其实就是把字母全变大写或者小写，找 “WRONGANSWER” 和 “wronganswer” 即可，在看同学们代码的时候，有一些不正确的写法被我的类似于 “WWRONGANSWER” 数据卡掉了，同学们可以课下再改一下。\",\"#include<bits/stdc++.h> using namespace std; string s; string wa=\\\"wronganswer\\\"; int main() { cin>>s; int len=(int)s.size(); for(int i=0;i<len;i++) { if(s[i]>='A'&&s[i]<='Z') s[i]+='a'-'A'; } if(s.find(\\\"wronganswer\\\")!=s.npos) puts(\\\"Yes\\\"); else puts(\\\"No\\\"); return 0; }\"]},\"547\":{\"h\":\"TooY0ung 的等差数列\",\"t\":[\"正解就是输出 X 就行，因为题目中写了数列长度大于等于 1，所以可以长度为 1。\",\"#include<bits/stdc++.h> using namespace std; int x; int main() { cin >> x; cout << 1 << '\\\\n'; cout << x << '\\\\n'; return 0; }\"]},\"548\":{\"h\":\"语法周赛 Round 14 题解\"},\"549\":{\"h\":\"A.喜欢开方的 33DAI\"},\"550\":{\"h\":\"分析\",\"t\":[\"难度：趣味题，语法上只需要输入输出和常用数学函数，难点主要在运气。\",\"子任务 1（30 分）：输出 0 即可。\",\"子任务 2（30 分）：平方根有可能是 3 或 -3。任选一个输出，然后祈祷运气好猜对了即可，猜错了就再交一次。\",\"子任务 3（40 分）：输入一个数，输出他的算术平方根即可。本题难点在于判题时会随机的选择正的还是负的，所以如果错了需要再次提交，直到正确为止。如果代码没有问题，每次提交都有 \\\\frac{1}{4} 的概率拿到满分。\"]},\"551\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { int x; cin >> x; cout << (int)sqrt(x) << \\\"\\\\n\\\"; return 0; }\",\"可能有同学会好奇是怎么做到随机判题的，简单来说就是写了另一个代码来判断你的答案是否正确。我们把这样的判题方法叫做 special judge。\",\"#include \\\"testlib.h\\\" #include <ctime> int main(int argc, char *argv[]) { registerTestlibCmd(argc, argv); int ja = ans.readInt(); int pa = ouf.readInt(); int seed = clock(); if (seed % 2) ja = -ja; if (ja != pa) quitf(_wa, \\\"expected %d, found %d, %d\\\", ja, pa, seed); quitf(_ok, \\\"answer is %d, %d\\\", ja, seed); }\"]},\"552\":{\"h\":\"B. 喜欢除法的 TooY0ung\"},\"553\":{\"h\":\"分析\",\"t\":[\"难度：因为后两题相对较难，所以第二题给了个相对简单的题目。\",\"子任务 1（30 分）：当 时，显然 不用变化，如果 是偶数就不用变，否则就需要 -1，所以变成了一个简单的条件判断的题目。\",\"子任务 2（30 分）：容易发现就是要把每个 除以 的余数都减掉。子任务 2 的数据范围保证了不需要使用 long long\",\"子任务 3（40 分）：子任务 2 的基础上开好 long long 即可。\"]},\"554\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { int n, ai; cin >> n; long long ans = 0; for (int i = 1; i <= n; i++) { cin >> ai; ans += ai % i; } cout << ans; return 0; }\"]},\"555\":{\"h\":\"C. 玩字符串的 Didi\"},\"556\":{\"h\":\"分析\",\"t\":[\"难度：简单分析、排序。\",\"子任务 1（30 分）：此时变化后要么是 、要么是 ，看看是否有一个和 一样就好。\",\"子任务 2（30 分）：一个凑数的子任务，没啥意义。\",\"子任务 3（40 分）：由于每次选择的区间左端点不能小于之前选择的区间左端点，所以显然可以考虑从小到大考虑每个位置作为左端点时需要做到多少。对于 来说，如果它与 一致，显然就不需要操作了，否则就需要在 串的 后面去找 ，假设在 的位置。此时显然就需要对 进行排序。因为如果对更短的区间排序，显然不可能有效。对更长的区间排序则有可能会变得更坏，不如回头再扩展到更长。如果排完序后一致，就可以处理下一个位置了，否则就说明不可能完成目标了。\"]},\"557\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { string s; string t; cin >> s >> t; int ans = 0; for (int i = 0; i < s.size(); i++) { if (s[i] == t[i]) continue; // 找找 t[i] 在哪儿 int pos = -1; for (int j = i + 1; j <= t.size(); j++) if (s[j] == t[i]) { pos = j; break; } if (pos == -1) { cout << \\\"No\\\"; return 0; } // 对 i~pos 进行排序 ans++; for (int j = i; j <= pos; j++) for (int k = j + 1; k <= pos; k++) if (s[k] < s[j]) swap(s[k], s[j]); if (s[i] != t[i]) { cout << \\\"No\\\"; return 0; } } cout << \\\"Yes\\\\n\\\"; return 0; }\"]},\"558\":{\"h\":\"D. 随意发糖的 LEEZ\"},\"559\":{\"h\":\"分析\",\"t\":[\"难度：有一些小细节的模拟题\",\"子任务 1（30 分）：每次只能发一颗糖，那么总共缺几颗糖就发几次即可。\",\"子任务 2（30 分）：每次只能选一个人，那么就一个个去看看发几次能超过要求即可。\",\"子任务 3（40 分）：既然每次只能发一个区间，我们可以先类似于子任务 2，一个一个人看过去，先给当前用户发到溢出，然后把溢出的依次往后分给后面的 个人即可。有同学可能会觉得这是个双重循环会超时。实际上这个双重循环的时间复杂度还是 ，因为第二重循环每多执行一次，都是给下一个人装满了的情况，那么 枚举到下一个人时就不会在执行第二轮循环了。\"]},\"560\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n, m, k, num; int a[5005]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m >> k >> num; for (int i = 1; i <= n; i++) cin >> a[i]; int ans = 0; for (int i = 1; i <= n; i++) { // 当前需要这么多 int now = m - a[i]; // 要加这么多次 int cnt = now / num + (now % num > 0); ans += cnt; int sum = cnt * num; // 一共这么多，可以分配给 k 个 for (int j = i; j <= i + k - 1 && j <= n; j++) { if (sum > m - a[j]) { sum -= (m - a[j]); a[j] = m; } else { a[j] += sum; sum = 0; break; } } } cout << ans << \\\"\\\\n\\\"; return 0; }\"]},\"561\":{\"h\":\"语法周赛 Round 15 题解\"},\"562\":{\"h\":\"从大到小吗？\",\"t\":[\"子任务 1（30 分）：由于 ，数字又不一样，所以一定是没办法满足从大到小的，输出 No 即可。\",\"子任务 2（30 分）：由于 ，数字又不一样，所以一定是没办法满足从大到小的，输出 No 即可。\",\"子任务 3（40 分）：其实只需要用 if 语句判断一下大小关系就好了。\",\"#include<bits/stdc++.h> using namespace std; int a, b, c, d; int main() { cin >> a >> b >> c >> d; if(a > b && b > c && c > d) cout << \\\"Yes\\\" << '\\\\n'; else cout << \\\"No\\\" << '\\\\n'; return 0; }\"]},\"563\":{\"h\":\"谁赢了？\",\"t\":[\"子任务 1（30 分）： 这个时候可以随便输出一种答案，应该能得点分。\",\"子任务 2（30 分）：输出 33dai 即可。\",\"子任务 3（40 分）：其实只需要用 if 语句判断一下大小关系就好，然后顺便统计获胜次数，最后根据获胜次数进行输出即可。\",\"#include<bits/stdc++.h> using namespace std; int sum1, sum2, n, a, b, c, d; int main() { cin >> n; while(n--) { cin >> a >> b >> c >> d; if(a + b > c + d) sum1++; else if(a + b < c + d) sum2++; } if(sum1 > sum2) cout << \\\"TooY0ung\\\" << '\\\\n'; else if(sum1 == sum2) cout << \\\"tie\\\" << '\\\\n'; else cout << \\\"33dai\\\" << '\\\\n'; return 0; }\"]},\"564\":{\"h\":\"奇数还是偶数？\",\"t\":[\"子任务 1（30 分）：由于一定是偶数，直接输出 even 即可。\",\"子任务 2（30 分）：保证了 long long 可以存下，用 long long 类型直接判断即可。\",\"子任务 3（40 分）：其实只需要用字符串类型读入，判断最后一位是奇数还是偶数就好了。\",\"#include<bits/stdc++.h> using namespace std; string s; int main() { cin >> s; int len = (int) s.size(); if((s[len - 1] - '0') % 2 == 0) cout << \\\"even\\\" << '\\\\n'; else cout << \\\"odd\\\" << '\\\\n'; return 0; }\"]},\"565\":{\"h\":\"TooY0ung的等差数列2.0\",\"t\":[\"子任务 1（30 分）：由于输入的 ，所以只要判断输入的 和 是否相等即可。\",\"子任务 2（30 分）：保证是正数其实就不用判断负数而已，不过 TooY0ung 的标程写法可以忽略掉负数的判断，TooY0ung 的标程也确确实实就是 R13 周赛的 T4 spj 程序。\",\"子任务 3（40 分）： \",\"其实只要能够判断两个事情就好了：1.公差要一样。2.和要等于 。\",\"可能会有一些恶心的细节问题，比如如果是 ，那就不存在公差问题，代码细节处理没问题通过本道题目应该是没有任何难度的，记得使用long long，因为数据里存在 int 类型溢出后正好和 相等的情况。\",\"#include<bits/stdc++.h> using namespace std; long long x, n, a[1010]; long long sum, last, d; int main() { cin >> x >> n; for(int i = 0; i < n; i++) cin >> a[i]; for(int i = 0; i < n; i++) { sum += a[i]; if(i == 0) last = a[i]; else if(i == 1) { d = a[i] - last; last = a[i]; } else { if(a[i] - last != d) { cout << \\\"No\\\" << '\\\\n'; return 0; } last = a[i]; } } if(sum != x) { cout << \\\"No\\\" << '\\\\n'; return 0; } else cout << \\\"Yes\\\" << '\\\\n'; return 0; }\"]},\"566\":{\"h\":\"语法周赛 Round 16 题解\"},\"567\":{\"h\":\"A.WOTOJO 型字符串\"},\"568\":{\"h\":\"分析\",\"t\":[\"难度：基础条件判断。\",\"子任务 1（30 分）：输出 Yes 即可。\",\"子任务 2（30 分）：此时只需要判断 都不同即可。\",\"子任务 3（40 分）：因为保证了字符串长度为 ，所以直接用 个字符输入配合条件判断即可。正常堆 if 判断就好。语法周赛第一题保证了只需要用到条件判断，不会超纲的。\"]},\"569\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { char a, b, c, d, e, f; cin >> a >> b >> c >> d >> e >> f; if (b == d && d == f && a != b && a != c && a != e && b != c && b != e && c != e) cout << \\\"Yes\\\"; else cout << \\\"No\\\"; return 0; }\"]},\"570\":{\"h\":\"B. 疯疯疯狂星期四\"},\"571\":{\"h\":\"分析\",\"t\":[\"难度：经典日期循环模拟题。\",\"子任务 1（30 分）：直接把样例输出前三行拿过来输出即可。\",\"子任务 2（30 分）：利用样例数据配合条件判断完成即可。\",\"子任务 3（40 分）：循环一天天过就好，比较基础的日期模拟题，与之类似的经典题有《A0274 黑色星期五》。这里为了避免使用循环后面的知识点，每个月的天数我是用条件判断实现的。实际上利用数组记好二月之外的天数，然后封装成一个小函数代码会更简洁。\"]},\"572\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n; // 年份、月份、日期、星期几 int yy, mm, dd, ww; int main() { int n; cin >> n; // 一天天模拟 yy = 2024; mm = 4; dd = 4; ww = 4; while (n) { if (yy % 10 == 4 && mm == 4 && dd == 4 && ww == 4) { cout << yy << \\\" \\\" << mm << \\\" \\\" << dd << \\\"\\\\n\\\"; n--; } // 这个月的天数 int maxDay; if (mm == 4 || mm == 6 || mm == 11 || mm == 9) maxDay = 30; else if (mm != 2) maxDay = 31; else if (yy % 4 == 0 && yy % 100 != 0 || yy % 400 == 0) maxDay = 29; else maxDay = 28; // 过一天 dd++; if (dd > maxDay) { mm++; dd = 1; } if (mm > 12) { yy++; mm = 1; } ww++; if (ww > 7) ww = 1; } return 0; }\"]},\"573\":{\"h\":\"C. TooY0ung的WrongAnswer 2.0\"},\"574\":{\"h\":\"分析\",\"t\":[\"难度：贪心，循环，条件判断，字符串\",\"题解：首先就是这个题目要想明白几个事情：\",\"1.题目中所写的恰好 次操作，其实应该是计算最少几次操作可以让原字符串中出现 ，这里我们设为 ，那么应该是只要满足 ，应该是都可以满足，因为多出的操作次数可以通过 胡乱排序、或者 胡乱转换大小写 把多余的次数浪费掉。\",\"2.题目中的排序最多只需要进行一次，因为排序是随意的，所以既然排序了肯定是要把自己要的东西，通过一次排序都搞好。\",\"3.想明白了这些之后，接下来的问题就是想办法把 里面的每种字母个数进行统计就行了，这里给出两种方法，第一种就是没什么技术含量的开很多个变量进行统计就好了，第二种的话就是用桶来统计，个人还是很推荐第二种方法，然后优先查找 ，能查到就在这个里面优先查，查不到就去 里面查即可，统计次数即可。\",\"4.注意一个 贴心准备的很坑的数据点： 很多错误的写法都会认为不需要排序，所以很输出“Yes”，那么就错了，嘿嘿。\"]},\"575\":{\"h\":\"满分参考代码1\",\"t\":[\"#include<bits/stdc++.h> #define ll long long #define ull unsigned long long #define eps 1e-10 #define INF 1e9 #define delta 0.996 #define T 3000 #define pi acos(-1.0) #define ld long double using namespace std; const ll mod1=1e9+7; const ll mod2=998244353; const int maxn=1e6 + 10; const ll inf=1e18L; typedef pair<int,int>P; using namespace std; //WrongAnswer //w : 2 //r : 2 //n : 2 string ss, wa = \\\"WrongAnswer\\\"; int x, W, w, r, R; int o, O, n, N, g, G, A, a, s, S, e, E, sum; int main() { cin >> ss >> x; int len = (int) ss.size(); ss = \\\" \\\" + ss; for(int i = 1; i <= len; i++) { if(ss[i] == 'W') W++; if(ss[i] == 'w') w++; if(ss[i] == 'R') R++; if(ss[i] == 'r') r++; if(ss[i] == 'O') O++; if(ss[i] == 'o') o++; if(ss[i] == 'N') N++; if(ss[i] == 'n') n++; if(ss[i] == 'G') G++; if(ss[i] == 'g') g++; if(ss[i] == 'A') A++; if(ss[i] == 'a') a++; if(ss[i] == 'S') S++; if(ss[i] == 's') s++; if(ss[i] == 'E') E++; if(ss[i] == 'e') e++; } if(W + w < 2 || R + r < 2 || O + o < 1 || N + n < 2 || G + g < 1 || A + a < 1 || S + s < 1 || E + e < 1) { puts(\\\"No\\\"); return 0; } if(W == 0) sum++; if(w == 0) sum++; if(r == 0) sum += 2; if(r == 1) sum++; if(o == 0) sum++; if(n == 0) sum += 2; if(n == 1) sum++; if(g == 0) sum++; if(A == 0) sum++; if(s == 0) sum++; if(e == 0) sum++; if(sum > x) { puts(\\\"No\\\"); return 0; } else if(sum < x) { puts(\\\"Yes\\\"); return 0; } else { if(x == 0) { if(ss.find(\\\"WrongAnswer\\\")==ss.npos) { puts(\\\"No\\\"); return 0; } else { puts(\\\"Yes\\\"); return 0; } } int flag = 0; for(int i = 1; i <= len - 10; i++) { int ans = 0; for(int j = 0; j <= 10; j++) { if((j == 0 || j == 5) && ss[i + j] != wa[j] && ss[i + j] != wa[j] + 32) { break; } if(((j >= 1 && j <= 4) || (j >= 6 && j <=10)) && ss[i + j] != wa[j] && ss[i + j] != wa[j] - 32) { break; } if((j == 0 || j == 5) && ss[i + j] != wa[j] && ss[i + j] == wa[j] + 32) ans++; else if(((j >= 1 && j <= 4) || (j >= 6 && j <=10)) && ss[i + j] != wa[j] && ss[i + j] == wa[j] - 32) ans++; } if(ans == x) { puts(\\\"Yes\\\"); flag = 1; return 0; } } if(flag == 0) { puts(\\\"No\\\"); return 0; } } return 0; }\"]},\"576\":{\"h\":\"满分参考代码2\",\"t\":[\"#include<bits/stdc++.h> #define ll long long #define ull unsigned long long #define eps 1e-10 #define INF 1e9 #define delta 0.996 #define T 3000 #define pi acos(-1.0) #define ld long double using namespace std; const ll mod1=1e9+7; const ll mod2=998244353; const int maxn=1e6 + 10; const ll inf=1e18L; typedef pair<int,int>P; using namespace std; //WrongAnswer //w : 2 //r : 2 //n : 2 string ss, wa = \\\"WrongAnswer\\\", wawa = \\\"wRONGaNSWER\\\"; int mp[130]; int x, cnt, flag = 1; int main() { cin >> ss >> x; int len = (int) ss.size(); ss = \\\" \\\" + ss; string sss = ss; for(int i = 1; i <= len; i++) { mp[ss[i]]++; } for(int i = 1;i <= len; i++) { if(ss[i] >= 'A' && ss[i] <= 'Z') ss[i] += 'a'-'A'; } if(ss.find(\\\"wronganswer\\\")==ss.npos) cnt++; for(int i = 0; i <= 10; i++) { if(mp[wa[i]] >= 1) mp[wa[i]]--; else if(mp[wawa[i]] >= 1) cnt++, mp[wawa[i]]--; else { flag = 0; puts(\\\"No\\\"); return 0; } } if(x == 0) { if(sss.find(\\\"WrongAnswer\\\")==sss.npos) { puts(\\\"No\\\"); return 0; } else { puts(\\\"Yes\\\"); return 0; } } if(cnt > x) puts(\\\"No\\\"); else puts(\\\"Yes\\\"); return 0; }\"]},\"577\":{\"h\":\"D. 坏掉的数码管\"},\"578\":{\"h\":\"分析\",\"t\":[\"难度：模拟、基础组合数学（乘法原理）\",\"子任务 1（30 分）：只有一个数码管，利用题面给的代码，给大家提供了 对应的字符串。一一比对可能是哪些即可，显然只要所有输入的 Y 的位置，数字对应的也是 Y 即可。一旦出现了输入的某一位是 Y，但是当前判断的这个数字的这一位不是 Y，那就不可能是当前数字了。\",\"子任务 2（30 分）：可以枚举所有两位数，一一判断。但实际上子任务 2 是一个提示性的子任务，很容易想到就是第一位可能的数量乘以第二位可能的数量。\",\"子任务 3（40 分）：利用子任务 2 很容易被提示乘法原理。把每一位可能的数量相乘即可。因为 是每一根发光二极管都亮着，所以显然不会有无解情况。需要注意本题模数是 而不是 \"]},\"579\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> #define int long long using namespace std; const int MOD = 988244353; string s[10] = { \\\"YYYYYYN\\\", \\\"NYYNNNN\\\", \\\"YYNYYNY\\\", \\\"YYYYNNY\\\", \\\"NYYNNYY\\\", \\\"YNYYNYY\\\", \\\"YNYYYYY\\\", \\\"YYYNNNN\\\", \\\"YYYYYYY\\\", \\\"YYYYNYY\\\"}; int n; // 检查 a 是否可能是 b 换掉几个之后的结果 bool check(string &a, string &b) { for (int i = 0; i < 7; i++) if (a[i] == 'Y' && b[i] == 'N') return false; return true; } signed main() { cin >> n; int ans = 1; for (int i = 1; i <= n; i++) { string temp; cin >> temp; int nowCnt = 0; // 当前位有几种可能 for (int i = 0; i < 10; i++) if (check(temp, s[i])) nowCnt++; ans = (ans * nowCnt) % MOD; } cout << ans; return 0; }\"]},\"580\":{\"h\":\"语法周赛 Round 17 题解\"},\"581\":{\"h\":\"A. 整型溢出\"},\"582\":{\"h\":\"分析\",\"t\":[\"难度：基础条件判断。\",\"子任务 1（30 分）：肯定不超 int，输出 int 即可。\",\"子任务 2（30 分）：都是正数，只需要判断是否小于 ，当然自己存储的时候要开 long long。\",\"子任务 3（40 分）：用 long long 类型存储结果，然后就是判断如果在 int 范围内就输出 int，否则输出 long long 即可。\"]},\"583\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { long long a, b, c; cin >> a >> b; c = a + b; if (c < -2147483648 || 2147483647 < c) cout << \\\"long long\\\"; else cout << \\\"int\\\"; return 0; }\"]},\"584\":{\"h\":\"B. i 的 i 次方\"},\"585\":{\"h\":\"分析\",\"t\":[\"难度：基础循环嵌套。\",\"做法：没有子任务，一共十个点，分别是输入 的测试，也就是说可以手动算出结果后打表。标准做法就是一个基础的循环嵌套，依次算出 分别的 ，然后求和即可。注意要开 long long。\"]},\"586\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { int n; cin >> n; long long res = 0; for (int i = 1; i <= n; i++) { long long now = 1; for (int j = 1; j <= i; j++) now *= i; res += now; } cout << res; return 0; }\"]},\"587\":{\"h\":\"C. 顺子\"},\"588\":{\"h\":\"分析\",\"t\":[\"难度：基础排序\",\"子任务 1（30 分）：保证了从小到大，不需要排序了，直接从第二个字符开始比较是不是前一个字符 即可。\",\"子任务 2（30 分）：互不相同又都是 abcde 中的一个，那肯定是顺子。\",\"子任务 3（40 分）：先排序然后按照子任务 1 处理即可。\"]},\"589\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { string s; cin >> s; sort(s.begin(), s.end()); for (int i = 1; i <= 4; i++) if (s[i] != s[i - 1] + 1) { cout << \\\"No\\\\n\\\"; return 0; } cout << \\\"Yes\\\\n\\\"; return 0; }\"]},\"590\":{\"h\":\"D. 偶数位的数\"},\"591\":{\"h\":\"分析\",\"t\":[\"难度：暴力枚举数位分解（）或者数学思路手动处理（）\",\"子任务 1（30 分）：只有一个数，判断它是不是偶数位即可。\",\"子任务 2（30 分）： 位数一致，那么如果 是偶数位的，答案就是 ，否则答案就是 。\",\"子任务 3（40 分）：枚举每个数，依次计算出位数即可。或者用数学的思路，看看所有的 位数有多少在范围里。\"]},\"592\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; bool check(int x) { int cnt = 0; while (x > 0) { cnt++; x /= 10; } return cnt % 2 == 0; } int main() { int l, r; cin >> l >> r; int ans = 0; for (int i = l; i <= r; i++) ans += check(i); cout << ans; return 0; }\"]},\"593\":{\"h\":\"语法周赛 Round 18 题解\"},\"594\":{\"h\":\"A. 高兴\"},\"595\":{\"h\":\"分析\",\"t\":[\"难度：简单数学，基础条件判断。\",\"子任务 1（30 分）：需要注意，并不是无脑做正方形更好的，有可能不做成正方形能赚更多钱。如果做了正方形，那么肯定会做尽可能大的正方形。把两种情况都计算一下收入即可。子任务 1 保证了 是 的倍数，如果做正方形，边长刚好是 n/4，没有额外的藤条。\",\"子任务 2（30 分）：其实没有啥特殊的作用。\",\"子任务 3（40 分）：如果做正方形，显然会做成一个边长是 n/4 的正方形，然后会剩下 的藤条。计算两种方案的售价即可。\"]},\"596\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n, a, b; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> a >> b; int ans1 = n * a; int ans2 = n % 4 * a + (n / 4) * (n / 4) * b; cout << max(ans1, ans2); return 0; }\"]},\"597\":{\"h\":\"B. 考试\"},\"598\":{\"h\":\"分析\",\"t\":[\"难度：枚举优化。\",\"子任务 1（30 分）：此时显然能拿到满分，输出 即可。\",\"子任务 2（30 分）：保证了每题要么满分要么 分，贪心选择花时间小的即可。\",\"子任务 3（40 分）：基础枚举，检查所有情况，分别枚举 ，然后显然 ，然后找到得分的最大值即可。\"]},\"599\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(0); int a1, a2, a3; int b1, b2, b3; int c1, c2, c3; int d1, d2, d3; cin >> a1 >> a2 >> a3; cin >> b1 >> b2 >> b3; cin >> c1 >> c2 >> c3; cin >> d1 >> d2 >> d3; int x1, x2, x3, x4, ans = 0; for (int ia = 0; ia <= 120; ia++) for (int ib = 0; ib <= 120 - ia; ib++) for (int ic = 0; ic <= 120 - ia - ib; ic++) { int id = 120 - ia - ib - ic; int now = 0; if (ia >= a3) now += 100; else if (ia >= a2) now += 60; else if (ia >= a1) now += 30; if (ib >= b3) now += 100; else if (ib >= b2) now += 60; else if (ib >= b1) now += 30; if (ic >= c3) now += 100; else if (ic >= c2) now += 60; else if (ic >= c1) now += 30; if (id >= d3) now += 100; else if (id >= d2) now += 60; else if (id >= d1) now += 30; if (now > ans) { ans = now; x1 = ia; x2 = ib; x3 = ic; x4 = id; } } //cout << ans << \\\"\\\\n\\\"; cout << x1 << \\\" \\\" << x2 << \\\" \\\" << x3 << \\\" \\\" << x4 << \\\"\\\\n\\\"; return 0; }\"]},\"600\":{\"h\":\"C. 加速\"},\"601\":{\"h\":\"分析\",\"t\":[\"难度：简单推理，字符串\",\"子任务 1（30 分）：显然可以列举出来所有情况。\",\"子任务 2（30 分）：保证了有解，可以想到如果要翻转，那必然是某个地方出现了连续两个相同的字符，需要在两个相同的字符中间断开翻转。\",\"子任务 3（40 分）：如果出现了连续三个字符一样，或者有多处连续两个字符一样显然都是无解。但需要注意一个特殊情况，万一断开的位置反转到后面有一样的字符也不可以，比如 rrbr，前两个字符断开反转的话，到后面还是相等的两个字符。\"]},\"602\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n; string s; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; cin >> s; int cntX = 0; int pos = 0; for (int i = 1; i < n; i++) { if (s[i] == s[i - 1]) { cntX++; pos = i; } } // 多个位置要断开 if (cntX > 1) { cout << \\\"-1\\\"; return 0; } // 断开的地方不能翻到后面去 if (cntX == 1 && s[pos] == s[s.size() - 1]) { cout << \\\"-1\\\"; return 0; } cout << pos; return 0; }\"]},\"603\":{\"h\":\"D. 油箱\"},\"604\":{\"h\":\"分析\",\"t\":[\"难度：暴力枚举。\",\"子任务 1（30 分）：保证两个油箱，双重循环枚举所有装油可能性即可。\",\"子任务 2（30 分）：每个油箱容量都是 ，那显然只有 010101.... 和 101010... 两种合法的装油方法，算算这两个有几个装油量小于 即可。\",\"子任务 3（40 分）：很容易被误会为类似于摆花要考动态规划，但考虑到 且 ，显然可以用所有 位数来枚举所有可能性。\"]},\"605\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n, m, ans; int a[10]; int x[10]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m; for (int i = 1; i <= n; i++) cin >> a[i]; int up = 1; for (int i = 1; i <= n; i++) up *= 10; ans = 0; for (int i = 0; i < up; i++) { for (int j = 1, ii = i; j <= n; j++) { x[j] = ii % 10; ii /= 10; } bool flag = true; // 和为 m int sum = 0; for (int j = 1; j <= n; j++) sum += x[j]; if (sum > m) flag = false; // 油箱限制范围内 for (int j = 1; j <= n; j++) if (x[j] > a[j]) flag = false; // 相邻奇偶性不同 for (int j = 2; j <= n; j++) if (x[j] % 2 == x[j - 1] % 2) flag = false; if (flag) ans++; } cout << ans; return 0; }\"]},\"606\":{\"h\":\"语法周赛 Round 19 题解\"},\"607\":{\"h\":\"A. 三位数重新排列\"},\"608\":{\"h\":\"分析\",\"t\":[\"难度：简单数位分解，基础条件判断。\",\"子任务 1（30 分）：显然直接输出 即可。\",\"子任务 2（30 分）：分别取出来个位、十位、百位，三个数排序后输出即可。\",\"子任务 3（40 分）：子任务 中的有可能得到 0 或者 00 开头的数。可以用条件判断特殊处理，也可以直接把三个数字重新组成为一个数。\"]},\"609\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { int n; cin >> n; int a = n / 100; int b = n / 10 % 10; int c = n % 10; if (a > b) swap(a, b); if (a > c) swap(a, c); if (b > c) swap(b, c); cout << a * 100 + b * 10 + c; return 0; }\"]},\"610\":{\"h\":\"B. 千钱买千鸡\"},\"611\":{\"h\":\"分析\",\"t\":[\"难度：枚举优化。\",\"子任务 1（30 分）：显然不可能买前两种鸡了，暴力枚举后两种各买几只即可。\",\"子任务 2（30 分）：没啥特殊作用的凑数子任务。\",\"子任务 3（40 分）：其实就是个百钱买百鸡的升级版。按百钱买百鸡一样的模式，枚举前三种鸡的数量，然后算出第四种鸡的数量，计算是否满足条件即可。看上去 可能会超时，但实际上控制好三种鸡数量之和为 的话，常数是非常小的。而且也可以进一步优化，第四种鸡的数量必然是 的倍数，可以考虑先枚举第四种鸡，当 为 时也可以直接输出 0 0 0 1000\"]},\"612\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { int a, b, c, d; cin >> a >> b >> c >> d; int ans = 0; for (int i = 0; i <= 1000; i++) for (int j = 0; j <= 1000 - i; j++) for (int k = 0; k <= 1000 - i - j; k++) { int l = 1000 - i - j - k; if (d != 0 && l % d == 0 && i * a + j * b + k * c + l / d == 1000) { cout << i << \\\" \\\" << j << \\\" \\\" << k << \\\" \\\" << l; return 0; } } cout << \\\"-i\\\"; return 0; }\"]},\"613\":{\"h\":\"C. 前后洗牌\"},\"614\":{\"h\":\"分析\",\"t\":[\"难度：简单字符串枚举\",\"子任务 1（30 分）：直接输出 即可。\",\"子任务 2（30 分）：让 枚举前半部分，依次输出 与对称位置即可。\",\"子任务 3（40 分）：做法很多。考虑在子任务 的基础上中间的位置只输出依次就好。可以用两个变量分别指示头部和尾部。当然也可以真的按照题目意思模拟。\"]},\"615\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { string s, t; cin >> s; t = \\\"\\\"; int l = 0; int r = (int)s.size() - 1; while (l <= r) { if (l <= r) { t += s[l]; l++; } if (l <= r) { t += s[r]; r--; } } cout << t; return 0; }\"]},\"616\":{\"h\":\"D. 一维分形图\"},\"617\":{\"h\":\"分析\",\"t\":[\"难度：基础递归/打表。\",\"按点得分，数据范围又小。所以可以先把样例给的五个点打表，那 分就得到了。\",\"后面的分数可以考虑手动模拟画出来，然后打表，这题是不会超源文件长度限制的。\",\"标准做法自然是递归地去画这个分形图。\"]},\"618\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n3[10]; string s; void f(int k, int pos) { if (k == 0) { s[pos] = '#'; return; } f(k - 1, pos); f(k - 1, pos + 2 * n3[k - 1]); } int main() { int n; cin >> n; n3[0] = 1; for (int i = 1; i <= n; i++) n3[i] = n3[i - 1] * 3; s.resize(n3[n]); for (int i = 0; i < s.size(); i++) s[i] = '.'; f(n, 0); cout << s; return 0; }\"]},\"619\":{\"h\":\"语法周赛 Round 2 题解\"},\"620\":{\"h\":\"凑数\",\"t\":[\"难度：学过输入输出就可以拿到满分。\",\"满分做法：题目要求我们输出三个非负整数 ，使得 。可能有多种答案，而我们只需要输出其中一种即可。又根据n的范围得知， 一定是大于等于 的正整数。所以 这个数必然可以被拆分成 三个数，我们直接输出这三个数就可以啦。\",\"#include<bits/stdc++.h> using namespace std; int n; int main() { cin>>n; cout<<1<<' '<<1<<' '<<n-2<<endl; return 0; }\"]},\"621\":{\"h\":\"开三方\",\"t\":[\"难度：掌握单层循环语句，并且了解次方的数学含义。就可以拿到满分。 满分做法：根据题意 即 。又因为 ，所以我们只需要从小到大枚举 的值，找到第一个满足 的解。\",\"注：本题数据范围较大，要把变量定义成 long long 类型！！！\",\"#include<bits/stdc++.h> using namespace std; long long n,r; int main(){ cin>>n; while(r*r*r<=n){ r++; } cout<<r-1<<' '<<r; return 0; }\"]},\"622\":{\"h\":\"比大小\",\"t\":[\"难度：需要熟练掌握分支、字符串以及字典序才可以拿到满分。\",\"30 分做法：对于 的数据， 均在 int 的范围之内，使用整型来存储和比较即可。\",\"满分做法：对于 的数据， 显然无法再使用 int 或 long long 进行存储，需要将 定义成字符串来储存，而字符串之间的关系运算已不符合数值之间的运算规则，我们需要思考所有可能的情况，进行分类讨论：\",\"（1）两数相等，输出 same，则对应的字符串也应完全一致，我们可以通过 == 直接进行判断。\",\"（2）第一个数是负数，第二个数是正数，即 a[0] 是 '-' ，b[0] 不是 '-' 时输出 second。\",\"（3）第一个数是正数，第二个数是负数，即 a[0] 不是 '-' ，b[0] 是 '-' 时输出 first。\",\"（4）两个数同正或者同负。\",\"同正，即 a[0] 不是 '-' 且 b[0] 也不是 '-' 。先判断一下两个数的位数（字符串长度）是否相等。如果不等，则位数大的数值本身也一定更大。如果位数相等，则可以比较字典序，字典序大的数值更大。然后根据结果输出对应的语句即可！\",\"同负，即 a[0] 是 '-' 且 b[0] 也是 '-' 。判断原理同上，但结果相反。\",\"#include <bits/stdc++.h> using namespace std; string a,b; int main() { cin >> a >> b; if (a == b) cout << \\\"same\\\"; // 相等 else if (a[0] == '-' && b[0] != '-') cout << \\\"second\\\"; // 一负一正 else if (a[0] != '-' && b[0] == '-') cout << \\\"first\\\"; // 一正一负 else if (a[0] != '-' && b[0] != '-') { // 两个正数 if (a.length() < b.length() || (a.length() == b.length() && a < b)) cout << \\\"second\\\"; else cout << \\\"first\\\"; } else { // 两个负数 if (a.length() < b.length() || (a.length() == b.length() && a < b)) cout << \\\"first\\\"; else cout << \\\"second\\\"; } return 0; }\"]},\"623\":{\"h\":\"吃桃子\",\"t\":[\"难度：需要熟练掌握结构体、 sort 排序和贪心思想。\",\"满分做法：为了吃到最多的桃子，我们的策略是优先吃最开胃的桃子，因为这样能吃到尽可能多的桃子，必然开心程度也就高。而如果有相同开胃值的桃子，我们要优先吃其中开心值最高的桃子。\",\"具体实现为，首先定义一个结构体，其中包括桃子的开胃值和开心值。因为我们要先按开胃值从大到小排序，开胃值相等时再按开心值从大到小排序。那么我们可以用 sort 排序，通过自定义 cmp 函数来处理这种二级排序的问题。在排序之后，我们就可以从头到尾模拟吃桃的过程，最后算出最大的开心程度即可得到答案。\",\"#include<bits/stdc++.h> using namespace std; struct st{ //把桃子定义成结构体类型 int a,b; }; st p[100000]; //定义一个结构体数组存储各个桃子的信息 bool cmp(st A,st B){ // 自定义cmp函数，进行二级排序 if(A.b==B.b){ return A.a>B.a; } return A.b>B.b; } int n,sum=1,i=0,ans=0; int main(){ cin>>n; for(int i=1;i<=n;i++){ cin>>p[i].a>>p[i].b; } sort(p+1,p+1+n,cmp); //调用sort while(sum!=0||i==n){ //模拟吃桃子的过程计算最大开心程度 i++; ans+=p[i].a; sum--; sum+=p[i].b; } cout<<ans; return 0; }\"]},\"624\":{\"h\":\"语法周赛 Round 20 题解\"},\"625\":{\"h\":\"A. 编号第几小的思维场 T1\"},\"626\":{\"h\":\"分析\",\"t\":[\"难度：简单数学运算，难点主要在读题\",\"子任务 1（30 分）：显然轮数为 。保证了是普通轮，直接输出 轮数+1 即可。\",\"子任务 2（30 分）：保证了是思维场，思维场是 ，显然输出 轮数/2-2 即可。\",\"子任务 3（40 分）：容易发现，简单场直接用 轮数/2-2 也能得到正确的结果。所以根据轮数，判断出来非普通轮就输出 轮数/2-2。\"]},\"627\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { int n; cin >> n; int r = n / 4; // 所属轮数 int t = n % 4 + 1; // 在那一场比赛中的题号（其实没用） if (r <= 5) cout << r + 1; else cout << r / 2 - 2; return 0; }\"]},\"628\":{\"h\":\"B. 小猫向日葵\"},\"629\":{\"h\":\"分析\",\"t\":[\"难度：循环嵌套，主要难点在于耐心，当然如果用后期知识点就是简单题了。\",\"子任务 1（30 分）：只买得起一个小猫向日葵或者一个樱桃辣椒，根据 决定输出 还是 还是 即可。\",\"子任务 2（30 分）：考虑 的阳光有多少种种植方案即可。\",\"子任务 3（40 分）：可以枚举每个地皮是什么植物，七层嵌套循环完成。也可以枚举每种植物有几个，然后排列组合求出答案。\"]},\"630\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { int n, m; cin >> n >> m; int ans = 0; for(int a=0;a<=3;a++) for(int b=0;b<=3;b++) for(int c=0;c<=3;c++) for(int d=0;d<=3;d++) for(int e=0;e<=3;e++) for(int f=0;f<=3;f++) for(int g=0;g<=3;g++) { int sun = 0, power = 0; if(a==1) sun+=150,power+=300; if(b==1) sun+=150,power+=300; if(c==1) sun+=150,power+=300; if(d==1) sun+=150,power+=300; if(e==1) sun+=150,power+=300; if(f==1) sun+=150,power+=300; if(g==1) sun+=150,power+=300; if(a==2) sun+=888,power+=1600; if(b==2) sun+=888,power+=1600; if(c==2) sun+=888,power+=1600; if(d==2) sun+=888,power+=1600; if(e==2) sun+=888,power+=1600; if(f==2) sun+=888,power+=1600; if(g==2) sun+=888,power+=1600; if(a==3) sun+=275,power+=600; if(b==3) sun+=275,power+=600; if(c==3) sun+=275,power+=600; if(d==3) sun+=275,power+=600; if(e==3) sun+=275,power+=600; if(f==3) sun+=275,power+=600; if(g==3) sun+=275,power+=600; if(sun<=n && power>=m) ans++; } cout << ans; return 0; }\"]},\"631\":{\"h\":\"C. 乒乓球\"},\"632\":{\"h\":\"题解\",\"t\":[\"我们把颗球看做是一轮。\",\"对于每一轮来说，如果在这一轮开始前，比分是a:b，那么这一轮结束后，比分是多少就是确定的。\",\"很明显可以看出来的一点是，开始时候两个人的当前局得分如果都的话，同时把两个人的分数减去同样的分数，使得两个人的分数都，是不会影响这一轮结果的。\",\"那么，我们开三个数组，分别记录：\",\"：最早什么时候，遇到这一轮开始前，比分是。\",\"：这个时候，小明/小红一共赢了多少局。\",\"那么，当我下一次在时候（此时总比分是）模拟遇到同样的时，就可以视作，模拟的过程是每一个周期，每个周期内，大局的得分都是。\",\"直接跳过这个超级大周期，然后模拟完剩余的时间即可。\",\"由于开始的比分最多只有种，因此模拟的总次数不会超过。\"]},\"633\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> #define maxn 1000005 #define ll long long #define mod 998244353 using namespace std; ll t[17][17]; ll sa[17][17],sb[17][17]; ll n,k; string s; ll a=0,b=0,A=0,B=0; ll tim=0; void moni() { for (int i=0;i<k;i++) { tim++; if (s[i]=='A') a++; else b++; if (max(a,b)>=11 && abs(a-b)>=2) { if (a>b) A++; else B++; a=b=0; } if (tim==n) {cout<<A<<\\\":\\\"<<B<<endl; exit(0);} } } int main() { cin>>n>>k; cin>>s; memset(t,-1,sizeof(t)); t[0][0]=0; while (true) { moni(); if (a==b && a>11) a=b=11; if (min(a,b)>=11 && a!=b) {if (a>b) a=12,b=11; else a=11,b=12;} if (t[a][b]!=-1) //曾经出现过 { ll da=A-sa[a][b],db=B-sb[a][b]; //deltaA,deltaB ll zhouqi=tim-t[a][b]; //周期大小 ll quan=(n-tim)/zhouqi; A+=da*quan; B+=db*quan; tim+=quan*zhouqi; if (tim==n) {cout<<A<<\\\":\\\"<<B<<endl; return 0;} while (true) moni(); } else { t[a][b]=tim; sa[a][b]=A; sb[a][b]=B; } } return 0; }\"]},\"634\":{\"h\":\"D. 分糖果\"},\"635\":{\"h\":\"题解\",\"t\":[\"小朋友实际上只有三种，按分为三类。\",\"组成小组只有四种类型：。\",\"显然，超过是没有意义的，因为三个可以拆分成各一个。\",\"因此，枚举组成了几组即可。\"]},\"636\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> #define maxn 1000005 #define ll long long #define mod 998244353 using namespace std; int n; vector<int> a[3]; int x,best,f; int get(int x) { for (int i=0;i<=2;i++) if (a[i].size()<x) return 0; int ret=x; for (int i=0;i<=2;i++) ret+=(a[i].size()-x)/3; return ret; } int main() { cin>>n; for (int i=1;i<=n;i++) {cin>>x; a[x%3].push_back(i);} for (int i=0;i<=2;i++) { int tt=get(i); if (tt>best) {best=tt; f=i;} } cout<<best<<endl; for (int i=1;i<=f;i++) { for (int j=0;j<=2;j++) {cout<<a[j][a[j].size()-1]<<\\\" \\\"; a[j].pop_back();} cout<<endl; } for (int i=0;i<=2;i++) { while (a[i].size()>=3) { int siz=a[i].size(); cout<<a[i][siz-1]<<\\\" \\\"<<a[i][siz-2]<<\\\" \\\"<<a[i][siz-3]<<endl; a[i].pop_back(); a[i].pop_back(); a[i].pop_back(); } } return 0; }\"]},\"637\":{\"h\":\"语法周赛 Round 21 题解\"},\"638\":{\"h\":\"A. 计算 BMI\"},\"639\":{\"h\":\"分析\",\"t\":[\"难度：简单数学运算，难点主要在读题\",\"子任务 1（30 分）：输出样例即可。\",\"子任务 2（30 分）：保证了 为 1，输出体重和 ， 即可。\",\"子任务 3（40 分）：BMI 的计算按照公式来就好，显然某个 BMI 指数对应的体重应该是：。\"]},\"640\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; double a, b; int main() { cin >> a >> b; cout << fixed << setprecision(8); cout << b / a / a << \\\"\\\\n\\\"; cout << 18.5 * a * a << \\\" \\\" << 24 * a * a << \\\"\\\\n\\\"; return 0; }\"]},\"641\":{\"h\":\"B. 零碎文件占用大小\"},\"642\":{\"h\":\"分析\",\"t\":[\"难度：循环，求和，主要难点还是读题。\",\"子任务 1（30 分）：保证了只有一个文件，计算这个文件占用空间就好，不用循环。显然空间占用就是考虑有几个整块，以及有没有多余的部分，简单检查除以 的余数是否为 即可。\",\"子任务 2（30 分）：最小单元为 KB，直接输出所有文件原始大小之和即可。\",\"子任务 3（40 分）：分别求解每个文件的空间占用然后求和即可。\"]},\"643\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n, m; int x, ans; int main() { cin >> n >> m; ans = 0; for (int i = 1; i <= n; i++) { cin >> x; ans += x / m; if (x % m != 0) ans++; } cout << ans * m; return 0; }\"]},\"644\":{\"h\":\"C. 科学记数法\"},\"645\":{\"h\":\"分析\",\"t\":[\"难度：模拟，主要难点还是读题。\",\"子任务 1（30 分）：显然直接输出字符串 ，然后再输出 *10^0 即可。\",\"子任务 2（30 分）：显然对于字符串 ，输出 x[0].x[1]~x[s.size()-1]\\\\times 10^(x.size()-1) 即可。\",\"子任务 3（40 分）：注意到，题目规定了 大于等于 。容易发现，不管怎么样，都会输出字符串 中的所有数字字符。小数点只是用来判断最后乘以 的多少次方的。\"]},\"646\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; string s; int main() { cin >> s; int num = 0; for (int i = 0; i < s.size(); i++) if (s[i] == '.') break; else num++; cout << s[0]; if (s.size() > 1) cout << \\\".\\\"; for (int i = 1; i < s.size(); i++) if (s[i] != '.') cout << s[i]; cout << \\\"*10^\\\" << num - 1 << \\\"\\\\n\\\"; return 0; }\"]},\"647\":{\"h\":\"D. 变大变大变成回文数\"},\"648\":{\"h\":\"分析\",\"t\":[\"难度：暴力枚举，数位分解。\",\"子任务 1（30 分）：不需要变化，输出 即可。\",\"子任务 2（30 分）：个位是 ，那显然最少把个位变成百位上的数即可，最后答案就是所有数百位上的数之和。\",\"子任务 3（40 分）：暴力枚举每个数，然后再暴力枚举加多少能变成回文数即可。\"]},\"649\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n, ai, ans; bool f(int x) { if (1 <= x && x <= 9) return true; if (10 <= x && x <= 99) return x % 10 == x / 10; if (100 <= x && x <= 999) return x % 10 == x / 100; return true; // 其实没必要 } int main() { cin >> n; ans = 0; for (int i = 1; i <= n; i++) { cin >> ai; while (!f(ai)) { ans++; ai++; } } cout << ans; return 0; }\"]},\"650\":{\"h\":\"语法周赛 Round 22 题解\"},\"651\":{\"h\":\"A. 测试三位数\"},\"652\":{\"h\":\"分析\",\"t\":[\"难度：简单三位数数位分解\",\"子任务 1（30 分）：此时所有数字都是完全正确的，输出 222 即可。\",\"子任务 2（30 分）：首先进行数位分解。因为没有 0，只要对应位置的数字相等就输出 2。不相等就输出 1 即可。\",\"子任务 3（40 分）：当对应位置不相等时，多检查一下和其它位置是否相等即可。\"]},\"653\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { int a, b; cin >> a >> b; int i = a / 100 % 10; int j = a / 10 % 10; int k = a % 10; int x = b / 100 % 10; int y = b / 10 % 10; int z = b % 10; if (x == i) cout << '2'; else if (x == j || x == k) cout << '1'; else cout << '0'; if (y == j) cout << '2'; else if (y == i || y == k) cout << '1'; else cout << '0'; if (z == k) cout << '2'; else if (z == i || z == j) cout << '1'; else cout << '0'; return 0; }\"]},\"654\":{\"h\":\"B. 猜三位数\"},\"655\":{\"h\":\"分析\",\"t\":[\"难度：主要难度在于可能之前没接触过交互题。\",\"子任务 1（30 分）：直接尝试 的每个数字即可。\",\"子任务 2（30 分）： 的三个位置各不相同，所以可以过滤掉有相同的情况，剩下 种情况。\",\"子任务 3（40 分）： \",\"做法 1：可以先猜 三个数，就可以确定三个数位分别是哪三个数。然后枚举三个数字的所有排列（ 种情况）。这样最多 次就能完成了。\",\"做法 2：每次猜的时候三个数独立变化，每个数位都从 尝试到 。如果某个数位回答的是 ，那就不变了。最多 次就猜完了。\"]},\"656\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { int ans = 0; char x, y, z; cout << 123 << \\\"\\\\n\\\"; cout.flush(); cin >> x >> y >> z; if (x == '2' && y == '2' && z == '2') return 0; if (x != '0') ans = ans * 10 + 1; if (y != '0') ans = ans * 10 + 2; if (z != '0') ans = ans * 10 + 3; cout << 456 << \\\"\\\\n\\\"; cout.flush(); cin >> x >> y >> z; if (x == '2' && y == '2' && z == '2') return 0; if (x != '0') ans = ans * 10 + 4; if (y != '0') ans = ans * 10 + 5; if (z != '0') ans = ans * 10 + 6; cout << 789 << \\\"\\\\n\\\"; cout.flush(); cin >> x >> y >> z; if (x == '2' && y == '2' && z == '2') return 0; if (x != '0') ans = ans * 10 + 7; if (y != '0') ans = ans * 10 + 8; if (z != '0') ans = ans * 10 + 9; int a = ans / 100 % 10; int b = ans / 10 % 10; int c = ans % 10; cout << a << b << c << \\\"\\\\n\\\"; cout.flush(); if (x == '2' && y == '2' && z == '2') return 0; cout << a << c << b << \\\"\\\\n\\\"; cout.flush(); if (x == '2' && y == '2' && z == '2') return 0; cout << b << a << c << \\\"\\\\n\\\"; cout.flush(); if (x == '2' && y == '2' && z == '2') return 0; cout << b << c << a << \\\"\\\\n\\\"; cout.flush(); if (x == '2' && y == '2' && z == '2') return 0; cout << c << a << b << \\\"\\\\n\\\"; cout.flush(); if (x == '2' && y == '2' && z == '2') return 0; cout << c << b << a << \\\"\\\\n\\\"; cout.flush(); if (x == '2' && y == '2' && z == '2') return 0; return 0; }\"]},\"657\":{\"h\":\"C. 子串取模\"},\"658\":{\"h\":\"分析\",\"t\":[\"难度：经典的考察怎么把一些数位组合成一个数。\",\"子任务 1（30 分）：输出 对应的数字除以 的余数即可。\",\"子任务 2（30 分）：模数为 时只要考虑最后三位的值即可。\",\"子任务 3（40 分）： \",\"假设 ，则 对应的数为 。预处理所有 的幂次模 ，就可以 算出答案了。\",\"可以直接用秦九韶算法，把式子转换为 构成的数显然等于 。\",\"如果 是一个定值的话。这题可以进一步扩展数据范围。用类似于前缀和的方式，算出 的值 。这样 就是 。这样在预处理完后就可以 求每个问题的答案了。这个方式在字符串哈希算法的求子串哈希值时也会用到。\"]},\"659\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { int n; string s; cin >> n; cin >> s; while (n--) { int l, r, m; cin >> l >> r >> m; long long now = 0; for (int i = l; i <= r; i++) { now = now * 10 + (s[i - 1] - '0'); now = now % m; } cout << now << \\\"\\\\n\\\"; } return 0; }\"]},\"660\":{\"h\":\"D. K 的倍数或个位是 K\"},\"661\":{\"h\":\"分析\",\"t\":[\"难度：60 分就是个分类讨论的暴力枚举。满分需要一些数学方式处理。\",\"子任务 1（30 分）：所有数都是 的倍数，输出 即可。\",\"子任务 2（30 分）：暴力枚举 的每个数检查即可。\",\"子任务 3（40 分）： \",\"为了方便处理，可以首先把问题转换成 满足条件的数量减去 满足条件的数的数量。我们就可以专心考虑怎么算 满足条件的数的数量了。\",\"显然 中 的倍数有 个。\",\"个位是 的数就是固定个位为 ，考虑其他位置的情况，显然可能是 ，最大的那个需要看看是否超过了 。\",\"这里重复计算了既是 的倍数，个位又是 的情况。即 中， 是 的倍数的情况。去掉这些重复计算的就是答案了。\"]},\"662\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n, k, l, r; // 1~x 的答案 int f(int x) { // k 的倍数 int a = x / k; // 个位是 k 的数 int b = x / 10; // [0~(x/10-1)]k if (x % 10 >= k) b++; // [x/10]k // 个位是 k 且是 k 的倍数 int kk = k;//记录去掉 10 的贡献后的内容 if (k % 2 == 0) kk /= 2; if (k % 5 == 0) kk /= 5; int c = max(0, (x / 10 - 1) / kk); //[1~x/10-1]k if (x / 10 >= 1 && x % 10 >= k && x / 10 * 10 % k == 0) c++; //[x/10]k if (x >= k) c++; //[0]k return a + b - c; } int main() { cin >> n >> k; while (n--) { cin >> l >> r; cout << f(r) - f(l - 1) << '\\\\n'; } return 0; }\"]},\"663\":{\"h\":\"语法周赛 Round 23 题解\"},\"664\":{\"h\":\"A. 课间休息时间设置\"},\"665\":{\"h\":\"分析\",\"t\":[\"难度：简单数学计算及按格式输出\",\"子任务 1（30 分）：手动算算， 个小时的课应该在 小时 分时课间休息，所以课间休息时间应该是 09:55。\",\"子任务 2（30 分）：保证了时间是偶数，那去掉课间 分钟之后剩下的部分也是偶数。两节课时间一样，都是 分钟，也就是 (n-10)/2/60 小时 (n-10)/2%60 分钟。应该 (n-10)/2/60+8 点 (n-10)/2%60 分下课。按格式输出即可。\",\"子任务 3（40 分）：如果时间是奇数，实际上因为需要第一节课时间稍短一点，所以就按照子任务 2 的式子也是对的。\"]},\"666\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { int n; cin >> n; n -= 10; n /= 2; int hh, mm; hh = 8 + n / 60; mm = n % 60; if (hh < 10) cout << \\\"0\\\"; cout << hh; cout << \\\":\\\"; if (mm < 10) cout << \\\"0\\\"; cout << mm; return 0; }\"]},\"667\":{\"h\":\"B. 游泳同步起步\"},\"668\":{\"h\":\"分析\",\"t\":[\"难度：简单枚举。\",\"子任务 1（30 分）：因为 ，所以此时保证了每个整数时间 33DAI 都在起点。就看 kitten 经过了几次起点即可。显然 kitten 会在 时间在起点，一共 次。\",\"子任务 2（30 分）：因为 是 的倍数，所以显然 kitten 在起点时，33DAI 都在起点，还是一样输出 n/b+1 即可。\",\"子任务 3（40 分）： \",\"（做法 1）枚举：直接显然时间从 ，如果当前时间 除以 的余数为 的话 33DAI 就在起点，除以 的余数为 的话 kitten 就在起点。枚举每个时间，检查多少个时间满足这个要求即可。\",\"（做法 2）数论：显然核心就是找 有多少个 的公倍数。因此可以找到最小公倍数 lcm(a,b)，答案就是 n/lcm(a,b)+1。这个做法可以做更大数据范围。\"]},\"669\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { int a, b, n; cin >> a >> b >> n; int ans = 0; for (int i = 0; i <= n; i++) if (i % a == 0 && i % b == 0) ans++; cout << ans; return 0; }\"]},\"670\":{\"h\":\"C. 比大小 Plus\"},\"671\":{\"h\":\"分析\",\"t\":[\"难度：简单字符串操作。\",\"子任务 1（30 分）：直接输入两个整数比较即可，多余的前导 是不会影响正常的整数输入的。\",\"子任务 2（30 分）：没有多余前导 时，就是我们之前第二场语法周赛的比大小的弱化版了，直接先比较长度，长度一致时直接用小于号比较两个 string 的字典序即可。\",\"子任务 3（40 分）：先找到两个数第一个不是 0 的位置，然后比较长度，长度一致时比较字典序即可。\"]},\"672\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; string a, b; int aL, aLen; int bL, bLen; int main() { cin >> a >> b; aL = 0; while (aL < (int)a.size() - 1 && a[aL] == '0') aL++; bL = 0; while (bL < (int)b.size() - 1 && b[bL] == '0') bL++; aLen = (int)a.size() - aL + 1; bLen = (int)b.size() - bL + 1; if (aLen > bLen) { cout << \\\"first\\\"; return 0; } if (bLen > aLen) { cout << \\\"second\\\"; return 0; } for (int i = aL, j = bL; i < a.size(); i++, j++) { if (a[i] > b[j]) { cout << \\\"first\\\"; return 0; } if (b[j] > a[i]) { cout << \\\"second\\\"; return 0; } } cout << \\\"same\\\"; return 0; }\"]},\"673\":{\"h\":\"D. 小数独验证\"},\"674\":{\"h\":\"分析\",\"t\":[\"难度：二维数组。\",\"子任务 1（1 分）：输出 yes 即可。只是为了提醒大家要注意读题。\",\"子任务 2（99 分）：难点只是麻烦，可以把检查四个数是不是 的排列打包成一个函数来简化代码。\"]},\"675\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int num[5]; bool check() { sort(num + 1, num + 5); for (int i = 1; i <= 4; i++) if (num[i] != i) return false; return true; } int a[5][5]; int main() { for (int i = 1; i <= 4; i++) for (int j = 1; j <= 4; j++) cin >> a[i][j]; for (int i = 1; i <= 4; i++) { for (int j = 1; j <= 4; j++) num[j] = a[i][j]; if (!check()) { cout << \\\"no\\\\n\\\"; return 0; } for (int j = 1; j <= 4; j++) num[j] = a[j][i]; if (!check()) { cout << \\\"no\\\\n\\\"; return 0; } } // 左上 num[1] = a[1][1], num[2] = a[1][2]; num[3] = a[2][1], num[4] = a[2][2]; if (!check()) { cout << \\\"no\\\\n\\\"; return 0; } // 右上 num[1] = a[1][3], num[2] = a[1][4]; num[3] = a[2][3], num[4] = a[2][4]; if (!check()) { cout << \\\"no\\\\n\\\"; return 0; } // 左下 num[1] = a[3][1], num[2] = a[3][2]; num[3] = a[4][1], num[4] = a[4][2]; if (!check()) { cout << \\\"no\\\\n\\\"; return 0; } // 右下 num[1] = a[3][3], num[2] = a[3][4]; num[3] = a[4][3], num[4] = a[4][4]; if (!check()) { cout << \\\"no\\\\n\\\"; return 0; } cout << \\\"yes\\\\n\\\"; return 0; }\"]},\"676\":{\"h\":\"语法周赛 Round 24 题解\"},\"677\":{\"h\":\"A. MB 还是 MiB？\"},\"678\":{\"h\":\"分析\",\"t\":[\"难度：根据字符判断单位即可。\",\"子任务 1（30 分）：确定了单位，输出的必然是 \",\"子任务 2（30 分）：可以用两个字符输入单位，然后根据第一个字符来决定乘几个 。\",\"子任务 3（40 分）：\"]},\"679\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { long long a, b; char x, y; cin >> a >> x >> y; if (y == 'i') b = 1024; else b = 1000; if (x == 'K') cout << a * b << \\\"\\\\n\\\"; else if (x == 'M') cout << a * b * b << \\\"\\\\n\\\"; else if (x == 'G') cout << a * b * b * b << \\\"\\\\n\\\"; return 0; }\"]},\"680\":{\"h\":\"B. 优化代码 2\"},\"681\":{\"h\":\"分析\",\"t\":[\"难度：\",\"子任务 1（30 分）：\",\"子任务 2（30 分）：\",\"子任务 3（40 分）：\"]},\"682\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { long long n; cin >> n; long long i, num; for (i = 1;; i++) { // i*i+1 对应的 n num = i * i + 1 - i; if (num > n) break; } i--; num = i * i + 1 - i; cout << i * i + 1 + (n - num); return 0; }\"]},\"683\":{\"h\":\"C. 比大小 Pro\"},\"684\":{\"h\":\"分析\",\"t\":[\"难度：\",\"子任务 1（30 分）：\",\"子任务 2（30 分）：\",\"子任务 3（40 分）：\"]},\"685\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { string a, b; cin >> a >> b; bool neg = false; if (a[0] == '-' && b[0] != '-') { cout << \\\"second\\\"; return 0; } if (a[0] != '-' && b[0] == '-') { cout << \\\"first\\\"; return 0; } if (a[0] == '-') neg = true; int aL = 0, bL = 0; while (aL != (int)a.size() - 1 && (a[aL] == '-' || a[aL] == '0')) aL++; while (bL != (int)b.size() - 1 && (b[bL] == '-' || b[bL] == '0')) bL++; int ans = 0; // 正数时的大小关系 if ((int)a.size() - aL > (int)b.size() - bL) ans = 1; else if ((int)a.size() - aL < (int)b.size() - bL) ans = 2; else { for (int i = aL, j = bL; i < a.size(); i++, j++) { if (a[i] > b[j]) { ans = 1; break; } if (a[i] < b[j]) { ans = 2; break; } } } if (ans == 0) cout << \\\"same\\\"; else if (ans == 1 && !neg || ans == 2 && neg) cout << \\\"first\\\"; else cout << \\\"second\\\"; return 0; }\"]},\"686\":{\"h\":\"D. 按行排序按列排序\"},\"687\":{\"h\":\"分析\",\"t\":[\"难度：\",\"子任务 1（30 分）：\",\"子任务 2（30 分）：\",\"子任务 3（40 分）：\"]},\"688\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n, op, pos, x, y; int a[1005][1005]; int num[1005]; int main() { cin >> n; for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) cin >> a[i][j]; for (int t = 1; t <= n; t++) { cin >> op >> x; if (op == 1) { for (int i = 1; i <= n; i++) num[i] = a[x][i]; sort(num + 1, num + n + 1); for (int i = 1; i <= n; i++) a[x][i] = num[i]; } if (op == 2) { for (int i = 1; i <= n; i++) num[i] = a[i][x]; sort(num + 1, num + n + 1); for (int i = 1; i <= n; i++) a[i][x] = num[i]; } } for (int t = 1; t <= n; t++) { cin >> x >> y; cout << a[x][y] << \\\"\\\\n\\\"; } return 0; }\"]},\"689\":{\"h\":\"语法周赛 Round 25 题解\"},\"690\":{\"h\":\"A. WYH 问题目名叫啥\"},\"691\":{\"h\":\"分析\",\"t\":[\"难度：简单三位数数位分解，基础条件判断或者字符运算\",\"子任务 1（30 分）：假设数位分解后三个数为分别是 abc，那么输出必然是 3*w,星号的部分为 b 对应的大写字母。可以用 ‘A’+b 或者十个 if 语句完成。\",\"子任务 2（30 分）：留个不怕累的同学的分数，根据个位写是个 if 语句即可。\",\"子任务 3（40 分）：数位分解后依次算出每一位对应的字符即可。\"]},\"692\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n; int main() { cin >> n; int a = n / 100 % 10; int b = n / 10 % 10; int c = n % 10; char aa = 'A' + a; char cc = 'z' - c; cout << aa << b << cc; return 0; }\"]},\"693\":{\"h\":\"B. 惠子相梁\"},\"694\":{\"h\":\"分析\",\"t\":[\"难度：简单计算题，输入范围很小，也可以手动计算打表。\"]},\"695\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; long long a; long long x, y, temp; int main() { cin >> a; x = y = 0; // a^a temp = 1; for (int i = 1; i <= a; i++) temp *= a; x += temp; // a! temp = 1; for (int i = 1; i <= a; i++) temp *= i; x += temp; // 2*a x += 2 * a; // a^2+a y = a * a + a; // output cout << x - y; return 0; }\"]},\"696\":{\"h\":\"C. 文件 IO\"},\"697\":{\"h\":\"分析\",\"t\":[\"难度：基础字符串输入输出\",\"按题意输入一个字符串，输出特定内容即可。主要转义符用法，常用的转义符有：\",\"\\\\：'\\\\\\\\'\",\"'：'\\\\''\",\"\\\"：'\\\\\\\"'\"]},\"698\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; string wotojo; int main() { cin >> wotojo; cout << \\\"freopen(\\\\\\\"\\\" << wotojo << \\\".in\\\\\\\", \\\\\\\"r\\\\\\\", stdin);\\\\n\\\"; cout << \\\"freopen(\\\\\\\"\\\" << wotojo << \\\".out\\\\\\\", \\\\\\\"w\\\\\\\", stdout);\\\\n\\\"; return 0; }\"]},\"699\":{\"h\":\"D. 26.59 s\"},\"700\":{\"h\":\"分析\",\"t\":[\"难度：基础二维数组枚举及位置关系判断\",\"子任务 1（30 分）：只有一个格子，答案必然是 （如果是雷，就没有地方放数字了。如果不是雷就没有数字了）\",\"子任务 2（30 分）：根据那一个雷所处的位置，可以确定周边有几个数字。四个角上有三个数字，边上有五个数字，中间有八个数字。\",\"子任务 3（40 分）：枚举二维数组每个位置，检查周边有没有雷即可。\"]},\"701\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n, m; char g[105][105]; int main() { cin >> n >> m; for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) cin >> g[i][j]; int cnt = 0; for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) { if (g[i][j] == '*') continue; bool flag = false; for (int x = i - 1; x <= i + 1; x++) for (int y = j - 1; y <= j + 1; y++) if (g[x][y] == '*') flag = true; cnt += flag; } cout << cnt; return 0; }\"]},\"702\":{\"h\":\"语法周赛 Round 26 题解\"},\"703\":{\"h\":\"A. 等差数列变化求和\"},\"704\":{\"h\":\"分析\",\"t\":[\"难度：比较麻烦的数学题。\",\"子任务 1（30 分）：min(r, max(l, a1))。\",\"子任务 2（30 分）：直接暴力枚举即可。\",\"子任务 3（40 分）：显然麻烦的点是情况非常多，可能递增或递减，可能分为三段、两段或一段，中间的情况也会非常复杂。 大家要学会不要只一味的判断当前情况，而要提前预处理做一些整理才能让后续事半功倍。我的代码第一步就是先把递减的序列转换为对应等价的递增序列。这样情况就简单了非常多。 然后把三段直接用数学方法算出分界点，分别用对应的规则进行计算即可。\"]},\"705\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> #define int long long using namespace std; int n, a1, d, l, r; signed main() { freopen(\\\"sum.in\\\", \\\"r\\\", stdin); freopen(\\\"sum.out\\\", \\\"w\\\", stdout); cin >> n >> a1 >> d >> l >> r; // 调整数列，为连续上升 if (d < 0) { a1 = a1 + (n - 1) * d; d = -d; } int ans = 0; // lllll if (a1 < l) { // 前 cnt 项都 <= l，第 cnt+1 项肯定大于 l int cnt = (l - a1) / d + 1; if (cnt > n) cnt = n; ans += cnt * l; // cnt 个 l a1 += cnt * d; // 首项变到第 cnt+1 项 n -= cnt; // 现在少了 cnt 项 } // 等差阶段 if (a1 < r) { // 前 cnt 项都 <= r，第 cnt+1 项肯定大于 r int cnt = (r - a1) / d + 1; if (cnt > n) cnt = n; // 首项 加 末项 乘以 项数 除以 2 ans += (a1 + (a1 + (cnt - 1) * d)) * cnt / 2; a1 += cnt * d; n -= cnt; } // rrrrrr 后面的全都大于 r ans += n * r; cout << ans; return 0; }\"]},\"706\":{\"h\":\"B. 停车费计算\"},\"707\":{\"h\":\"分析\",\"t\":[\"难度：基础的求和，求和的每一项都根据具体情况计算价格即可。\",\"子任务 1（30 分）：每天只有两种费用， 或 元，判断每天停车时间是否大于 来决定加多少即可。\",\"子任务 2（30 分）：第一个小时和后续价格一致，超过 元直接算出多少个小时乘以对应的单价即可。\",\"子任务 3（40 分）：每天的停车时长算出属于哪一档，按规则计算即可。\"]},\"708\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> #define int long long using namespace std; int n; // 总次数 int x; // 免费时长 int y, a, b; // 第一个 y 分钟 a 元。后面每 y 分钟 b 元 int t[10000 + 5], ans; signed main() { freopen(\\\"park.in\\\", \\\"r\\\", stdin); freopen(\\\"park.out\\\", \\\"w\\\", stdout); cin >> n; cin >> x; cin >> y >> a >> b; for (int i = 1; i <= n; i++) cin >> t[i]; ans = 0; for (int i = 1; i <= n; i++) { if (t[i] <= x) continue; if (t[i] <= y) { ans += a; continue; } int cnt = (t[i] + (y - 1)) / y; ans += a + (cnt - 1) * b; } cout << ans; return 0; }\"]},\"709\":{\"h\":\"C. 复制画作\"},\"710\":{\"h\":\"分析\",\"t\":[\"难度：基础绘图，注意转义符。\"]},\"711\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; string g[4] = {\\\"./\\\\\\\\.\\\", \\\"/..\\\\\\\\\\\", \\\"\\\\\\\\../\\\", \\\".\\\\\\\\/.\\\"}; int main() { freopen(\\\"copy.in\\\", \\\"r\\\", stdin); freopen(\\\"copy.out\\\", \\\"w\\\", stdout); int n, m; cin >> n >> m; for (int i = 1; i <= n; i++) for (int row = 0; row <= 3; row++) { for (int j = 1; j <= m; j++) { cout << g[row]; } cout << \\\"\\\\n\\\"; } return 0; }\"]},\"712\":{\"h\":\"D. 计算补码\"},\"713\":{\"h\":\"分析\",\"t\":[\"难度：按照补码规则处理即可，最后的加 稍微麻烦一点。按竖式计算即可。\"]},\"714\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; string s; int main() { freopen(\\\"code.in\\\", \\\"r\\\", stdin); freopen(\\\"code.out\\\", \\\"w\\\", stdout); cin >> s; if (s[0] == '0') { cout << s; return 0; } for (int i = 1; i <= (int)s.size() - 1; i++) { if (s[i] == '0') s[i] = '1'; else s[i] = '0'; } int add = 1; // 进位 for (int i = (int)s.size() - 1; i >= 0; i--) { int num = s[i] - '0' + add; add = num / 2; num = num % 2; s[i] = '0' + num; } cout << s; return 0; }\"]},\"715\":{\"h\":\"语法周赛 Round 27 题解\"},\"716\":{\"h\":\"A. 33DAI 的数字游戏\"},\"717\":{\"h\":\"分析\",\"t\":[\"难度：CSP-J 2019 第一题的数字游戏升级版。处理的时候大家不用想复杂了，毕竟才第一题嘛。\"]},\"718\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { freopen(\\\"number.in\\\", \\\"r\\\", stdin); freopen(\\\"number.out\\\", \\\"w\\\", stdout); char a; int cnt = 0; cin >> a; if (a == '3') cnt++; // 1 cin >> a; if (a == '3') cnt++; // 2 cin >> a; if (a == '3') cnt++; // 3 cin >> a; if (a == '3') cnt++; // 4 cin >> a; if (a == '3') cnt++; // 5 cin >> a; if (a == '3') cnt++; // 6 cin >> a; if (a == '3') cnt++; // 7 cin >> a; if (a == '3') cnt++; // 8 cout << cnt; return 0; }\"]},\"719\":{\"h\":\"B. 第三大的数\"},\"720\":{\"h\":\"分析\",\"t\":[\"子任务 1（30 分）：保证了三个数，三数排序后输出第三个数即可。\",\"子任务 2（30 分）：所有数都相等，输出 即可。\",\"子任务 3（40 分）：语法周赛第二题是不能考数组的，所以这里给的也是不用数组记录的方式。显然我们只需要记录前三名的数。按大小规则替换即可。\"]},\"721\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n, x; int a, b, c; int main() { freopen(\\\"thrid.in\\\", \\\"r\\\", stdin); freopen(\\\"thrid.out\\\", \\\"w\\\", stdout); a = b = c = -1'000'000'000 - 1; cin >> n; for (int i = 1; i <= n; i++) { cin >> x; if (x >= a) { c = b; b = a; a = x; } else if (x >= b) { c = b; b = x; } else if (x >= c) { c = x; } } cout << c; return 0; }\"]},\"722\":{\"h\":\"C. 曼哈顿圆圈\"},\"723\":{\"h\":\"分析\",\"t\":[\"难度：如题所述，算出 、算出中心点 ，然后枚举 每个位置，符合条件的输出 *，不符合条件的输出 . 即可。\"]},\"724\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n, k, x; int main() { freopen(\\\"circle.in\\\", \\\"r\\\", stdin); freopen(\\\"circle.out\\\", \\\"w\\\", stdout); cin >> n; k = (n - 1) / 2; x = (n + 1) / 2; for (int i = 1; i <= n; i++) { for (int j = 1; j <= n; j++) { if (abs(i - x) + abs(j - x) == k) cout << \\\"*\\\"; else cout << \\\".\\\"; } cout << \\\"\\\\n\\\"; } return 0; }\"]},\"725\":{\"h\":\"D. 朋友平均有几个朋友\"},\"726\":{\"h\":\"分析\",\"t\":[\"题面中提到的视频是：https://www.bilibili.com/video/BV1PE421w7jL/\",\"子任务 1（30 分）：每个人都有 个朋友，按格式直接输出即可。\",\"子任务 2（30 分）：整个朋友关系形成了一条链， 有一个朋友，其他人都有两个朋友。\",\"子任务 3（40 分）：有同学觉得这是图论，但实际上我们只需要记住朋友有谁，每个人几个朋友。就可以算出每个人朋友的朋友总数，和平均朋友数量了。这里我没有用 vector 存图，数据范围很小，我就用最简单的方式存下每条边，判断每个人朋友数量，完全不超纲。\"]},\"727\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n, m; pair<int, int> e[1000 * 999 / 2 + 5]; int cnt[1005], sum[1005]; int main() { freopen(\\\"friend.in\\\", \\\"r\\\", stdin); freopen(\\\"friend.out\\\", \\\"w\\\", stdout); cin >> n >> m; for (int i = 1; i <= m; i++) cin >> e[i].first >> e[i].second; for (int i = 1; i <= m; i++) { cnt[e[i].first]++; cnt[e[i].second]++; } for (int i = 1; i <= m; i++) { sum[e[i].first] += cnt[e[i].second]; sum[e[i].second] += cnt[e[i].first]; } for (int i = 1; i <= n; i++) cout << cnt[i] << \\\" \\\" << (sum[i] + (cnt[i] - 1)) / cnt[i] << \\\"\\\\n\\\"; return 0; }\"]},\"728\":{\"h\":\"语法周赛 Round 28 题解\"},\"729\":{\"h\":\"p 除以 q\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(0); long long p, q, x, l, r; cin >> p >> q; x = p / q; r = x + 1; l = x - 1; if (abs(l * q - p) <= abs(x * q - p)) x = l; if (abs(r * q - p) < abs(x * q - p)) x = r; cout << x; return 0; }\"]},\"730\":{\"h\":\"根号 x\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(0); long long x; cin >> x; long long ans = 0; for (long long i = 1; i * i <= x; i++) if (x % (i * i) == 0) ans = i; cout << ans; return 0; }\"]},\"731\":{\"h\":\"提交文件夹\",\"t\":[\"#include <bits/stdc++.h> using namespace std; string id, a, b, c, d; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> id >> a >> b >> c >> d; cout << id << \\\"/\\\" << a << \\\"/\\\" << a << \\\".cpp\\\\n\\\"; cout << id << \\\"/\\\" << b << \\\"/\\\" << b << \\\".cpp\\\\n\\\"; cout << id << \\\"/\\\" << c << \\\"/\\\" << c << \\\".cpp\\\\n\\\"; cout << id << \\\"/\\\" << d << \\\"/\\\" << d << \\\".cpp\\\\n\\\"; return 0; }\"]},\"732\":{\"h\":\"乌龟对对碰\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n, m, x; string s; int turtle_cnt; // 乌龟计数器 int g[10]; // 棋盘 int temp[10]; // 棋盘 // 检查全家福 bool QJF() { for (int i = 1; i <= 9; i++) { temp[i] = g[i]; if (g[i] == -1) return false; } sort(temp + 1, temp + 10); for (int i = 2; i <= 9; i++) if (temp[i] == temp[i - 1]) return false; m += 8; for (int i = 1; i <= 9; i++) g[i] = -1; return true; } // 检查三个位置是否相等 bool check3(int i, int j, int k) { if (g[i] != -1 && g[i] == g[j] && g[j] == g[k]) { g[i] = g[j] = g[k] = -1; m += 2; return true; } return false; } // 行列对角线按顺序检查 bool HLD() { return check3(1, 2, 3) || check3(4, 5, 6) || check3(7, 8, 9) || check3(1, 4, 7) || check3(2, 5, 8) || check3(3, 6, 9) || check3(1, 5, 9) || check3(3, 5, 7); } // 碰 bool P() { for (int i = 1; i <= 9; i++) { if (g[i] == -1) continue; for (int j = i + 1; j <= 9; j++) { if (g[j] == g[i]) { g[j] = g[i] = -1; m += 1; return true; } } } return false; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n >> m >> x; cin >> s; for (int i = 1; i <= 9; i++) g[i] = -1; while (turtle_cnt < m) { // 拿乌龟 for (int i = 1; i <= 9; i++) { if (g[i] == -1 && turtle_cnt < m) { g[i] = s[turtle_cnt] - '0'; if (s[turtle_cnt] - '0' == x) m++; turtle_cnt++; } } // 结算 bool flag = true; while (flag) { flag = false; if (QJF()) flag = true; else if (HLD()) flag = true; else if (P()) flag = true; } } cout << turtle_cnt; return 0; }\"]},\"733\":{\"h\":\"语法周赛 Round 29 题解\"},\"734\":{\"h\":\"A. 初赛估分\",\"t\":[\"子任务 1：必然能过，输出 Yes 即可。\",\"子任务 2：直接分别除以 和 就行，不用担心整型相除自动取整。\",\"子任务 3：建议能只用整型就只用整型。\",\"#include <bits/stdc++.h> using namespace std; int x, y, z, a; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> x >> y >> z >> a; // x + y / 2 + z / 4 >= a // 4x + 2y + z >= 4a if (4 * x + 2 * y + z >= 4 * a) cout << \\\"Yes\\\\n\\\"; else cout << \\\"No\\\\n\\\"; return 0; }\"]},\"735\":{\"h\":\"B. 第 n 个质数\",\"t\":[\"当题目给你一个不可能完成的任务时，注意有没有奇怪的数据规模约定。\",\"子任务 1：暴力枚举即可。\",\"子任务 2：显然没法在规定的时间空间限制下算出来，那么可以本地用暴力程序跑出来第 个质数是 。直接暴力跑的程序在我的电脑上花了不到 分钟跑出来了这个结果，如果你会筛法会更快（欧拉筛就更更快了）。然后直接输出这个结果就好。这个做法我们一般叫“打表”或者广义的“离线处理”。\",\"子任务 3：既然最多只在子任务 2 的基础上往后数 个数，直接往后暴力枚举就好了（如果你用函数判断质数，下面的代码会更简洁）。当然你也可以继续往后打表，打出来这 101 个数。\",\"#include <bits/stdc++.h> using namespace std; const int P1 = 2; const int P83 = 640663963; int main() { ios::sync_with_stdio(false); cin.tie(0); int n, start; cin >> n; if (n > 100) { start = P83; // 把 33333333 对应到 1 n = n - 33'333'332; } else start = P1; for (int i = 1; i <= n - 1; i++) { // 变成下一个质数 start++; while (1) { // 检查是否为质数 bool flag = true; for (int j = 2; j * j <= start; j++) if (start % j == 0) { flag = false; break; } // 是质数就停，否则变成下一个数 if (flag) break; else start++; } } cout << start; return 0; }\"]},\"736\":{\"h\":\"C. 连续打卡与累计打卡\",\"t\":[\"简单场的第二题已经这么难了，后两题我自然出的就简单了。\",\"子任务 1：输出 即可。\",\"子任务 2：根据 输出 或者 即可。\",\"子任务 3：按题意模拟计数即可。\",\"#include <bits/stdc++.h> using namespace std; int n; string s; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; cin >> s; int now, all; now = all = 0; for (int i = 0; i < s.size(); i++) { if (s[i] == 'o') now++; else break; } for (int i = 0; i < s.size(); i++) if (s[i] == 'o') all++; cout << now << \\\" \\\" << all; return 0; }\"]},\"737\":{\"h\":\"D. 冒泡排序步骤\",\"t\":[\"有同学可能会问这道题有什么意义，实际上有下面几个意义：\",\"凑数\",\"教大家怎么通过中间加输出语句，观察程序的运行流程，进而调试代码。\",\"初赛阅读程序训练。\",\"#include <bits/stdc++.h> using namespace std; const int MAXN = 1000; int n; int a[MAXN + 5]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; bool flag = true; while (flag) { flag = false; for (int i = 1; i <= n - 1; i++) { cout << \\\"cmp,a[\\\" << i << \\\"],a[\\\" << i + 1 << \\\"]\\\\n\\\"; if (a[i] > a[i + 1]) { cout << \\\"swp,a[\\\" << i << \\\"],a[\\\" << i + 1 << \\\"]\\\\n\\\"; swap(a[i], a[i + 1]); flag = true; } } } /* for (int i = 1; i <= n; i++) cout << a[i] << \\\" \\\"; */ return 0; }\"]},\"738\":{\"h\":\"语法周赛 Round 3 题解\"},\"739\":{\"h\":\"算利润\",\"t\":[\"难度：简单数学问题。\",\"钱包金额 元，今天的价格 元，明天价格 元。\",\"首先判断价格是否存在涨幅，如果明天价格 元小于等于今天价格 元，买了不会赚，所以不做买卖，金钱没有变动，输出 。\",\"如果明天价格 元高于今天价格 元，首先计算一件物品的盈利金额 元，可以购买 (计算机整数除整数自动取整)件，所以一共可以盈利 元，总钱数 。\",\"#include <bits/stdc++.h> using namespace std; int n,x,y; int main(){ cin>>n>>x>>y; if(x<y){ cout<<n/x*y+n-n/x*x; }else{ cout<<n; } return 0; }\"]},\"740\":{\"h\":\"星星历\",\"t\":[\"难度：日期进制的数学计算问题，只需要计算日期输出 1 1 n 也有 分。\",\"首先理解星星历的机制，星星历采用每星 天，每年 星，从 年 星 日开始计算。\",\"还需要了解日期进制和普通进制的差异，例如： 星 日下一天是 星 日， 年 星 日下一天是 年 星 日。日期进制没有 ，每次满日或者满星是不进位的，直到下一天，才会进位，并且当前直接为 开始，所以计算年星日的时候一定要注意这个满星，满日问题。\",\"计算方法有两种：\",\"方法一，可以使用暴力方案一天一天去数，本题数据可做 分。\",\"方法二， \",\"计算年可以通过 的方案，主要给天数减一，规避掉整除商会加 的情况，然后从 年开始计算，加到 上即可。\",\"计算星可以通过计算得到当前的天数 (也是要规避整除情况)，然后再由 计算出星。\",\"计算日同上，规避整除即可。\",\"#include <iostream> using namespace std; int main(){ int n; cin>>n; cout<<(n-1)/360+1<<\\\" \\\"; cout<<(((n-1)%360+1)-1)/120+1<<\\\" \\\"; cout<<(n-1)%120+1; return 0; }\"]},\"741\":{\"h\":\"简单系动词\",\"t\":[\"难度：主要考察输入问题，如果使用文件结束符结束输入。\",\"输入完成后，从左到右扫描单词，只要不是系动词就输出，如果是系动词，根据当前系动词前面的单词情况，更改现在的系统词输出即可，因为题目保证语句通顺，所以可以保证系统词只是位置不对，数量和匹配一定是对的，也不需要统计系动词数量。\",\"#include <bits/stdc++.h> using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(0); string last, now; last = \\\"\\\"; while (cin >> now) { if (now == \\\"am\\\" || now == \\\"are\\\" || now == \\\"is\\\") { if (last == \\\"i\\\") now = \\\"am\\\"; else if (last == \\\"you\\\") now = \\\"are\\\"; else now = \\\"is\\\"; } cout << now << \\\" \\\"; last = now; } return 0; }\"]},\"742\":{\"h\":\"唱跳 RAP\",\"t\":[\"难度：主要考察桶的应用。\",\"利用桶统计每个数字出现的次数，然后根据每个数字出现的次数，计算选择方案即可。\",\"对于数字 i 出现次数为 T[i] 次，根据排列组合的逻辑 T[i] 个中取两个 数量次数为 T[i]-1+T[i]-2+T[i]-3+......1。利用高斯求和公式得出计算公式为 (T[i]-1+1)*(T[i]-1)/2 为数字 i 选取 2 个的次数，所有数字的次数和即为答案。\",\"#include <iostream> using namespace std; int n,m; int a[1005]; int T[105]; int main(){ cin>>n>>m; for(int i=1;i<=n;i++){ cin>>a[i]; T[a[i]]++; } for(int i=1;i<=m;i++){ int t; cin>>t; T[a[t]]--; } long long sum=0; for(int i=1;i<=100;i++){ if(T[i]>=2){ sum+=(T[i]-1+1)*(T[i]-1)/2; } } cout<<sum; }\"]},\"743\":{\"h\":\"语法周赛 Round 30 题解\"},\"744\":{\"h\":\"A. 粗心的 33DAI\",\"t\":[\"子任务 1：手算，输出 26\",\"子任务 2：输入五个 char，根据哪个是 1 决定输出及就好。\",\"子任务 3：输入五个 char，把 1 对应的权值相加即可。\",\"#include <bits/stdc++.h> using namespace std; char x; int ans; int main() { ans = 0; cin >> x; if (x == '1') ans += 16; cin >> x; if (x == '1') ans += 8; cin >> x; if (x == '1') ans += 4; cin >> x; if (x == '1') ans += 2; cin >> x; if (x == '1') ans += 1; cout << ans; return 0; }\"]},\"745\":{\"h\":\"B. A+B-C+D\",\"t\":[\"核心是输入到文件末尾，先输入一个整数，然后不停输入一个符号和一个数直到文件结尾。根据符号决定怎么计算即可。\",\"#include <bits/stdc++.h> using namespace std; int main() { long long ans, x; char op; cin >> ans; while (cin >> op >> x) { if (op == '-') ans -= x; if (op == '+') ans += x; } cout << ans; return 0; }\"]},\"746\":{\"h\":\"C. 二进制小数\",\"t\":[\"先学会怎么算小数的二进制转换。\",\"这题的精度直接用 double 类型读进来，然后每次乘以 2 取整得到每一位即可。如果位数要求更多，就需要用不损失精度的做法了。这里提供高精度的做法。\",\"#include <bits/stdc++.h> using namespace std; string s; int len, a[10]; int main() { cin >> s; len = (int)s.size() - 2; for (int i = 0; i < len; i++) a[i] = s[(int)s.size() - 1 - i] - '0'; cout << \\\"0.\\\"; for (int i = 1; i <= 9; i++) { for (int j = 0; j < len; j++) a[j] *= 2; for (int j = 0; j < len; j++) { a[j + 1] += a[j] / 10; a[j] %= 10; } cout << a[len]; a[len] = 0; } return 0; }\"]},\"747\":{\"h\":\"D. 争先红葫芦\",\"t\":[\"显然只要下一次会死，就不停使用，直到不会死或者用完了为止即可。子任务送了很多分。\",\"#include <bits/stdc++.h> using namespace std; int x, n, m; int a[105]; int main() { cin >> x >> n >> m; for (int i = 1; i <= m; i++) cin >> a[i]; int now = x; // 当前气血 int cnt = 0; // 用葫芦的次数 for (int i = 1; i <= m; i++) { while (now - a[i] <= 0) { if (cnt < n) { if (cnt == 0) now = x; else now = min(x, now + x / 3); cnt++; } else { cout << i; return 0; } } now -= a[i]; } cout << -1; return 0; }\"]},\"748\":{\"h\":\"挖土机周赛 Round 31（语法场）题解\"},\"749\":{\"h\":\"今年比赛有没有三等奖\"},\"750\":{\"h\":\"题解\",\"t\":[\"根据省一等奖分数线 是否大于等于全国基准线 。来确定是否有三等奖。\",\"如果有三等奖，那么就输出 ，否则输出 即可。\"]},\"751\":{\"h\":\"参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int a, b, c, x; int main() { cin >> a >> b >> c >> x; if (x >= a) cout << x << \\\" \\\" << b << \\\" \\\" << c << \\\"\\\\n\\\"; else cout << x << \\\" \\\" << c << \\\" \\\" << -1 << \\\"\\\\n\\\"; return 0; }\"]},\"752\":{\"h\":\"公差等差的等差数列们\"},\"753\":{\"h\":\"题解\",\"t\":[\"数据范围非常小，直接按照题意模拟即可。当然也可以在求每个等差数列的和的时候用等差数列求和公式。\",\"有兴趣的同学可以想想，假设 ，有没有更快的做法。以及 的时候有没有更快的做法。\"]},\"754\":{\"h\":\"参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n, m, a, d, dd; int main() { cin >> n >> m >> a >> d >> dd; int ans = 0; for (int i = 1; i <= n; i++) { int nowA = a + (i - 1) * d; int nowD = d + (i - 1) * dd; for (int j = 1; j <= m; j++) { int now = nowA + (j - 1) * nowD; ans += now; //cout << now << \\\" \\\"; } //cout << \\\"\\\\n\\\"; } cout << ans; return 0; }\"]},\"755\":{\"h\":\"有几个不重叠的三十三\"},\"756\":{\"h\":\"题解\",\"t\":[\"显然按顺序贪心即可，从前往后，发现了一个 33，就用着一个，就不会重叠了。\"]},\"757\":{\"h\":\"参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n; string s; int main() { cin >> n; cin >> s; int ans = 0; for (int i = 1; i <= n - 1; i++) if (s[i] == '3' && s[i - 1] == '3') { ans++; s[i] = s[i - 1] = '0'; } cout << ans; return 0; }\"]},\"758\":{\"h\":\"一道非常简单的排序题\"},\"759\":{\"h\":\"题解\",\"t\":[\"题目本身确实非常简单，就是排个序然后按照题意模拟即可。\",\"这题主要卡了一个没学好 sort 的同学，大家一定要注意 sort 的比较函数是用来代替小于号 < 的，必须是严格的偏序关系，否则 sort 判断相等和不等关系的时候会判断错，这在极端情况下会出现错误。最常见的极端情况就是有大量相等数据的时候。\",\"所以所有比较函数写 >= 的都被卡成了 分。\"]},\"760\":{\"h\":\"参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int seed, P; // 通过输入得到 int f(int id) { return 1LL * id * id % P * seed % P; } int n; int a[5123456]; int cmp(int a, int b) { return a > b; } int main() { cin >> n >> seed >> P; for (int i = 1; i <= n; i++) a[i] = f(i); sort(a + 1, a + n + 1, cmp); int ans = 0; for (int i = 1; i <= n; i++) ans = ans ^ (a[i] + i); cout << ans; return 0; }\"]},\"761\":{\"h\":\"挖土机周赛 Round 32（语法场）题解\",\"t\":[\"这场为了和 CSP-J 2024 标题一致，第三题没有特别严谨地做纯字符串题。\"]},\"762\":{\"h\":\"33DAI 的扑克牌\"},\"763\":{\"h\":\"题解\",\"t\":[\"作为语法周赛的第一题，不超纲的话那就下面的 if-else 处理最方便。\",\"更优雅的代码可以定义两个字符串 \\\"A23456789TJQK\\\" 和 \\\"DCHS\\\"，然后用循环找到下标来对应到具体的数字。\"]},\"764\":{\"h\":\"参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { char D1, D2, K1, K2; cin >> D1 >> D2 >> K1 >> K2; int d1, d2, k1, k2; if (D1 == 'D') d1 = 4; else if (D1 == 'C') d1 = 3; else if (D1 == 'H') d1 = 2; else if (D1 == 'S') d1 = 1; if (D2 == 'A') d2 = 1; else if (D2 == 'T') d2 = 10; else if (D2 == 'J') d2 = 11; else if (D2 == 'Q') d2 = 12; else if (D2 == 'K') d2 = 13; else d2 = D2 - '0'; if (K1 == 'D') k1 = 4; else if (K1 == 'C') k1 = 3; else if (K1 == 'H') k1 = 2; else if (K1 == 'S') k1 = 1; if (K2 == 'A') k2 = 1; else if (K2 == 'T') k2 = 10; else if (K2 == 'J') k2 = 11; else if (K2 == 'Q') k2 = 12; else if (K2 == 'K') k2 = 13; else k2 = K2 - '0'; if (d1 * 14 + d2 > k1 * 14 + k2) cout << \\\"33DAI\\\"; else cout << \\\"Kitten\\\"; return 0; }\"]},\"765\":{\"h\":\"33DAI 的地图探险\"},\"766\":{\"h\":\"题解\",\"t\":[\"首先因为 到了 ，所以显然不能真的把地图二维数组真的开出来。这题 ，所以直接模拟走 步就好。\",\"大家可以想一下，假如 该怎么做。\",\"显然此时不能模拟了，但很容易发现没有障碍物的时候整个路径分为两步\",\"走到边界：可以通过位置和方向 算出走到了边界的什么位置。\",\"在边界上绕圈：可以算算多少步回到起始位置，显然接下来对这个步数取余，即可找到对应位置了。\"]},\"767\":{\"h\":\"参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n, m, k; int x, y, d; int main() { cin >> n >> m >> k; cin >> x >> y >> d; for (int i = 1; i <= k; i++) { int xx = x, yy = y; if (d == 0) yy++; if (d == 1) xx++; if (d == 2) yy--; if (d == 3) xx--; if (1 <= xx && xx <= n && 1 <= yy && yy <= m) x = xx, y = yy; else d = (d + 1) % 4; } cout << x << \\\" \\\" << y << \\\"\\\\n\\\"; return 0; }\"]},\"768\":{\"h\":\"33DAI 的小木棍\"},\"769\":{\"h\":\"题解\",\"t\":[\"对比 CSP-J 2024 的 T3，这题没要求恰好，并且只能用一种数字，所以非常简单。\",\"先算算用不同的数字分别需要至少几位才够，然后找位数最少的，位数一样就找数字最小的即可。\"]},\"770\":{\"h\":\"参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int num[] = {6, 2, 5, 5, 4, 5, 6, 3, 7, 6}; int n; int a[10]; int main() { cin >> n; for (int i = 1; i <= 9; i++) a[i] = (n + (num[i] - 1)) / num[i]; int ans = 1; for (int i = 2; i <= 9; i++) if (a[i] < a[ans]) ans = i; for (int i = 1; i <= a[ans]; i++) cout << ans; return 0; }\"]},\"771\":{\"h\":\"33DAI 的接龙\"},\"772\":{\"h\":\"题解\",\"t\":[\"首先对于 ，我们这实际上告诉我们的是只要能变为 就可以变为 。\",\"有多同学一看到这个就以为要上并查集了，但要注意这实际上是单向边，所以不能直接来并查集。并查集有可能 到了同一个集合，但实际上方向是能从 变成 ，甚至可能是某个数可以变成 。不能保证 能到 。\",\"有同学可能会想到建个图然后 dfs，但显然作为语法周赛是朝纲的。\",\"实际上我们很容易用 vis[i] 记录能不能变为 i，然后写出下面这段代码，\",\"for (int j = 1; j <= n; j++) if (vis[a[j]]) vis[b[j]] = true;\",\"但容易发现，做一次肯定是不够的，那多做几次就好了。这个次数如果不想推可以给一个不超时的大数就好。实际上可以保证 轮就足够了。学过最短路的同学容易发现，这样是一个简化的 Bellman-Ford 算法。\"]},\"773\":{\"h\":\"参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n, s, e; int a[15], b[15]; bool vis[15]; int main() { cin >> n >> s >> e; for (int i = 1; i <= n; i++) cin >> a[i] >> b[i]; vis[s] = true; for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) if (vis[a[j]]) vis[b[j]] = true; if (vis[e]) cout << \\\"Yes\\\\n\\\"; else cout << \\\"No\\\\n\\\"; return 0; }\"]},\"774\":{\"h\":\"挖土机周赛 Round 33（语法场）题解\"},\"775\":{\"h\":\"33DAI 的决斗\"},\"776\":{\"h\":\"题解\",\"t\":[\"简单分类讨论即可。\"]},\"777\":{\"h\":\"参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { int a, b, c, x, y, z; cin >> a >> b >> c >> x >> y >> z; bool flag1, flag2; if (a > y && z - (a - y) <= 0) flag1 = true; else flag1 = false; if (x > b && c - (x - b) <= 0) flag2 = true; else flag2 = false; if (flag1 && flag2) cout << -1; else if (flag1) cout << 1; else if (flag2) cout << 2; else cout << 0; return 0; }\"]},\"778\":{\"h\":\"33DAI 的擂台游戏\"},\"779\":{\"h\":\"题解\",\"t\":[\"显然如果想要进入第二轮，就需要有 个人比自己实力低。如果想要进入第三轮，就额外再需要由 个人比自己实力低。如果想要进入第四轮，就额外再需要由 个人比自己实力低。\",\"而比 的实力低的选手共 位，由此就可以判断能进入到第几轮了。\",\"其实也就是 这样排布就可以让 尽可能进入到后面的比赛。\"]},\"780\":{\"h\":\"参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { int k, x; cin >> k >> x; int ans = 0; int cnt = 0; for (int i = 1;; i *= 2) { cnt += i; ans++; if (cnt >= x) { cout << min(k, ans); return 0; } } return 0; }\"]},\"781\":{\"h\":\"33DAI 的染色\"},\"782\":{\"h\":\"题解\",\"t\":[\"简单暴力双重循环可以拿到 分，但显然我们不需要枚举前面每个位置来找到最近的同色字符，只需要全局记录每种颜色的字符最新出现在哪儿即可。\"]},\"783\":{\"h\":\"参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n; string s; int last[30]; int main() { cin >> n; cin >> s; s = \\\"^\\\" + s + \\\"$\\\"; long long ans = 0; for (int i = 1; i <= n; i++) { ans += last[s[i] - 'a']; last[s[i] - 'a'] = i; } cout << ans; return 0; }\"]},\"784\":{\"h\":\"33DAI 的超速检测\"},\"785\":{\"h\":\"题解\",\"t\":[\"这个数据范围就是一个简单的模拟题。\"]},\"786\":{\"h\":\"参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; const int MAXN = 1000; int n, L; int s[MAXN + 5], e[MAXN + 5]; int main() { cin >> n >> L; for (int i = 1; i <= n; i++) cin >> s[i] >> e[i]; int ans = 0; for (int i = 0; i <= L; i++) { bool flag = true; for (int j = 1; j <= n; j++) if (i < s[j] || e[j] < i) { flag = false; break; } ans += flag; } cout << ans; return 0; }\"]},\"787\":{\"h\":\"挖土机周赛 Round 34（语法场）题解\"},\"788\":{\"h\":\"算出了几个i9\"},\"789\":{\"h\":\"题解\",\"t\":[\"鸡兔同笼现代版。\"]},\"790\":{\"h\":\"参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(0); // 8x + 6y = a // 16x + 8y = b // 4y = 2a-b int a, b; cin >> a >> b; int x, y; y = (2 * a - b) / 4; x = (a - 6 * y) / 8; cout << x << \\\" \\\" << y << \\\"\\\\n\\\"; return 0; }\"]},\"791\":{\"h\":\"分解了一个整数\"},\"792\":{\"h\":\"题解\",\"t\":[\"经典的质因数分解题，因为记得有同学不会，所以出一下。\",\"显然只需要从 开始依次检查每个数是否是因子即可，如果是因子，就不停消除掉当前因子，这样就能保证检查到的全都是质因子。\",\"需要注意不能做到 为止，而是最多只需要做当 就好了。\"]},\"793\":{\"h\":\"参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { ios::sync_with_stdio(false); cin.tie(0); int n; cin >> n; int nn = sqrt(n); for (int i = 2; i <= nn; i++) while (n % i == 0) { cout << i << \\\" \\\"; n /= i; } if (n != 1) cout << n; cout << \\\"\\\\n\\\"; return 0; }\"]},\"794\":{\"h\":\"压缩了一篇文章\"},\"795\":{\"h\":\"题解\",\"t\":[\"基础的字符串处理。遇到字母就继续记录下来，遇到其他字符就把前面的字母字符串输出即可。\"]},\"796\":{\"h\":\"参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; string s, t; int main() { ios::sync_with_stdio(false); cin.tie(0); getline(cin, s); t = \\\"\\\"; for (int i = 0; i < s.size(); i++) { if ('a' <= s[i] && s[i] <= 'z' || 'A' <= s[i] && s[i] <= 'Z') t += s[i]; else { if (t != \\\"\\\") { if (t.size() <= 2) cout << t; else cout << t[0] << t.size() - 2 << t[t.size() - 1]; } cout << s[i]; t = \\\"\\\"; } } if (t != \\\"\\\") { if (t.size() <= 2) cout << t; else cout << t[0] << t.size() - 2 << t[t.size() - 1]; } return 0; }\"]},\"797\":{\"h\":\"发放了多少硬币\"},\"798\":{\"h\":\"题解\",\"t\":[\"基础排序后，算出每个人的排名，对应的发奖即可。\"]},\"799\":{\"h\":\"参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n; int a[1005]; int rnk[1005]; bool cmp(int a, int b) { return a > b; } int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; sort(a + 1, a + n + 1, cmp); rnk[1] = 1; for (int i = 2; i <= n; i++) if (a[i] == a[i - 1]) rnk[i] = rnk[i - 1]; else rnk[i] = i; int ans = 0; for (int i = 1; i <= n; i++) { if (1 <= rnk[i] && rnk[i] <= 5) ans += 800; else if (6 <= rnk[i] && rnk[i] <= 15) ans += 400; else { ans += min(10, n - i + 1) * 200; break; } } cout << ans; return 0; }\"]},\"800\":{\"h\":\"挖土机周赛 Round 35（语法场）题解\"},\"801\":{\"h\":\"三次方或三的幂\",\"t\":[\"显然只有当 时 ，其他时候都有 \",\"#include <bits/stdc++.h> using namespace std; int main() { int n; cin >> n; if (n == 3) cout << \\\"No\\\"; else cout << \\\"Yes\\\"; return 0; }\"]},\"802\":{\"h\":\"几个子区间合法\",\"t\":[\"首先区间的端点必然在 ，直接双重循环枚举所有起点终点，然后等差数列求和来计算的话，显然只能拿到 分。\",\"满分做法的话有很多，可以直接枚举所有起点，然后用二分或者数学方法找终点。\",\"实际上直接暴力从前往后枚举终点，如果和超过 就停也是能满分的，这个做法时间复杂度不太好算，可以简单估算一下上限。起点为 时，不可能超过 $\\\\frac{n}{i} 项，所以时间复杂度显然小于 。即小于 。数学好一点容易直到实际上项数少得多，这里就不展开推了。\"]},\"803\":{\"h\":\"二分做法\",\"t\":[\"#include <bits/stdc++.h> #define int long long using namespace std; signed main() { int n, cnt; cin >> n; cnt = 0; for (int i = 0; i <= n; i++) { int l = i; int r = n; int j = n; while (l <= r) { int mid = (l + r) / 2; if ((i + mid) * (mid - i + 1) >= 2 * n) { j = mid; r = mid - 1; } else l = mid + 1; } if ((i + j) * (j - i + 1) == 2 * n) cnt++; } cout << cnt; return 0; }\"]},\"804\":{\"h\":\"枚举做法\",\"t\":[\"// 代码来自 jonnyyuan #include<bits/stdc++.h> #define int long long using namespace std; int n; int ans=0; signed main(){ cin>>n; for(int i=0;i<=n;i++){ int now=i; int sum=0; while(true){ sum+=now; now++; if(sum==n){ ans++; break; } if(sum>n){ break; } } } cout<<ans; }\"]},\"805\":{\"h\":\"字符串有几个洞\",\"t\":[\"其实唯一麻烦点是数清楚每个字符几个洞。\",\"#include <bits/stdc++.h> using namespace std; int num[256]; string t1 = \\\"ADOPQRabdeopq469\\\"; string t2 = \\\"Bg08\\\"; int main() { string s; cin >> s; for (int i = 0; i < 256; i++) num[i] = 0; for (int i = 0; i < t1.size(); i++) num[t1[i]] = 1; for (int i = 0; i < t2.size(); i++) num[t2[i]] = 2; int ans = 0; for (int i = 0; i < s.size(); i++) ans += num[s[i]]; cout << ans; return 0; }\"]},\"806\":{\"h\":\"切了又切的纸牌\",\"t\":[\"本来想要求翻转后放到末尾的，但是似乎有点过难了，所以就改成直接放到末尾了，但现在就太简单了。\",\"实际上不管做多少次，整个序列一定是环状意义上连续的，所以直接算出一共往后面放了 个数，那就直到最终序列的起点了。\",\"#include <bits/stdc++.h> using namespace std; int main() { long long n, a, b; cin >> n >> a >> b; long long pos = a * b % n + 1; for (int i = pos; i <= n; i++) cout << i << \\\" \\\"; for (int i = 1; i <= pos - 1; i++) cout << i << \\\" \\\"; return 0; }\"]},\"807\":{\"h\":\"语法周赛 Round 4 题解\"},\"808\":{\"h\":\"A.点外卖\"},\"809\":{\"h\":\"分析\",\"t\":[\"难度：简单分支语句\",\"子任务 1（30 分）：由于黄焖鸡米饭的价格没达到所有红包的使用要求，所以红包都用不了，直接输出 即可。\",\"子任务 2（30 分）：由于所有红包优惠的价格都一样，所以只需要判断能不能使用任何一个红包就好，即 n <= a1 || n <= a2 || n <= a3 成立就输出 n - b1，否则输出 n。\",\"子任务 3（40 分）：分别判断在三个红包的影响下，分别的最终价格是多少，然后挑选最低的输出即可。\"]},\"810\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { int n, a1, b1, a2, b2, a3, b3; int ans1, ans2, ans3; cin >> n; cin >> a1 >> b1; cin >> a2 >> b2; cin >> a3 >> b3; ans1 = ans2 = ans3 = n; if (n >= a1) ans1 -= b1; if (n >= a2) ans2 -= b2; if (n >= a3) ans3 -= b3; cout << min(ans1, min(ans2, ans3)) << \\\"\\\\n\\\"; return 0; }\"]},\"811\":{\"h\":\"B.优化代码\"},\"812\":{\"h\":\"分析\",\"t\":[\"核心在于三重循环的优化：\",\"for (long long i = 1; i <= n; i++) { for (long long j = 1; j <= i; j++) { long long now = 0; for (long long k = 1; k <= i; k++) if (k % 10 == 0) now += j; ans += now; } }\",\"难度：简单的数学、基础循环代码阅读理解\",\"子任务 1（30 分）：直接提交题面的代码即可，白送的 分。\",\"子任务 2（30 分）：最内层的循环中， 从 到 的枚举，当 为 的倍数时， 被增加了 。而 到 中， 的倍数有 个，所以整个内层循环可以优化成一句 now = (i / 10) * j;\",\"子任务 3（40 分）：优化完最内层循环后，在中间的循环里， 从 到 的枚举，每次循环都给 ans 增加了 (i / 10) * j。即 ans += (i / 10) * 1 + (i / 10) * 2 + ... + (i / 10) * i。提取一个公因式 (i / 10)，就可以优化为 ans += (i / 10) * (1 + 2 + ... + i)，使用等差数列求和公式，即可把内部两层循环优化为 ans += (i / 10) * ((1 + i) * i / 2)。\"]},\"813\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; long long n; long long ans; int main() { cin >> n; ans = 0; for (long long i = 1; i <= n; i++) ans += i / 10 * ((1 + i) * i / 2); cout << ans << \\\"\\\\n\\\"; return 0; }\"]},\"814\":{\"h\":\"C.unrank\"},\"815\":{\"h\":\"分析\",\"t\":[\"难度： 分只要会基础的字符串，暴力枚举即可。满分做法较多。\",\"子任务 1（30 分）：因为保证了 为 ，所以直接判断 个字符串有没有和第二行的那个字符串一样的即可。\",\"子任务 2（30 分）： 都小于等于 ，直接双重循环暴力枚举检查即可。\",\"子任务 3（40 分）：重点是判断第三行的每个字符串是否在第二行出现过。 \",\"可以把字符串当作一个 进制的整数处理，或者直接使用一个四维数组标记即可，这样的时间复杂度为 。\",\"学过 set 的同学可以直接用 set 标记，用一个 时间复杂度的代码完成该题。\",\"当然也可以把两行字符串分别排序，然后用双指针检查，此时时间复杂度的瓶颈为排序的 。\"]},\"816\":{\"h\":\"满分参考代码\",\"t\":[\"这里给出张昊宇同学的四维数组标记的做法。\",\"#include <bits/stdc++.h> using namespace std; int n,m,cnt=0; string a[50010],r; bool f[30][30][30][30]={}; int main() { cin>>n>>m; for(int i=1;i<=n;++i) { cin>>a[i]; int l=a[i].size(),c=4-l; for(int j=1;j<=c;j++) { a[i]+=(char)(96); } f[a[i][0]-96][a[i][1]-96][a[i][2]-96][a[i][3]-96]=true; } for(int i=1;i<=m;++i) { cin>>r; int l=r.size(),c=4-l; for(int j=1;j<=c;j++) { r+=(char)(96); } if(!f[r[0]-96][r[1]-96][r[2]-96][r[3]-96]) { cnt++; } } cout<<cnt; return 0; }\"]},\"817\":{\"h\":\"D.最大逆序对和\"},\"818\":{\"h\":\"分析\",\"t\":[\"难度：前两个子任务比较简单，满分需要用贪心的思想去分析判断，对于前期同学一定难度。\",\"子任务 1（30 分）：由于保证了整体逆序，所以直接输入前两个数，输出他们的和即可。也就是说，你提交一个 问题的代码就能拿到 分。\",\"子任务 2（30 分）：因为 ，所以直接 枚举所有逆序对即可。但如果想要拿到 分，你需要判断当前是子任务 还是子任务 。\",\"子任务 3（40 分）：考虑枚举逆序对中靠后的那个第二个数 ，显然对应的前一个数 必须满足 并且 。考虑到我们需要找到最大的逆序对和，显然贪心选择 中最大的数来和 对比肯定是最好的。维护一下这个前缀最大值就可以 完成该题了。\"]},\"819\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n; int a[112345]; int main() { ios::sync_with_stdio(false); cin.tie(0); cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; int ans = 0; int maxAi = a[1]; for (int i = 2; i <= n; i++) { if (a[i] < maxAi) ans = max(ans, a[i] + maxAi); else maxAi = a[i]; } cout << ans << \\\"\\\\n\\\"; return 0; }\"]},\"820\":{\"h\":\"语法周赛 Round 5 题解\"},\"821\":{\"h\":\"A.起床时间\"},\"822\":{\"h\":\"分析\",\"t\":[\"难度：简单数学题\",\"子任务 1（30 分）：由于 ，所以直接输出 和 就好。\",\"子任务 2（30 分）：由于是刚好减去一个小时，所以直接输出 和 就好。\",\"子任务 3（40 分）：有多种做法。 \",\"做法 1：可以直接模拟时间变化，先把分钟数 减去 ，然后只要分钟数小于 ，就给小时数减少 ，分钟数加上 。由于 ，所以这个过程最多执行两次就可以，重复两次 if 语句判断即可。\",\"做法 2：我自己的习惯是先把“小时:分钟”的时间描述法转换为只有分钟的，即“小时数 分钟数” 这么多分钟。这样在同一天内就可以直接减去 ，再转回去即可。\"]},\"823\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { int h, m, x; cin >> h >> m >> x; int ans = h * 60 + m - x; cout << ans / 60 << \\\" \\\" << ans % 60 << \\\"\\\\n\\\"; return 0; }\"]},\"824\":{\"h\":\"B.联合 ChatGPT\"},\"825\":{\"h\":\"分析\",\"t\":[\"难度：简单的条件判断与求和\",\"子任务 1（30 分）：因为只有一道题，所以直接输出 中的较大值就好。\",\"子任务 2（30 分）：因为保证了 所以直接输出所有 之和就好，简单的循环输入与求和。\",\"子任务 3（40 分）：在子任务 2 的基础上，加上判断 哪个高算哪个就好。需要最后的答案可以达到 是超过了 int 的，需要使用 long long。\"]},\"826\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { int n, a, b; cin >> n; long long ans = 0; for (int i = 1; i <= n; i++) { cin >> a >> b; ans += max(a, b); } cout << ans << \\\"\\\\n\\\"; return 0; }\"]},\"827\":{\"h\":\"C.摩斯电码数数\"},\"828\":{\"h\":\"分析\",\"t\":[\"难度：简单的字符串枚举，主要给大家提醒了一下转义符的使用。\",\"子任务 1（30 分）：因为保证了不包含 \\\\ 所以只有一个单词，只需要输出 即可。\",\"子任务 2（30 分）：因为保证了编码长度为 ，所以答案就是 (s.size()+1)/6。\",\"子任务 3（40 分）：单词数就是 \\\\ 数量加一。记住反斜杠本身也是个特殊字符，需要用转义模式 '\\\\\\\\' 表示即可。\"]},\"829\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { string s; int ans = 0; cin >> s; for (int i = 0; i < s.size(); i++) if (s[i] == '\\\\\\\\') ans++; cout << ans + 1 << \\\"\\\\n\\\"; return 0; }\"]},\"830\":{\"h\":\"D.校门外好多树\"},\"831\":{\"h\":\"分析\",\"t\":[\"难度：数组综合应用。\",\"子任务 1（30 分）：因为 ，所以在完成了基础的暴力枚举标记所有有数的位置后，就是一个弱化版的“最长平台”问题，有几段树答案就是几。统计多少个位置有树且前一个位置没树即可（第一个位置特殊判断）。\",\"子任务 2（30 分）：每次不再是区间修改而是单点修改了。给没学过循环嵌套的同学送点分，但其实意义不大。\",\"子任务 3（40 分）：如果是数据范围更大，就需要使用差分的方式处理。但是数据范围这么小，直接暴力标记每个位置有没有树即可。标记完后，问题就变成了判断有几段树的数量达到了 。\"]},\"832\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int L, M, x; bool a[5005]; int main() { cin >> L >> M >> x; // 一开始认为所有位置都有树 for (int i = 0; i <= L; i++) a[i] = true; // 把建地铁的位置的树都拔掉 for (int i = 1; i <= M; i++) { int l, r; cin >> l >> r; for (int j = l; j <= r; j++) a[j] = false; } // 从前往后，找整段的树 int now = 0; // 当前段的树的棵数 int ans = 0; // 记录有几段树的长度达到了 x for (int i = 0; i <= L; i++) { if (a[i] == true) now++; else { if (now >= x) ans++; now = 0; } } // 有可能出现一段树，需要特殊处理 if (now >= x) ans++; cout << ans << \\\"\\\\n\\\"; return 0; }\"]},\"833\":{\"h\":\"语法周赛 Round 6 题解\"},\"834\":{\"h\":\"A.桃园南路上的红绿灯\"},\"835\":{\"h\":\"分析\",\"t\":[\"难度：知道数学中周期的概念，然后简单条件判断即可。如果实在搞不清楚的，也可以直接用循环模拟处理。\",\"子任务 1（30 分）：只有红灯，输出 red 就好。\",\"子任务 2（30 分）：没有黄灯，只有红灯和绿灯，每个周期只有两种颜色了，处理起来会方便一点（其实也差不多）。\",\"子任务 3（40 分）：循环模拟的做法略，第一题咱不考虑高阶语法的做法。首先可以算出每个周期的长度 。这题主要目的就是给大家强化从 开始和从 开始的区别。可以先把 分钟通过减 转换到 ，然后通过 就可以得到第一个周期的结果，然后再加 就可以从 转换回 了。当然也可以一开始就给 减少 ，然后每个灯的时间看成 是红灯、 是黄灯，以此类推。\"]},\"836\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { int x, y, z, q; cin >> x >> y >> z >> q; int t = x + y + z + y; q = (q - 1) % t + 1; if (q <= x) cout << \\\"red\\\"; else if (q <= x + y) cout << \\\"yellow\\\"; else if (q <= x + y + z) cout << \\\"green\\\"; else cout << \\\"yellow\\\"; return 0; }\"]},\"837\":{\"h\":\"B.不太随机的随机数列\"},\"838\":{\"h\":\"分析\",\"t\":[\"难度：打表找规律！\",\"子任务 1（30 分）： 非常小，把死循环改成循环执行 次，然后只在第 次输出即可。\",\"子任务 2（30 分）：虽然 很大，但是这里是等于号，也就是告诉了大家测试点的输入，所以不需要实时算出这一项，自己在本地跑出来结果后，当 时直接输出答案就好。\",\"子任务 3（40 分）：子任务 2 主要就是提醒大家可以本地打表，如果你执行上面的代码输出前 项，很容易发现中间会出现循环的结果。前两项分别是 和 ，第 项是 而第 项也是 ，所以 是一个周期，周期长度为 。去掉前两项之后的 项就是每 个数是一样的，直接按照类似于第一题的方式处理即可。这样能把数据缩小到 以内，直接用子任务 1 的方式处理即可。\"]},\"839\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; // 1:33 2:157 3:184 ... 30:76 31:184 const int t = 30 - 3 + 1; int main() { long long x; cin >> x; assert(1LL <= x && x <= 1'000'000'000'000LL); if (x > 2) { long long partA = 2; long long partB = x - 2; partB = (partB - 1) % t + 1; x = partA + partB; } int seed = 33; for (int i = 1; i <= x; i++) { if (i == x) cout << seed << '\\\\n'; seed = seed * seed % 233; } return 0; }\"]},\"840\":{\"h\":\"C.假装在洗一副扑克牌\"},\"841\":{\"h\":\"分析\",\"t\":[\"难度：简单的字符串处理\",\"子任务 1（30 分）：只有一张牌，原样输出即可。\",\"子任务 2（30 分）：没有 10，那就是逆序输出字符串。\",\"子任务 3（40 分）：逆序输出时遇到 01 就输出 10 即可。下面给出常规做法之外，另外再给出一个有趣的递归形式。\"]},\"842\":{\"h\":\"满分参考代码\",\"t\":[\"在遇到 s.size()-1 的形式时大家需要注意，s.size() 的返回值是无符号整型，所以当字符串为空、s.size() 为 0 时，减一就会变成无符号整型的最大值。所以建议如果要减 就习惯性改成 int 后再处理。（当然这题的字符串长度保证大于等于 ，所以倒也无所谓了）\"]},\"843\":{\"h\":\"李知颖的满分代码\",\"t\":[\"#include<iostream> using namespace std; string a; int n; int main() { cin>>a; n=a.size(); for(int i=n-1;i>=0;i--) { if(a[i]=='0'&&a[i-1]=='1') { cout<<10; i--; } else cout<<a[i]; } return 0; }\"]},\"844\":{\"h\":\"有趣的递归形式实现逆序输出\",\"t\":[\"#include <bits/stdc++.h> using namespace std; string s; void f(int l, int r) { if (l > r) return; if (s[l] == '1') { f(l + 2, r); cout << \\\"10\\\"; } else { f(l + 1, r); cout << s[l]; } } int main() { cin >> s; f(0, (int)s.size() - 1); return 0; }\"]},\"845\":{\"h\":\"D.可持久化入门之数对\"},\"846\":{\"h\":\"分析\",\"t\":[\"难度：主要难度在于读题，读题搞定后，就是一个简单的模拟题了。\",\"子任务 1（30 分）：因为只有操作 2，没有修改，所以每个版本的两个数都一样。每次询问时根据 来决定输出 还是 即可。\",\"子任务 2（30 分）：因为操作的数只有第一个数，所以就是个一维数组的模拟了。每次先 a[i] = a[vi]; 复制一份，然后看看是改还是输出就好。\",\"子任务 3（40 分）：在子任务 2 的基础上，从维护一个数改成维护两个数就好。每次操作前先复制一份，然后处理当前数对即可。\"]},\"847\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int M; int a[105][3]; int main() { cin >> M; cin >> a[0][1] >> a[0][2]; for (int i = 1; i <= M; i++) { int v, op, loc, val; cin >> v >> op; a[i][1] = a[v][1]; a[i][2] = a[v][2]; if (op == 1) { cin >> loc >> val; a[i][loc] = val; } if (op == 2) { cin >> loc; cout << a[i][loc] << \\\"\\\\n\\\"; } } return 0; }\"]},\"848\":{\"h\":\"语法周赛 Round 7 题解\"},\"849\":{\"h\":\"A.难or易？\"},\"850\":{\"h\":\"分析\",\"t\":[\"难度：简单的条件判断语句\",\"子任务 1（30 分）：保证了 ，直接输出 normal 就好。\",\"子任务 2（30 分）：保证了 是奇数，只需要判断是否小于 就可以知道该输出什么。\",\"子任务 3（40 分）：基础的条件判断语句，可以用三个分支，也可以嵌套一层。\"]},\"851\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { int n; cin >> n; if (n < 5) cout << \\\"normal\\\"; else if (n % 2 == 1) cout << \\\"easy\\\"; else cout << \\\"difficult\\\"; return 0; }\"]},\"852\":{\"h\":\"B.好or坏？\"},\"853\":{\"h\":\"分析\",\"t\":[\"难度：循环数位分解基础题\",\"子任务 1（30 分）：保证了 是一个一位数，变成了简单的条件判断的题目，只需要根据是否为 就可以算出具体的数。\",\"子任务 2（30 分）：保证了 是一个四位数，不需要循环数位分解。直接取个十百千位即可。\",\"子任务 3（40 分）：在基础的数位分解的循环基础上配合上计数即可。\"]},\"854\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { int n; cin >> n; int cnt3 = 0; int cntE = 0; while (n > 0) { if (n % 10 == 3) cnt3++; else cntE++; n /= 10; } if (cnt3 > cntE) cout << \\\"good\\\"; else cout << \\\"bad\\\"; return 0; }\"]},\"855\":{\"h\":\"C.读or过\"},\"856\":{\"h\":\"分析\",\"t\":[\"难度：用字符串存储高精度数并进行操作。\",\"子任务 1（30 分）：保证了 在 int 范围内。只需要按照第二题的做法来循环数位分解即可。\",\"子任务 2（30 分）：整型没法存储那么大的数，所以需要用字符串存储。这个子任务保证了没有 ，只需要判断是否是 的倍数即可。按照提示，如果一个数的所有数位之和为 的倍数，那么它就是 的倍数。所以只需要计算 位的字符串的所有数字字符对应的数字之和是否是 的倍数即可。\",\"子任务 3（40 分）：在做子任务 2 的基础上，顺带看看有没有哪个数位是 就好。\"]},\"857\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { string s; cin >> s; bool flag = true; // 读 int sum = 0; for (int i = 0; i < s.size(); i++) if (s[i] == '3') { flag = false; break; } else sum += s[i] - '0'; if (sum % 3 == 0) flag = false; if (flag) cout << s; else cout << \\\"guo\\\"; return 0; }\"]},\"858\":{\"h\":\"D.缺or满？\"},\"859\":{\"h\":\"分析\",\"t\":[\"难度：简单的贪心模拟\",\"做法：显然只要把都加到水最多的水杯的水量即可。即找到所有数的最大值，然后求“每个数与最大值的差”之和即可。\",\"子任务 1（30 分）：第一个数就是最大值，方便了很多，不用数组直接循环也可以。\",\"子任务 2（30 分）：最后一个数才是最大值，用数组存储后直接求“每个数与最后一个数的差”之和即可。\",\"子任务 3（40 分）：正常数组存储，然后找到最大值，再求“每个数与最大值的差”之和即可。\",\"不用数组的做法：如果不允许用数组的话，在找到最大值后就不能回过头去看每个数了。此时可以在枚举输入时直接算出每个水杯灌到 水量需要多少水，然后减去最大值和 的差乘以 即可。\"]},\"860\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n; int a[1005]; int main() { cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; int maxAi = a[1]; for (int i = 1; i <= n; i++) maxAi = max(maxAi, a[i]); int ans = 0; for (int i = 1; i <= n; i++) ans += maxAi - a[i]; cout << ans; return 0; }\"]},\"861\":{\"h\":\"语法周赛 Round 8 题解\"},\"862\":{\"h\":\"A.红色警戒\"},\"863\":{\"h\":\"分析\",\"t\":[\"难度：主要难点在于读题\",\"子任务 1（30 分）：由于所有桥的耐久度都相同，所以炸掉谁都一样，本来直接输出任何一座桥的耐久度都可以，但要注意耐久度为 也要一辆卡车，所以至少要输出 。\",\"子任务 2（30 分）：此时保证了数据从小到大排序，所以第一座桥的耐久度是最低的，输出 即可。\",\"子任务 3（40 分）：此时要找到九座桥的最小值，再来按照前面的做法即可。\"]},\"864\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { int a, ans; ans = 1001; cin >> a; if (a < ans) ans = a; cin >> a; if (a < ans) ans = a; cin >> a; if (a < ans) ans = a; cin >> a; if (a < ans) ans = a; cin >> a; if (a < ans) ans = a; cin >> a; if (a < ans) ans = a; cin >> a; if (a < ans) ans = a; cin >> a; if (a < ans) ans = a; cin >> a; if (a < ans) ans = a; if(ans == 0) ans = 1; cout << ans; return 0; }\"]},\"865\":{\"h\":\"B.有趣的&运算\"},\"866\":{\"h\":\"分析\",\"t\":[\"难度：需要一些数学思维，要能推理出只要拆开了就只会让结果变大或者保持不变，因此答案就是只分为一个区间 [1,n]，所有数进行与运算的结果。\",\"子任务 1（30 分）：只有两个数，答案只有两种情况： 或者 ，输出其中较小的即可。\",\"子任务 2（30 分）： 非常小，可以暴力枚举所有的划分方案，但实际上暴力枚举所有划分方案的代码挺难写。\",\"子任务 3（40 分）：求所有数进行与运算的结果，需要注意和求和的初始化为 不同，与运算的初始化比较复杂。你可以初始化为第一个数或者初始化为补码为全 的 。\"]},\"867\":{\"h\":\"满分参考代码\"},\"868\":{\"h\":\"做法 1\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { int n, ai, ans; cin >> n; for (int i = 1; i <= n; i++) { cin >> ai; if (i == 1) ans = ai; else ans = ans & ai; } cout << ans; return 0; }\"]},\"869\":{\"h\":\"做法 2\",\"t\":[\"利用 的补码为全 的特性，初始化为全 即可算出与运算之和。\",\"#include <bits/stdc++.h> using namespace std; int main() { int n, ai, ans; cin >> n; ans = -1; for (int i = 1; i <= n; i++) { cin >> ai; ans = ans & ai; } cout << ans; return 0; }\"]},\"870\":{\"h\":\"C.比赛的获奖规则\"},\"871\":{\"h\":\"分析\",\"t\":[\"难度：结构体排序的模拟题\",\"子任务 1（30 分）：此时省去了排序的步骤，可以先算出有效队伍数量，然后算出需要输出的排名，最后输出对应的排名即可。\",\"子任务 2（30 分）：最后输出的就是排在前面金牌区的选手，耐心写完排序后会简单很多。\",\"子任务 3（40 分）：题目怎么说的就怎么排序就好，我的代码中有一些特殊处理，我把打星队伍的排名挪到了最低，这样最后输出某个排名区间的队伍会方便一点。\"]},\"872\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n; struct Team { string school, team; int solved, tim; bool flag; // 是否打星 }; Team a[200000 + 5]; bool cmp(Team x, Team y) { if (x.flag == false && y.flag == false) return x.school < y.school; if (x.flag == false || y.flag == false) return x.flag > y.flag; if (x.solved != y.solved) return x.solved > y.solved; return x.tim < y.tim; } int main() { cin >> n; int A = 0, J, Y, T; for (int i = 1; i <= n; i++) { cin >> a[i].school >> a[i].team >> a[i].solved >> a[i].tim; a[i].flag = (a[i].solved > 0) && (a[i].team.back() != '*'); A += a[i].flag; } J = A * 10 / 100 + (A * 10 % 100 > 0); Y = A * 30 / 100 + (A * 30 % 100 > 0) - J; T = A * 60 / 100 + (A * 60 % 100 > 0) - Y - J; sort(a + 1, a + n + 1, cmp); string s; cin >> s; int l, r; if (s == \\\"gold\\\") l = 1, r = J; else if (s == \\\"silver\\\") l = J + 1, r = J + Y; else l = J + Y + 1, r = J + Y + T; cout << (r - l + 1) << \\\"\\\\n\\\"; for (int i = l; i <= r; i++) cout << a[i].school << \\\" \\\" << a[i].team << \\\" \\\" << a[i].solved << \\\" \\\" << a[i].tim << \\\"\\\\n\\\"; return 0; }\"]},\"873\":{\"h\":\"D.真的是毒瘤题吗？\"},\"874\":{\"h\":\"分析\",\"t\":[\"难度：比较麻烦的二维数组上的模拟，满分需要一个小技巧，求出初始值后每次只修改变动带来的影响。\",\"子任务 1（30 分）：只有操作 ，整个数组没有修改过，按照题目模拟求出所有单词出现的次数即可。\",\"子任务 2（30 分）：数据范围很小，可以纯枚举做所有操作。\",\"子任务 3（40 分）：数据范围比较大，每次查询不能纯暴力枚举了。当算出了初始的所有单词以及对应的出现次数后，容易发现每次只修改了一个位置，因此最多影响了和这个位置有关的单词。可以先去掉之前所有相关的单词，然后新增新产生的单词即可。这里我没有偷懒使用 map 存所有单词出现次数，而是直接采用了一个四维数组。然后我写了挺多辅助函数，来让我的主函数更简洁。当时间复杂度没有问题的时候，我建议同学们也可以采用这样的方法，不用图快，把每一块做清楚能省掉更多调试的时间。\"]},\"875\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n, m; char g[305][305]; int cnt[30][30][30][30]; int dx[] = {0, 1, 0, 1}; int dy[] = {0, 0, 1, 1}; // 行数、列数、方向（竖1、横2、右下斜着3）、长度 string getS(int x, int y, int fx, int len) { if (x < 1 || y < 1) return \\\"\\\"; if (fx == 1 && x + len - 1 > n) return \\\"\\\"; if (fx == 2 && y + len - 1 > m) return \\\"\\\"; if (fx == 3 && (x + len - 1 > n || y + len - 1 > m)) return \\\"\\\"; string res = \\\"\\\"; for (int i = 0; i < len; i++) { res += g[x][y]; x += dx[fx]; y += dy[fx]; } return res; } // s 的出现次数加上 num void cal(string s, int num) { int a[4] = {0, 0, 0, 0}; for (int i = 0; i < s.size(); i++) a[i] = s[i] - 'a' + 1; cnt[a[0]][a[1]][a[2]][a[3]] += num; } // 返回 s 的出现次数 int getCnt(string s) { int a[4] = {0, 0, 0, 0}; for (int i = 0; i < s.size(); i++) a[i] = s[i] - 'a' + 1; return cnt[a[0]][a[1]][a[2]][a[3]]; } // 把 (x,y) 相关的单词数量增加 t void change(int x, int y, int t) { for (int len = 1; len <= 4; len++) { cal(getS(x, y, 1, len), t); cal(getS(x, y, 2, len), t); cal(getS(x, y, 3, len), t); } for (int len = 2; len <= 4; len++) { cal(getS(x - 1, y, 1, len), t); cal(getS(x, y - 1, 2, len), t); cal(getS(x - 1, y - 1, 3, len), t); } for (int len = 3; len <= 4; len++) { cal(getS(x - 2, y, 1, len), t); cal(getS(x, y - 2, 2, len), t); cal(getS(x - 2, y - 2, 3, len), t); } for (int len = 4; len <= 4; len++) { cal(getS(x - 3, y, 1, len), t); cal(getS(x, y - 3, 2, len), t); cal(getS(x - 3, y - 3, 3, len), t); } } int main() { cin >> n >> m; for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) cin >> g[i][j]; for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) for (int len = 1; len <= 4; len++) { cal(getS(i, j, 1, len), 1); cal(getS(i, j, 2, len), 1); cal(getS(i, j, 3, len), 1); } int q; cin >> q; while (q--) { int op; cin >> op; if (op == 1) { int x, y; char c; cin >> x >> y >> c; change(x, y, -1); g[x][y] = c; change(x, y, 1); } if (op == 2) { string s; cin >> s; cout << getCnt(s) << \\\"\\\\n\\\"; } } return 0; }\"]},\"876\":{\"h\":\"语法周赛 Round 9 题解\"},\"877\":{\"h\":\"A.王老师的新水杯\"},\"878\":{\"h\":\"分析\",\"t\":[\"难度：简单数学计算\",\"子任务 1（30 分）：由于两种方式的喝水量相同，上下限相等，输出 即可。\",\"子任务 2（30 分）：保证了 ，因此上限为 ，下限为 ，直接输出 即可。需要注意数据范围，需要使用 long long 类型记录答案。\",\"子任务 3（40 分）：此时 的大小不一定，加一个判断分别处理即可。\"]},\"879\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { int n, x, y; cin >> n >> x >> y; if (x > y) { cout << (long long)n * (x - y); } else { cout << (long long)n * (y - x); } return 0; }\"]},\"880\":{\"h\":\"B.代老师骑行健身\"},\"881\":{\"h\":\"分析\",\"t\":[\"难度：循环、求和、高级循环控制（break/continue）\",\"子任务 1（30 分）：保证了刚好骑了三天，可以用三个 if 分别判断 、 或 是否大于等于 。\",\"子任务 2（30 分）：保证了 ，所以必然是第 天达到了 千米。\",\"子任务 3（40 分）：在循环的过程中对输入的变量求和，当总和达到 时输出天数并停止循环即可。\"]},\"882\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { int n, ai, sum; cin >> n; sum = 0; for (int i = 1; i <= n; i++) { cin >> ai; sum += ai; if (sum >= 100) { cout << i; break; } } return 0; }\"]},\"883\":{\"h\":\"C.数数放了几天假\"},\"884\":{\"h\":\"分析\",\"t\":[\"难度：简单字符串题\",\"子任务 1（30 分）：字符串中仅包含 .，每天都放假，一共上了 天班，输出 即可。\",\"子任务 2（30 分）：由于不好办 ~，只需要计算 o 的数量即可。\",\"子任务 3（40 分）：可以用 double 类型计算结果。更建议尽可能避免浮点数运算，分别统计半天和整天上班的数量，最后计算结果。\"]},\"885\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { int n; string s; cin >> n; cin >> s; int one = 0; int half = 0; for (int i = 0; i < n; i++) { if (s[i] == 'o') one++; if (s[i] == '~') half++; } one += half / 2; half %= 2; cout << one; if (half == 1) cout << \\\".5\\\"; return 0; }\"]},\"886\":{\"h\":\"D.再整理一次水杯\"},\"887\":{\"h\":\"分析\",\"t\":[\"和 Round 7 的 “D. 缺or满？” 几乎一样，不同的是这次只能倒掉了，因此把所有水杯的水量倒成最少的水量即可。\",\"难度：数组、求最值、求和\",\"子任务 1（30 分）：保证了最后一项为最小值，不需要额外求一遍最小值了。\",\"子任务 2（30 分）：保证了第一项为最小值，不需要额外求一遍最小值了。\",\"子任务 3（40 分）：正常求出最小值后，求出“每个数和最小值的差”之和即可。\"]},\"888\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n; int a[1005]; int main() { cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; int minAi = a[1]; for (int i = 1; i <= n; i++) minAi = min(minAi, a[i]); int ans = 0; for (int i = 1; i <= n; i++) ans += a[i] - minAi; cout << ans; return 0; }\"]},\"889\":{\"h\":\"新春算法马拉松比赛\"},\"890\":{\"h\":\"A.A乘B小于C吗\"},\"891\":{\"h\":\"分析\",\"t\":[\"难度：简单条件判断语句\",\"子任务 1（30 分）：因为 为 ，现在只需要比较 和 的大小关系了。\",\"子任务 2（30 分）：因为 ，所以答案从三个变成两个了，更简单一点了。但这意义不大，这个子任务最大的作用是隐含的 ，即只需要用 int 处理就好。\",\"子任务 3（40 分）：需要注意 是有可能超过 int 的，所以需要用 long long。当然也可以先判断 与 的关系，来规避这个问题，但是细节需要注意。\"]},\"892\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { int a, b, c; cin >> a >> b >> c; long long ans = (long long)a * b; if (ans < c) cout << '<'; else if (ans == c) cout << '='; else if (ans > c) cout << '>'; return 0; }\"]},\"893\":{\"h\":\"B.jonny 办比赛\"},\"894\":{\"h\":\"分析\",\"t\":[\"难度：基础求和算法\",\"子任务 1（30 分）：只有一个人，这个人考多少分就收多少报名费就好。\",\"子任务 2（30 分）：每个人的得分在 以内，不会超 int 了。（33DAI 一直在提醒大家要注意算数据范围）\",\"子任务 3（40 分）：求和后，算平均数上取整即可。\"]},\"895\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int main() { int n, ai; cin >> n; long long sum = 0; for (int i = 1; i <= n; i++) { cin >> ai; sum += ai; } cout << sum / n + (sum % n > 0); return 0; }\"]},\"896\":{\"h\":\"C.分帽子\"},\"897\":{\"h\":\"分析\",\"t\":[\"难度：数组综合运用。\",\"子任务 1（30 分）：，可以使用 的做法通过。可以直接枚举所有数对，遇到一样的颜色就答案加一，然后把两个颜色改为非法颜色 -1 就好（后续判断遇到 -1 就跳过）。\",\"子任务 2（30 分）：，可以直接开计数数组（或者有的同学学到的桶、或者叫做权值数组），计算每个颜色有几顶帽子。所有颜色的帽子数整除以 再求和就好。\",\"子任务 3（40 分）：这里不能再开计数数组了。可以通过 map<int,int> 处理。也可以直接对所有帽子排序，这样所有相同颜色的帽子就排到一起了。从前往后枚举计数就好。\"]},\"898\":{\"h\":\"满分参考代码\",\"t\":[\"#include <bits/stdc++.h> using namespace std; int n, ans; int a[112345]; int main() { cin >> n; for (int i = 1; i <= n; i++) cin >> a[i]; sort(a + 1, a + n + 1); for (int i = 1; i + 1 <= n;) { if (a[i] == a[i + 1]) { ans++; i += 2; } else { i += 1; } } cout << ans; return 0; }\"]},\"899\":{\"h\":\"D.TooY0ung的16位内存系统\"},\"900\":{\"h\":\"分析\",\"t\":[\"首先这题的数据范围给的是十六进制，比较不好估算规模。一个比较关键的数据规模是：，即已分配的块的范围最多是这么多，并且每次访问的也最多是这些位置。\",\"很容易想到直接暴力给所有已分配的块标记上，然后读写的地址看看是否被标记过了就好。唯一的难点只在十六进制的转换上了。\",\"有同学可能会想在极限数据下， 次，每次最多 的标记会不会超时呢？实际上是完全不会的，不同于“校门外的树”之类的区间覆盖题目，这题保证了分配时数据保证不会有重合，所以 次分配块的标记加在一起也不超过 次标记。\",\"难度：进制转换，暴力枚举。\",\"20 分：其实没太看懂这 分给的是啥分数。最终得分也只有 和 两种。 从 降到 感觉意义不大。\"]},\"901\":{\"h\":\"满分参考代码\"},\"902\":{\"h\":\"TooY0ung 的代码\",\"t\":[\"#include<bits/stdc++.h> using namespace std; int helper(char a) { if(a>='A') { return a-'A'+10; } return a-'0'; } int a[100010]; int main() { int n,q; cin>>n>>q; for(int i=1;i<=n;i++) { string s1,s2; cin>>s1>>s2; int l=0,r=0; for(int i=3;i>=0;i--) { l+=helper(s1[i])*(1<<(4*(3-i))); } for(int i=3;i>=0;i--) { r+=helper(s2[i])*(1<<(4*(3-i))); } for(int i=l;i<=r;i++) { a[i]=1; } } while(q--) { string s; cin>>s; int t=0; for(int i=3;i>=0;i--) { t+=helper(s[i])*pow(16,(3-i)); } if(!a[t]) { cout<<\\\"RE\\\"<< endl; return 0; } } cout<<\\\"AC\\\"<<endl; return 0; }\"]},\"903\":{\"h\":\"E.TooY0ung的数学简单题\"},\"904\":{\"h\":\"分析\",\"t\":[\"首先需要了解关于同余的基础知识，为了方便理解这里我用 C++ 的语法来描述。\",\"假设这题需要找到的两个数分别为 ，那么显然需要 。\",\"单看这个式子有点不太好找到突破口，显然上面式子意味着 。问题就转换成了找到一个 ，使得它除以 的余数等于之前某个小于 的 除以 的余数。\",\"因此可以从小到大枚举数列中的每个数，依次算出来除以 的余数，然后检查之前是否出现过即可。假设第 个数除以 的余数为 ，很容易得到递推式 \",\"还有另一种思路，由于最终的差一定是 这样的模式，即 。容易发现前面的一串 不可能提供因子 和 。所以可以把 的因子 剔除，得到最终差末尾几个 ，这样就只需要枚举前面的几个 能达成 剩余部分的倍数了。\",\"难度：难点主要在数学，需要一些基础的数学同余的概念。\",\"10 分：此时 在 以内，所以余数最大范围是 。数列最多前 项就必然出现余数相同的项。只需要算出数列前 项除以 的余数，然后 枚举找到是哪两个数即可。\",\"100 分：可以使用 记录上一次出现余数 是数列的第几项。这样就能 判断当前项的余数是否出现过了。最多 次的循环就能找到答案了。\"]},\"905\":{\"h\":\"满分参考代码\"},\"906\":{\"h\":\"TooY0ung 的代码\",\"t\":[\"#include<bits/stdc++.h> using namespace std; int m,vis[10000010],res; int main() { //ios::sync_with_stdio(false);cin.tie(0);cout.tie(0); cin>>m; for(int i=1;;i++) { res=(res*10+5)%m; if(vis[res]) { for(int j=i;j>vis[res];j--) cout<<'5'; for(int j=vis[res];j>=1;j--) cout<<'0'; return 0; } vis[res]=i; } return 0; }\"]},\"907\":{\"h\":\"王彬铸的代码\",\"t\":[\"这就是题解部分说的先剔除因子 来找到答案后面有几个 再来处理的做法。\",\"#include <bits/stdc++.h> using namespace std; typedef long long int LL; int main(){ LL t,x,i,n=1,m,zero=0; cin >> m; while(m%10==0){ m /= 10; zero++; } while(m%2==0){ m /= 2; zero++; } x = t = 50 % m; for(n=1 ; t ; n++){ x = x * 10 % m; t = (t+x) % m; } for(i=1 ; i<=n ; i++) cout << \\\"5\\\"; if(zero){ while(zero--) cout << \\\"0\\\"; }else{ cout << \\\"0\\\"; } return 0; }\"]},\"908\":{\"h\":\"F.TooY0ung的贪吃蛇\"},\"909\":{\"h\":\"分析\",\"t\":[\"手玩一下很容易得出结论，答案只有可能是 或者 ，如果刚好撞到四个顶点就是后者。\",\"那这个结论能不能证明呢？其实是可以的。\",\"答案为 的情况显而易见。其他情况下很容易发现每次碰撞都是一个 度的碰撞，那么与顶点刚好能构成一个等腰直角三角形，容易看到其中隐含着一个对称的关系。最终必然就对称回原点了。\",\"难度：读题读懂之后，部分分就是暴力在二维数组上处理，满分需要自己多尝试找结论。\",\"40 分：二维数组上模拟走路即可，有同学会被题面给的时间吓到，其实标记一下走过的位置，经历了重复的状态就停下就好。\",\"100 分：根据上面的结论处理即可。\"]},\"910\":{\"h\":\"满分参考代码\"},\"911\":{\"h\":\"TooY0ung 的代码\",\"t\":[\"#include<bits/stdc++.h> int n,x,y; string d; int main() { cin>>n>>x>>y>>d; if(x+y==n+1) { if(d==\\\"DL\\\"||d==\\\"UR\\\") cout<<n<<endl; else cout<<2*n-2<<endl; } else if(x==y) { if(d==\\\"DR\\\"||d==\\\"UL\\\") cout<<n<<endl; else cout<<2*n-2<<endl; } else cout<<2*n-2<<endl; return 0; }\"]},\"912\":{\"h\":\"\",\"t\":[\"404 Not Found\"]},\"913\":{\"h\":\"YACS\"},\"914\":{\"h\":\"Atcoder\"},\"915\":{\"h\":\"Dmy\"}},\"dirtCount\":0,\"index\":[[\"部分分就是暴力在二维数组上处理\",{\"1\":{\"909\":1}}],[\"部分分给了很多爆搜的分\",{\"1\":{\"479\":1}}],[\"度的碰撞\",{\"1\":{\"909\":1}}],[\"剔除\",{\"1\":{\"904\":1}}],[\"感觉意义不大\",{\"1\":{\"900\":1}}],[\"降到\",{\"1\":{\"900\":1}}],[\"办比赛\",{\"0\":{\"893\":1}}],[\"王彬铸的代码\",{\"0\":{\"907\":1}}],[\"王老师的新水杯\",{\"0\":{\"877\":1}}],[\"王到汇合点的路程\",{\"1\":{\"259\":1}}],[\"横2\",{\"1\":{\"875\":1}}],[\"横坐标为i时的上管道底端与下管道顶端\",{\"1\":{\"260\":1}}],[\"耐心写完排序后会简单很多\",{\"1\":{\"871\":1}}],[\"红色警戒\",{\"0\":{\"862\":1}}],[\"红楼\",{\"0\":{\"453\":1}}],[\"缺or满\",{\"0\":{\"858\":1},\"1\":{\"887\":1}}],[\"李知颖的满分代码\",{\"0\":{\"843\":1}}],[\"李代桃僵\",{\"0\":{\"499\":1}}],[\"知道数学中周期的概念\",{\"1\":{\"835\":1}}],[\"桃园南路上的红绿灯\",{\"0\":{\"834\":1}}],[\"校门外好多树\",{\"0\":{\"830\":1}}],[\"校门外的树\",{\"0\":{\"218\":1},\"1\":{\"900\":1}}],[\"摩斯电码数数\",{\"0\":{\"827\":1}}],[\"哪个高算哪个就好\",{\"1\":{\"825\":1}}],[\"联合\",{\"0\":{\"824\":1}}],[\"白送的\",{\"1\":{\"812\":1}}],[\"成立就输出\",{\"1\":{\"809\":1}}],[\"切了又切的纸牌\",{\"0\":{\"806\":1}}],[\"切绳子\",{\"0\":{\"245\":1}}],[\"压缩了一篇文章\",{\"0\":{\"794\":1}}],[\"压入队列\",{\"1\":{\"106\":1}}],[\"压入栈\",{\"1\":{\"105\":1}}],[\"鸡兔同笼现代版\",{\"1\":{\"789\":1}}],[\"甚至可能是某个数可以变成\",{\"1\":{\"772\":1}}],[\"该怎么做\",{\"1\":{\"766\":1}}],[\"今年比赛有没有三等奖\",{\"0\":{\"749\":1}}],[\"今天的价格\",{\"1\":{\"739\":1}}],[\"争先红葫芦\",{\"0\":{\"747\":1}}],[\"核心在于三重循环的优化\",{\"1\":{\"812\":1}}],[\"核心是输入到文件末尾\",{\"1\":{\"745\":1}}],[\"核心就是每次贪心选两个权值最小的节点\",{\"1\":{\"406\":1}}],[\"核心就是求某个区间的某种颜色的客栈数量\",{\"1\":{\"223\":1}}],[\"粗心的\",{\"0\":{\"744\":1}}],[\"唱跳\",{\"0\":{\"742\":1}}],[\"规避整除即可\",{\"1\":{\"740\":1}}],[\"规避掉整除商会加\",{\"1\":{\"740\":1}}],[\"规则数量\",{\"1\":{\"179\":1}}],[\"日\",{\"1\":{\"740\":2}}],[\"日下一天是\",{\"1\":{\"740\":2}}],[\"日开始计算\",{\"1\":{\"740\":1}}],[\"日期进制没有\",{\"1\":{\"740\":1}}],[\"日期进制的数学计算问题\",{\"1\":{\"740\":1}}],[\"日期\",{\"1\":{\"572\":1}}],[\"天班\",{\"1\":{\"884\":1}}],[\"天达到了\",{\"1\":{\"881\":1}}],[\"天\",{\"1\":{\"740\":1}}],[\"天容错\",{\"1\":{\"516\":1}}],[\"件\",{\"1\":{\"739\":1}}],[\"件物品\",{\"1\":{\"359\":2,\"361\":1}}],[\"件物品在\",{\"1\":{\"359\":1}}],[\"金钱没有变动\",{\"1\":{\"739\":1}}],[\"金蝉脱壳\",{\"0\":{\"425\":1}}],[\"买了不会赚\",{\"1\":{\"739\":1}}],[\"明天价格\",{\"1\":{\"739\":1}}],[\"钱包金额\",{\"1\":{\"739\":1}}],[\"观察程序的运行流程\",{\"1\":{\"737\":1}}],[\"教大家怎么通过中间加输出语句\",{\"1\":{\"737\":1}}],[\"欧拉筛就更更快了\",{\"1\":{\"735\":1}}],[\"欧拉序+st表\",{\"0\":{\"13\":1}}],[\"初赛阅读程序训练\",{\"1\":{\"737\":1}}],[\"初赛估分\",{\"0\":{\"734\":1}}],[\"初始血量为\",{\"1\":{\"475\":1}}],[\"初始化为全\",{\"1\":{\"869\":1}}],[\"初始化\",{\"1\":{\"362\":1}}],[\"初始化分块\",{\"1\":{\"321\":1}}],[\"初始情况检查\",{\"1\":{\"276\":1}}],[\"初始速度\",{\"1\":{\"198\":3}}],[\"初始是\",{\"1\":{\"139\":1,\"140\":1}}],[\"初始数组为空\",{\"1\":{\"103\":1}}],[\"初始值\",{\"1\":{\"62\":1}}],[\"初始两点之间是祖孙关系时\",{\"1\":{\"12\":1}}],[\"拿乌龟\",{\"1\":{\"732\":1}}],[\"拿个优先队列建树就好\",{\"1\":{\"406\":1}}],[\"碰\",{\"1\":{\"732\":1}}],[\"碰到墙或者到达二维数组的边缘就停下来\",{\"1\":{\"509\":1}}],[\"棋盘\",{\"1\":{\"732\":2}}],[\"乌龟计数器\",{\"1\":{\"732\":1}}],[\"乌龟对对碰\",{\"0\":{\"732\":1}}],[\"提取一个公因式\",{\"1\":{\"812\":1}}],[\"提交文件夹\",{\"0\":{\"731\":1}}],[\"提高组\",{\"0\":{\"163\":1,\"175\":1,\"176\":1,\"177\":1,\"178\":1,\"179\":1,\"182\":1,\"183\":1,\"188\":1,\"223\":1,\"227\":1,\"240\":1,\"260\":1,\"287\":1,\"307\":1}}],[\"朋友平均有几个朋友\",{\"0\":{\"725\":1}}],[\"符合条件的输出\",{\"1\":{\"723\":1}}],[\"如题所述\",{\"1\":{\"723\":1}}],[\"如果刚好撞到四个顶点就是后者\",{\"1\":{\"909\":1}}],[\"如果一个数的所有数位之和为\",{\"1\":{\"856\":1}}],[\"如果一样就是\",{\"1\":{\"409\":1}}],[\"如果实在搞不清楚的\",{\"1\":{\"835\":1}}],[\"如果和超过\",{\"1\":{\"802\":1}}],[\"如果和目标不一样就变颜色\",{\"1\":{\"494\":1}}],[\"如果想要进入第四轮\",{\"1\":{\"779\":1}}],[\"如果想要进入第三轮\",{\"1\":{\"779\":1}}],[\"如果有三等奖\",{\"1\":{\"750\":1}}],[\"如果有了一个这样的合法的状态\",{\"1\":{\"280\":1}}],[\"如果位数要求更多\",{\"1\":{\"746\":1}}],[\"如果位数相等\",{\"1\":{\"622\":1}}],[\"如果使用文件结束符结束输入\",{\"1\":{\"741\":1}}],[\"如果明天价格\",{\"1\":{\"739\":2}}],[\"如果你执行上面的代码输出前\",{\"1\":{\"838\":1}}],[\"如果你用函数判断质数\",{\"1\":{\"735\":1}}],[\"如果你会筛法会更快\",{\"1\":{\"735\":1}}],[\"如果你想到了用个优先队列优化这个查找\",{\"1\":{\"428\":1}}],[\"如果时间是奇数\",{\"1\":{\"665\":1}}],[\"如果某个数位回答的是\",{\"1\":{\"655\":1}}],[\"如果不允许用数组的话\",{\"1\":{\"859\":1}}],[\"如果不是雷就没有数字了\",{\"1\":{\"700\":1}}],[\"如果不是定长的字符串就需要\",{\"1\":{\"465\":1}}],[\"如果不等\",{\"1\":{\"622\":1}}],[\"如果出现了连续三个字符一样\",{\"1\":{\"601\":1}}],[\"如果做正方形\",{\"1\":{\"595\":2}}],[\"如果做了正方形\",{\"1\":{\"595\":1}}],[\"如果排完序后一致\",{\"1\":{\"556\":1}}],[\"如果它与\",{\"1\":{\"556\":1}}],[\"如果代码没有问题\",{\"1\":{\"550\":1}}],[\"如果把\",{\"1\":{\"541\":1}}],[\"如果发现子任务1无法通过\",{\"1\":{\"526\":1}}],[\"如果会写子任务1\",{\"1\":{\"526\":1}}],[\"如果会写子任务\",{\"1\":{\"525\":1}}],[\"如果直接列举所有情况显然要写很多\",{\"1\":{\"512\":1}}],[\"如果直接用\",{\"1\":{\"414\":1}}],[\"如果大于等于\",{\"1\":{\"500\":1}}],[\"如果错了\",{\"1\":{\"492\":1}}],[\"如果哪题反馈比较多看不懂我的代码\",{\"1\":{\"454\":1}}],[\"如果列表可以无限长\",{\"1\":{\"453\":1}}],[\"如果答案是\",{\"1\":{\"446\":1}}],[\"如果写了\",{\"1\":{\"445\":1}}],[\"如果与前一个不相等\",{\"1\":{\"441\":1}}],[\"如果当前时间\",{\"1\":{\"668\":1}}],[\"如果当前局面操作完只能变为先手必胜的状态\",{\"1\":{\"432\":1}}],[\"如果当前区间已经有启用了的测速点\",{\"1\":{\"198\":1}}],[\"如果往左一段然后回头\",{\"1\":{\"404\":1}}],[\"如果放了两个\",{\"1\":{\"397\":1}}],[\"如果放到最小的那组\",{\"1\":{\"280\":1}}],[\"如果翻译为最多一个间隔\",{\"1\":{\"351\":1}}],[\"如果用到了一个\",{\"1\":{\"329\":1}}],[\"如果这个\",{\"1\":{\"329\":1}}],[\"如果在这一轮开始前\",{\"1\":{\"632\":1}}],[\"如果在\",{\"1\":{\"329\":1}}],[\"如果看结尾\",{\"1\":{\"328\":1}}],[\"如果没有\",{\"1\":{\"328\":1}}],[\"如果没有被确定过\",{\"1\":{\"185\":1,\"186\":1}}],[\"如果算过了\",{\"1\":{\"307\":1}}],[\"如果limit为真\",{\"1\":{\"273\":1}}],[\"如果前面没贴边\",{\"1\":{\"270\":1}}],[\"如果能见到\",{\"1\":{\"203\":1}}],[\"如果上一轮没法达成\",{\"1\":{\"196\":1}}],[\"如果上一行的这个位置是一个\",{\"1\":{\"154\":1}}],[\"如果已经填了就不管了\",{\"1\":{\"248\":1,\"249\":1}}],[\"如果已经确定了\",{\"1\":{\"187\":1}}],[\"如果已经被确定了\",{\"1\":{\"185\":1,\"186\":1}}],[\"如果每个插座充完一辆车能继续下一辆的话\",{\"1\":{\"325\":1}}],[\"如果每一列都填完了\",{\"1\":{\"185\":1,\"186\":1}}],[\"如果每次加法后用\",{\"1\":{\"109\":1}}],[\"如果每次加法后直接取模会退化成超时\",{\"1\":{\"109\":1}}],[\"如果第i位是\",{\"1\":{\"165\":1}}],[\"如果处于下降\",{\"1\":{\"137\":1}}],[\"如果处于上升\",{\"1\":{\"137\":1}}],[\"如果是数据范围更大\",{\"1\":{\"831\":1}}],[\"如果是因子\",{\"1\":{\"792\":1}}],[\"如果是系动词\",{\"1\":{\"741\":1}}],[\"如果是雷\",{\"1\":{\"700\":1}}],[\"如果是基于\",{\"1\":{\"216\":1}}],[\"如果是\",{\"1\":{\"91\":2}}],[\"如果题目说保留\",{\"1\":{\"91\":1}}],[\"如果\",{\"1\":{\"70\":1,\"71\":1,\"141\":3,\"211\":1,\"216\":1,\"500\":1,\"509\":1,\"553\":1,\"658\":1}}],[\"如果两个运算数都是整数\",{\"1\":{\"58\":1}}],[\"如果要进行区间修改\",{\"1\":{\"22\":1}}],[\"曼哈顿圆圈\",{\"0\":{\"722\":1}}],[\"毕竟才第一题嘛\",{\"1\":{\"717\":1}}],[\"稍微麻烦一点\",{\"1\":{\"713\":1}}],[\"复制画作\",{\"0\":{\"709\":1}}],[\"复制一份\",{\"1\":{\"166\":1,\"846\":1}}],[\"免费时长\",{\"1\":{\"708\":1}}],[\"停车费计算\",{\"0\":{\"706\":1}}],[\"停车场收费\",{\"0\":{\"514\":1}}],[\"末项\",{\"1\":{\"705\":1}}],[\"末项为\",{\"1\":{\"169\":1}}],[\"等差阶段\",{\"1\":{\"705\":1}}],[\"等差数列变化求和\",{\"0\":{\"703\":1}}],[\"等于siz的能有无限次\",{\"1\":{\"146\":1}}],[\"等于\",{\"1\":{\"72\":1,\"146\":2}}],[\"惠子相梁\",{\"0\":{\"693\":1}}],[\"确定了单位\",{\"1\":{\"678\":1}}],[\"确定最大值在\",{\"1\":{\"448\":1}}],[\"确定最次值的位置\",{\"1\":{\"448\":1}}],[\"经历了重复的状态就停下就好\",{\"1\":{\"909\":1}}],[\"经过了几次起点即可\",{\"1\":{\"668\":1}}],[\"经典的质因数分解题\",{\"1\":{\"792\":1}}],[\"经典的考察怎么把一些数位组合成一个数\",{\"1\":{\"658\":1}}],[\"经典的明明的随机数\",{\"1\":{\"346\":1}}],[\"经典日期循环模拟题\",{\"1\":{\"571\":1}}],[\"经典广搜\",{\"1\":{\"421\":1}}],[\"游泳同步起步\",{\"0\":{\"667\":1}}],[\"课间休息时间设置\",{\"0\":{\"664\":1}}],[\"尝试到\",{\"1\":{\"655\":1}}],[\"尝试更新答案\",{\"1\":{\"154\":1,\"259\":1}}],[\"科学记数法\",{\"0\":{\"644\":1}}],[\"零碎文件占用大小\",{\"0\":{\"641\":1}}],[\"曾经出现过\",{\"1\":{\"633\":1}}],[\"乒乓球\",{\"0\":{\"631\":1}}],[\"七层嵌套循环完成\",{\"1\":{\"629\":1}}],[\"决定输出及就好\",{\"1\":{\"744\":1}}],[\"决定输出\",{\"1\":{\"629\":1}}],[\"决斗\",{\"0\":{\"197\":1}}],[\"思维场是\",{\"1\":{\"626\":1}}],[\"自己在本地跑出来结果后\",{\"1\":{\"838\":1}}],[\"自定义cmp函数\",{\"1\":{\"623\":1}}],[\"自带的去重\",{\"0\":{\"349\":1}}],[\"自带的去重都可以实现\",{\"1\":{\"346\":1}}],[\"具体实现为\",{\"1\":{\"623\":1}}],[\"具体做法如下\",{\"1\":{\"504\":1}}],[\"则\",{\"1\":{\"658\":1}}],[\"则可以比较字典序\",{\"1\":{\"622\":1}}],[\"则可以直接按照\",{\"1\":{\"503\":1}}],[\"则位数大的数值本身也一定更大\",{\"1\":{\"622\":1}}],[\"则对应的字符串也应完全一致\",{\"1\":{\"622\":1}}],[\"均在\",{\"1\":{\"622\":1}}],[\"注\",{\"1\":{\"621\":1}}],[\"注意有没有奇怪的数据规模约定\",{\"1\":{\"735\":1}}],[\"注意转义符\",{\"1\":{\"710\":1}}],[\"注意要开\",{\"1\":{\"585\":1}}],[\"注意要用\",{\"1\":{\"533\":1}}],[\"注意一个\",{\"1\":{\"574\":1}}],[\"注意用\",{\"1\":{\"527\":1}}],[\"注意字符串下标从0开始\",{\"1\":{\"504\":1}}],[\"注意这样写的话查\",{\"1\":{\"465\":1}}],[\"注意这里不能写\",{\"1\":{\"198\":1}}],[\"注意到\",{\"1\":{\"645\":1}}],[\"注意到了这个就很容易想到每个随机数都去看看再\",{\"1\":{\"457\":1}}],[\"注意到这题空间限制只有\",{\"1\":{\"457\":1}}],[\"注意到题目没有要求放最少的稻草人\",{\"1\":{\"426\":1}}],[\"注意数据范围\",{\"1\":{\"430\":1}}],[\"注意特判\",{\"0\":{\"264\":1}}],[\"注意不能用\",{\"1\":{\"256\":1}}],[\"注意\",{\"1\":{\"109\":1,\"110\":1}}],[\"掌握单层循环语句\",{\"1\":{\"621\":1}}],[\"千米\",{\"1\":{\"881\":1}}],[\"千钱买千鸡\",{\"0\":{\"610\":1}}],[\"千位\",{\"1\":{\"97\":1}}],[\"油箱限制范围内\",{\"1\":{\"605\":1}}],[\"油箱\",{\"0\":{\"603\":1}}],[\"断开的地方不能翻到后面去\",{\"1\":{\"602\":1}}],[\"考试\",{\"0\":{\"597\":1}}],[\"考虑到我们需要找到最大的逆序对和\",{\"1\":{\"818\":1}}],[\"考虑到第二题可能会花费一些同学比较多的时间\",{\"1\":{\"515\":1}}],[\"考虑枚举逆序对中靠后的那个第二个数\",{\"1\":{\"818\":1}}],[\"考虑其他位置的情况\",{\"1\":{\"661\":1}}],[\"考虑在子任务\",{\"1\":{\"614\":1}}],[\"考虑\",{\"1\":{\"248\":1,\"249\":1,\"629\":1}}],[\"边上有五个数字\",{\"1\":{\"700\":1}}],[\"边长刚好是\",{\"1\":{\"595\":1}}],[\"边数\",{\"1\":{\"215\":1}}],[\"偶数位的数\",{\"0\":{\"590\":1}}],[\"换掉几个之后的结果\",{\"1\":{\"579\":1}}],[\"坏掉的数码管\",{\"0\":{\"577\":1}}],[\"嘿嘿\",{\"1\":{\"574\":1}}],[\"贴心准备的很坑的数据点\",{\"1\":{\"574\":1}}],[\"统计多少个位置有树且前一个位置没树即可\",{\"1\":{\"831\":1}}],[\"统计次数即可\",{\"1\":{\"574\":1}}],[\"统计每个小写英文字母的出现次数\",{\"1\":{\"518\":1}}],[\"想明白了这些之后\",{\"1\":{\"574\":1}}],[\"想想好久没出麻烦一点的构造题了\",{\"1\":{\"480\":1}}],[\"胡乱转换大小写\",{\"1\":{\"574\":1}}],[\"胡乱排序\",{\"1\":{\"574\":1}}],[\"贪心选择花时间小的即可\",{\"1\":{\"598\":1}}],[\"贪心\",{\"1\":{\"574\":1}}],[\"贪心通过\",{\"1\":{\"267\":1}}],[\"星\",{\"1\":{\"740\":6}}],[\"星星历采用每星\",{\"1\":{\"740\":1}}],[\"星星历\",{\"0\":{\"740\":1}}],[\"星号的部分为\",{\"1\":{\"691\":1}}],[\"星期几\",{\"1\":{\"572\":1}}],[\"星球大战\",{\"0\":{\"215\":1}}],[\"黑色星期五\",{\"1\":{\"571\":1}}],[\"疯疯疯狂星期四\",{\"0\":{\"570\":1}}],[\"周期长度为\",{\"1\":{\"838\":1}}],[\"周期大小\",{\"1\":{\"633\":1}}],[\"周赛的\",{\"1\":{\"565\":1}}],[\"周边看看要不要调整\",{\"1\":{\"450\":1}}],[\"奇数还是偶数\",{\"0\":{\"564\":1}}],[\"谁赢了\",{\"0\":{\"563\":1}}],[\"串的\",{\"1\":{\"556\":1}}],[\"玩字符串的\",{\"0\":{\"555\":1}}],[\"除以\",{\"0\":{\"729\":1},\"1\":{\"553\":1,\"668\":2,\"705\":1,\"904\":1}}],[\"除法变成整除\",{\"1\":{\"58\":1}}],[\"除法\",{\"1\":{\"58\":1}}],[\"喜欢除法的\",{\"0\":{\"552\":1}}],[\"喜欢开方的\",{\"0\":{\"549\":1}}],[\"直到不会死或者用完了为止即可\",{\"1\":{\"747\":1}}],[\"直到下一天\",{\"1\":{\"740\":1}}],[\"直到正确为止\",{\"1\":{\"550\":1}}],[\"直接取个十百千位即可\",{\"1\":{\"853\":1}}],[\"直接按照类似于第一题的方式处理即可\",{\"1\":{\"838\":1}}],[\"直接按照题意模拟即可\",{\"1\":{\"753\":1}}],[\"直接双重循环暴力枚举检查即可\",{\"1\":{\"815\":1}}],[\"直接双重循环枚举所有起点终点\",{\"1\":{\"802\":1}}],[\"直接提交题面的代码即可\",{\"1\":{\"812\":1}}],[\"直接往后暴力枚举就好了\",{\"1\":{\"735\":1}}],[\"直接往右精准抵达\",{\"1\":{\"403\":1}}],[\"直接暴力标记每个位置有没有树即可\",{\"1\":{\"831\":1}}],[\"直接暴力跑的程序在我的电脑上花了不到\",{\"1\":{\"735\":1}}],[\"直接暴力枚举即可\",{\"1\":{\"704\":1}}],[\"直接暴力枚举就好\",{\"1\":{\"473\":1}}],[\"直接暴力枚举去计算覆盖肯定是不行\",{\"1\":{\"350\":1}}],[\"直接分别除以\",{\"1\":{\"734\":1}}],[\"直接先比较长度\",{\"1\":{\"671\":1}}],[\"直接显然时间从\",{\"1\":{\"668\":1}}],[\"直接尝试\",{\"1\":{\"655\":1}}],[\"直接跳过这个超级大周期\",{\"1\":{\"632\":1}}],[\"直接进行判断\",{\"1\":{\"622\":1}}],[\"直接从第二个字符开始比较是不是前一个字符\",{\"1\":{\"588\":1}}],[\"直接把样例输出前三行拿过来输出即可\",{\"1\":{\"571\":1}}],[\"直接专心模拟旋转即可\",{\"1\":{\"541\":1}}],[\"直接根据数学规律算出答案即可\",{\"1\":{\"533\":1}}],[\"直接用子任务\",{\"1\":{\"838\":1}}],[\"直接用\",{\"1\":{\"533\":1}}],[\"直接用这套编码算文章长度就好了\",{\"1\":{\"408\":1}}],[\"直接输入两个整数比较即可\",{\"1\":{\"671\":1}}],[\"直接输入\",{\"1\":{\"533\":1}}],[\"直接输出所有文件原始大小之和即可\",{\"1\":{\"642\":1}}],[\"直接输出字符串中的第\",{\"1\":{\"509\":1}}],[\"直接输出原文的值即可\",{\"1\":{\"464\":1}}],[\"直接输出\",{\"1\":{\"453\":1,\"502\":2,\"521\":1,\"530\":1,\"564\":1,\"614\":1,\"626\":1,\"809\":1,\"850\":1,\"878\":1}}],[\"直接使用循环解决\",{\"1\":{\"508\":1}}],[\"直接将\",{\"1\":{\"503\":1}}],[\"直接多做几次可以保证没错也不用想那么多\",{\"1\":{\"489\":1}}],[\"直接读一个字符串自然也更没什么问题了\",{\"1\":{\"487\":1}}],[\"直接数位分解当然没什么问题\",{\"1\":{\"487\":1}}],[\"直接第一个群有两个人你\",{\"1\":{\"480\":1}}],[\"直接就没了\",{\"1\":{\"470\":1}}],[\"直接有含义就做一层就好了\",{\"1\":{\"465\":1}}],[\"直接套数学式子算的话\",{\"1\":{\"458\":1}}],[\"直接每次包上\",{\"1\":{\"448\":1}}],[\"直接不写输入输出优化是最方便的\",{\"1\":{\"445\":1}}],[\"直接一步步模拟然后特判一下\",{\"1\":{\"435\":1}}],[\"直接一个递推就好了\",{\"1\":{\"402\":1}}],[\"直接在\",{\"1\":{\"427\":1}}],[\"直接\",{\"1\":{\"410\":1,\"518\":1}}],[\"直接给这个单词编码\",{\"1\":{\"407\":1}}],[\"直接左边往右走一步\",{\"1\":{\"405\":1}}],[\"直接二分套树状数组\",{\"0\":{\"213\":1}}],[\"直接做下一个位置\",{\"1\":{\"185\":1,\"186\":1}}],[\"平方根有可能是\",{\"1\":{\"550\":1}}],[\"平局\",{\"1\":{\"513\":1}}],[\"难or易\",{\"0\":{\"849\":1}}],[\"难点只是麻烦\",{\"1\":{\"674\":1}}],[\"难点主要在数学\",{\"1\":{\"904\":1}}],[\"难点主要在读题\",{\"1\":{\"626\":1,\"639\":1}}],[\"难点主要在运气\",{\"1\":{\"550\":1}}],[\"难度\",{\"1\":{\"502\":1,\"503\":1,\"504\":1,\"505\":1,\"507\":1,\"508\":1,\"509\":2,\"512\":1,\"515\":1,\"518\":1,\"521\":1,\"530\":1,\"533\":1,\"537\":1,\"541\":1,\"550\":1,\"553\":1,\"556\":1,\"559\":1,\"568\":1,\"571\":1,\"574\":1,\"578\":1,\"582\":1,\"585\":1,\"588\":1,\"591\":1,\"595\":1,\"598\":1,\"601\":1,\"604\":1,\"608\":1,\"611\":1,\"614\":1,\"617\":1,\"620\":1,\"621\":1,\"622\":1,\"623\":1,\"626\":1,\"629\":1,\"639\":1,\"642\":1,\"645\":1,\"648\":1,\"652\":1,\"655\":1,\"658\":1,\"661\":1,\"665\":1,\"668\":1,\"671\":1,\"674\":1,\"678\":1,\"681\":1,\"684\":1,\"687\":1,\"691\":1,\"694\":1,\"697\":1,\"700\":1,\"704\":1,\"707\":1,\"710\":1,\"713\":1,\"717\":1,\"723\":1,\"739\":1,\"740\":1,\"741\":1,\"742\":1,\"809\":1,\"812\":1,\"815\":1,\"818\":1,\"822\":1,\"825\":1,\"828\":1,\"831\":1,\"835\":1,\"838\":1,\"841\":1,\"846\":1,\"850\":1,\"853\":1,\"856\":1,\"859\":1,\"863\":1,\"866\":1,\"871\":1,\"874\":1,\"878\":1,\"881\":1,\"884\":1,\"887\":1,\"891\":1,\"894\":1,\"897\":1,\"900\":1,\"904\":1,\"909\":1}}],[\"趣味题\",{\"1\":{\"550\":1}}],[\"函数来处理这种二级排序的问题\",{\"1\":{\"623\":1}}],[\"函数就行\",{\"1\":{\"546\":1}}],[\"函数体使用大括号包裹\",{\"1\":{\"48\":1}}],[\"顺带看看有没有哪个数位是\",{\"1\":{\"856\":1}}],[\"顺子\",{\"0\":{\"587\":1}}],[\"顺时针\",{\"1\":{\"542\":1}}],[\"顺手牵羊\",{\"0\":{\"500\":1}}],[\"逆序输出时遇到\",{\"1\":{\"841\":1}}],[\"逆序对\",{\"0\":{\"258\":1},\"1\":{\"258\":2}}],[\"逆时针\",{\"1\":{\"542\":1}}],[\"四个角上有三个数字\",{\"1\":{\"700\":1}}],[\"四数转盘\",{\"0\":{\"540\":1}}],[\"四位质数必然为一个数的十位开头或者一个数的个位开头\",{\"1\":{\"537\":1}}],[\"四种\",{\"1\":{\"461\":1}}],[\"此处给出真的模拟旋转的代码\",{\"1\":{\"542\":1}}],[\"此处我还是按照我个人的习惯\",{\"1\":{\"531\":1}}],[\"此时省去了排序的步骤\",{\"1\":{\"871\":1}}],[\"此时要找到九座桥的最小值\",{\"1\":{\"863\":1}}],[\"此时保证了数据从小到大排序\",{\"1\":{\"863\":1}}],[\"此时可以在枚举输入时直接算出每个水杯灌到\",{\"1\":{\"859\":1}}],[\"此时时间复杂度的瓶颈为排序的\",{\"1\":{\"815\":1}}],[\"此时所有数字都是完全正确的\",{\"1\":{\"652\":1}}],[\"此时总比分是\",{\"1\":{\"632\":1}}],[\"此时显然能拿到满分\",{\"1\":{\"598\":1}}],[\"此时显然就需要对\",{\"1\":{\"556\":1}}],[\"此时只需要判断\",{\"1\":{\"568\":1}}],[\"此时变化后要么是\",{\"1\":{\"556\":1}}],[\"此时数串只有三种可能性\",{\"1\":{\"537\":1}}],[\"此时需要输入正确的时间\",{\"1\":{\"530\":1}}],[\"此时就是最多路上能经过的\",{\"1\":{\"500\":1}}],[\"此时就有单调性了\",{\"1\":{\"500\":1}}],[\"此时就可以写出来\",{\"1\":{\"413\":1}}],[\"此时考虑把朋友打包\",{\"1\":{\"499\":1}}],[\"此时我们可以简单想想什么情况下是不行的\",{\"1\":{\"490\":1}}],[\"此时如果至少有三个\",{\"1\":{\"441\":1}}],[\"此时后面的方案数\",{\"1\":{\"335\":1}}],[\"此时当前串的\",{\"1\":{\"160\":1}}],[\"此时\",{\"1\":{\"154\":1,\"440\":1,\"524\":1,\"878\":1,\"904\":1}}],[\"此时超过\",{\"1\":{\"146\":1}}],[\"此时你保留\",{\"1\":{\"91\":1}}],[\"补齐两位数\",{\"1\":{\"527\":1}}],[\"补码\",{\"0\":{\"86\":1},\"1\":{\"86\":1}}],[\"跨年份的情况\",{\"1\":{\"527\":1}}],[\"跨月份的情况\",{\"1\":{\"527\":1}}],[\"涉及到月份和闰年的计算\",{\"1\":{\"527\":1}}],[\"涉及一点点数学技巧\",{\"1\":{\"515\":1}}],[\"好or坏\",{\"0\":{\"852\":1}}],[\"好了\",{\"1\":{\"526\":1}}],[\"好一点的想到了偶数要求\",{\"1\":{\"413\":1}}],[\"温暖的签到题004\",{\"0\":{\"527\":1}}],[\"温暖的签到题003\",{\"0\":{\"526\":1}}],[\"温暖的签到题002\",{\"0\":{\"525\":1}}],[\"温暖的签到题001\",{\"0\":{\"524\":1}}],[\"额外花钱的天数显然是\",{\"1\":{\"524\":1}}],[\"额外标记实现\",{\"0\":{\"136\":1}}],[\"随意发糖的\",{\"0\":{\"558\":1}}],[\"随便判断一下即可\",{\"1\":{\"524\":1}}],[\"随机重复\",{\"0\":{\"457\":1}}],[\"随机数生成器\",{\"0\":{\"164\":1}}],[\"登记排行榜\",{\"0\":{\"520\":1}}],[\"登陆\",{\"1\":{\"70\":1}}],[\"码就好\",{\"1\":{\"518\":1}}],[\"留个不怕累的同学的分数\",{\"1\":{\"691\":1}}],[\"留\",{\"1\":{\"516\":1}}],[\"元高于今天价格\",{\"1\":{\"739\":1}}],[\"元小于等于今天价格\",{\"1\":{\"739\":1}}],[\"元直接算出多少个小时乘以对应的单价即可\",{\"1\":{\"707\":1}}],[\"元\",{\"1\":{\"515\":1,\"707\":1,\"708\":2,\"739\":7}}],[\"特殊情况\",{\"1\":{\"513\":2}}],[\"特判所有结果就好\",{\"1\":{\"495\":1}}],[\"特判一下不要除多了即可\",{\"1\":{\"435\":1}}],[\"特判\",{\"1\":{\"410\":1}}],[\"详细可以参考下面的代码\",{\"1\":{\"512\":1}}],[\"骰子比大小\",{\"0\":{\"511\":1}}],[\"照明\",{\"1\":{\"509\":1}}],[\"环状字符串\",{\"0\":{\"509\":1}}],[\"造成数组越界\",{\"1\":{\"505\":1}}],[\"竖1\",{\"1\":{\"875\":1}}],[\"竖\",{\"1\":{\"505\":1}}],[\"竖着或斜着构成三连\",{\"1\":{\"505\":1}}],[\"匹配上最近的一个\",{\"1\":{\"504\":1}}],[\"才会进位\",{\"1\":{\"740\":1}}],[\"才开始往后扫\",{\"1\":{\"504\":1}}],[\"才艺\",{\"1\":{\"293\":1}}],[\"便可得到\",{\"1\":{\"503\":1}}],[\"综上\",{\"1\":{\"503\":1}}],[\"仅仅会使用分支和单层循环可以拿到\",{\"1\":{\"503\":1}}],[\"刚入门学过输入输出也可以得到\",{\"1\":{\"502\":1}}],[\"名的位置是离散的\",{\"1\":{\"500\":1}}],[\"名\",{\"1\":{\"500\":1}}],[\"名查询\",{\"1\":{\"212\":1}}],[\"笑里藏刀\",{\"0\":{\"498\":1}}],[\"隔岸观火\",{\"0\":{\"497\":1}}],[\"由于最终的差一定是\",{\"1\":{\"904\":1}}],[\"由于不好办\",{\"1\":{\"884\":1}}],[\"由于两种方式的喝水量相同\",{\"1\":{\"878\":1}}],[\"由于所有桥的耐久度都相同\",{\"1\":{\"863\":1}}],[\"由于所有红包优惠的价格都一样\",{\"1\":{\"809\":1}}],[\"由于是刚好减去一个小时\",{\"1\":{\"822\":1}}],[\"由于保证了整体逆序\",{\"1\":{\"818\":1}}],[\"由于黄焖鸡米饭的价格没达到所有红包的使用要求\",{\"1\":{\"809\":1}}],[\"由于开始的比分最多只有种\",{\"1\":{\"632\":1}}],[\"由于输入的\",{\"1\":{\"565\":1}}],[\"由于输入的全部都是\",{\"1\":{\"545\":1}}],[\"由于一定是偶数\",{\"1\":{\"564\":1}}],[\"由于每次选择的区间左端点不能小于之前选择的区间左端点\",{\"1\":{\"556\":1}}],[\"由于\",{\"1\":{\"524\":1,\"525\":1,\"544\":1,\"562\":2,\"822\":2}}],[\"由于数据比较小\",{\"1\":{\"507\":1}}],[\"由于数据中\",{\"1\":{\"507\":1}}],[\"由此就可以判断能进入到第几轮了\",{\"1\":{\"779\":1}}],[\"由此可以数学方式或者二分算出\",{\"1\":{\"497\":1}}],[\"由此直接记忆化搜索就好了\",{\"1\":{\"495\":1}}],[\"由这题大家也能感受到并查集用了路径压缩和按秩合并之后\",{\"1\":{\"461\":1}}],[\"属性很容易被发现\",{\"1\":{\"495\":1}}],[\"暗渡陈仓\",{\"0\":{\"495\":1}}],[\"另外再给出一个有趣的递归形式\",{\"1\":{\"841\":1}}],[\"另外这题还给了一些部分分\",{\"1\":{\"494\":1}}],[\"另一个是直接用\",{\"1\":{\"478\":1}}],[\"另一种常见的\",{\"0\":{\"18\":1}}],[\"另一种写法\",{\"0\":{\"8\":1}}],[\"灵感来源\",{\"1\":{\"494\":1}}],[\"它只需要在某个端点声东击西\",{\"1\":{\"493\":1}}],[\"声东击西\",{\"0\":{\"493\":1}}],[\"依据数据中的子任务\",{\"1\":{\"504\":1}}],[\"依赖子任务\",{\"1\":{\"492\":2}}],[\"依次输出\",{\"1\":{\"614\":1}}],[\"依次计算出位数即可\",{\"1\":{\"591\":1}}],[\"依次算出来除以\",{\"1\":{\"904\":1}}],[\"依次算出\",{\"1\":{\"585\":1}}],[\"依次处理\",{\"1\":{\"168\":1}}],[\"依次推每一行\",{\"1\":{\"158\":1}}],[\"趁火打劫\",{\"0\":{\"492\":1}}],[\"描述任意两道题是否冲突\",{\"1\":{\"490\":1}}],[\"借刀杀人\",{\"0\":{\"489\":1}}],[\"借尸还魂\",{\"0\":{\"413\":1}}],[\"尽可能进入到后面的比赛\",{\"1\":{\"779\":1}}],[\"尽可能消耗\",{\"1\":{\"488\":1}}],[\"尽可能接近\",{\"1\":{\"413\":1}}],[\"围魏救赵\",{\"0\":{\"488\":1}}],[\"瞒天过海\",{\"0\":{\"487\":1}}],[\"继续往前\",{\"1\":{\"485\":1}}],[\"继续优化到满分\",{\"0\":{\"187\":1}}],[\"回头如果发现了数据问题重测一下就好了\",{\"1\":{\"485\":1}}],[\"回头到\",{\"1\":{\"405\":1}}],[\"赛制题面没问题就还好\",{\"1\":{\"485\":1}}],[\"踏遍线段\",{\"0\":{\"485\":1}}],[\"逢七上学\",{\"0\":{\"484\":1}}],[\"猫咪几岁\",{\"0\":{\"482\":1}}],[\"通过输入得到\",{\"1\":{\"760\":1}}],[\"通过自定义\",{\"1\":{\"623\":1}}],[\"通过一次排序都搞好\",{\"1\":{\"574\":1}}],[\"通过一个\",{\"1\":{\"3\":2}}],[\"通过加号把几个数组合成一个字符串后处理即可\",{\"1\":{\"537\":1}}],[\"通过第一个子任务的经验\",{\"1\":{\"480\":1}}],[\"拉多少个群\",{\"0\":{\"480\":1}}],[\"拉到同样深度就会变成同一个点\",{\"1\":{\"12\":1}}],[\"拉到同样的深度\",{\"1\":{\"12\":1}}],[\"肯定不超\",{\"1\":{\"582\":1}}],[\"肯定不可能再超速了\",{\"1\":{\"198\":1}}],[\"肯定超呀\",{\"1\":{\"478\":1}}],[\"默认参数和返回值都是\",{\"1\":{\"478\":1}}],[\"默认情况下\",{\"1\":{\"101\":1}}],[\"战斗结算\",{\"1\":{\"473\":1}}],[\"吓跑直接不战斗\",{\"1\":{\"473\":1}}],[\"敌人胆量\",{\"1\":{\"473\":1,\"475\":1}}],[\"敌人战斗力\",{\"1\":{\"473\":1,\"475\":1}}],[\"怎么办呢\",{\"1\":{\"484\":1}}],[\"怎么输出第二行\",{\"1\":{\"471\":1}}],[\"怎么输出第一行\",{\"1\":{\"471\":1}}],[\"怎么输入\",{\"1\":{\"471\":1}}],[\"怎么判断节点\",{\"1\":{\"414\":1}}],[\"圈个矩形\",{\"0\":{\"470\":1}}],[\"延迟罐罐\",{\"0\":{\"469\":1}}],[\"虽然\",{\"1\":{\"838\":1}}],[\"虽然有多层含义\",{\"1\":{\"466\":1}}],[\"虽然这件事本身挺无聊\",{\"1\":{\"399\":1}}],[\"澄其心\",{\"0\":{\"463\":1}}],[\"搭配欧拉筛甚至能做到\",{\"1\":{\"462\":1}}],[\"遣其欲\",{\"0\":{\"462\":1}}],[\"远超\",{\"1\":{\"461\":1}}],[\"远交近攻\",{\"0\":{\"427\":1}}],[\"诈骗题\",{\"1\":{\"461\":1,\"493\":1}}],[\"心好静\",{\"0\":{\"461\":1}}],[\"神好清\",{\"0\":{\"460\":1}}],[\"神奇的幻方\",{\"0\":{\"271\":1}}],[\"万一断开的位置反转到后面有一样的字符也不可以\",{\"1\":{\"601\":1}}],[\"万一有\",{\"1\":{\"458\":1}}],[\"万能头文件\",{\"1\":{\"47\":1}}],[\"读题读懂之后\",{\"1\":{\"909\":1}}],[\"读题搞定后\",{\"1\":{\"846\":1}}],[\"读\",{\"1\":{\"857\":1}}],[\"读or过\",{\"0\":{\"855\":1}}],[\"读写\",{\"1\":{\"478\":1}}],[\"读懂题意后\",{\"1\":{\"458\":1}}],[\"读询问\",{\"1\":{\"14\":1}}],[\"足够了\",{\"1\":{\"457\":1}}],[\"于是想出一道卡空间限制的题\",{\"1\":{\"457\":1}}],[\"于是他错误的点名开始了\",{\"0\":{\"269\":1}}],[\"场语法周赛似乎都没有卡过空间\",{\"1\":{\"457\":1}}],[\"咱老老实实好好写好暴力就好了\",{\"1\":{\"456\":1}}],[\"呀或者优先队列啊啥的\",{\"1\":{\"456\":1}}],[\"月份\",{\"1\":{\"572\":1}}],[\"月名排序\",{\"0\":{\"455\":1}}],[\"月丙组\",{\"0\":{\"322\":1}}],[\"翻倍操作\",{\"1\":{\"453\":1}}],[\"程序\",{\"1\":{\"565\":1}}],[\"程序会读取直到非数字字符为止\",{\"1\":{\"530\":1}}],[\"程序规划\",{\"1\":{\"453\":1}}],[\"程序输出完全正确\",{\"1\":{\"69\":1}}],[\"若干个\",{\"1\":{\"453\":1}}],[\"过一天\",{\"1\":{\"572\":1}}],[\"过去\",{\"1\":{\"453\":1}}],[\"过滤非法的边\",{\"1\":{\"352\":1}}],[\"过滤做过的点\",{\"1\":{\"352\":1}}],[\"层的位置\",{\"1\":{\"475\":1}}],[\"层\",{\"1\":{\"475\":2}}],[\"层就能完成\",{\"1\":{\"453\":1}}],[\"层祖宗节点\",{\"1\":{\"11\":1}}],[\"类似的方式\",{\"1\":{\"453\":1}}],[\"类型计算结果\",{\"1\":{\"884\":1}}],[\"类型记录答案\",{\"1\":{\"878\":1}}],[\"类型读进来\",{\"1\":{\"746\":1}}],[\"类型存储结果\",{\"1\":{\"582\":1}}],[\"类型存储不下\",{\"1\":{\"524\":1}}],[\"类型溢出后正好和\",{\"1\":{\"565\":1}}],[\"类型直接判断即可\",{\"1\":{\"564\":1}}],[\"类型标记\",{\"1\":{\"256\":1}}],[\"类型的\",{\"1\":{\"101\":1}}],[\"类型的值初始化\",{\"1\":{\"3\":1}}],[\"类型\",{\"1\":{\"101\":2,\"478\":1,\"621\":1}}],[\"类型转换\",{\"0\":{\"101\":1}}],[\"类型无法无法精确储存的数\",{\"1\":{\"91\":1}}],[\"类型可以精确储存的数\",{\"1\":{\"91\":1}}],[\"西游\",{\"0\":{\"452\":1}}],[\"本来直接输出任何一座桥的耐久度都可以\",{\"1\":{\"863\":1}}],[\"本来想要求翻转后放到末尾的\",{\"1\":{\"806\":1}}],[\"本题数据可做\",{\"1\":{\"740\":1}}],[\"本题数据范围较大\",{\"1\":{\"621\":1}}],[\"本题难点在于判题时会随机的选择正的还是负的\",{\"1\":{\"550\":1}}],[\"本题思路\",{\"0\":{\"329\":1}}],[\"本地跑完会发现极限数据有\",{\"1\":{\"484\":1}}],[\"本身是个简单的模拟题\",{\"1\":{\"451\":1}}],[\"水量需要多少水\",{\"1\":{\"859\":1}}],[\"水浒\",{\"0\":{\"450\":1}}],[\"水果数量\",{\"1\":{\"321\":1}}],[\"刷新缓冲区\",{\"1\":{\"445\":1}}],[\"刷表\",{\"0\":{\"110\":1}}],[\"导致\",{\"1\":{\"445\":1}}],[\"缓冲区的关联\",{\"1\":{\"445\":1}}],[\"缓冲区和\",{\"1\":{\"445\":1}}],[\"拓扑排序\",{\"1\":{\"444\":1}}],[\"拓扑排序广搜的队列\",{\"1\":{\"444\":1}}],[\"拓扑序\",{\"1\":{\"444\":1}}],[\"缩点后边\",{\"1\":{\"444\":1}}],[\"缩点后\",{\"1\":{\"444\":2}}],[\"缩点\",{\"1\":{\"444\":2}}],[\"缩到\",{\"1\":{\"444\":1}}],[\"缩到了新图的哪个点\",{\"1\":{\"444\":1}}],[\"连续打卡与累计打卡\",{\"0\":{\"736\":1}}],[\"连环计\",{\"0\":{\"442\":1}}],[\"连接到的点\",{\"1\":{\"215\":1}}],[\"苦肉计\",{\"0\":{\"441\":1}}],[\"美人计\",{\"0\":{\"437\":1}}],[\"唯一的难点只在十六进制的转换上了\",{\"1\":{\"900\":1}}],[\"唯一的小麻烦就是可能最后一步取模会变得比原本的数更小\",{\"1\":{\"435\":1}}],[\"唯一需要注意的时组成\",{\"1\":{\"329\":1}}],[\"很大\",{\"1\":{\"838\":1}}],[\"很明显可以看出来的一点是\",{\"1\":{\"632\":1}}],[\"很轻松能写出\",{\"1\":{\"484\":1}}],[\"很多错误的写法都会认为不需要排序\",{\"1\":{\"574\":1}}],[\"很多后期选手一看就二分\",{\"1\":{\"470\":1}}],[\"很多同学这题没注意输入输出优化挂掉\",{\"1\":{\"461\":1}}],[\"很多同学这部分分数没拿到有点可惜\",{\"1\":{\"407\":1}}],[\"很多同学被我卡到了\",{\"1\":{\"457\":1}}],[\"很多同学就止步于此了\",{\"1\":{\"402\":1}}],[\"很容易得到递推式\",{\"1\":{\"904\":1}}],[\"很容易想到直接暴力给所有已分配的块标记上\",{\"1\":{\"900\":1}}],[\"很容易想到就是第一位可能的数量乘以第二位可能的数量\",{\"1\":{\"578\":1}}],[\"很容易发现中间会出现循环的结果\",{\"1\":{\"838\":1}}],[\"很容易发现就是\",{\"1\":{\"533\":1}}],[\"很容易被误会为类似于摆花要考动态规划\",{\"1\":{\"604\":1}}],[\"很容易被提示乘法原理\",{\"1\":{\"578\":1}}],[\"很容易实现代码\",{\"1\":{\"545\":1}}],[\"很容易忽视掉非常多行输出时的\",{\"1\":{\"461\":1}}],[\"很容易推出来标程这个结论\",{\"1\":{\"431\":1}}],[\"指数对应的体重应该是\",{\"1\":{\"639\":1}}],[\"指桑骂槐\",{\"0\":{\"431\":1}}],[\"指最长不上升子序列长度\",{\"1\":{\"117\":1}}],[\"偷梁换柱\",{\"0\":{\"430\":1}}],[\"号点排名\",{\"1\":{\"427\":1}}],[\"号位置\",{\"1\":{\"236\":2,\"237\":2,\"239\":2}}],[\"步就好\",{\"1\":{\"766\":1}}],[\"步\",{\"1\":{\"423\":1}}],[\"混水摸鱼\",{\"0\":{\"420\":1}}],[\"釜底抽薪\",{\"0\":{\"419\":1}}],[\"擒贼擒王\",{\"0\":{\"418\":1}}],[\"抛砖引玉\",{\"0\":{\"417\":1}}],[\"质数数量大概是\",{\"1\":{\"415\":1}}],[\"埃筛\",{\"1\":{\"415\":1}}],[\"学过\",{\"1\":{\"815\":1}}],[\"学过最短路的同学容易发现\",{\"1\":{\"772\":1}}],[\"学过输入输出就可以拿到满分\",{\"1\":{\"620\":1}}],[\"学过分支就能拿到满分\",{\"1\":{\"502\":1}}],[\"学的好的同学很容易发现可以直接用类似于背包的方法搞定\",{\"1\":{\"436\":1}}],[\"学到后期的同学会知道这是完全积性函数\",{\"1\":{\"415\":1}}],[\"学会输入\",{\"0\":{\"66\":1}}],[\"学会输出\",{\"0\":{\"46\":1}}],[\"欲擒姑纵\",{\"0\":{\"415\":1}}],[\"看上去\",{\"1\":{\"611\":1}}],[\"看完题后容易发现\",{\"1\":{\"453\":1}}],[\"看懂了程序之后\",{\"1\":{\"415\":1}}],[\"看是不是\",{\"1\":{\"414\":1}}],[\"看看所有的\",{\"1\":{\"591\":1}}],[\"看看是否有一个和\",{\"1\":{\"556\":1}}],[\"看看在当前对边的要求下能否连通\",{\"1\":{\"352\":1}}],[\"看看前一个人能不能再抄一本书\",{\"1\":{\"219\":2}}],[\"看看这个测试点要不要启用\",{\"1\":{\"198\":1}}],[\"浪费点时间\",{\"1\":{\"412\":1}}],[\"出现次数为\",{\"1\":{\"742\":1}}],[\"出现\",{\"1\":{\"545\":1}}],[\"出现了几次\",{\"1\":{\"258\":1}}],[\"出题时突然想到之前\",{\"1\":{\"457\":1}}],[\"出题时想的是凑数让后期选手写筛写\",{\"1\":{\"412\":1}}],[\"既然最多只在子任务\",{\"1\":{\"735\":1}}],[\"既然每次只能发一个区间\",{\"1\":{\"559\":1}}],[\"既然每种颜色的下标有序\",{\"1\":{\"226\":1}}],[\"既然给的就是个合法的哈夫曼编码\",{\"1\":{\"408\":1}}],[\"合法就输出就直接算算文章长度输出就好\",{\"1\":{\"409\":1}}],[\"合法哈夫曼\",{\"0\":{\"406\":1}}],[\"合到一个节点上\",{\"1\":{\"406\":1}}],[\"合并每个点能到的点\",{\"1\":{\"444\":1}}],[\"合并同类块\",{\"1\":{\"321\":1}}],[\"合并在一起求\",{\"0\":{\"282\":1}}],[\"合并\",{\"1\":{\"127\":1,\"215\":2,\"251\":3}}],[\"走一步\",{\"1\":{\"495\":1}}],[\"走为上\",{\"0\":{\"445\":1}}],[\"走没走过\",{\"1\":{\"428\":1}}],[\"走过了\",{\"1\":{\"405\":1}}],[\"走到边界\",{\"1\":{\"766\":1}}],[\"走到\",{\"1\":{\"196\":1,\"352\":2,\"354\":1,\"355\":1,\"404\":2,\"495\":4}}],[\"跳转到程序部分\",{\"1\":{\"453\":1}}],[\"跳过\",{\"1\":{\"405\":1}}],[\"跳过去了\",{\"1\":{\"405\":1}}],[\"跳到了\",{\"1\":{\"12\":1}}],[\"牛调整到右边\",{\"1\":{\"403\":1}}],[\"画得真好看\",{\"1\":{\"401\":1}}],[\"参考代码\",{\"0\":{\"751\":1,\"754\":1,\"757\":1,\"760\":1,\"764\":1,\"767\":1,\"770\":1,\"773\":1,\"777\":1,\"780\":1,\"783\":1,\"786\":1,\"790\":1,\"793\":1,\"796\":1,\"799\":1},\"1\":{\"400\":1,\"402\":2,\"405\":1,\"448\":1}}],[\"送了\",{\"1\":{\"495\":1}}],[\"送了可以口算出来的\",{\"1\":{\"399\":1}}],[\"送达时间\",{\"1\":{\"244\":2}}],[\"猜三位数\",{\"0\":{\"654\":1}}],[\"猜错了就再交一次\",{\"1\":{\"550\":1}}],[\"猜数字作弊\",{\"0\":{\"398\":1}}],[\"猜一猜2\",{\"0\":{\"171\":1}}],[\"猜一猜\",{\"0\":{\"170\":1}}],[\"打出来这\",{\"1\":{\"735\":1}}],[\"打表找规律\",{\"1\":{\"838\":1}}],[\"打表\",{\"1\":{\"617\":1,\"735\":1}}],[\"打表的同学送的分数\",{\"1\":{\"397\":1}}],[\"打印\",{\"1\":{\"453\":1}}],[\"打草惊蛇\",{\"0\":{\"412\":1}}],[\"打地鼠\",{\"0\":{\"166\":1}}],[\"凑数\",{\"0\":{\"620\":1},\"1\":{\"737\":1}}],[\"凑数给愿意写\",{\"1\":{\"397\":1}}],[\"凑出了\",{\"1\":{\"126\":1}}],[\"子串取模\",{\"0\":{\"657\":1}}],[\"子序列的最短子串长度\",{\"1\":{\"504\":1}}],[\"子任务送了很多分\",{\"1\":{\"747\":1}}],[\"子任务其实是主要为了读错题的同学设置的\",{\"1\":{\"526\":1}}],[\"子任务\",{\"0\":{\"407\":1,\"408\":1,\"409\":1,\"410\":1,\"421\":1,\"446\":1,\"447\":1},\"1\":{\"397\":3,\"399\":1,\"402\":3,\"480\":8,\"492\":2,\"494\":1,\"512\":3,\"515\":3,\"518\":3,\"521\":3,\"524\":3,\"525\":3,\"526\":3,\"527\":3,\"530\":3,\"533\":3,\"537\":3,\"541\":3,\"544\":3,\"545\":3,\"546\":3,\"550\":3,\"553\":5,\"556\":3,\"559\":3,\"562\":3,\"563\":3,\"564\":3,\"565\":3,\"568\":3,\"571\":3,\"578\":3,\"582\":3,\"588\":3,\"591\":3,\"595\":4,\"598\":3,\"601\":3,\"604\":3,\"608\":4,\"611\":3,\"614\":3,\"626\":3,\"629\":3,\"639\":3,\"642\":3,\"645\":3,\"648\":3,\"652\":3,\"655\":3,\"658\":3,\"661\":3,\"665\":3,\"668\":3,\"671\":3,\"674\":2,\"678\":3,\"681\":3,\"684\":3,\"687\":3,\"691\":3,\"700\":3,\"704\":3,\"707\":3,\"720\":3,\"726\":3,\"734\":3,\"735\":3,\"736\":3,\"744\":3,\"809\":3,\"812\":3,\"815\":3,\"818\":3,\"822\":3,\"825\":3,\"828\":3,\"831\":3,\"835\":3,\"838\":4,\"841\":3,\"846\":3,\"850\":3,\"853\":3,\"856\":3,\"859\":3,\"863\":3,\"866\":3,\"871\":3,\"874\":3,\"878\":3,\"881\":3,\"884\":3,\"887\":3,\"891\":3,\"894\":3,\"897\":3}}],[\"子树\",{\"1\":{\"383\":1,\"384\":1}}],[\"余\",{\"1\":{\"397\":1}}],[\"余额\",{\"1\":{\"134\":1,\"135\":1,\"136\":1}}],[\"应该\",{\"1\":{\"665\":1}}],[\"应该是都可以满足\",{\"1\":{\"574\":1}}],[\"应该能得点分\",{\"1\":{\"563\":1}}],[\"应该也没什么难度\",{\"1\":{\"525\":1}}],[\"应该很好想到\",{\"1\":{\"413\":1}}],[\"应该放在从左往右第\",{\"1\":{\"397\":1}}],[\"应该被标记上\",{\"1\":{\"228\":1}}],[\"往前数\",{\"1\":{\"531\":2}}],[\"往下跑就能得到每节点的编码了\",{\"1\":{\"406\":1}}],[\"往右走到\",{\"1\":{\"405\":2}}],[\"往右狂奔或者折返回到牛\",{\"0\":{\"405\":1}}],[\"往右跳过牛\",{\"1\":{\"403\":1}}],[\"往左一段\",{\"1\":{\"403\":2}}],[\"往高位放\",{\"1\":{\"397\":1}}],[\"往后\",{\"1\":{\"302\":1,\"475\":1}}],[\"挖土机周赛\",{\"0\":{\"748\":1,\"761\":1,\"774\":1,\"787\":1,\"800\":1}}],[\"挖土机\",{\"0\":{\"396\":1,\"411\":1,\"416\":1,\"424\":1,\"429\":1,\"434\":1,\"439\":1,\"449\":1,\"454\":1,\"459\":1,\"468\":1,\"476\":1,\"481\":1,\"486\":1,\"491\":1,\"496\":1}}],[\"放到链表头\",{\"1\":{\"391\":1}}],[\"放进对顶堆\",{\"1\":{\"210\":2}}],[\"链表\",{\"0\":{\"391\":1}}],[\"辗转相除\",{\"0\":{\"389\":1}}],[\"辗转相减\",{\"0\":{\"388\":1}}],[\"男生前\",{\"1\":{\"374\":1}}],[\"正常求出最小值后\",{\"1\":{\"887\":1}}],[\"正常数组存储\",{\"1\":{\"859\":1}}],[\"正常堆\",{\"1\":{\"568\":1}}],[\"正解就是输出\",{\"1\":{\"547\":1}}],[\"正解其实就是分类讨论\",{\"1\":{\"527\":1}}],[\"正面比反面多\",{\"1\":{\"368\":1}}],[\"正数时的大小关系\",{\"1\":{\"685\":1}}],[\"正数补码与原码一致\",{\"1\":{\"86\":1}}],[\"正数反码与原码一致\",{\"1\":{\"86\":1}}],[\"正数为\",{\"1\":{\"86\":1}}],[\"解决先求谁在求谁的问题\",{\"1\":{\"366\":1}}],[\"化掉第一维\",{\"0\":{\"362\":1}}],[\"记住反斜杠本身也是个特殊字符\",{\"1\":{\"828\":1}}],[\"记住最大和次大的\",{\"1\":{\"440\":1}}],[\"记得使用long\",{\"1\":{\"565\":1}}],[\"记忆化加上就好了\",{\"1\":{\"467\":1}}],[\"记忆化搜索\",{\"0\":{\"359\":1}}],[\"记录有几段树的长度达到了\",{\"1\":{\"832\":1}}],[\"记录能不能变为\",{\"1\":{\"772\":1}}],[\"记录去掉\",{\"1\":{\"662\":1}}],[\"记录开心不开心即可\",{\"1\":{\"545\":1}}],[\"记录第\",{\"1\":{\"342\":1}}],[\"记录上一次出现余数\",{\"1\":{\"904\":1}}],[\"记录上一条线段的\",{\"1\":{\"312\":1,\"313\":1}}],[\"记录上一个选择的数\",{\"1\":{\"301\":1}}],[\"记录总的面积并\",{\"1\":{\"312\":1,\"313\":1}}],[\"记录简化后的货币系统大小\",{\"1\":{\"307\":1}}],[\"记录方案数\",{\"1\":{\"270\":1}}],[\"记录摧毁的房子\",{\"1\":{\"235\":1,\"236\":1,\"237\":1,\"239\":1}}],[\"记录答案\",{\"1\":{\"215\":1}}],[\"记录每个星球被摧毁后的答案\",{\"1\":{\"215\":1}}],[\"记录每个数当前在哪儿\",{\"1\":{\"173\":1}}],[\"记录当前的连通块数量\",{\"1\":{\"215\":1}}],[\"记录当前数的顺序\",{\"1\":{\"173\":1}}],[\"记录dfs走过的点\",{\"1\":{\"200\":1}}],[\"记录还能打几个人\",{\"1\":{\"197\":1}}],[\"记录最小的答案\",{\"1\":{\"320\":1}}],[\"记录最小的还没有被攻击的是哪一个\",{\"1\":{\"197\":1}}],[\"记录最大的面额\",{\"1\":{\"307\":1}}],[\"记录最终答案\",{\"1\":{\"146\":1}}],[\"记录那些位置操作了\",{\"1\":{\"154\":1}}],[\"记录超过\",{\"1\":{\"146\":2}}],[\"记录一共有多少次超过\",{\"1\":{\"146\":1}}],[\"记录\",{\"1\":{\"11\":3,\"12\":1,\"120\":1,\"124\":1,\"125\":1,\"235\":1,\"236\":1,\"237\":1,\"239\":1,\"475\":2}}],[\"价值\",{\"1\":{\"358\":1,\"362\":1}}],[\"价格\",{\"1\":{\"128\":1}}],[\"背包容量\",{\"1\":{\"358\":1,\"362\":1}}],[\"物品数量\",{\"1\":{\"358\":1,\"362\":1}}],[\"避免每次都要重新清空\",{\"1\":{\"352\":1}}],[\"避开差为2的限制\",{\"1\":{\"273\":1}}],[\"配合\",{\"1\":{\"352\":1}}],[\"型字符串\",{\"0\":{\"567\":1}}],[\"型\",{\"1\":{\"352\":1}}],[\"检测当前\",{\"1\":{\"352\":1}}],[\"检查是否为质数\",{\"1\":{\"735\":1}}],[\"检查是否有冲突\",{\"1\":{\"490\":1}}],[\"检查三个位置是否相等\",{\"1\":{\"732\":1}}],[\"检查全家福\",{\"1\":{\"732\":1}}],[\"检查周边有没有雷即可\",{\"1\":{\"700\":1}}],[\"检查所有情况\",{\"1\":{\"598\":1}}],[\"检查每个人的性别\",{\"1\":{\"521\":1}}],[\"检查答案是否大于等于\",{\"1\":{\"500\":1}}],[\"检查前缀问题\",{\"1\":{\"410\":1}}],[\"检查前一个位置会不会更好\",{\"1\":{\"310\":1}}],[\"检查文章总长度\",{\"1\":{\"410\":1}}],[\"检查可以在\",{\"1\":{\"362\":1}}],[\"检查去掉第\",{\"1\":{\"352\":1}}],[\"检查多少个时间满足这个要求即可\",{\"1\":{\"668\":1}}],[\"检查多少个面值无法被其他面值组合出来\",{\"1\":{\"307\":1}}],[\"检查多少组\",{\"1\":{\"258\":1}}],[\"检查间隔一行的两行有没有冲突\",{\"1\":{\"306\":1}}],[\"检查相邻两行是否有冲突\",{\"1\":{\"306\":1}}],[\"检查变成\",{\"1\":{\"286\":4}}],[\"检查能不能使不优美度小于等于\",{\"1\":{\"286\":2}}],[\"检查这个骑士能不能到\",{\"1\":{\"259\":1}}],[\"检查九宫格\",{\"1\":{\"248\":1}}],[\"检查最大速度为\",{\"1\":{\"244\":2}}],[\"检查到第几个垃圾的时候能出去\",{\"1\":{\"204\":1}}],[\"检查在\",{\"1\":{\"198\":1}}],[\"检查当前等式是否合法\",{\"1\":{\"184\":1,\"185\":1}}],[\"检查选择的数\",{\"1\":{\"301\":1}}],[\"检查选择\",{\"1\":{\"181\":2}}],[\"检查\",{\"1\":{\"169\":1,\"249\":1,\"258\":2,\"259\":1,\"307\":1,\"410\":1,\"414\":1,\"579\":1}}],[\"删掉所有\",{\"1\":{\"351\":1}}],[\"删除大小为1的块\",{\"1\":{\"321\":1}}],[\"容易看到其中隐含着一个对称的关系\",{\"1\":{\"909\":1}}],[\"容易被误解为只有直接依赖会得不到分\",{\"1\":{\"492\":1}}],[\"容易想到可以二分处理\",{\"1\":{\"437\":1}}],[\"容易发现前面的一串\",{\"1\":{\"904\":1}}],[\"容易发现每次只修改了一个位置\",{\"1\":{\"874\":1}}],[\"容易发现每七天的收费一样\",{\"1\":{\"515\":1}}],[\"容易发现就是要把每个\",{\"1\":{\"553\":1}}],[\"容易发现除了真的去模拟转盘旋转之外\",{\"1\":{\"541\":1}}],[\"容易发现当数据范围很大时上面的思路会超时\",{\"1\":{\"533\":1}}],[\"容易发现不可能先染色子节点再染色它的某个祖先节点\",{\"1\":{\"494\":1}}],[\"容易发现是当余数出现过了\",{\"1\":{\"489\":1}}],[\"容易发现\",{\"1\":{\"413\":1,\"415\":1,\"537\":1,\"626\":1,\"645\":1}}],[\"容易理解为是允许\",{\"1\":{\"351\":1}}],[\"容量下达到的最大价值\",{\"1\":{\"362\":1}}],[\"容器库\",{\"1\":{\"102\":1}}],[\"容器库常用内容\",{\"0\":{\"102\":1}}],[\"炮塔全拆了肯定行\",{\"1\":{\"350\":1}}],[\"减一就会变成无符号整型的最大值\",{\"1\":{\"842\":1}}],[\"减少\",{\"1\":{\"835\":1}}],[\"减去\",{\"1\":{\"349\":1,\"822\":1}}],[\"减法\",{\"1\":{\"58\":1}}],[\"去重后数组不包括结尾\",{\"1\":{\"349\":1}}],[\"去掉前两项之后的\",{\"1\":{\"838\":1}}],[\"去掉这些重复计算的就是答案了\",{\"1\":{\"661\":1}}],[\"去掉最高位\",{\"1\":{\"494\":1}}],[\"去掉栈顶小于等于\",{\"1\":{\"475\":1}}],[\"去掉只有\",{\"1\":{\"302\":1}}],[\"去掉不合理状态并合并\",{\"1\":{\"260\":1}}],[\"去掉第\",{\"1\":{\"259\":1}}],[\"去掉个位\",{\"1\":{\"97\":1}}],[\"几乎一样\",{\"1\":{\"887\":1}}],[\"几个子区间合法\",{\"0\":{\"802\":1}}],[\"几次能反转>\",{\"1\":{\"343\":1}}],[\"几点钟能出去\",{\"1\":{\"202\":1,\"203\":1}}],[\"维生素的第\",{\"1\":{\"340\":1}}],[\"维护一下这个前缀最大值就可以\",{\"1\":{\"818\":1}}],[\"维护拓扑序\",{\"1\":{\"366\":1}}],[\"维护路径\",{\"1\":{\"318\":1}}],[\"维护\",{\"1\":{\"258\":1}}],[\"三次方或三的幂\",{\"0\":{\"801\":1}}],[\"三数排序后输出第三个数即可\",{\"1\":{\"720\":1}}],[\"三位数重新排列\",{\"0\":{\"607\":1}}],[\"三个一样的点数\",{\"1\":{\"512\":1}}],[\"三个数\",{\"1\":{\"620\":1,\"655\":1}}],[\"三个数排序后输出即可\",{\"1\":{\"608\":1}}],[\"三个数时用类似的方法容斥即可\",{\"1\":{\"437\":1}}],[\"三个数的计算\",{\"1\":{\"343\":1}}],[\"三子棋\",{\"0\":{\"505\":1}}],[\"三三音乐\",{\"0\":{\"458\":1}}],[\"三国\",{\"0\":{\"451\":1}}],[\"三种维生素\",{\"1\":{\"340\":1}}],[\"三角形判断\",{\"0\":{\"99\":1}}],[\"种情况\",{\"1\":{\"655\":2}}],[\"种可能\",{\"1\":{\"489\":1}}],[\"种\",{\"1\":{\"478\":1}}],[\"种维生素\",{\"1\":{\"340\":1}}],[\"种上\",{\"1\":{\"218\":1}}],[\"卡路里量\",{\"1\":{\"340\":1}}],[\"卡路里量>\",{\"1\":{\"340\":1}}],[\"卡片\",{\"0\":{\"149\":1}}],[\"传统走迷宫的基础上\",{\"1\":{\"336\":1}}],[\"传纸条\",{\"0\":{\"177\":1}}],[\"恰好\",{\"1\":{\"335\":2}}],[\"摧毁\",{\"1\":{\"331\":2}}],[\"我建议同学们也可以采用这样的方法\",{\"1\":{\"874\":1}}],[\"我把打星队伍的排名挪到了最低\",{\"1\":{\"871\":1}}],[\"我自己的习惯是先把\",{\"1\":{\"822\":1}}],[\"我就用最简单的方式存下每条边\",{\"1\":{\"726\":1}}],[\"我的代码中有一些特殊处理\",{\"1\":{\"871\":1}}],[\"我的代码第一步就是先把递减的序列转换为对应等价的递增序列\",{\"1\":{\"704\":1}}],[\"我的写法是在中间位置数\",{\"1\":{\"329\":1}}],[\"我这里直接统计了每个人的排名\",{\"1\":{\"521\":1}}],[\"我这里给另一个做法\",{\"1\":{\"427\":1}}],[\"我也比较残忍\",{\"1\":{\"483\":1}}],[\"我看有一位同学就是用了\",{\"1\":{\"478\":1}}],[\"我给一个\",{\"1\":{\"465\":1}}],[\"我给个只学过条件判断的做法\",{\"1\":{\"460\":1}}],[\"我给了标程两倍以上的时间\",{\"1\":{\"457\":1}}],[\"我直接位运算处理了\",{\"1\":{\"458\":1}}],[\"我直接数学方法算了\",{\"1\":{\"458\":1}}],[\"我比较仁慈\",{\"1\":{\"458\":1}}],[\"我再抽空补一个视频题解\",{\"1\":{\"454\":1}}],[\"我题解先只给个简单的\",{\"1\":{\"454\":1}}],[\"我想的做法是找到一个倍增的构造方法\",{\"1\":{\"453\":1}}],[\"我本来打算卡\",{\"1\":{\"414\":1}}],[\"我用两个数组分别存了编码长度和编码\",{\"1\":{\"406\":1}}],[\"我一开始没发现子任务\",{\"1\":{\"405\":1}}],[\"我们这实际上告诉我们的是只要能变为\",{\"1\":{\"772\":1}}],[\"我们开三个数组\",{\"1\":{\"632\":1}}],[\"我们把颗球看做是一轮\",{\"1\":{\"632\":1}}],[\"我们把这样的判题方法叫做\",{\"1\":{\"551\":1}}],[\"我们要优先吃其中开心值最高的桃子\",{\"1\":{\"623\":1}}],[\"我们的策略是优先吃最开胃的桃子\",{\"1\":{\"623\":1}}],[\"我们需要思考所有可能的情况\",{\"1\":{\"622\":1}}],[\"我们直接输出这三个数就可以啦\",{\"1\":{\"620\":1}}],[\"我们可以通过\",{\"1\":{\"622\":1}}],[\"我们可以先类似于子任务\",{\"1\":{\"559\":1}}],[\"我们可以惊喜得发现\",{\"1\":{\"405\":1}}],[\"我们就可以专心考虑怎么算\",{\"1\":{\"661\":1}}],[\"我们就可以从头到尾模拟吃桃的过程\",{\"1\":{\"623\":1}}],[\"我们就怎么做\",{\"1\":{\"455\":1,\"456\":1,\"460\":1}}],[\"我们就肯定会选择最高位为\",{\"1\":{\"352\":1}}],[\"我们会发现实际储存的数大概是\",{\"1\":{\"91\":1}}],[\"我觉得更清晰\",{\"1\":{\"329\":1}}],[\"仍然加前面的\",{\"1\":{\"329\":1}}],[\"而第\",{\"1\":{\"838\":1}}],[\"而比\",{\"1\":{\"779\":1}}],[\"而要提前预处理做一些整理才能让后续事半功倍\",{\"1\":{\"704\":1}}],[\"而如果有相同开胃值的桃子\",{\"1\":{\"623\":1}}],[\"而字符串之间的关系运算已不符合数值之间的运算规则\",{\"1\":{\"622\":1}}],[\"而我们只需要输出其中一种即可\",{\"1\":{\"620\":1}}],[\"而且也可以进一步优化\",{\"1\":{\"611\":1}}],[\"而不是\",{\"1\":{\"578\":1}}],[\"而作为中间点有\",{\"1\":{\"505\":1}}],[\"而这个子问题是个非常经典的递推了\",{\"1\":{\"498\":1}}],[\"而这必然能达成\",{\"1\":{\"493\":1}}],[\"而当你求\",{\"1\":{\"495\":1}}],[\"而神自清\",{\"0\":{\"463\":1}}],[\"而心自静\",{\"0\":{\"462\":1}}],[\"而心扰之\",{\"0\":{\"460\":1}}],[\"而欲牵之\",{\"0\":{\"461\":1}}],[\"而根据题意只能量化编码为\",{\"1\":{\"458\":1}}],[\"而是直接采用了一个四维数组\",{\"1\":{\"874\":1}}],[\"而是最多只需要做当\",{\"1\":{\"792\":1}}],[\"而是返回去重后的结尾位置\",{\"1\":{\"349\":1}}],[\"而是用精度控制\",{\"1\":{\"91\":1}}],[\"而\",{\"1\":{\"328\":1,\"812\":1}}],[\"简化版问题的做法\",{\"0\":{\"328\":1}}],[\"简单暴力双重循环可以拿到\",{\"1\":{\"782\":1}}],[\"简单分支语句\",{\"1\":{\"809\":1}}],[\"简单分类讨论即可\",{\"1\":{\"776\":1}}],[\"简单分析\",{\"1\":{\"556\":1}}],[\"简单系动词\",{\"0\":{\"741\":1}}],[\"简单场的第二题已经这么难了\",{\"1\":{\"736\":1}}],[\"简单场直接用\",{\"1\":{\"626\":1}}],[\"简单计算题\",{\"1\":{\"694\":1}}],[\"简单枚举\",{\"1\":{\"668\":1}}],[\"简单三位数数位分解\",{\"1\":{\"652\":1,\"691\":1}}],[\"简单检查除以\",{\"1\":{\"642\":1}}],[\"简单数位分解\",{\"1\":{\"608\":1}}],[\"简单数学计算\",{\"1\":{\"878\":1}}],[\"简单数学计算及按格式输出\",{\"1\":{\"665\":1}}],[\"简单数学题\",{\"1\":{\"822\":1}}],[\"简单数学问题\",{\"1\":{\"739\":1}}],[\"简单数学运算\",{\"1\":{\"626\":1,\"639\":1}}],[\"简单数学\",{\"1\":{\"595\":1}}],[\"简单推理\",{\"1\":{\"601\":1}}],[\"简单来说就是写了另一个代码来判断你的答案是否正确\",{\"1\":{\"551\":1}}],[\"简单模拟\",{\"1\":{\"541\":1}}],[\"简单字符串题\",{\"1\":{\"884\":1}}],[\"简单字符串操作\",{\"1\":{\"671\":1}}],[\"简单字符串枚举\",{\"1\":{\"614\":1}}],[\"简单字符串处理及质数判断\",{\"1\":{\"537\":1}}],[\"简单字符串中的字符统计+排序\",{\"1\":{\"518\":1}}],[\"简单条件判断语句\",{\"1\":{\"891\":1}}],[\"简单条件判断\",{\"1\":{\"530\":1}}],[\"简单替换\",{\"1\":{\"487\":1}}],[\"简单的贪心模拟\",{\"1\":{\"859\":1}}],[\"简单的条件判断语句\",{\"1\":{\"850\":1}}],[\"简单的条件判断与求和\",{\"1\":{\"825\":1}}],[\"简单的字符串处理\",{\"1\":{\"841\":1}}],[\"简单的字符串枚举\",{\"1\":{\"828\":1}}],[\"简单的循环输入与求和\",{\"1\":{\"825\":1}}],[\"简单的数学\",{\"1\":{\"812\":1}}],[\"简单的输出\",{\"1\":{\"349\":1}}],[\"简单的枚举\",{\"1\":{\"345\":1}}],[\"简单哈希做法\",{\"0\":{\"190\":1}}],[\"简单版\",{\"0\":{\"112\":1}}],[\"简单框架\",{\"0\":{\"49\":1}}],[\"查不到就去\",{\"1\":{\"574\":1}}],[\"查找\",{\"0\":{\"327\":1}}],[\"查询末尾\",{\"1\":{\"216\":2}}],[\"查询\",{\"0\":{\"23\":1,\"24\":1,\"213\":1,\"214\":1},\"1\":{\"216\":1,\"237\":1,\"239\":1}}],[\"满日问题\",{\"1\":{\"740\":1}}],[\"满足条件的数的数量了\",{\"1\":{\"661\":1}}],[\"满足条件的数的数量\",{\"1\":{\"661\":1}}],[\"满足条件的数量减去\",{\"1\":{\"661\":1}}],[\"满足条件的这些与在一起肯定还是包含\",{\"1\":{\"326\":1}}],[\"满足\",{\"1\":{\"462\":1}}],[\"满分需要自己多尝试找结论\",{\"1\":{\"909\":1}}],[\"满分需要一个小技巧\",{\"1\":{\"874\":1}}],[\"满分需要一些数学方式处理\",{\"1\":{\"661\":1}}],[\"满分需要用贪心的思想去分析判断\",{\"1\":{\"818\":1}}],[\"满分就是个分组背包的小变种\",{\"1\":{\"479\":1}}],[\"满分除了做法本身之外还有两个问题\",{\"1\":{\"478\":1}}],[\"满分的\",{\"1\":{\"453\":1}}],[\"满分超纲\",{\"1\":{\"442\":1}}],[\"满分只需要注意本来要走\",{\"1\":{\"423\":1}}],[\"满分参考代码2\",{\"0\":{\"576\":1}}],[\"满分参考代码1\",{\"0\":{\"575\":1}}],[\"满分参考代码\",{\"0\":{\"513\":1,\"516\":1,\"519\":1,\"522\":1,\"531\":1,\"535\":1,\"538\":1,\"539\":1,\"542\":1,\"551\":1,\"554\":1,\"557\":1,\"560\":1,\"569\":1,\"572\":1,\"579\":1,\"583\":1,\"586\":1,\"589\":1,\"592\":1,\"596\":1,\"599\":1,\"602\":1,\"605\":1,\"609\":1,\"612\":1,\"615\":1,\"618\":1,\"627\":1,\"630\":1,\"633\":1,\"636\":1,\"640\":1,\"643\":1,\"646\":1,\"649\":1,\"653\":1,\"656\":1,\"659\":1,\"662\":1,\"666\":1,\"669\":1,\"672\":1,\"675\":1,\"679\":1,\"682\":1,\"685\":1,\"688\":1,\"692\":1,\"695\":1,\"698\":1,\"701\":1,\"705\":1,\"708\":1,\"711\":1,\"714\":1,\"718\":1,\"721\":1,\"724\":1,\"727\":1,\"810\":1,\"813\":1,\"816\":1,\"819\":1,\"823\":1,\"826\":1,\"829\":1,\"832\":1,\"836\":1,\"839\":1,\"842\":1,\"847\":1,\"851\":1,\"854\":1,\"857\":1,\"860\":1,\"864\":1,\"867\":1,\"872\":1,\"875\":1,\"879\":1,\"882\":1,\"885\":1,\"888\":1,\"892\":1,\"895\":1,\"898\":1,\"901\":1,\"905\":1,\"910\":1},\"1\":{\"397\":1,\"410\":1}}],[\"满分代码\",{\"0\":{\"384\":1}}],[\"满分\",{\"0\":{\"249\":1,\"380\":1,\"400\":1},\"1\":{\"413\":1}}],[\"满分做法较多\",{\"1\":{\"815\":1}}],[\"满分做法的话有很多\",{\"1\":{\"802\":1}}],[\"满分做法其实就是把字母全变大写或者小写\",{\"1\":{\"546\":1}}],[\"满分做法除了无解情况\",{\"1\":{\"544\":1}}],[\"满分做法首先要能看出来先二分答案\",{\"1\":{\"485\":1}}],[\"满分做法\",{\"0\":{\"173\":1},\"1\":{\"502\":1,\"503\":1,\"504\":1,\"505\":1,\"507\":1,\"508\":1,\"509\":2,\"620\":1,\"621\":1,\"622\":1,\"623\":1}}],[\"充电问题\",{\"0\":{\"325\":1}}],[\"遇到一样的颜色就答案加一\",{\"1\":{\"897\":1}}],[\"遇到一个地鼠就敲\",{\"1\":{\"166\":1}}],[\"遇到其他字符就把前面的字母字符串输出即可\",{\"1\":{\"795\":1}}],[\"遇到字母就继续记录下来\",{\"1\":{\"795\":1}}],[\"遇到这一轮开始前\",{\"1\":{\"632\":1}}],[\"遇到循环了还没找到就停\",{\"1\":{\"489\":1}}],[\"遇到零就说明上一段结束了\",{\"1\":{\"324\":1}}],[\"遇到非零就加一\",{\"1\":{\"324\":1}}],[\"年开始计算\",{\"1\":{\"740\":1}}],[\"年份\",{\"1\":{\"572\":1}}],[\"年一定是闰年\",{\"1\":{\"527\":1}}],[\"年\",{\"0\":{\"322\":1},\"1\":{\"527\":1,\"740\":3}}],[\"修改水果连接关系\",{\"1\":{\"321\":1}}],[\"修改水果数量\",{\"1\":{\"321\":1}}],[\"修复公路\",{\"0\":{\"191\":1}}],[\"递推\",{\"0\":{\"358\":1}}],[\"递减的需求\",{\"1\":{\"320\":1}}],[\"递归写法\",{\"0\":{\"272\":1}}],[\"调用sort\",{\"1\":{\"623\":1}}],[\"调虎离山\",{\"0\":{\"414\":1}}],[\"调整数列\",{\"1\":{\"705\":1}}],[\"调整为\",{\"1\":{\"483\":1}}],[\"调整到\",{\"1\":{\"320\":1}}],[\"调整最高点\",{\"1\":{\"320\":1}}],[\"调试\",{\"1\":{\"198\":1,\"444\":1}}],[\"让\",{\"1\":{\"614\":1}}],[\"让右边递减\",{\"1\":{\"320\":2}}],[\"让左边递增\",{\"1\":{\"320\":2}}],[\"让互补串作为当前串\",{\"1\":{\"160\":1}}],[\"作为语法周赛的第一题\",{\"1\":{\"763\":1}}],[\"作为中间点的四个方向\",{\"1\":{\"505\":1}}],[\"作为端点的八个方向\",{\"1\":{\"505\":1}}],[\"作为端点一共有\",{\"1\":{\"505\":1}}],[\"作为全局变量挂掉了\",{\"1\":{\"477\":1}}],[\"作为第二题直接爆搜就好了\",{\"1\":{\"400\":1}}],[\"作为最高点的答案\",{\"1\":{\"320\":1}}],[\"作为最高点\",{\"1\":{\"320\":2}}],[\"作为表达式时\",{\"1\":{\"64\":2}}],[\"超过\",{\"1\":{\"707\":1}}],[\"超过是没有意义的\",{\"1\":{\"635\":1}}],[\"超时代码\",{\"1\":{\"320\":1}}],[\"超速车多一台\",{\"1\":{\"198\":1}}],[\"超速车数量\",{\"1\":{\"198\":1}}],[\"超速车的数量\",{\"1\":{\"198\":2}}],[\"超速区间按照结束位置排序\",{\"1\":{\"198\":1}}],[\"超速了且在最后测速点之前抄的\",{\"1\":{\"198\":2}}],[\"超速检测\",{\"0\":{\"198\":1}}],[\"とてもたのしい家庭菜園\",{\"0\":{\"320\":1}}],[\"江西\",{\"0\":{\"315\":1}}],[\"坐标\",{\"1\":{\"313\":1,\"314\":1}}],[\"范围内\",{\"1\":{\"856\":1}}],[\"范围内就输出\",{\"1\":{\"582\":1}}],[\"范围内的每个数都跑一遍这段代码看看输出是几\",{\"1\":{\"399\":1}}],[\"范围内的所有字母\",{\"1\":{\"126\":1}}],[\"范围\",{\"1\":{\"312\":1,\"313\":1,\"508\":1}}],[\"矩阵最大列数\",{\"1\":{\"377\":1}}],[\"矩阵最大行数\",{\"1\":{\"377\":1}}],[\"矩阵取数游戏\",{\"0\":{\"176\":1}}],[\"矩形右边竖线\",{\"1\":{\"312\":1,\"313\":1}}],[\"矩形左边竖线\",{\"1\":{\"312\":1,\"313\":1}}],[\"矩形的数量\",{\"1\":{\"312\":1,\"313\":1}}],[\"扫描线\",{\"0\":{\"311\":1},\"1\":{\"313\":2,\"314\":1}}],[\"木材仓库\",{\"0\":{\"308\":1}}],[\"面额的数量\",{\"1\":{\"307\":1}}],[\"货币系统\",{\"0\":{\"307\":1}}],[\"啥都不摆的时候是一种合法方案\",{\"1\":{\"306\":1}}],[\"啥是字符串\",{\"0\":{\"56\":1}}],[\"啥是编程\",{\"0\":{\"34\":1}}],[\"爆搜能跑出来子任务\",{\"1\":{\"402\":1}}],[\"爆搜\",{\"0\":{\"305\":1}}],[\"摆上马\",{\"0\":{\"304\":1}}],[\"魔法少女小scarlet\",{\"0\":{\"299\":1}}],[\"共\",{\"1\":{\"298\":2,\"404\":1,\"497\":1}}],[\"世界冰球锦标赛\",{\"0\":{\"298\":1}}],[\"世纪闰年\",{\"1\":{\"98\":1}}],[\"格点编号\",{\"1\":{\"295\":1}}],[\"电路维修\",{\"0\":{\"294\":1}}],[\"花神游历各国\",{\"0\":{\"290\":1}}],[\"花色\",{\"1\":{\"193\":1}}],[\"```cpp\",{\"1\":{\"289\":1,\"313\":1}}],[\"```\",{\"1\":{\"289\":1,\"313\":1}}],[\"奶酪\",{\"0\":{\"289\":1},\"1\":{\"289\":1}}],[\"奶牛晒衣服\",{\"0\":{\"250\":1}}],[\"需求码长度和需求码\",{\"1\":{\"288\":1}}],[\"需要一些基础的数学同余的概念\",{\"1\":{\"904\":1}}],[\"需要一些数学思维\",{\"1\":{\"866\":1}}],[\"需要特殊处理\",{\"1\":{\"832\":1}}],[\"需要用转义模式\",{\"1\":{\"828\":1}}],[\"需要最后的答案可以达到\",{\"1\":{\"825\":1}}],[\"需要将\",{\"1\":{\"622\":1}}],[\"需要熟练掌握结构体\",{\"1\":{\"623\":1}}],[\"需要熟练掌握分支\",{\"1\":{\"622\":1}}],[\"需要熟练掌握二维数组以及嵌套循环的使用\",{\"1\":{\"509\":1}}],[\"需要熟练掌握二维数组以及枚举思想并有一定的程序优化能力\",{\"1\":{\"505\":1}}],[\"需要在两个相同的字符中间断开翻转\",{\"1\":{\"601\":1}}],[\"需要使用\",{\"1\":{\"524\":1,\"825\":1,\"878\":1}}],[\"需要掌握分支以及字符和数字之间的转换\",{\"1\":{\"507\":1}}],[\"需要学过字符串并找到正确的枚举策略可以拿到满分\",{\"1\":{\"504\":1}}],[\"需要先建图\",{\"1\":{\"442\":1}}],[\"需要留充足时间把送的分拿满\",{\"1\":{\"438\":1}}],[\"需要进一步推\",{\"1\":{\"415\":1}}],[\"需要的最少重量\",{\"1\":{\"361\":1}}],[\"需要递增\",{\"1\":{\"320\":1}}],[\"需要多少次\",{\"1\":{\"286\":4}}],[\"需要占用烘干机的时间\",{\"1\":{\"250\":2}}],[\"需要几个人\",{\"1\":{\"219\":2}}],[\"需要注意数据范围\",{\"1\":{\"878\":1}}],[\"需要注意和求和的初始化为\",{\"1\":{\"866\":1}}],[\"需要注意不能做到\",{\"1\":{\"792\":1}}],[\"需要注意本题模数是\",{\"1\":{\"578\":1}}],[\"需要注意如果可以整除\",{\"1\":{\"544\":1}}],[\"需要注意空格在这题不属于标点符号\",{\"1\":{\"518\":1}}],[\"需要注意交互题不能些输入输出优化那两行代码\",{\"1\":{\"445\":1}}],[\"需要注意\",{\"1\":{\"211\":1,\"524\":1,\"595\":1,\"891\":1}}],[\"需要开启的测速点数量\",{\"1\":{\"198\":1}}],[\"需要全\",{\"1\":{\"160\":1,\"161\":1}}],[\"需要对\",{\"1\":{\"151\":1}}],[\"需要给\",{\"1\":{\"19\":1,\"20\":1,\"21\":1}}],[\"图书管理员\",{\"0\":{\"288\":1}}],[\"常数是非常小的\",{\"1\":{\"611\":1}}],[\"常规获胜规则\",{\"1\":{\"513\":1}}],[\"常用的转义符有\",{\"1\":{\"697\":1}}],[\"常用\",{\"0\":{\"284\":1}}],[\"常见范围为\",{\"1\":{\"83\":1}}],[\"常见评测结果\",{\"0\":{\"69\":1}}],[\"常见数据类型\",{\"0\":{\"61\":1}}],[\"文件\",{\"0\":{\"696\":1}}],[\"文章长度就是\",{\"1\":{\"408\":1}}],[\"文章长度就是单词数量乘以\",{\"1\":{\"407\":1}}],[\"文本串\",{\"1\":{\"283\":1}}],[\"文档\",{\"1\":{\"102\":1}}],[\"模数为\",{\"1\":{\"658\":1}}],[\"模拟的过程是每一个周期\",{\"1\":{\"632\":1}}],[\"模拟遇到同样的时\",{\"1\":{\"632\":1}}],[\"模拟吃桃子的过程计算最大开心程度\",{\"1\":{\"623\":1}}],[\"模拟\",{\"1\":{\"578\":1,\"645\":1}}],[\"模拟赛\",{\"0\":{\"396\":1,\"411\":1,\"416\":1,\"424\":1,\"429\":1,\"434\":1,\"439\":1,\"449\":1,\"454\":1,\"459\":1,\"468\":1,\"476\":1,\"481\":1,\"486\":1,\"491\":1,\"496\":1}}],[\"模式串\",{\"1\":{\"283\":1}}],[\"模板\",{\"0\":{\"233\":1,\"281\":1,\"285\":1,\"311\":1},\"1\":{\"17\":1,\"19\":1,\"313\":1}}],[\"显然上面式子意味着\",{\"1\":{\"904\":1}}],[\"显然贪心选择\",{\"1\":{\"818\":1}}],[\"显然对应的前一个数\",{\"1\":{\"818\":1}}],[\"显然对于字符串\",{\"1\":{\"645\":1}}],[\"显然如果想要进入第二轮\",{\"1\":{\"779\":1}}],[\"显然如果要断开子树\",{\"1\":{\"433\":1}}],[\"显然接下来对这个步数取余\",{\"1\":{\"766\":1}}],[\"显然此时不能模拟了\",{\"1\":{\"766\":1}}],[\"显然按顺序贪心即可\",{\"1\":{\"756\":1}}],[\"显然没法在规定的时间空间限制下算出来\",{\"1\":{\"735\":1}}],[\"显然我们只需要记录前三名的数\",{\"1\":{\"720\":1}}],[\"显然麻烦的点是情况非常多\",{\"1\":{\"704\":1}}],[\"显然核心就是找\",{\"1\":{\"668\":1}}],[\"显然可能是\",{\"1\":{\"661\":1}}],[\"显然可以用所有\",{\"1\":{\"604\":1}}],[\"显然可以列举出来所有情况\",{\"1\":{\"601\":1}}],[\"显然空间占用就是考虑有几个整块\",{\"1\":{\"642\":1}}],[\"显然某个\",{\"1\":{\"639\":1}}],[\"显然输出\",{\"1\":{\"626\":1}}],[\"显然轮数为\",{\"1\":{\"626\":1}}],[\"显然无法再使用\",{\"1\":{\"622\":1}}],[\"显然直接输出字符串\",{\"1\":{\"645\":1}}],[\"显然直接输出\",{\"1\":{\"608\":1}}],[\"显然直接枚举找个答案就好\",{\"1\":{\"469\":1}}],[\"显然会做成一个边长是\",{\"1\":{\"595\":1}}],[\"显然不可能买前两种鸡了\",{\"1\":{\"611\":1}}],[\"显然不可能有效\",{\"1\":{\"556\":1}}],[\"显然不停减\",{\"1\":{\"418\":1}}],[\"显然在本题中\",{\"1\":{\"531\":1}}],[\"显然要花的钱有\",{\"1\":{\"524\":1}}],[\"显然要尽可能把\",{\"1\":{\"397\":1}}],[\"显然哪种能覆盖更多就选哪种即可\",{\"1\":{\"485\":1}}],[\"显然第一个人需要\",{\"1\":{\"480\":1}}],[\"显然发现可以直接先拉\",{\"1\":{\"480\":1}}],[\"显然每次算某个词的时候\",{\"1\":{\"467\":1}}],[\"显然每次走能走到的点中最小的那个是最有选项\",{\"1\":{\"428\":1}}],[\"显然只能拿到\",{\"1\":{\"802\":1}}],[\"显然只要把都加到水最多的水杯的水量即可\",{\"1\":{\"859\":1}}],[\"显然只要下一次会死\",{\"1\":{\"747\":1}}],[\"显然只要所有输入的\",{\"1\":{\"578\":1}}],[\"显然只要每个人都和所有没有同群的人拉个群就好了\",{\"1\":{\"480\":1}}],[\"显然只有当\",{\"1\":{\"801\":1}}],[\"显然只有\",{\"1\":{\"500\":1}}],[\"显然只有两种情况\",{\"1\":{\"462\":1}}],[\"显然只需要从\",{\"1\":{\"792\":1}}],[\"显然只需要\",{\"1\":{\"453\":1}}],[\"显然最左边的人需要负责把左边的踏满\",{\"1\":{\"485\":1}}],[\"显然最多\",{\"1\":{\"453\":1}}],[\"显然最优方案就是最大速度狂飙\",{\"1\":{\"244\":2}}],[\"显然\",{\"1\":{\"451\":1,\"553\":1,\"635\":1,\"661\":1,\"668\":1}}],[\"显然答案为\",{\"1\":{\"450\":1}}],[\"显然因为还有稻草人数量要求\",{\"1\":{\"426\":1}}],[\"显然开不下\",{\"1\":{\"422\":1}}],[\"显然一个暴力枚举的做法就是对\",{\"1\":{\"399\":1}}],[\"显然这是\",{\"1\":{\"504\":1}}],[\"显然这是段二分的代码\",{\"1\":{\"399\":1}}],[\"显然这两个数的公倍数不能要\",{\"1\":{\"437\":1}}],[\"显然这个子任务的输出是\",{\"1\":{\"397\":1}}],[\"显然就不需要操作了\",{\"1\":{\"556\":1}}],[\"显然就是模拟看每一位\",{\"1\":{\"489\":1}}],[\"显然就是看哪个城墙被覆盖的炮塔最少\",{\"1\":{\"350\":1}}],[\"显然就需要考虑每个物品放到\",{\"1\":{\"280\":1}}],[\"显然全都要选\",{\"1\":{\"326\":1}}],[\"组成小组只有四种类型\",{\"1\":{\"635\":1}}],[\"组初赛常考的哈夫曼编码\",{\"1\":{\"406\":1}}],[\"组\",{\"1\":{\"280\":1}}],[\"组关系\",{\"1\":{\"243\":1,\"251\":2}}],[\"剪枝\",{\"0\":{\"279\":1}}],[\"已有分组组数\",{\"1\":{\"278\":1,\"279\":1}}],[\"已经被标记过\",{\"1\":{\"228\":1}}],[\"已经确定过了并且正确\",{\"1\":{\"186\":1}}],[\"差分之和\",{\"1\":{\"275\":1}}],[\"差为\",{\"1\":{\"221\":1}}],[\"待统计得数字\",{\"1\":{\"270\":1}}],[\"根号\",{\"0\":{\"730\":1}}],[\"根节点为\",{\"1\":{\"268\":1}}],[\"根据上面的结论处理即可\",{\"1\":{\"909\":1}}],[\"根据省一等奖分数线\",{\"1\":{\"750\":1}}],[\"根据符号决定怎么计算即可\",{\"1\":{\"745\":1}}],[\"根据哪个是\",{\"1\":{\"744\":1}}],[\"根据排列组合的逻辑\",{\"1\":{\"742\":1}}],[\"根据当前系动词前面的单词情况\",{\"1\":{\"741\":1}}],[\"根据那一个雷所处的位置\",{\"1\":{\"700\":1}}],[\"根据个位写是个\",{\"1\":{\"691\":1}}],[\"根据字符判断单位即可\",{\"1\":{\"678\":1}}],[\"根据题意\",{\"1\":{\"621\":1}}],[\"根据题目描述\",{\"1\":{\"537\":1}}],[\"根据题目描述容易发现答案都是\",{\"1\":{\"537\":1}}],[\"根据数据范围\",{\"1\":{\"502\":1}}],[\"根据最少时间生成方案\",{\"1\":{\"219\":2}}],[\"根据贪心原理\",{\"1\":{\"127\":1}}],[\"根据\",{\"1\":{\"127\":1,\"146\":1,\"158\":1,\"530\":1,\"541\":1,\"629\":1,\"736\":1}}],[\"病毒检测\",{\"0\":{\"268\":1}}],[\"完全不超纲\",{\"1\":{\"726\":1}}],[\"完整一周的价格\",{\"1\":{\"516\":1}}],[\"完整题解标程晚些给出\",{\"1\":{\"449\":1}}],[\"完整的自己本身\",{\"1\":{\"335\":1}}],[\"完整含义\",{\"0\":{\"48\":1}}],[\"完成该题了\",{\"1\":{\"818\":1}}],[\"完成\",{\"1\":{\"267\":1}}],[\"马步距离\",{\"0\":{\"267\":1}}],[\"询问的编号>\",{\"1\":{\"266\":1}}],[\"临时字符串\",{\"1\":{\"262\":1,\"263\":1,\"264\":1}}],[\"口算出答案后直接输出对应的结果即可\",{\"1\":{\"530\":1}}],[\"口算练习题\",{\"0\":{\"261\":1}}],[\"口算训练\",{\"0\":{\"59\":1}}],[\"管道数量\",{\"1\":{\"260\":1}}],[\"宽\",{\"1\":{\"260\":1}}],[\"飞扬的小鸟\",{\"0\":{\"260\":1}}],[\"会在\",{\"1\":{\"668\":1}}],[\"会超\",{\"1\":{\"470\":1}}],[\"会刷新缓冲区导致超时\",{\"1\":{\"461\":1}}],[\"会解除掉\",{\"1\":{\"445\":1}}],[\"会发现其实是有规律的\",{\"1\":{\"402\":1}}],[\"会合\",{\"1\":{\"259\":1}}],[\"会自动初始化为\",{\"1\":{\"3\":1}}],[\"骑士坐标\",{\"1\":{\"259\":1}}],[\"骑士数量\",{\"1\":{\"259\":1}}],[\"亚瑟王的宫殿\",{\"0\":{\"259\":1}}],[\"状态定义为前\",{\"1\":{\"499\":1}}],[\"状态定义和转移方程看下面的代码吧\",{\"1\":{\"495\":1}}],[\"状态的\",{\"1\":{\"109\":1}}],[\"状压dp\",{\"0\":{\"306\":1}}],[\"状压\",{\"0\":{\"257\":1,\"280\":1}}],[\"互不相同又都是\",{\"1\":{\"588\":1}}],[\"互不侵犯\",{\"0\":{\"252\":1}}],[\"互补串数量\",{\"1\":{\"161\":1}}],[\"互补串\",{\"1\":{\"160\":1}}],[\"团伙\",{\"0\":{\"251\":1}}],[\"秒还需要烘的量\",{\"1\":{\"250\":2}}],[\"秒能不能踏遍呢\",{\"1\":{\"485\":1}}],[\"秒能自然烘干的量\",{\"1\":{\"250\":2}}],[\"秒能否烘干所有衣服\",{\"1\":{\"250\":2}}],[\"撤销影响\",{\"1\":{\"249\":1}}],[\"填\",{\"1\":{\"249\":1}}],[\"填表\",{\"0\":{\"109\":1}}],[\"九行都填完了就检查\",{\"1\":{\"248\":1,\"249\":1}}],[\"纯暴力\",{\"0\":{\"248\":1}}],[\"纯暴力搜索\",{\"0\":{\"202\":1}}],[\"六个数字\",{\"1\":{\"246\":1}}],[\"斯诺登的密码\",{\"0\":{\"246\":1}}],[\"段\",{\"1\":{\"245\":1}}],[\"村村通\",{\"0\":{\"243\":1}}],[\"深基17\",{\"0\":{\"308\":1}}],[\"深搜+记忆化搜索+最少线段覆盖\",{\"0\":{\"242\":1}}],[\"深度\",{\"1\":{\"15\":1}}],[\"引水入城\",{\"0\":{\"240\":1}}],[\"略\",{\"1\":{\"238\":1,\"250\":1,\"271\":1}}],[\"节点\",{\"1\":{\"237\":2,\"239\":2,\"291\":1,\"383\":2,\"384\":2}}],[\"节点数量\",{\"1\":{\"23\":1}}],[\"认为右边第一个被摧毁的是\",{\"1\":{\"236\":1,\"237\":1,\"239\":1}}],[\"认为左边第一个被摧毁的是\",{\"1\":{\"236\":1,\"237\":1,\"239\":1}}],[\"鬼子进村\",{\"0\":{\"234\":1}}],[\"敲砖块\",{\"0\":{\"232\":1}}],[\"目标颜色\",{\"1\":{\"494\":1}}],[\"目标的位置\",{\"1\":{\"230\":1}}],[\"目前下一行被变成了\",{\"1\":{\"109\":1,\"110\":1}}],[\"广搜+递推+最少线段覆盖\",{\"0\":{\"241\":1}}],[\"广搜\",{\"0\":{\"230\":1,\"231\":1},\"1\":{\"259\":1}}],[\"八数码难题\",{\"0\":{\"229\":1}}],[\"八皇后\",{\"0\":{\"217\":1}}],[\"未编号\",{\"1\":{\"228\":1}}],[\"封锁阳光大学\",{\"0\":{\"228\":1}}],[\"封装好的结构体\",{\"0\":{\"3\":1}}],[\"低消\",{\"1\":{\"224\":1,\"225\":1,\"226\":1}}],[\"同时把两个人的分数减去同样的分数\",{\"1\":{\"632\":1}}],[\"同时记录最小值\",{\"1\":{\"504\":1}}],[\"同负\",{\"1\":{\"622\":1}}],[\"同正\",{\"1\":{\"622\":1}}],[\"同学们可以课下再改一下\",{\"1\":{\"546\":1}}],[\"同色前缀和\",{\"1\":{\"224\":1}}],[\"同步往上走\",{\"1\":{\"12\":1}}],[\"书的复制\",{\"0\":{\"219\":1}}],[\"砍掉\",{\"1\":{\"218\":1}}],[\"砍掉了多少棵树苗\",{\"1\":{\"218\":1}}],[\"空城计\",{\"0\":{\"438\":1}}],[\"空穴\",{\"1\":{\"218\":1}}],[\"空串也是字符串\",{\"1\":{\"56\":1}}],[\"增强版\",{\"0\":{\"218\":1}}],[\"增加了\",{\"1\":{\"812\":1}}],[\"增加了一个数的送分情况和三个数的更复杂的容斥\",{\"1\":{\"437\":1}}],[\"增加\",{\"1\":{\"64\":2}}],[\"强制在线\",{\"1\":{\"216\":2}}],[\"恢复了第\",{\"1\":{\"215\":1}}],[\"恢复所有\",{\"1\":{\"215\":1}}],[\"恢复\",{\"1\":{\"215\":2}}],[\"建议能只用整型就只用整型\",{\"1\":{\"734\":1}}],[\"建立一个\",{\"1\":{\"494\":1}}],[\"建立除了被摧毁的星球之外的连接关系\",{\"1\":{\"215\":1}}],[\"建新图\",{\"1\":{\"444\":1}}],[\"建图\",{\"1\":{\"295\":1,\"444\":1}}],[\"建树\",{\"1\":{\"216\":1,\"410\":1}}],[\"建线段树\",{\"1\":{\"19\":1,\"20\":1,\"21\":1}}],[\"编码\",{\"1\":{\"410\":1}}],[\"编号第几小的思维场\",{\"0\":{\"625\":1}}],[\"编号\",{\"1\":{\"228\":1}}],[\"编号从\",{\"1\":{\"215\":1,\"313\":1,\"314\":1}}],[\"编译失败\",{\"1\":{\"69\":1}}],[\"替换为了对应的排名\",{\"1\":{\"213\":1,\"214\":1}}],[\"权值树状数组\",{\"1\":{\"213\":1,\"214\":1}}],[\"离线处理\",{\"0\":{\"394\":1},\"1\":{\"735\":1}}],[\"离线+并查集\",{\"0\":{\"14\":1}}],[\"离散化+权值线段树做法\",{\"0\":{\"312\":1},\"1\":{\"313\":1}}],[\"离散化+权值树状数组+第\",{\"1\":{\"212\":1}}],[\"离散化\",{\"1\":{\"213\":1,\"214\":1,\"258\":1,\"312\":2,\"313\":2}}],[\"协调两边\",{\"1\":{\"210\":1}}],[\"做一次肯定是不够的\",{\"1\":{\"772\":1}}],[\"做\",{\"1\":{\"499\":1}}],[\"做了\",{\"1\":{\"413\":1}}],[\"做下一步\",{\"1\":{\"249\":1}}],[\"做下一个位置\",{\"1\":{\"185\":1,\"186\":2}}],[\"做到了第\",{\"1\":{\"270\":1}}],[\"做到了\",{\"1\":{\"237\":2,\"239\":2,\"291\":1}}],[\"做法很多\",{\"1\":{\"614\":1}}],[\"做法\",{\"0\":{\"210\":1,\"868\":1,\"869\":1},\"1\":{\"585\":1,\"655\":2,\"668\":2,\"822\":2,\"859\":1}}],[\"插入的数为\",{\"1\":{\"216\":2}}],[\"插入到正序的第len个\",{\"1\":{\"216\":1}}],[\"插入到\",{\"1\":{\"209\":3}}],[\"插入排序\",{\"0\":{\"30\":1},\"1\":{\"30\":1}}],[\"利用\",{\"1\":{\"869\":1}}],[\"利用高斯求和公式得出计算公式为\",{\"1\":{\"742\":1}}],[\"利用桶统计每个数字出现的次数\",{\"1\":{\"742\":1}}],[\"利用子任务\",{\"1\":{\"578\":1}}],[\"利用题面给的代码\",{\"1\":{\"578\":1}}],[\"利用样例数据配合条件判断完成即可\",{\"1\":{\"571\":1}}],[\"利用拓扑排序\",{\"0\":{\"366\":1}}],[\"利用记忆化搜索\",{\"0\":{\"365\":1}}],[\"利用字符串流\",{\"0\":{\"265\":1}}],[\"利用多重集的满分\",{\"0\":{\"211\":1}}],[\"利用插入排序的\",{\"0\":{\"209\":1}}],[\"利用结束程序的语句\",{\"0\":{\"135\":1}}],[\"银行贷款\",{\"0\":{\"205\":1}}],[\"生活大爆炸版石头剪刀布\",{\"0\":{\"227\":1}}],[\"生命可以达到\",{\"1\":{\"204\":1}}],[\"生命为\",{\"1\":{\"204\":1}}],[\"生成所有竖线\",{\"1\":{\"313\":1,\"314\":1}}],[\"生成所有可能的表达式并计算结果\",{\"1\":{\"40\":1}}],[\"生成互补串并检查互补串数量\",{\"1\":{\"161\":1}}],[\"生成解\",{\"1\":{\"158\":1}}],[\"活不下来时\",{\"1\":{\"203\":1}}],[\"写出来子任务3应该没有什么难度\",{\"1\":{\"526\":1}}],[\"写出来子任务\",{\"1\":{\"525\":1}}],[\"写的\",{\"1\":{\"405\":1}}],[\"写一个假贪心\",{\"1\":{\"203\":1}}],[\"写法\",{\"0\":{\"146\":1,\"147\":1,\"255\":1,\"256\":1}}],[\"暴力\",{\"0\":{\"235\":1},\"1\":{\"422\":1}}],[\"暴力搜索+假贪心\",{\"0\":{\"203\":1}}],[\"暴力搜索\",{\"0\":{\"278\":1},\"1\":{\"202\":1,\"203\":1}}],[\"暴力枚举即可\",{\"1\":{\"735\":1,\"815\":1}}],[\"暴力枚举每个数\",{\"1\":{\"648\":1}}],[\"暴力枚举后两种各买几只即可\",{\"1\":{\"611\":1}}],[\"暴力枚举数位分解\",{\"1\":{\"591\":1}}],[\"暴力枚举的代码\",{\"1\":{\"413\":1}}],[\"暴力枚举深搜\",{\"0\":{\"301\":1}}],[\"暴力枚举\",{\"0\":{\"185\":1},\"1\":{\"309\":1,\"310\":1,\"413\":1,\"478\":1,\"533\":1,\"604\":1,\"648\":1,\"661\":1,\"900\":1}}],[\"吃桃子\",{\"0\":{\"623\":1}}],[\"吃完后的高度不变\",{\"1\":{\"204\":1}}],[\"吃了\",{\"1\":{\"204\":1}}],[\"吃一个垃圾\",{\"1\":{\"203\":1}}],[\"吃垃圾直到能见到当前垃圾\",{\"1\":{\"203\":1}}],[\"吃掉多余单个字符\",{\"1\":{\"471\":1}}],[\"吃掉后面的\",{\"1\":{\"287\":1}}],[\"吃掉最近的垃圾\",{\"1\":{\"203\":1}}],[\"吃掉\",{\"1\":{\"202\":1,\"203\":1}}],[\"吃菜\",{\"0\":{\"128\":1}}],[\"垫高\",{\"1\":{\"202\":1,\"203\":1,\"204\":1}}],[\"达标的话只记半边\",{\"1\":{\"484\":1}}],[\"达标率比拼\",{\"0\":{\"477\":1}}],[\"达到\",{\"1\":{\"202\":1,\"203\":1}}],[\"达成\",{\"1\":{\"196\":1}}],[\"落下的时间\",{\"1\":{\"202\":1,\"203\":1,\"204\":1}}],[\"垃圾数量\",{\"1\":{\"202\":1,\"203\":1,\"204\":1}}],[\"垃圾陷阱\",{\"0\":{\"201\":1}}],[\"井的深度\",{\"1\":{\"202\":1,\"203\":1,\"204\":1}}],[\"储存dfs走过的路\",{\"1\":{\"200\":1}}],[\"储存输入的密码\",{\"1\":{\"70\":1,\"74\":1}}],[\"储存输入的用户名\",{\"1\":{\"70\":1,\"74\":1}}],[\"可持久化入门之数对\",{\"0\":{\"845\":1}}],[\"可能分为三段\",{\"1\":{\"704\":1}}],[\"可能递增或递减\",{\"1\":{\"704\":1}}],[\"可能有多种答案\",{\"1\":{\"620\":1}}],[\"可能有同学会好奇是怎么做到随机判题的\",{\"1\":{\"551\":1}}],[\"可能会超时\",{\"1\":{\"611\":1}}],[\"可能会有一些恶心的细节问题\",{\"1\":{\"565\":1}}],[\"可能还要找\",{\"1\":{\"428\":1}}],[\"可变长数组\",{\"1\":{\"200\":1}}],[\"可以纯枚举做所有操作\",{\"1\":{\"874\":1}}],[\"可以暴力枚举所有的划分方案\",{\"1\":{\"866\":1}}],[\"可以简单估算一下上限\",{\"1\":{\"802\":1}}],[\"可以算算多少步回到起始位置\",{\"1\":{\"766\":1}}],[\"可以算出来每个数是第几次被\",{\"1\":{\"400\":1}}],[\"可以购买\",{\"1\":{\"739\":1}}],[\"可以确定周边有几个数字\",{\"1\":{\"700\":1}}],[\"可以首先把问题转换成\",{\"1\":{\"661\":1}}],[\"可以枚举每个地皮是什么植物\",{\"1\":{\"629\":1}}],[\"可以枚举所有两位数\",{\"1\":{\"578\":1}}],[\"可以想到如果要翻转\",{\"1\":{\"601\":1}}],[\"可以想想这里的细节\",{\"1\":{\"198\":1}}],[\"可以想想这里为什么可以规避浮点运算\",{\"1\":{\"198\":1}}],[\"可以分配给\",{\"1\":{\"560\":1}}],[\"可以先去掉之前所有相关的单词\",{\"1\":{\"874\":1}}],[\"可以先算出有效队伍数量\",{\"1\":{\"871\":1}}],[\"可以先把\",{\"1\":{\"835\":1}}],[\"可以先猜\",{\"1\":{\"655\":1}}],[\"可以先找\",{\"1\":{\"526\":1}}],[\"可以先左再右\",{\"1\":{\"485\":1}}],[\"可以提前预留多一些天来暴力枚举\",{\"1\":{\"515\":1}}],[\"可以参考我的代码\",{\"1\":{\"515\":1}}],[\"可以考虑先枚举第四种鸡\",{\"1\":{\"611\":1}}],[\"可以考虑先打印出每个数的一位数位和看看规律\",{\"1\":{\"533\":1}}],[\"可以考虑先整理一下每个人的点数\",{\"1\":{\"512\":1}}],[\"可以考虑\",{\"1\":{\"500\":1}}],[\"可以做第\",{\"1\":{\"500\":1}}],[\"可以走两步\",{\"1\":{\"495\":1}}],[\"可以直接开计数数组\",{\"1\":{\"897\":1}}],[\"可以直接模拟时间变化\",{\"1\":{\"822\":1}}],[\"可以直接枚举所有数对\",{\"1\":{\"897\":1}}],[\"可以直接枚举所有起点\",{\"1\":{\"802\":1}}],[\"可以直接枚举两次\",{\"1\":{\"521\":1}}],[\"可以直接用秦九韶算法\",{\"1\":{\"658\":1}}],[\"可以直接用\",{\"1\":{\"531\":1}}],[\"可以直接\",{\"1\":{\"490\":1}}],[\"可以手算一下除法什么时候出现循环节\",{\"1\":{\"489\":1}}],[\"可以多想想再写\",{\"1\":{\"488\":1}}],[\"可以拉\",{\"1\":{\"480\":1}}],[\"可以反向求解每个算术平方根对应的数有几个来计算即可\",{\"1\":{\"478\":1}}],[\"可以看最初给的形式\",{\"1\":{\"471\":1}}],[\"可以转为二进制输出\",{\"1\":{\"458\":1}}],[\"可以用三个\",{\"1\":{\"881\":1}}],[\"可以用三个分支\",{\"1\":{\"850\":1}}],[\"可以用\",{\"1\":{\"691\":1,\"884\":1}}],[\"可以用两个字符输入单位\",{\"1\":{\"678\":1}}],[\"可以用两个变量分别指示头部和尾部\",{\"1\":{\"614\":1}}],[\"可以用条件判断特殊处理\",{\"1\":{\"608\":1}}],[\"可以用一个位置存当前的数\",{\"1\":{\"453\":1}}],[\"可以用动态数组或者字符串的形式\",{\"1\":{\"422\":1}}],[\"可以通过位置和方向\",{\"1\":{\"766\":1}}],[\"可以通过枚举左半边\",{\"1\":{\"484\":1}}],[\"可以通过\",{\"1\":{\"418\":1,\"897\":1}}],[\"可以得到两种结论\",{\"1\":{\"415\":1}}],[\"可以得到一个\",{\"1\":{\"101\":1}}],[\"可以二分或者数学方法算出\",{\"1\":{\"413\":1}}],[\"可以衔接上\",{\"1\":{\"320\":1}}],[\"可以进一步优化为先考虑大的\",{\"1\":{\"250\":1}}],[\"可以但没必要的利用离散化+数据结构的做法\",{\"0\":{\"212\":1}}],[\"可以垫高的高度\",{\"1\":{\"202\":1,\"203\":1,\"204\":1}}],[\"可以关闭多少台\",{\"1\":{\"198\":2}}],[\"可以由第\",{\"1\":{\"196\":1}}],[\"可以把字符串当作一个\",{\"1\":{\"815\":1}}],[\"可以把检查四个数是不是\",{\"1\":{\"674\":1}}],[\"可以把题目描述给的代码打包成一个函数\",{\"1\":{\"399\":1}}],[\"可以把\",{\"1\":{\"160\":2}}],[\"可以凑出来\",{\"1\":{\"126\":1}}],[\"可以使用暴力方案一天一天去数\",{\"1\":{\"740\":1}}],[\"可以使用\",{\"1\":{\"126\":1,\"897\":1,\"904\":1}}],[\"可以达成状态的\",{\"1\":{\"110\":1}}],[\"可以存下\",{\"1\":{\"564\":1}}],[\"可以存\",{\"1\":{\"103\":1}}],[\"可以储存数据的一块空间\",{\"1\":{\"60\":1}}],[\"可以改变顺序\",{\"1\":{\"39\":1}}],[\"颜色为\",{\"1\":{\"225\":1,\"226\":1}}],[\"颜色\",{\"1\":{\"199\":1,\"224\":1,\"225\":1,\"226\":2}}],[\"项除以\",{\"1\":{\"904\":1}}],[\"项就必然出现余数相同的项\",{\"1\":{\"904\":1}}],[\"项就是每\",{\"1\":{\"838\":1}}],[\"项也是\",{\"1\":{\"838\":1}}],[\"项是\",{\"1\":{\"838\":1}}],[\"项肯定大于\",{\"1\":{\"705\":2}}],[\"项都\",{\"1\":{\"705\":2}}],[\"项的\",{\"1\":{\"302\":2}}],[\"项的中位数\",{\"1\":{\"208\":1}}],[\"项为\",{\"1\":{\"199\":1}}],[\"项\",{\"1\":{\"199\":2,\"221\":1,\"302\":1,\"453\":1,\"705\":2,\"802\":1,\"838\":1}}],[\"项数\",{\"1\":{\"147\":1,\"705\":1}}],[\"项数为\",{\"1\":{\"146\":1}}],[\"染色就好了\",{\"1\":{\"494\":1}}],[\"染色\",{\"0\":{\"199\":1}}],[\"性质\",{\"1\":{\"198\":2}}],[\"辆车的初始位置\",{\"1\":{\"198\":3}}],[\"限速\",{\"1\":{\"198\":3}}],[\"主要就是提醒大家可以本地打表\",{\"1\":{\"838\":1}}],[\"主要就是为了科普一下\",{\"1\":{\"478\":1}}],[\"主要给大家提醒了一下转义符的使用\",{\"1\":{\"828\":1}}],[\"主要给天数减一\",{\"1\":{\"740\":1}}],[\"主要考察桶的应用\",{\"1\":{\"742\":1}}],[\"主要考察输入问题\",{\"1\":{\"741\":1}}],[\"主要考查一个细心和阅读能力\",{\"1\":{\"454\":1}}],[\"主要转义符用法\",{\"1\":{\"697\":1}}],[\"主要难度在于读题\",{\"1\":{\"846\":1}}],[\"主要难度在于可能之前没接触过交互题\",{\"1\":{\"655\":1}}],[\"主要难点在于读题\",{\"1\":{\"863\":1}}],[\"主要难点在于耐心\",{\"1\":{\"629\":1}}],[\"主要难点还是读题\",{\"1\":{\"642\":1,\"645\":1}}],[\"主要原因是这段代码会修改\",{\"1\":{\"399\":1}}],[\"主要的坑点有\",{\"1\":{\"527\":1}}],[\"主要的\",{\"1\":{\"47\":1}}],[\"主干道长度\",{\"1\":{\"198\":3}}],[\"测试三位数\",{\"0\":{\"651\":1}}],[\"测试点\",{\"1\":{\"196\":2}}],[\"测速点的位置\",{\"1\":{\"198\":3}}],[\"测速仪数量\",{\"1\":{\"198\":3}}],[\"车的数量\",{\"1\":{\"198\":3}}],[\"攻击力为\",{\"1\":{\"197\":2}}],[\"攻击的\",{\"1\":{\"197\":1}}],[\"攻击者\",{\"1\":{\"197\":3}}],[\"无中生有\",{\"0\":{\"494\":1}}],[\"无敌闯关\",{\"0\":{\"472\":1}}],[\"无法刷新\",{\"1\":{\"445\":1}}],[\"无法达成\",{\"1\":{\"196\":1}}],[\"无非是当前会出现\",{\"1\":{\"329\":1}}],[\"无脑\",{\"0\":{\"262\":1}}],[\"无符号\",{\"1\":{\"83\":2}}],[\"要能推理出只要拆开了就只会让结果变大或者保持不变\",{\"1\":{\"866\":1}}],[\"要把变量定义成\",{\"1\":{\"621\":1}}],[\"要加这么多次\",{\"1\":{\"560\":1}}],[\"要输出的是\",{\"1\":{\"509\":1}}],[\"要回头\",{\"1\":{\"485\":1}}],[\"要么是\",{\"1\":{\"556\":1}}],[\"要么只额外开销一次\",{\"1\":{\"524\":1}}],[\"要么断掉所有\",{\"1\":{\"433\":1}}],[\"要么断开\",{\"1\":{\"433\":1}}],[\"要么跳过了\",{\"1\":{\"405\":1}}],[\"要么精准往右到\",{\"1\":{\"405\":1}}],[\"要么\",{\"1\":{\"351\":1}}],[\"要么新开一组\",{\"1\":{\"280\":1}}],[\"要求对有序数组操作\",{\"1\":{\"349\":1}}],[\"要维护的权值数组长度为\",{\"1\":{\"312\":1,\"313\":1}}],[\"要判断\",{\"1\":{\"196\":1}}],[\"要做的事写中间\",{\"1\":{\"49\":1}}],[\"任选一个输出\",{\"1\":{\"550\":1}}],[\"任意两点间骑士最短路\",{\"1\":{\"259\":1}}],[\"任意两边之和大于第三边\",{\"1\":{\"99\":1}}],[\"任务个数\",{\"1\":{\"196\":1}}],[\"人数\",{\"1\":{\"196\":1}}],[\"没啥特殊作用的凑数子任务\",{\"1\":{\"611\":1}}],[\"没啥意义\",{\"1\":{\"556\":1}}],[\"没啥好说的\",{\"1\":{\"479\":1}}],[\"没必要写得那么精细\",{\"1\":{\"515\":1}}],[\"没必要算\",{\"1\":{\"329\":1}}],[\"没获胜的情况\",{\"1\":{\"513\":1}}],[\"没注意到这个直接\",{\"1\":{\"483\":1}}],[\"没走过\",{\"1\":{\"405\":1}}],[\"没走\",{\"1\":{\"405\":1}}],[\"没用到\",{\"1\":{\"329\":1}}],[\"没人能达成\",{\"1\":{\"196\":2}}],[\"没有修改\",{\"1\":{\"846\":1}}],[\"没有黄灯\",{\"1\":{\"835\":1}}],[\"没有多余前导\",{\"1\":{\"671\":1}}],[\"没有额外的藤条\",{\"1\":{\"595\":1}}],[\"没有额外含义\",{\"1\":{\"466\":1,\"467\":1}}],[\"没有子任务\",{\"1\":{\"585\":1}}],[\"没有\",{\"1\":{\"545\":1,\"841\":1}}],[\"没有被标记过\",{\"1\":{\"228\":1}}],[\"没有出现过不够用\",{\"1\":{\"136\":1}}],[\"没有实根\",{\"1\":{\"129\":1}}],[\"没有消息就是最好的消息\",{\"1\":{\"47\":1}}],[\"轮就足够了\",{\"1\":{\"772\":1}}],[\"轮数\",{\"1\":{\"626\":3}}],[\"轮数+1\",{\"1\":{\"626\":1}}],[\"轮能否接到\",{\"1\":{\"196\":1}}],[\"轮由谁达成\",{\"1\":{\"196\":2}}],[\"轮\",{\"1\":{\"196\":3}}],[\"轮要凑出来\",{\"1\":{\"196\":1}}],[\"轮凑出来\",{\"1\":{\"196\":1}}],[\"接着可能能想到用埃筛处理出来最小质因子来加速分解质因子\",{\"1\":{\"415\":1}}],[\"接近\",{\"1\":{\"413\":1}}],[\"接近程度\",{\"1\":{\"142\":1}}],[\"接下来的问题就是想办法把\",{\"1\":{\"574\":1}}],[\"接下来有两种常见满分路线\",{\"1\":{\"413\":1}}],[\"接下来为了减小误差\",{\"1\":{\"285\":1}}],[\"接下来要覆盖\",{\"1\":{\"242\":1}}],[\"接到\",{\"1\":{\"196\":2}}],[\"接龙到\",{\"1\":{\"196\":1}}],[\"接龙序列上限\",{\"1\":{\"196\":1}}],[\"接龙\",{\"0\":{\"196\":1}}],[\"地图探险\",{\"0\":{\"194\":1}}],[\"地精的位置\",{\"1\":{\"32\":1}}],[\"地精排序\",{\"0\":{\"32\":1}}],[\"扑克牌\",{\"0\":{\"193\":1}}],[\"又因为\",{\"1\":{\"621\":1}}],[\"又根据n的范围得知\",{\"1\":{\"620\":1}}],[\"又至少有一个\",{\"1\":{\"541\":1}}],[\"又加了点优化\",{\"1\":{\"187\":1}}],[\"又见采药\",{\"0\":{\"127\":1}}],[\"设置为小于所有数的值\",{\"1\":{\"216\":1}}],[\"设置为\",{\"1\":{\"186\":1}}],[\"被增加了\",{\"1\":{\"812\":1}}],[\"被保留的是否大于等于\",{\"1\":{\"437\":2}}],[\"被走过了\",{\"1\":{\"405\":1}}],[\"被标记的数量\",{\"1\":{\"228\":1}}],[\"被标记了的不能翻转\",{\"1\":{\"150\":1}}],[\"被标记了不能翻转\",{\"1\":{\"150\":1}}],[\"被摧毁的星球数量\",{\"1\":{\"215\":1}}],[\"被用过了\",{\"1\":{\"186\":1}}],[\"优化完最内层循环后\",{\"1\":{\"812\":1}}],[\"优化代码\",{\"0\":{\"680\":1,\"811\":1}}],[\"优化合并得到每个点能到哪些点\",{\"1\":{\"442\":1}}],[\"优化后就能拿到不少分数\",{\"1\":{\"415\":1}}],[\"优化\",{\"0\":{\"186\":1,\"302\":1},\"1\":{\"186\":2,\"187\":2}}],[\"优先级高于\",{\"1\":{\"98\":1}}],[\"手玩一下很容易得出结论\",{\"1\":{\"909\":1}}],[\"手算\",{\"1\":{\"744\":1}}],[\"手推几个例子\",{\"1\":{\"431\":1}}],[\"手动算算\",{\"1\":{\"665\":1}}],[\"手动算\",{\"1\":{\"335\":1}}],[\"手动交互器\",{\"0\":{\"174\":1}}],[\"手写\",{\"0\":{\"185\":1}}],[\"进而调试代码\",{\"1\":{\"737\":1}}],[\"进制转换\",{\"1\":{\"900\":1}}],[\"进制的整数处理\",{\"1\":{\"815\":1}}],[\"进制\",{\"1\":{\"465\":1}}],[\"进制整数再处理\",{\"1\":{\"465\":1}}],[\"进行二级排序\",{\"1\":{\"623\":1}}],[\"进行分类讨论\",{\"1\":{\"622\":1}}],[\"进行存储\",{\"1\":{\"622\":1}}],[\"进行排序\",{\"1\":{\"556\":1,\"557\":1}}],[\"进行第二天的日期计算即可\",{\"1\":{\"527\":1}}],[\"进行当前接龙\",{\"1\":{\"196\":1}}],[\"进行翻转\",{\"1\":{\"151\":1}}],[\"进位\",{\"1\":{\"184\":1,\"185\":1,\"714\":1}}],[\"后续判断遇到\",{\"1\":{\"897\":1}}],[\"后再处理\",{\"1\":{\"842\":1}}],[\"后两题我自然出的就简单了\",{\"1\":{\"736\":1}}],[\"后来想想还是算了\",{\"1\":{\"414\":1}}],[\"后半部分就两种结果了\",{\"1\":{\"405\":1}}],[\"后面每\",{\"1\":{\"708\":1}}],[\"后面每个人依次看看怎么在上一次的基础上能多覆盖就好\",{\"1\":{\"485\":1}}],[\"后面的全都大于\",{\"1\":{\"705\":1}}],[\"后面的分数可以考虑手动模拟画出来\",{\"1\":{\"617\":1}}],[\"后面去找\",{\"1\":{\"556\":1}}],[\"后面来了会让他输掉游戏\",{\"1\":{\"493\":1}}],[\"后面第\",{\"1\":{\"475\":1}}],[\"后面没走的那些位置显然可以通过这个点走过去而不会更劣\",{\"1\":{\"423\":1}}],[\"后面多少种\",{\"1\":{\"329\":1}}],[\"后面就不用\",{\"1\":{\"184\":1,\"185\":1,\"186\":1}}],[\"后还要看看这个\",{\"1\":{\"329\":1}}],[\"后的体积\",{\"1\":{\"280\":1}}],[\"后手吃了\",{\"1\":{\"128\":1}}],[\"虫食算\",{\"0\":{\"183\":1}}],[\"及以上的量的最小卡路里\",{\"1\":{\"340\":1}}],[\"及以上的量\",{\"1\":{\"340\":1}}],[\"及以上数量的次数都钓完\",{\"1\":{\"147\":1}}],[\"及\",{\"1\":{\"182\":2}}],[\"得数不能处理\",{\"1\":{\"418\":1}}],[\"得到最终差末尾几个\",{\"1\":{\"904\":1}}],[\"得到次大值位置\",{\"1\":{\"447\":1}}],[\"得到每个结点的排名\",{\"1\":{\"427\":1}}],[\"得到\",{\"1\":{\"361\":1}}],[\"得到对应的字符串\",{\"1\":{\"3\":1}}],[\"得分\",{\"1\":{\"182\":2}}],[\"获取对应的分值\",{\"1\":{\"182\":1}}],[\"获取在哪个小方块\",{\"1\":{\"182\":2}}],[\"获取第\",{\"1\":{\"3\":1}}],[\"靶形数独\",{\"0\":{\"182\":1}}],[\"多余的前导\",{\"1\":{\"671\":1}}],[\"多余时间不停钓\",{\"1\":{\"147\":1}}],[\"多检查一下和其它位置是否相等即可\",{\"1\":{\"652\":1}}],[\"多个位置要断开\",{\"1\":{\"602\":1}}],[\"多个解\",{\"1\":{\"484\":1}}],[\"多少种得分\",{\"0\":{\"479\":1}}],[\"多米诺骨牌\",{\"0\":{\"220\":1}}],[\"多测清空\",{\"1\":{\"196\":2}}],[\"多保留几位小数\",{\"1\":{\"181\":1}}],[\"选取\",{\"1\":{\"742\":1}}],[\"选不选第\",{\"1\":{\"499\":1}}],[\"选第\",{\"1\":{\"301\":1}}],[\"选\",{\"1\":{\"298\":3}}],[\"选了几个数\",{\"1\":{\"301\":1}}],[\"选了\",{\"1\":{\"280\":1}}],[\"选择当前货币\",{\"1\":{\"307\":1}}],[\"选择客栈\",{\"0\":{\"223\":1}}],[\"选择排序\",{\"0\":{\"26\":1},\"1\":{\"27\":1}}],[\"选用了一个测速点\",{\"1\":{\"198\":1}}],[\"选数\",{\"0\":{\"180\":1}}],[\"普通排序\",{\"0\":{\"347\":1}}],[\"普通闰年\",{\"1\":{\"98\":1}}],[\"普及组\",{\"0\":{\"180\":1,\"274\":1,\"288\":1}}],[\"然后检查之前是否出现过即可\",{\"1\":{\"904\":1}}],[\"然后检查两个单词是否满足其中一个是不是另一个的前缀就好\",{\"1\":{\"410\":1}}],[\"然后读写的地址看看是否被标记过了就好\",{\"1\":{\"900\":1}}],[\"然后读整数的方法读每个整数\",{\"1\":{\"471\":1}}],[\"然后我写了挺多辅助函数\",{\"1\":{\"874\":1}}],[\"然后新增新产生的单词即可\",{\"1\":{\"874\":1}}],[\"然后减去最大值和\",{\"1\":{\"859\":1}}],[\"然后求\",{\"1\":{\"859\":1}}],[\"然后求和即可\",{\"1\":{\"533\":1,\"585\":1}}],[\"然后处理当前数对即可\",{\"1\":{\"846\":1}}],[\"然后看看是改还是输出就好\",{\"1\":{\"846\":1}}],[\"然后看看左上到右下的最大路径和\",{\"1\":{\"500\":1}}],[\"然后只在第\",{\"1\":{\"838\":1}}],[\"然后只要分钟数小于\",{\"1\":{\"822\":1}}],[\"然后每个灯的时间看成\",{\"1\":{\"835\":1}}],[\"然后每次乘以\",{\"1\":{\"746\":1}}],[\"然后通过\",{\"1\":{\"835\":1}}],[\"然后简单条件判断即可\",{\"1\":{\"835\":1}}],[\"然后挑选最低的输出即可\",{\"1\":{\"809\":1}}],[\"然后等差数列求和来计算的话\",{\"1\":{\"802\":1}}],[\"然后写出下面这段代码\",{\"1\":{\"772\":1}}],[\"然后写错了\",{\"1\":{\"480\":1}}],[\"然后找到最大值\",{\"1\":{\"859\":1}}],[\"然后找到得分的最大值即可\",{\"1\":{\"598\":1}}],[\"然后找位数最少的\",{\"1\":{\"769\":1}}],[\"然后不停输入一个符号和一个数直到文件结尾\",{\"1\":{\"745\":1}}],[\"然后不能直接用\",{\"1\":{\"478\":1}}],[\"然后从\",{\"1\":{\"740\":1}}],[\"然后从根节点开始\",{\"1\":{\"406\":1}}],[\"然后直接输出这个结果就好\",{\"1\":{\"735\":1}}],[\"然后根据每个数字出现的次数\",{\"1\":{\"742\":1}}],[\"然后根据第一个字符来决定乘几个\",{\"1\":{\"678\":1}}],[\"然后根据结果输出对应的语句即可\",{\"1\":{\"622\":1}}],[\"然后比较长度\",{\"1\":{\"671\":1}}],[\"然后模拟完剩余的时间即可\",{\"1\":{\"632\":1}}],[\"然后排列组合求出答案\",{\"1\":{\"629\":1}}],[\"然后打表\",{\"1\":{\"617\":1}}],[\"然后算出需要输出的排名\",{\"1\":{\"871\":1}}],[\"然后算出第四种鸡的数量\",{\"1\":{\"611\":1}}],[\"然后算算输入给的文章长度\",{\"1\":{\"409\":1}}],[\"然后显然\",{\"1\":{\"598\":1}}],[\"然后显然花一次去掉所有相等的\",{\"1\":{\"441\":1}}],[\"然后会剩下\",{\"1\":{\"595\":1}}],[\"然后就是判断如果在\",{\"1\":{\"582\":1}}],[\"然后就一个个看过去不一样就变就好\",{\"1\":{\"419\":1}}],[\"然后优先查找\",{\"1\":{\"574\":1}}],[\"然后封装成一个小函数代码会更简洁\",{\"1\":{\"571\":1}}],[\"然后顺便统计获胜次数\",{\"1\":{\"563\":1}}],[\"然后祈祷运气好猜对了即可\",{\"1\":{\"550\":1}}],[\"然后对\",{\"1\":{\"541\":1}}],[\"然后对两个数组种存储的编号按照排名为依据排序\",{\"1\":{\"521\":1}}],[\"然后用双指针检查\",{\"1\":{\"815\":1}}],[\"然后用二分或者数学方法找终点\",{\"1\":{\"802\":1}}],[\"然后用循环找到下标来对应到具体的数字\",{\"1\":{\"763\":1}}],[\"然后用一个字符型变量吃掉中间的冒号再输入第二个整数即可\",{\"1\":{\"530\":1}}],[\"然后用这个最小值来放置猫咪就好\",{\"1\":{\"497\":1}}],[\"然后代码中会直接判断中间是否都是=\",{\"1\":{\"526\":1}}],[\"然后把两个颜色改为非法颜色\",{\"1\":{\"897\":1}}],[\"然后把三段直接用数学方法算出分界点\",{\"1\":{\"704\":1}}],[\"然后把溢出的依次往后分给后面的\",{\"1\":{\"559\":1}}],[\"然后把男生女生放到了不同的数组\",{\"1\":{\"521\":1}}],[\"然后把他放两次到末尾\",{\"1\":{\"453\":1}}],[\"然后一个个输出女生即可\",{\"1\":{\"521\":1}}],[\"然后一个小时一个小时模拟就好\",{\"1\":{\"515\":1}}],[\"然后进行结构体排序\",{\"1\":{\"518\":1}}],[\"然后进一步数学推式子\",{\"1\":{\"413\":1}}],[\"然后进一步如果能推出\",{\"1\":{\"413\":1}}],[\"然后按照出现次数排序输出即可\",{\"1\":{\"518\":1}}],[\"然后前后一个小时一个小时模拟就好\",{\"1\":{\"515\":1}}],[\"然后分别判断好两个人的类型\",{\"1\":{\"512\":1}}],[\"然后往另一个端点走就可以了\",{\"1\":{\"493\":1}}],[\"然后往右下走到最终位置即可\",{\"1\":{\"414\":1}}],[\"然后往右跳过牛\",{\"1\":{\"403\":1}}],[\"然后往右精准抵达\",{\"1\":{\"403\":1}}],[\"然后怎么检查\",{\"1\":{\"485\":1}}],[\"然后还有一个群直接拉一个所有人的群就好了\",{\"1\":{\"480\":1}}],[\"然后两个人分别自己待一个单人群就好了\",{\"1\":{\"480\":1}}],[\"然后赋值过去\",{\"1\":{\"478\":1}}],[\"然后二分就能找到结束位置了\",{\"1\":{\"474\":1}}],[\"然后二分检查\",{\"1\":{\"414\":1}}],[\"然后枚举三个数字的所有排列\",{\"1\":{\"655\":1}}],[\"然后枚举\",{\"1\":{\"462\":1,\"723\":1}}],[\"然后剩下的部分再来给一个固定的哪个数字就可以了\",{\"1\":{\"453\":1}}],[\"然后输出多次\",{\"1\":{\"453\":1}}],[\"然后输入不合法就输出你的方案就好\",{\"1\":{\"409\":1}}],[\"然后问\",{\"1\":{\"448\":1}}],[\"然后问一下次大值那半边的次大值\",{\"1\":{\"447\":1}}],[\"然后在\",{\"1\":{\"442\":1}}],[\"然后在文本串中匹配\",{\"0\":{\"284\":1}}],[\"然后缩点\",{\"1\":{\"442\":1}}],[\"然后有一个比较难的小台阶\",{\"1\":{\"415\":1}}],[\"然后很容易发现题面那个代码已经有不少可以优化的地方了\",{\"1\":{\"415\":1}}],[\"然后\",{\"1\":{\"413\":1,\"415\":1,\"530\":1,\"904\":1}}],[\"然后状态转移方程其实很好退出来\",{\"1\":{\"405\":1}}],[\"然后回头精准抵达\",{\"1\":{\"403\":1}}],[\"然后抓牛得情况看上去很多\",{\"1\":{\"403\":1}}],[\"然后其实是可以数学方法\",{\"1\":{\"400\":1}}],[\"然后第二次被\",{\"1\":{\"400\":1}}],[\"然后再加\",{\"1\":{\"835\":1}}],[\"然后再由\",{\"1\":{\"740\":1}}],[\"然后再暴力枚举加多少能变成回文数即可\",{\"1\":{\"648\":1}}],[\"然后再输出\",{\"1\":{\"645\":1}}],[\"然后再用循环去找是否存在一些个连续的\",{\"1\":{\"526\":1}}],[\"然后再看看用到了几个\",{\"1\":{\"329\":1}}],[\"然后再来一口气\",{\"1\":{\"173\":1}}],[\"然后开敲\",{\"1\":{\"166\":1}}],[\"划分左右\",{\"1\":{\"172\":1}}],[\"快排居然能拿到\",{\"1\":{\"172\":1}}],[\"置最小\",{\"1\":{\"168\":1}}],[\"蓄水池问题\",{\"0\":{\"167\":1}}],[\"起床时间\",{\"0\":{\"821\":1}}],[\"起床困难综合症\",{\"0\":{\"165\":1}}],[\"起点为\",{\"1\":{\"802\":1}}],[\"起点入队\",{\"1\":{\"259\":1,\"438\":1}}],[\"起始位置迭代器\",{\"1\":{\"103\":1}}],[\"执行\",{\"1\":{\"164\":1}}],[\"执行的自然是\",{\"1\":{\"91\":1}}],[\"蚯蚓\",{\"0\":{\"163\":1}}],[\"错误代码\",{\"0\":{\"161\":1}}],[\"钦定第\",{\"1\":{\"162\":1}}],[\"钦定\",{\"1\":{\"160\":1,\"161\":1}}],[\"两段或一段\",{\"1\":{\"704\":1}}],[\"两节课时间一样\",{\"1\":{\"665\":1}}],[\"两数相等\",{\"1\":{\"622\":1}}],[\"两种\",{\"1\":{\"900\":1}}],[\"两种合法的装油方法\",{\"1\":{\"604\":1}}],[\"两种串的数量翻转\",{\"1\":{\"160\":1}}],[\"两个负数\",{\"1\":{\"622\":1}}],[\"两个正数\",{\"1\":{\"622\":1}}],[\"两个数同正或者同负\",{\"1\":{\"622\":1}}],[\"两个棋子方向正相反\",{\"1\":{\"505\":1}}],[\"两个代码总结在一起就是个\",{\"1\":{\"402\":1}}],[\"两个运算数\",{\"1\":{\"262\":1,\"263\":1,\"264\":1}}],[\"两个人都是用最有走法\",{\"1\":{\"495\":1}}],[\"两个人之间为朋友\",{\"1\":{\"251\":1}}],[\"两个人之间为敌人\",{\"1\":{\"251\":1}}],[\"两个人能达成\",{\"1\":{\"196\":2}}],[\"两个实根不相等\",{\"1\":{\"129\":1}}],[\"两个实根相等\",{\"1\":{\"129\":1}}],[\"操作几次可以反转>\",{\"1\":{\"343\":1}}],[\"操作次数就要加\",{\"1\":{\"494\":1}}],[\"操作次数\",{\"1\":{\"286\":2}}],[\"操作次数少于等于\",{\"1\":{\"286\":2}}],[\"操作互补串的零\",{\"1\":{\"160\":1}}],[\"操作当前串的零\",{\"1\":{\"160\":1}}],[\"全都删掉\",{\"1\":{\"351\":1}}],[\"全都是\",{\"1\":{\"158\":1,\"292\":1}}],[\"全\",{\"1\":{\"160\":2}}],[\"变大变大变成回文数\",{\"0\":{\"647\":1}}],[\"变成了简单的条件判断的题目\",{\"1\":{\"853\":1}}],[\"变成下一个质数\",{\"1\":{\"735\":1}}],[\"变成\",{\"1\":{\"419\":2,\"772\":1}}],[\"变成大于\",{\"1\":{\"168\":1}}],[\"变为一位数\",{\"1\":{\"534\":1}}],[\"变为\",{\"1\":{\"160\":2}}],[\"变量记得开\",{\"1\":{\"508\":1}}],[\"变量命名规则\",{\"1\":{\"62\":1}}],[\"变量名3\",{\"1\":{\"62\":1}}],[\"变量名2\",{\"1\":{\"62\":1}}],[\"变量名1\",{\"1\":{\"62\":1}}],[\"变量名\",{\"1\":{\"62\":2}}],[\"变量定义方法\",{\"1\":{\"62\":1}}],[\"变量定义规则\",{\"0\":{\"62\":1}}],[\"变量类型\",{\"0\":{\"61\":1},\"1\":{\"62\":3}}],[\"变量与赋值语句\",{\"0\":{\"60\":1}}],[\"还需要了解日期进制和普通进制的差异\",{\"1\":{\"740\":1}}],[\"还是子任务\",{\"1\":{\"818\":1}}],[\"还是一样输出\",{\"1\":{\"668\":1}}],[\"还是\",{\"0\":{\"677\":1},\"1\":{\"448\":1,\"503\":1,\"541\":1,\"629\":2,\"846\":1}}],[\"还要不要找\",{\"1\":{\"428\":1}}],[\"还要动几次\",{\"1\":{\"161\":1}}],[\"还原\",{\"1\":{\"186\":1}}],[\"还剩这么多次操作\",{\"1\":{\"160\":2}}],[\"还有另一种思路\",{\"1\":{\"904\":1}}],[\"还有更多别的构造方法\",{\"1\":{\"453\":1}}],[\"还有一种是先推出\",{\"1\":{\"413\":1}}],[\"还有一个做法\",{\"1\":{\"400\":1}}],[\"还有\",{\"1\":{\"160\":2,\"503\":1}}],[\"还能钓鱼的次数\",{\"1\":{\"146\":1}}],[\"还能钓鱼\",{\"1\":{\"146\":1}}],[\"了\",{\"1\":{\"160\":2,\"184\":1,\"185\":1,\"186\":1,\"407\":1,\"413\":1,\"414\":1,\"453\":1,\"457\":1,\"465\":1,\"835\":1,\"894\":1}}],[\"更简单一点了\",{\"1\":{\"891\":1}}],[\"更建议尽可能避免浮点数运算\",{\"1\":{\"884\":1}}],[\"更优雅的代码可以定义两个字符串\",{\"1\":{\"763\":1}}],[\"更改现在的系统词输出即可\",{\"1\":{\"741\":1}}],[\"更改数组大小\",{\"1\":{\"103\":1}}],[\"更好的做法是在\",{\"1\":{\"450\":1}}],[\"更新新的右端点天数\",{\"1\":{\"516\":1}}],[\"更新最大次大\",{\"1\":{\"440\":1}}],[\"更新最新测速点位置\",{\"1\":{\"198\":1}}],[\"更新高度\",{\"1\":{\"203\":1}}],[\"更新\",{\"1\":{\"196\":2}}],[\"更新答案\",{\"1\":{\"160\":1,\"320\":1}}],[\"代老师骑行健身\",{\"0\":{\"880\":1}}],[\"代替\",{\"1\":{\"531\":1}}],[\"代码来自\",{\"1\":{\"804\":1}}],[\"代码细节处理没问题通过本道题目应该是没有任何难度的\",{\"1\":{\"565\":1}}],[\"代码源挑战赛r12\",{\"0\":{\"385\":1}}],[\"代码\",{\"0\":{\"160\":1}}],[\"代指真和假\",{\"1\":{\"80\":1}}],[\"列数\",{\"1\":{\"875\":1}}],[\"列有没有数字\",{\"1\":{\"249\":1}}],[\"列向下求和\",{\"1\":{\"232\":1}}],[\"列向下计数\",{\"1\":{\"232\":1}}],[\"列变化\",{\"1\":{\"162\":2}}],[\"列的方块的行数的相反数\",{\"1\":{\"342\":1}}],[\"列的\",{\"1\":{\"162\":2}}],[\"列操作完后\",{\"1\":{\"162\":2}}],[\"列不翻转\",{\"1\":{\"162\":2}}],[\"列不进行单点操作\",{\"1\":{\"162\":1}}],[\"列是否整体翻转\",{\"1\":{\"162\":1}}],[\"列\",{\"1\":{\"158\":1,\"217\":1,\"248\":1,\"305\":1,\"342\":1}}],[\"消耗剩余次数\",{\"1\":{\"161\":1}}],[\"消耗掉了\",{\"1\":{\"126\":1}}],[\"消掉其他方程的第\",{\"1\":{\"158\":1}}],[\"^2\",{\"1\":{\"164\":1}}],[\"^\",{\"1\":{\"158\":1,\"162\":2,\"169\":1,\"319\":2,\"329\":1,\"335\":1,\"351\":1,\"415\":4,\"427\":3,\"760\":1,\"783\":1}}],[\"^=\",{\"1\":{\"153\":8,\"158\":9,\"319\":2}}],[\"循环数位分解基础题\",{\"1\":{\"853\":1}}],[\"循环模拟的做法略\",{\"1\":{\"835\":1}}],[\"循环嵌套\",{\"1\":{\"629\":1}}],[\"循环\",{\"1\":{\"574\":1,\"642\":1,\"881\":1}}],[\"循环一天天过就好\",{\"1\":{\"571\":1}}],[\"循环求\",{\"1\":{\"525\":1}}],[\"循环从第\",{\"1\":{\"509\":1}}],[\"循环枚举\",{\"1\":{\"413\":1}}],[\"循环代替多层\",{\"0\":{\"263\":1}}],[\"循环生成下一行\",{\"1\":{\"158\":1}}],[\"循环做法\",{\"0\":{\"131\":1,\"132\":1}}],[\"构造右半边的形式\",{\"1\":{\"484\":1}}],[\"构造方程\",{\"1\":{\"158\":1}}],[\"构建一个哈夫曼编码\",{\"1\":{\"410\":1}}],[\"构建线段\",{\"1\":{\"312\":1,\"313\":1}}],[\"构建每个第一行的点对应的区间\",{\"1\":{\"241\":1}}],[\"构成的数显然等于\",{\"1\":{\"658\":1}}],[\"构成的数\",{\"1\":{\"270\":1}}],[\"构成的长度为\",{\"1\":{\"126\":1}}],[\"滚动\",{\"1\":{\"158\":1}}],[\"都小于等于\",{\"1\":{\"815\":1}}],[\"都在起点\",{\"1\":{\"668\":2}}],[\"都在注释里了\",{\"1\":{\"475\":1}}],[\"都会输出字符串\",{\"1\":{\"645\":1}}],[\"都不同即可\",{\"1\":{\"568\":1}}],[\"都不需要进行染色\",{\"1\":{\"157\":2}}],[\"都可以变为\",{\"1\":{\"436\":1}}],[\"都可以结尾\",{\"1\":{\"329\":1}}],[\"都拿到\",{\"1\":{\"340\":1}}],[\"都是\",{\"1\":{\"665\":1}}],[\"都是正数\",{\"1\":{\"582\":1}}],[\"都是给下一个人装满了的情况\",{\"1\":{\"559\":1}}],[\"都是访问不到任意位置\",{\"1\":{\"443\":1}}],[\"都是不能选的\",{\"1\":{\"326\":1}}],[\"都是动态数组\",{\"1\":{\"103\":1}}],[\"都抄不完\",{\"1\":{\"219\":2}}],[\"弱化版\",{\"0\":{\"155\":1}}],[\"按格式直接输出即可\",{\"1\":{\"726\":1}}],[\"按格式输出即可\",{\"1\":{\"665\":1}}],[\"按格式输出\",{\"1\":{\"531\":1}}],[\"按大小规则替换即可\",{\"1\":{\"720\":1}}],[\"按竖式计算即可\",{\"1\":{\"713\":1}}],[\"按规则计算即可\",{\"1\":{\"707\":1}}],[\"按行排序按列排序\",{\"0\":{\"686\":1}}],[\"按分为三类\",{\"1\":{\"635\":1}}],[\"按点得分\",{\"1\":{\"617\":1}}],[\"按百钱买百鸡一样的模式\",{\"1\":{\"611\":1}}],[\"按题意模拟计数即可\",{\"1\":{\"736\":1}}],[\"按题意模拟就好了\",{\"1\":{\"458\":1}}],[\"按题意输入一个字符串\",{\"1\":{\"697\":1}}],[\"按题目要求一点点处理\",{\"1\":{\"471\":1}}],[\"按照题目模拟求出所有单词出现的次数即可\",{\"1\":{\"874\":1}}],[\"按照题意比较即可\",{\"1\":{\"512\":1}}],[\"按照提示\",{\"1\":{\"856\":1}}],[\"按照补码规则处理即可\",{\"1\":{\"713\":1}}],[\"按照拓扑顺序求解\",{\"1\":{\"366\":1}}],[\"按照所在行的\",{\"1\":{\"182\":1}}],[\"按顺序存被摧毁的星球\",{\"1\":{\"215\":1}}],[\"按顺序存所有\",{\"1\":{\"192\":1}}],[\"按\",{\"1\":{\"154\":1,\"181\":1}}],[\"按完了\",{\"1\":{\"154\":1}}],[\"按反转后权值从大到小排序后的\",{\"1\":{\"151\":1}}],[\"行数\",{\"1\":{\"875\":1}}],[\"行数列数\",{\"1\":{\"377\":1}}],[\"行列对角线按顺序检查\",{\"1\":{\"732\":1}}],[\"行有没有数字\",{\"1\":{\"249\":1}}],[\"行有连续两个的空位也是对的\",{\"1\":{\"109\":1,\"110\":1}}],[\"行\",{\"1\":{\"248\":1,\"305\":1,\"306\":1,\"318\":1,\"342\":1}}],[\"行的可选范围是\",{\"1\":{\"164\":1}}],[\"行的案件情况\",{\"1\":{\"154\":1}}],[\"行次数\",{\"1\":{\"162\":1}}],[\"行全对了\",{\"1\":{\"154\":1}}],[\"行分别怎么按\",{\"1\":{\"154\":1}}],[\"先把分钟数\",{\"1\":{\"822\":1}}],[\"先把中间的完整周用数学方法快速计算\",{\"1\":{\"515\":1}}],[\"先算算用不同的数字分别需要至少几位才够\",{\"1\":{\"769\":1}}],[\"先算算自己的反转次数\",{\"1\":{\"162\":2}}],[\"先学会怎么算小数的二进制转换\",{\"1\":{\"746\":1}}],[\"先输入一个整数\",{\"1\":{\"745\":1}}],[\"先找到两个数第一个不是\",{\"1\":{\"671\":1}}],[\"先判断一下两个数的位数\",{\"1\":{\"622\":1}}],[\"先排序然后按照子任务\",{\"1\":{\"588\":1}}],[\"先排个序方便后续操作\",{\"1\":{\"513\":1}}],[\"先给当前用户发到溢出\",{\"1\":{\"559\":1}}],[\"先给个简易题解\",{\"1\":{\"449\":1}}],[\"先一个个输出男生\",{\"1\":{\"521\":1}}],[\"先手的得分\",{\"1\":{\"495\":2}}],[\"先左再右还是先右再左\",{\"1\":{\"485\":1}}],[\"先问一次\",{\"1\":{\"448\":1}}],[\"先问\",{\"1\":{\"447\":1}}],[\"先放到备选答案上\",{\"1\":{\"310\":1}}],[\"先对模式串本身求\",{\"1\":{\"283\":1}}],[\"先用归并排序\",{\"1\":{\"173\":1}}],[\"先清空一下下面\",{\"1\":{\"154\":1}}],[\"先竖着放一个\",{\"1\":{\"109\":1,\"110\":1}}],[\"总钱数\",{\"1\":{\"739\":1}}],[\"总次数\",{\"1\":{\"708\":1}}],[\"总天数\",{\"1\":{\"516\":1}}],[\"总共有\",{\"1\":{\"497\":1}}],[\"总体来说就是道数据范围题\",{\"1\":{\"490\":1}}],[\"总和查询\",{\"1\":{\"313\":1,\"314\":1}}],[\"总时间\",{\"1\":{\"147\":1}}],[\"总鱼数\",{\"1\":{\"147\":1}}],[\"总耗时\",{\"1\":{\"109\":2,\"110\":1}}],[\"那多做几次就好了\",{\"1\":{\"772\":1}}],[\"那去掉课间\",{\"1\":{\"665\":1}}],[\"那显然最少把个位变成百位上的数即可\",{\"1\":{\"648\":1}}],[\"那显然只有\",{\"1\":{\"604\":1}}],[\"那显然不具有单调性\",{\"1\":{\"500\":1}}],[\"那必然是某个地方出现了连续两个相同的字符\",{\"1\":{\"601\":1}}],[\"那肯定是顺子\",{\"1\":{\"588\":1}}],[\"那些特殊的标点符号写起来比较麻烦\",{\"1\":{\"518\":1}}],[\"那个人的贡献\",{\"1\":{\"499\":1}}],[\"那个规律\",{\"1\":{\"405\":1}}],[\"那有两种方案\",{\"1\":{\"485\":1}}],[\"那满分怎么看都超\",{\"1\":{\"484\":1}}],[\"那满分怎么做呢\",{\"1\":{\"478\":1}}],[\"那满足条件的\",{\"1\":{\"326\":1}}],[\"那直接任意两个人之间拉一个群就好了\",{\"1\":{\"480\":1}}],[\"那直接乘以\",{\"1\":{\"451\":1}}],[\"那直接输出\",{\"1\":{\"397\":1}}],[\"那这个结论能不能证明呢\",{\"1\":{\"909\":1}}],[\"那这题就没啥难的了\",{\"1\":{\"351\":1}}],[\"那这一轮无法达成\",{\"1\":{\"196\":1}}],[\"那就是逆序输出字符串\",{\"1\":{\"841\":1}}],[\"那就直到最终序列的起点了\",{\"1\":{\"806\":1}}],[\"那就不变了\",{\"1\":{\"655\":1}}],[\"那就不可能是当前数字了\",{\"1\":{\"578\":1}}],[\"那就不存在公差问题\",{\"1\":{\"565\":1}}],[\"那就只需要检查是否存在一条路劲使得大于等于\",{\"1\":{\"500\":1}}],[\"那就可以直接在埃筛的同时算出每个数对应的\",{\"1\":{\"415\":1}}],[\"那就可能超过\",{\"1\":{\"414\":1}}],[\"那就多记录一下上一步的方向就好了\",{\"1\":{\"336\":1}}],[\"那就出现了\",{\"1\":{\"329\":2}}],[\"那就看\",{\"1\":{\"329\":1}}],[\"那就看看多大的能搞完\",{\"1\":{\"147\":1}}],[\"那\",{\"1\":{\"329\":1,\"617\":1}}],[\"那遇到\",{\"1\":{\"328\":1}}],[\"那其实很简单\",{\"1\":{\"328\":1}}],[\"那么与顶点刚好能构成一个等腰直角三角形\",{\"1\":{\"909\":1}}],[\"那么显然需要\",{\"1\":{\"904\":1}}],[\"那么它就是\",{\"1\":{\"856\":1}}],[\"那么输出必然是\",{\"1\":{\"691\":1}}],[\"那么这一轮结束后\",{\"1\":{\"632\":1}}],[\"那么这一行的这个位置就需要按\",{\"1\":{\"154\":1}}],[\"那么我们可以用\",{\"1\":{\"623\":1}}],[\"那么我们可以枚举当前这个没有放棋子的位置作为端点或作为中间点能否横着\",{\"1\":{\"505\":1}}],[\"那么肯定会做尽可能大的正方形\",{\"1\":{\"595\":1}}],[\"那么如果\",{\"1\":{\"591\":1}}],[\"那么如果存在前缀关系\",{\"1\":{\"410\":1}}],[\"那么应该是只要满足\",{\"1\":{\"574\":1}}],[\"那么总共缺几颗糖就发几次即可\",{\"1\":{\"559\":1}}],[\"那么就输出\",{\"1\":{\"750\":1}}],[\"那么就错了\",{\"1\":{\"574\":1}}],[\"那么就一个个去看看发几次能超过要求即可\",{\"1\":{\"559\":1}}],[\"那么就直接输出\",{\"1\":{\"526\":1}}],[\"那么就按照上面方式输出就可以了\",{\"1\":{\"91\":1}}],[\"那么可以本地用暴力程序跑出来第\",{\"1\":{\"735\":1}}],[\"那么可以把所有\",{\"1\":{\"500\":1}}],[\"那么可以横着放一个\",{\"1\":{\"109\":1,\"110\":1}}],[\"那么是有后效性的\",{\"1\":{\"499\":1}}],[\"那么是图灵完备的\",{\"1\":{\"453\":1}}],[\"那么子任务\",{\"1\":{\"492\":1}}],[\"那么也可以直接快速求出来每个数的因子个数\",{\"1\":{\"462\":1}}],[\"那么\",{\"1\":{\"445\":1,\"497\":1,\"500\":1,\"559\":1,\"632\":2}}],[\"那么直接广度优先搜索是最稳妥的方法\",{\"1\":{\"436\":1}}],[\"那么其实中间可以用取模优化来加速\",{\"1\":{\"435\":1}}],[\"那么当前操作的人就会这么做\",{\"1\":{\"432\":1}}],[\"那么当前就是先手必败的\",{\"1\":{\"432\":1}}],[\"那么很好\",{\"1\":{\"428\":1}}],[\"那么稻草人放在第一行\",{\"1\":{\"426\":1}}],[\"那么精准抵达\",{\"1\":{\"405\":1}}],[\"那么必然是\",{\"1\":{\"404\":1}}],[\"那么类似双指针的做法\",{\"1\":{\"226\":1}}],[\"那么会插入到之前的\",{\"1\":{\"211\":1}}],[\"那么会舍入到最接近的偶数数位\",{\"1\":{\"91\":1}}],[\"那么保留\",{\"1\":{\"91\":1}}],[\"那么有可能会有两个小问题\",{\"1\":{\"91\":1}}],[\"时直接输出答案就好\",{\"1\":{\"838\":1}}],[\"时只要考虑最后三位的值即可\",{\"1\":{\"658\":1}}],[\"时输出天数并停止循环即可\",{\"1\":{\"881\":1}}],[\"时输出\",{\"1\":{\"622\":2}}],[\"时也可以直接输出\",{\"1\":{\"611\":1}}],[\"时答案都为\",{\"1\":{\"537\":1}}],[\"时答案为\",{\"1\":{\"537\":3}}],[\"时区转换\",{\"0\":{\"529\":1}}],[\"时都是先手必胜的\",{\"1\":{\"432\":1}}],[\"时后面随便填\",{\"1\":{\"335\":1}}],[\"时看前面多少种\",{\"1\":{\"329\":1}}],[\"时间在起点\",{\"1\":{\"668\":1}}],[\"时间复杂度的代码完成该题\",{\"1\":{\"815\":1}}],[\"时间复杂度的做法了\",{\"1\":{\"329\":1}}],[\"时间复杂度会不够\",{\"1\":{\"478\":1}}],[\"时间复杂度\",{\"0\":{\"287\":1},\"1\":{\"287\":2,\"388\":1,\"389\":1,\"400\":1,\"457\":1,\"490\":1}}],[\"时间够把所有\",{\"1\":{\"147\":1}}],[\"时间够不够\",{\"1\":{\"147\":1}}],[\"时能否送完\",{\"1\":{\"244\":2}}],[\"时最少反转次数\",{\"1\":{\"221\":1}}],[\"时\",{\"1\":{\"211\":1,\"328\":1,\"400\":1,\"413\":1,\"415\":1,\"446\":1,\"553\":1,\"671\":1,\"801\":1,\"802\":1,\"842\":1}}],[\"时的状态\",{\"1\":{\"204\":1}}],[\"时交换两个变量\",{\"1\":{\"129\":1}}],[\"枚举找到是哪两个数即可\",{\"1\":{\"904\":1}}],[\"枚举所有逆序对即可\",{\"1\":{\"818\":1}}],[\"枚举所有可能性\",{\"1\":{\"185\":1,\"186\":1,\"329\":1}}],[\"枚举做法\",{\"0\":{\"804\":1}}],[\"枚举二维数组每个位置\",{\"1\":{\"700\":1}}],[\"枚举组成了几组即可\",{\"1\":{\"635\":1}}],[\"枚举前半部分\",{\"1\":{\"614\":1}}],[\"枚举前三种鸡的数量\",{\"1\":{\"611\":1}}],[\"枚举优化\",{\"1\":{\"598\":1,\"611\":1}}],[\"枚举到下一个人时就不会在执行第二轮循环了\",{\"1\":{\"559\":1}}],[\"枚举出每一个\",{\"1\":{\"504\":1}}],[\"枚举策略为遍历字符串\",{\"1\":{\"504\":1}}],[\"枚举后就只要\",{\"1\":{\"490\":1}}],[\"枚举每种答案组合\",{\"1\":{\"395\":1}}],[\"枚举每个时间\",{\"1\":{\"668\":1}}],[\"枚举每个数\",{\"1\":{\"591\":1}}],[\"枚举每个物品放到了哪组\",{\"1\":{\"278\":1}}],[\"枚举每个人花费不超过多少时间\",{\"1\":{\"219\":2}}],[\"枚举上上行\",{\"1\":{\"306\":1}}],[\"枚举sta1的每个1\",{\"1\":{\"306\":2}}],[\"枚举当前这一位\",{\"1\":{\"270\":1}}],[\"枚举哪个骑士接\",{\"1\":{\"259\":1}}],[\"枚举他能攻击多少人\",{\"1\":{\"197\":1}}],[\"枚举\",{\"1\":{\"184\":1,\"259\":1,\"668\":1}}],[\"枚举第\",{\"1\":{\"154\":1}}],[\"枚举第一行的写法\",{\"0\":{\"154\":1}}],[\"枚举右边界\",{\"1\":{\"146\":1}}],[\"枚举走到了第几个钓鱼点\",{\"1\":{\"144\":1,\"147\":1,\"148\":1}}],[\"剩余部分的倍数了\",{\"1\":{\"904\":1}}],[\"剩余的钓鱼次数钓的必然都是\",{\"1\":{\"146\":1}}],[\"剩下\",{\"1\":{\"655\":1}}],[\"剩下所有物品中最小的那组\",{\"1\":{\"280\":1}}],[\"剩下位置为原数绝对值的二进制\",{\"1\":{\"86\":1}}],[\"使得它除以\",{\"1\":{\"904\":1}}],[\"使得两个人的分数都\",{\"1\":{\"632\":1}}],[\"使得\",{\"1\":{\"413\":1,\"620\":1}}],[\"使得超过\",{\"1\":{\"146\":1}}],[\"使用等差数列求和公式\",{\"1\":{\"812\":1}}],[\"使用整型来存储和比较即可\",{\"1\":{\"622\":1}}],[\"使用题目给出的\",{\"1\":{\"533\":1}}],[\"使用简单的嵌套循环\",{\"1\":{\"503\":1}}],[\"使用差分数组就能快速搞定了\",{\"1\":{\"350\":1}}],[\"使用标准命名空间\",{\"1\":{\"48\":1}}],[\"使用万能头文件\",{\"1\":{\"48\":1}}],[\"使用\",{\"0\":{\"67\":1},\"1\":{\"47\":1,\"139\":1,\"140\":1}}],[\"二分做法\",{\"0\":{\"803\":1}}],[\"二分或者双指针都可以\",{\"1\":{\"462\":1}}],[\"二分找到\",{\"1\":{\"146\":1}}],[\"二维形式\",{\"0\":{\"361\":1}}],[\"二维数组上模拟走路即可\",{\"1\":{\"909\":1}}],[\"二维数组\",{\"0\":{\"221\":1},\"1\":{\"674\":1}}],[\"二进制小数\",{\"0\":{\"746\":1}}],[\"二进制从最低位到最高位\",{\"1\":{\"85\":1}}],[\"二进制即要求满二进一\",{\"1\":{\"85\":1}}],[\"次标记\",{\"1\":{\"900\":1}}],[\"次分配块的标记加在一起也不超过\",{\"1\":{\"900\":1}}],[\"次输出即可\",{\"1\":{\"838\":1}}],[\"次就猜完了\",{\"1\":{\"655\":1}}],[\"次就能完成了\",{\"1\":{\"655\":1}}],[\"次操作\",{\"1\":{\"574\":1}}],[\"次操作机会\",{\"1\":{\"160\":2}}],[\"次乘以\",{\"1\":{\"508\":2}}],[\"次方\",{\"0\":{\"584\":1},\"1\":{\"508\":2}}],[\"次完成输入\",{\"1\":{\"503\":1}}],[\"次大值在右半边\",{\"1\":{\"447\":1}}],[\"次大值在左半边\",{\"1\":{\"447\":1}}],[\"次大\",{\"1\":{\"440\":1}}],[\"次检查\",{\"1\":{\"352\":1}}],[\"次的循环就能找到答案了\",{\"1\":{\"904\":1}}],[\"次的右边某个数到\",{\"1\":{\"320\":2}}],[\"次的左边某个数到\",{\"1\":{\"320\":2}}],[\"次交换完成排序\",{\"1\":{\"173\":1}}],[\"次都会在这里消耗\",{\"1\":{\"146\":1}}],[\"次\",{\"1\":{\"146\":1,\"164\":2,\"286\":2,\"329\":2,\"453\":1,\"489\":1,\"503\":1,\"668\":1,\"742\":1,\"838\":1,\"900\":1}}],[\"次以内被钓完\",{\"1\":{\"146\":1}}],[\"钓鱼2\",{\"0\":{\"148\":1}}],[\"钓鱼\",{\"1\":{\"146\":1}}],[\"钓鱼1\",{\"0\":{\"143\":1}}],[\"条以上的次数都抓完\",{\"1\":{\"147\":1}}],[\"条的次数\",{\"1\":{\"146\":1}}],[\"条的钓鱼点都能被钓完\",{\"1\":{\"146\":1}}],[\"条的钓鱼点\",{\"1\":{\"146\":2}}],[\"条\",{\"1\":{\"146\":1}}],[\"条件不成立时执行的语句\",{\"1\":{\"75\":1}}],[\"条件成立时执行的语句\",{\"1\":{\"75\":1}}],[\"条件表达式\",{\"1\":{\"75\":1}}],[\"条件判断语法\",{\"0\":{\"75\":1}}],[\"条件判断\",{\"0\":{\"70\":1},\"1\":{\"574\":1}}],[\"相关的单词数量增加\",{\"1\":{\"875\":1}}],[\"相邻奇偶性不同\",{\"1\":{\"605\":1}}],[\"相等\",{\"1\":{\"622\":1}}],[\"相等的情况\",{\"1\":{\"565\":1}}],[\"相等之后\",{\"1\":{\"441\":1}}],[\"相等不等\",{\"1\":{\"81\":1}}],[\"相连的都能走了\",{\"1\":{\"428\":1}}],[\"相当于第\",{\"1\":{\"335\":1}}],[\"相同位数\",{\"1\":{\"142\":1}}],[\"值\",{\"1\":{\"142\":2,\"415\":1}}],[\"值为增加之后的值\",{\"1\":{\"64\":1}}],[\"值为增加之前的值\",{\"1\":{\"64\":1}}],[\"命中的有两个\",{\"1\":{\"400\":1}}],[\"命中的是\",{\"1\":{\"400\":1}}],[\"命中的\",{\"1\":{\"400\":1}}],[\"命中了的话的首项\",{\"1\":{\"141\":1}}],[\"命名空间\",{\"1\":{\"47\":1}}],[\"就跳过\",{\"1\":{\"897\":1}}],[\"就习惯性改成\",{\"1\":{\"842\":1}}],[\"就输出\",{\"1\":{\"841\":1}}],[\"就给小时数减少\",{\"1\":{\"822\":1}}],[\"就停也是能满分的\",{\"1\":{\"802\":1}}],[\"就额外再需要由\",{\"1\":{\"779\":2}}],[\"就用着一个\",{\"1\":{\"756\":1}}],[\"就需要有\",{\"1\":{\"779\":1}}],[\"就需要用不损失精度的做法了\",{\"1\":{\"746\":1}}],[\"就需要使用差分的方式处理\",{\"1\":{\"831\":1}}],[\"就需要使用\",{\"1\":{\"518\":1}}],[\"就没有地方放数字了\",{\"1\":{\"700\":1}}],[\"就在起点\",{\"1\":{\"668\":2}}],[\"就看\",{\"1\":{\"668\":1}}],[\"就看看更小的全搞完时间行不行\",{\"1\":{\"147\":1}}],[\"就行\",{\"1\":{\"547\":1,\"734\":1}}],[\"就行了\",{\"1\":{\"546\":1}}],[\"就将结果直接换为字符\",{\"1\":{\"507\":1}}],[\"就好\",{\"1\":{\"484\":1,\"488\":1,\"530\":1,\"822\":2,\"835\":1,\"850\":1,\"856\":1,\"897\":1}}],[\"就好了\",{\"1\":{\"407\":1,\"452\":1,\"453\":1,\"545\":1,\"792\":1}}],[\"就两个人\",{\"1\":{\"480\":1}}],[\"就确定了根就两个\",{\"1\":{\"471\":1}}],[\"就自带一个\",{\"1\":{\"465\":1}}],[\"就更简单了\",{\"1\":{\"462\":1}}],[\"就\",{\"1\":{\"457\":1}}],[\"就有了这道题\",{\"1\":{\"457\":1}}],[\"就再放回来之前再放个\",{\"1\":{\"453\":1}}],[\"就完成了\",{\"1\":{\"453\":1}}],[\"就说明最大值在左半边\",{\"1\":{\"446\":1}}],[\"就免费\",{\"1\":{\"441\":1}}],[\"就够了\",{\"1\":{\"413\":1}}],[\"就一个单词\",{\"1\":{\"407\":1}}],[\"就来一个\",{\"1\":{\"397\":1}}],[\"就能拿到\",{\"1\":{\"435\":1,\"453\":1}}],[\"就能\",{\"1\":{\"413\":1}}],[\"就能存\",{\"1\":{\"406\":1}}],[\"就能让我们知道实际的意思是\",{\"1\":{\"351\":1}}],[\"就能转变为去重后最后一个元素位置的下标\",{\"1\":{\"349\":1}}],[\"就能组成多少个\",{\"1\":{\"328\":1}}],[\"就会相对麻烦很多\",{\"1\":{\"325\":1}}],[\"就可以算出具体的数\",{\"1\":{\"853\":1}}],[\"就可以算出每个人朋友的朋友总数\",{\"1\":{\"726\":1}}],[\"就可以知道该输出什么\",{\"1\":{\"850\":1}}],[\"就可以从\",{\"1\":{\"835\":1}}],[\"就可以得到第一个周期的结果\",{\"1\":{\"835\":1}}],[\"就可以优化为\",{\"1\":{\"812\":1}}],[\"就可以变为\",{\"1\":{\"772\":1}}],[\"就可以\",{\"1\":{\"658\":1}}],[\"就可以确定三个数位分别是哪三个数\",{\"1\":{\"655\":1}}],[\"就可以视作\",{\"1\":{\"632\":1}}],[\"就可以拿到满分\",{\"1\":{\"621\":1}}],[\"就可以处理下一个位置了\",{\"1\":{\"556\":1}}],[\"就可以构建下面这棵树\",{\"1\":{\"494\":1}}],[\"就可以分析出最大值在左半边还是右半边了\",{\"1\":{\"447\":1}}],[\"就可以考虑塞一个新物品能否达成就要么放到最小的那组\",{\"1\":{\"280\":1}}],[\"就可以两个程序完成手动交互了\",{\"1\":{\"174\":1}}],[\"就记忆化一下\",{\"1\":{\"270\":1}}],[\"就往后挪\",{\"1\":{\"226\":1}}],[\"就改成\",{\"1\":{\"216\":1}}],[\"就是一个简单的模拟题了\",{\"1\":{\"846\":1}}],[\"就是一个弱化版的\",{\"1\":{\"831\":1}}],[\"就是排个序然后按照题意模拟即可\",{\"1\":{\"759\":1}}],[\"就是我们之前第二场语法周赛的比大小的弱化版了\",{\"1\":{\"671\":1}}],[\"就是\",{\"1\":{\"658\":1}}],[\"就是真\",{\"1\":{\"500\":1}}],[\"就是所有他做过的题只能出现一个\",{\"1\":{\"490\":1}}],[\"就是所有大于等于\",{\"1\":{\"436\":1}}],[\"就是把较大的数变为两个数的差\",{\"1\":{\"435\":1}}],[\"就是简单的模拟即可\",{\"1\":{\"430\":1}}],[\"就是先向父亲节点方向走到\",{\"1\":{\"414\":1}}],[\"就是个暴力枚举\",{\"1\":{\"412\":1}}],[\"就是唯一的一种走法了\",{\"1\":{\"404\":1}}],[\"就是前\",{\"1\":{\"215\":1}}],[\"就是当前的月份\",{\"1\":{\"135\":1,\"136\":1}}],[\"就直接检查就好了\",{\"1\":{\"187\":1}}],[\"就不停消除掉当前因子\",{\"1\":{\"792\":1}}],[\"就不停使用\",{\"1\":{\"747\":1}}],[\"就不会重叠了\",{\"1\":{\"756\":1}}],[\"就不需要判断跨天了\",{\"1\":{\"527\":1}}],[\"就不需要判断闰年了\",{\"1\":{\"527\":1}}],[\"就不需要想那么多了\",{\"1\":{\"515\":1}}],[\"就不可能再折返回去了\",{\"1\":{\"403\":1}}],[\"就不管了\",{\"1\":{\"186\":1}}],[\"就不用修改\",{\"1\":{\"141\":1}}],[\"就不用看后面的了\",{\"1\":{\"141\":1}}],[\"就多一位了\",{\"1\":{\"181\":1}}],[\"公差等差的等差数列们\",{\"0\":{\"752\":1}}],[\"公差要一样\",{\"1\":{\"565\":1}}],[\"公差为\",{\"1\":{\"302\":1,\"303\":1}}],[\"公差\",{\"1\":{\"141\":2}}],[\"首次参赛手册\",{\"1\":{\"477\":1}}],[\"首先需要了解关于同余的基础知识\",{\"1\":{\"904\":1}}],[\"首先需要确定枚举的策略来确保不会重复或遗漏\",{\"1\":{\"505\":1}}],[\"首先这题的数据范围给的是十六进制\",{\"1\":{\"900\":1}}],[\"首先可以算出每个周期的长度\",{\"1\":{\"835\":1}}],[\"首先区间的端点必然在\",{\"1\":{\"802\":1}}],[\"首先对于\",{\"1\":{\"772\":1}}],[\"首先因为\",{\"1\":{\"766\":1}}],[\"首先理解星星历的机制\",{\"1\":{\"740\":1}}],[\"首先计算一件物品的盈利金额\",{\"1\":{\"739\":1}}],[\"首先判断价格是否存在涨幅\",{\"1\":{\"739\":1}}],[\"首先进行数位分解\",{\"1\":{\"652\":1}}],[\"首先定义一个结构体\",{\"1\":{\"623\":1}}],[\"首先就是这个题目要想明白几个事情\",{\"1\":{\"574\":1}}],[\"首先在二维数组中找出灯所在的位置\",{\"1\":{\"509\":1}}],[\"首先循环\",{\"1\":{\"503\":1}}],[\"首先子任务\",{\"1\":{\"495\":1}}],[\"首先容易发现\",{\"1\":{\"493\":1}}],[\"首先简单的暴力枚举就不说了\",{\"1\":{\"484\":1}}],[\"首先写完暴力枚举的代码后\",{\"1\":{\"437\":1}}],[\"首先还原时显然每次都只有一种可能的操作\",{\"1\":{\"435\":1}}],[\"首先所有质数局面以及小于\",{\"1\":{\"432\":1}}],[\"首先要想清楚\",{\"1\":{\"419\":1}}],[\"首先要注意到\",{\"1\":{\"403\":1}}],[\"首先\",{\"1\":{\"413\":1}}],[\"首先显然二叉搜索树的中序遍历就是完整的顺序\",{\"1\":{\"427\":1}}],[\"首先显然直接\",{\"1\":{\"402\":1}}],[\"首先显然如果最高位为\",{\"1\":{\"352\":1}}],[\"首项变到第\",{\"1\":{\"705\":1}}],[\"首项为\",{\"1\":{\"146\":1,\"169\":1}}],[\"首项\",{\"1\":{\"141\":1,\"705\":1}}],[\"首页\",{\"0\":{\"0\":1}}],[\"|=\",{\"1\":{\"139\":1,\"140\":4,\"319\":2,\"444\":1}}],[\"|\",{\"1\":{\"139\":4,\"140\":3,\"248\":3,\"319\":2,\"338\":3,\"479\":1}}],[\"||d==\",{\"1\":{\"911\":2}}],[\"||\",{\"1\":{\"3\":4,\"15\":1,\"18\":1,\"73\":1,\"81\":1,\"98\":2,\"126\":1,\"142\":2,\"153\":1,\"154\":1,\"162\":2,\"163\":2,\"167\":7,\"187\":2,\"188\":2,\"196\":4,\"199\":1,\"203\":2,\"214\":1,\"216\":1,\"217\":3,\"237\":1,\"239\":1,\"242\":1,\"249\":2,\"257\":2,\"260\":2,\"267\":1,\"268\":3,\"275\":2,\"276\":8,\"283\":1,\"288\":1,\"291\":1,\"295\":1,\"305\":4,\"306\":1,\"307\":2,\"317\":1,\"320\":2,\"329\":1,\"336\":6,\"343\":1,\"397\":1,\"402\":2,\"421\":4,\"422\":4,\"423\":4,\"428\":1,\"435\":1,\"440\":1,\"448\":1,\"460\":6,\"471\":1,\"483\":2,\"487\":1,\"488\":2,\"494\":1,\"499\":2,\"513\":5,\"516\":1,\"527\":2,\"572\":4,\"575\":11,\"583\":1,\"622\":2,\"653\":3,\"685\":3,\"732\":7,\"741\":2,\"786\":1,\"796\":1,\"809\":2,\"872\":1,\"875\":2}}],[\"从维护一个数改成维护两个数就好\",{\"1\":{\"846\":1}}],[\"从左到右扫描单词\",{\"1\":{\"741\":1}}],[\"从左往右扫描\",{\"1\":{\"312\":1,\"313\":1}}],[\"从下标为\",{\"1\":{\"505\":1}}],[\"从而构建一棵树\",{\"1\":{\"494\":1}}],[\"从前往后枚举计数就好\",{\"1\":{\"897\":1}}],[\"从前往后\",{\"1\":{\"485\":1,\"756\":1,\"832\":1}}],[\"从大到小吗\",{\"0\":{\"562\":1}}],[\"从大到小\",{\"1\":{\"441\":1}}],[\"从链表中删除\",{\"1\":{\"391\":1}}],[\"从小到大枚举每个货币\",{\"1\":{\"307\":1}}],[\"从接王点骑士去汇合点\",{\"1\":{\"259\":1}}],[\"从第一行开始搜看能否覆盖下面的所有位置\",{\"1\":{\"242\":1}}],[\"从后往前恢复每个星球\",{\"1\":{\"215\":1}}],[\"从1开始\",{\"1\":{\"213\":1,\"214\":1}}],[\"从上往下第\",{\"1\":{\"187\":1}}],[\"从个位开始枚举\",{\"1\":{\"185\":1,\"186\":1}}],[\"从\",{\"1\":{\"139\":1,\"140\":1,\"248\":1,\"249\":1,\"320\":1,\"405\":1,\"414\":1,\"740\":1,\"812\":2,\"900\":1}}],[\"从队列开头弹出元素\",{\"1\":{\"104\":1}}],[\"从队列开头放入\",{\"1\":{\"104\":1}}],[\"从队列末尾弹出元素\",{\"1\":{\"104\":1}}],[\"从队列末尾放入\",{\"1\":{\"104\":1}}],[\"验证一下就好了\",{\"1\":{\"137\":1}}],[\"$\",{\"1\":{\"137\":1,\"169\":1,\"783\":1,\"802\":1}}],[\"$o\",{\"1\":{\"137\":1}}],[\"再整理一次水杯\",{\"0\":{\"886\":1}}],[\"再来处理的做法\",{\"1\":{\"907\":1}}],[\"再来按照前面的做法即可\",{\"1\":{\"863\":1}}],[\"再来一个个用户检查是否符合条件\",{\"1\":{\"490\":1}}],[\"再求和就好\",{\"1\":{\"897\":1}}],[\"再求\",{\"1\":{\"859\":1}}],[\"再转回去即可\",{\"1\":{\"822\":1}}],[\"再次仔细读题就可以发现题目没有读对\",{\"1\":{\"526\":1}}],[\"再次抓住牛\",{\"0\":{\"401\":1}}],[\"再判断结果是否小于\",{\"1\":{\"507\":1}}],[\"再放回来\",{\"1\":{\"453\":1}}],[\"再执行一次\",{\"1\":{\"453\":1}}],[\"再回头\",{\"1\":{\"405\":1}}],[\"再回头精准抵达\",{\"1\":{\"403\":1}}],[\"再\",{\"1\":{\"137\":1,\"453\":1}}],[\"必须满足\",{\"1\":{\"818\":1}}],[\"必须是严格的偏序关系\",{\"1\":{\"759\":1}}],[\"必须是连续的一段\",{\"1\":{\"351\":1}}],[\"必须是更优先的类型\",{\"1\":{\"101\":1}}],[\"必然能过\",{\"1\":{\"734\":1}}],[\"必然开心程度也就高\",{\"1\":{\"623\":1}}],[\"必然就是最优解\",{\"1\":{\"493\":1}}],[\"必然要花差那么多次变成相等的\",{\"1\":{\"441\":1}}],[\"必然小于等于\",{\"1\":{\"413\":1}}],[\"必然是\",{\"1\":{\"413\":1,\"440\":1}}],[\"必然存在相邻的前缀关系\",{\"1\":{\"410\":1}}],[\"必然合法了\",{\"1\":{\"186\":1}}],[\"必然不是无限次\",{\"1\":{\"146\":1}}],[\"必要条件为\",{\"1\":{\"137\":1}}],[\"报数\",{\"0\":{\"137\":1}}],[\"整型没法存储那么大的数\",{\"1\":{\"856\":1}}],[\"整型溢出\",{\"0\":{\"581\":1}}],[\"整个数组没有修改过\",{\"1\":{\"874\":1}}],[\"整个序列一定是环状意义上连续的\",{\"1\":{\"806\":1}}],[\"整个朋友关系形成了一条链\",{\"1\":{\"726\":1}}],[\"整个路程都超速\",{\"1\":{\"198\":1}}],[\"整百的存钱\",{\"1\":{\"134\":1,\"135\":1,\"136\":1}}],[\"整数编码\",{\"0\":{\"84\":1}}],[\"整数\",{\"1\":{\"47\":1,\"61\":1}}],[\"扣除掉预算\",{\"1\":{\"134\":1,\"135\":1,\"136\":1}}],[\"块的数量\",{\"1\":{\"321\":1}}],[\"块\",{\"1\":{\"134\":1,\"135\":1,\"136\":1}}],[\"发放了多少硬币\",{\"0\":{\"797\":1}}],[\"发现线性筛能考\",{\"1\":{\"415\":1}}],[\"发现了一个\",{\"1\":{\"756\":1}}],[\"发现了这个之后这题就没啥难度了\",{\"1\":{\"414\":1}}],[\"发现了小的就交换\",{\"0\":{\"27\":1}}],[\"发现\",{\"1\":{\"413\":1}}],[\"发\",{\"1\":{\"134\":1,\"135\":1,\"136\":1}}],[\"津津的储蓄计划\",{\"0\":{\"133\":1}}],[\"里面查即可\",{\"1\":{\"574\":1}}],[\"里面的每种字母个数进行统计就行了\",{\"1\":{\"574\":1}}],[\"里面遍历\",{\"0\":{\"309\":1}}],[\"里面\",{\"1\":{\"131\":1,\"132\":1}}],[\"含k个3的数\",{\"0\":{\"130\":1}}],[\"也要一辆卡车\",{\"1\":{\"863\":1}}],[\"也有\",{\"1\":{\"740\":1}}],[\"也是要规避整除情况\",{\"1\":{\"740\":1}}],[\"也是\",{\"1\":{\"622\":1}}],[\"也不需要统计系动词数量\",{\"1\":{\"741\":1}}],[\"也不是\",{\"1\":{\"622\":1}}],[\"也不会影响正确的数值\",{\"1\":{\"530\":1}}],[\"也可获得\",{\"1\":{\"502\":1}}],[\"也可以嵌套一层\",{\"1\":{\"850\":1}}],[\"也可以手动计算打表\",{\"1\":{\"694\":1}}],[\"也可以枚举每种植物有几个\",{\"1\":{\"629\":1}}],[\"也可以直接对所有帽子排序\",{\"1\":{\"897\":1}}],[\"也可以直接用循环模拟处理\",{\"1\":{\"835\":1}}],[\"也可以直接把三个数字重新组成为一个数\",{\"1\":{\"608\":1}}],[\"也可以直接不停读字符然后处理\",{\"1\":{\"471\":1}}],[\"也可以用整数的方式\",{\"1\":{\"537\":1}}],[\"也可以先右再左\",{\"1\":{\"485\":1}}],[\"也可以去原题看看题解\",{\"1\":{\"475\":1}}],[\"也可以写\",{\"1\":{\"352\":1}}],[\"也可以使用自带的\",{\"1\":{\"129\":1}}],[\"也拿不到分\",{\"1\":{\"492\":1}}],[\"也就是告诉了大家测试点的输入\",{\"1\":{\"838\":1}}],[\"也就是说\",{\"1\":{\"818\":1}}],[\"也就是说可以手动算出结果后打表\",{\"1\":{\"585\":1}}],[\"也就是\",{\"1\":{\"665\":1}}],[\"也就是字符的\",{\"1\":{\"518\":1}}],[\"也就是每个节点如果和父节点颜色不一样\",{\"1\":{\"494\":1}}],[\"也就是他做过的题之间任意两个都是冲突的\",{\"1\":{\"490\":1}}],[\"也就是能存得下\",{\"1\":{\"478\":1}}],[\"也写不下呀\",{\"1\":{\"484\":1}}],[\"也能得到正确的结果\",{\"1\":{\"626\":1}}],[\"也能到这个级别\",{\"1\":{\"451\":1}}],[\"也能造出来的\",{\"1\":{\"406\":1}}],[\"也会造成和我们所想不同\",{\"1\":{\"91\":1}}],[\"较小\",{\"1\":{\"129\":1}}],[\"来找到答案后面有几个\",{\"1\":{\"907\":1}}],[\"来规避这个问题\",{\"1\":{\"891\":1}}],[\"来让我的主函数更简洁\",{\"1\":{\"874\":1}}],[\"来让自己必胜\",{\"1\":{\"432\":1}}],[\"来确定是否有三等奖\",{\"1\":{\"750\":1}}],[\"来决定输出\",{\"1\":{\"846\":1}}],[\"来决定加多少即可\",{\"1\":{\"707\":1}}],[\"来决定怎么输出\",{\"1\":{\"397\":1}}],[\"来说\",{\"1\":{\"556\":1}}],[\"来统计就很方便了\",{\"1\":{\"518\":1}}],[\"来输入了\",{\"1\":{\"518\":1}}],[\"来把枚举规模降低到\",{\"1\":{\"484\":1}}],[\"来存储当前的数\",{\"1\":{\"453\":1}}],[\"来二分即可\",{\"1\":{\"448\":1}}],[\"来源\",{\"1\":{\"437\":1,\"445\":1}}],[\"来加速\",{\"1\":{\"418\":1}}],[\"来拿到\",{\"1\":{\"415\":1}}],[\"来做了\",{\"1\":{\"399\":1}}],[\"来避免非法\",{\"1\":{\"397\":1}}],[\"来实现\",{\"1\":{\"198\":1}}],[\"来保证\",{\"1\":{\"129\":1}}],[\"来初始化\",{\"1\":{\"3\":1}}],[\"求出\",{\"1\":{\"887\":1}}],[\"求出初始值后每次只修改变动带来的影响\",{\"1\":{\"874\":1}}],[\"求最值\",{\"1\":{\"887\":1}}],[\"求所有数进行与运算的结果\",{\"1\":{\"866\":1}}],[\"求每个问题的答案了\",{\"1\":{\"658\":1}}],[\"求数位和\",{\"1\":{\"533\":1}}],[\"求解全局最小值\",{\"1\":{\"350\":1}}],[\"求解一元二次方程\",{\"0\":{\"129\":1}}],[\"求模式串\",{\"1\":{\"284\":1}}],[\"求模式串的\",{\"0\":{\"284\":1}}],[\"求\",{\"1\":{\"283\":1,\"306\":1,\"366\":1}}],[\"求和后\",{\"1\":{\"894\":1}}],[\"求和的每一项都根据具体情况计算价格即可\",{\"1\":{\"707\":1}}],[\"求和\",{\"0\":{\"274\":1},\"1\":{\"466\":1,\"467\":1,\"642\":1,\"881\":1,\"887\":1}}],[\"求前\",{\"1\":{\"208\":1}}],[\"求节点\",{\"1\":{\"12\":1}}],[\"能达成\",{\"1\":{\"904\":1}}],[\"能到\",{\"1\":{\"772\":1}}],[\"能查到就在这个里面优先查\",{\"1\":{\"574\":1}}],[\"能正确使用字符串即可\",{\"1\":{\"509\":1}}],[\"能拿不少分\",{\"1\":{\"490\":1}}],[\"能拉\",{\"1\":{\"480\":1}}],[\"能连通\",{\"1\":{\"352\":1}}],[\"能构成的\",{\"1\":{\"328\":1}}],[\"能走到\",{\"1\":{\"241\":1}}],[\"能活到\",{\"1\":{\"202\":1,\"203\":1}}],[\"能维持的生命\",{\"1\":{\"202\":1,\"203\":1,\"204\":1}}],[\"能否从\",{\"1\":{\"352\":1}}],[\"能否凑出来\",{\"1\":{\"307\":1}}],[\"能否由\",{\"1\":{\"196\":2}}],[\"能否达成\",{\"1\":{\"196\":1}}],[\"能否在\",{\"1\":{\"196\":1,\"340\":1}}],[\"能不能做第\",{\"1\":{\"500\":1}}],[\"能不能接上\",{\"1\":{\"485\":1}}],[\"能不能走到\",{\"1\":{\"428\":1}}],[\"能不能被表示出来\",{\"1\":{\"307\":1}}],[\"能不能表示出来\",{\"1\":{\"307\":1}}],[\"能不能到\",{\"1\":{\"259\":1}}],[\"能不能填\",{\"1\":{\"249\":1}}],[\"能不能达成\",{\"1\":{\"169\":1}}],[\"能不能再\",{\"1\":{\"146\":1}}],[\"能过\",{\"1\":{\"164\":1}}],[\"能搞定几个\",{\"1\":{\"161\":1}}],[\"能在\",{\"1\":{\"146\":1}}],[\"能吃的上第i道菜\",{\"1\":{\"128\":1}}],[\"能储存的范围\",{\"1\":{\"83\":1}}],[\"第九场\",{\"0\":{\"496\":1}}],[\"第八场\",{\"0\":{\"491\":1}}],[\"第七场\",{\"0\":{\"486\":1}}],[\"第六场\",{\"0\":{\"481\":1}}],[\"第五场\",{\"0\":{\"476\":1}}],[\"第四种鸡的数量必然是\",{\"1\":{\"611\":1}}],[\"第四场\",{\"0\":{\"468\":1}}],[\"第四题主要没考虑输入数据的类型可能会超\",{\"1\":{\"452\":1}}],[\"第三题没有特别严谨地做纯字符串题\",{\"1\":{\"761\":1}}],[\"第三题没有考虑\",{\"1\":{\"452\":1}}],[\"第三大的数\",{\"0\":{\"719\":1}}],[\"第三场\",{\"0\":{\"459\":1}}],[\"第三行的字母还没确定的话\",{\"1\":{\"186\":1}}],[\"第三行的式子\",{\"1\":{\"184\":1,\"185\":1,\"186\":1}}],[\"第三行直接计算\",{\"1\":{\"186\":1}}],[\"第三行直接算结果\",{\"0\":{\"186\":1}}],[\"第十六场\",{\"0\":{\"449\":1}}],[\"第十五场\",{\"0\":{\"439\":1}}],[\"第十四场\",{\"0\":{\"434\":1}}],[\"第十三场\",{\"0\":{\"429\":1}}],[\"第十二场\",{\"0\":{\"424\":1}}],[\"第十一场\",{\"0\":{\"416\":1}}],[\"第十场\",{\"0\":{\"411\":1}}],[\"第j个点为\",{\"1\":{\"318\":1}}],[\"第i行\",{\"1\":{\"306\":1}}],[\"第i行摆放方案为\",{\"1\":{\"306\":1}}],[\"第i\",{\"1\":{\"306\":2}}],[\"第x个数加k\",{\"1\":{\"266\":1}}],[\"第x层放在了第ans\",{\"1\":{\"217\":1}}],[\"第二个数是负数\",{\"1\":{\"622\":1}}],[\"第二个数是正数\",{\"1\":{\"622\":1}}],[\"第二个人走到\",{\"1\":{\"177\":1}}],[\"第二种的话就是用桶来统计\",{\"1\":{\"574\":1}}],[\"第二天的日期计算\",{\"1\":{\"527\":1}}],[\"第二次输出所有女生即可\",{\"1\":{\"521\":1}}],[\"第二行很多同学会用一元二次方程求根公式\",{\"1\":{\"471\":1}}],[\"第二行的式子\",{\"1\":{\"184\":1,\"185\":1,\"186\":1}}],[\"第二场\",{\"0\":{\"454\":1}}],[\"第二题需要输出两个相加会炸\",{\"1\":{\"452\":1}}],[\"第一题咱不考虑高阶语法的做法\",{\"1\":{\"835\":1}}],[\"第一题的数字游戏升级版\",{\"1\":{\"717\":1}}],[\"第一题给两个奇数即可\",{\"1\":{\"452\":1}}],[\"第一种就是没什么技术含量的开很多个变量进行统计就好了\",{\"1\":{\"574\":1}}],[\"第一步也是两种情况\",{\"1\":{\"495\":1}}],[\"第一步只有两种情况\",{\"1\":{\"495\":1}}],[\"第一是谁\",{\"0\":{\"456\":1}}],[\"第一列\",{\"1\":{\"426\":1}}],[\"第一场\",{\"0\":{\"396\":1}}],[\"第一块的块编号\",{\"1\":{\"321\":1}}],[\"第一行为起点的搜索\",{\"1\":{\"241\":1}}],[\"第一行按键情况\",{\"1\":{\"158\":1}}],[\"第一行的内容就是要细致\",{\"1\":{\"471\":1}}],[\"第一行的式子\",{\"1\":{\"184\":1,\"185\":1,\"186\":1}}],[\"第一行的案件情况\",{\"1\":{\"158\":1}}],[\"第一行的前\",{\"1\":{\"154\":1}}],[\"第一次输出所有男生\",{\"1\":{\"521\":1}}],[\"第一次被\",{\"1\":{\"400\":1}}],[\"第一次\",{\"1\":{\"147\":1}}],[\"第一个位置特殊判断\",{\"1\":{\"831\":1}}],[\"第一个\",{\"1\":{\"708\":1}}],[\"第一个小时和后续价格一致\",{\"1\":{\"707\":1}}],[\"第一个数就是最大值\",{\"1\":{\"859\":1}}],[\"第一个数是正数\",{\"1\":{\"622\":1}}],[\"第一个数是负数\",{\"1\":{\"622\":1}}],[\"第一个数字直接加入表达式\",{\"1\":{\"40\":1}}],[\"第一个人走到\",{\"1\":{\"177\":1}}],[\"第一个程序\",{\"0\":{\"44\":1}}],[\"第\",{\"0\":{\"735\":1},\"1\":{\"128\":2,\"162\":9,\"164\":1,\"173\":1,\"179\":2,\"196\":2,\"198\":3,\"199\":1,\"244\":2,\"248\":2,\"249\":3,\"259\":1,\"335\":1,\"340\":2,\"374\":1,\"378\":1,\"499\":1,\"705\":2,\"838\":1}}],[\"道的最大价值\",{\"1\":{\"128\":1}}],[\"道菜自己吃\",{\"1\":{\"128\":1}}],[\"道菜给先手吃\",{\"1\":{\"128\":1}}],[\"道菜\",{\"1\":{\"128\":1}}],[\"味道\",{\"1\":{\"128\":1}}],[\"当总和达到\",{\"1\":{\"881\":1}}],[\"当时间复杂度没有问题的时候\",{\"1\":{\"874\":1}}],[\"当算出了初始的所有单词以及对应的出现次数后\",{\"1\":{\"874\":1}}],[\"当题目给你一个不可能完成的任务时\",{\"1\":{\"735\":1}}],[\"当对应位置不相等时\",{\"1\":{\"652\":1}}],[\"当我下一次在时候\",{\"1\":{\"632\":1}}],[\"当两个数不一样时\",{\"1\":{\"419\":1}}],[\"当然你也可以继续往后打表\",{\"1\":{\"735\":1}}],[\"当然你也可以利用减法和\",{\"1\":{\"453\":1}}],[\"当然如果用后期知识点就是简单题了\",{\"1\":{\"629\":1}}],[\"当然如果你记得唯一分解定理\",{\"1\":{\"462\":1}}],[\"当然自己存储的时候要开\",{\"1\":{\"582\":1}}],[\"当然熟悉的同学也会发现这就是个简单的区间\",{\"1\":{\"495\":1}}],[\"当然进一步总结会发现\",{\"1\":{\"494\":1}}],[\"当然这题的字符串长度保证大于等于\",{\"1\":{\"842\":1}}],[\"当然这题也不能手写二分\",{\"1\":{\"478\":1}}],[\"当然这个条件看上去就不充分\",{\"1\":{\"137\":1}}],[\"当然\",{\"1\":{\"436\":1}}],[\"当然满分是个线性筛的做法\",{\"1\":{\"415\":1}}],[\"当然直接用字符串存左子树\",{\"1\":{\"406\":1}}],[\"当然也可以先判断\",{\"1\":{\"891\":1}}],[\"当然也可以一开始就给\",{\"1\":{\"835\":1}}],[\"当然也可以把两行字符串分别排序\",{\"1\":{\"815\":1}}],[\"当然也可以在求每个等差数列的和的时候用等差数列求和公式\",{\"1\":{\"753\":1}}],[\"当然也可以真的按照题目意思模拟\",{\"1\":{\"614\":1}}],[\"当然也可以按照我的方式\",{\"1\":{\"335\":1}}],[\"当然也可以枚举中间的\",{\"1\":{\"328\":1}}],[\"当差为i时最少反转次数\",{\"1\":{\"222\":1}}],[\"当\",{\"1\":{\"129\":1,\"533\":1,\"553\":1,\"611\":1,\"812\":1,\"838\":1}}],[\"当有两件物品\",{\"1\":{\"127\":1}}],[\"当价值一定时\",{\"1\":{\"127\":1}}],[\"当费用相同时\",{\"1\":{\"127\":1}}],[\"当前段的树的棵数\",{\"1\":{\"832\":1}}],[\"当前气血\",{\"1\":{\"747\":1}}],[\"当前字符匹配上之后寻找下一个字符\",{\"1\":{\"504\":1}}],[\"当前字符串\",{\"1\":{\"142\":1}}],[\"当前颜色\",{\"1\":{\"494\":1}}],[\"当前编号放入单调栈\",{\"1\":{\"475\":1}}],[\"当前点是某个\",{\"1\":{\"444\":1}}],[\"当前点为\",{\"1\":{\"228\":1}}],[\"当前入度为\",{\"1\":{\"366\":1}}],[\"当前入度\",{\"1\":{\"366\":1}}],[\"当前块的最后一个水果\",{\"1\":{\"321\":1}}],[\"当前块的第一个水果\",{\"1\":{\"321\":1}}],[\"当前用到的点数\",{\"1\":{\"313\":1,\"314\":1}}],[\"当前货币的面额为\",{\"1\":{\"307\":1}}],[\"当前连续一样的长度\",{\"1\":{\"286\":2}}],[\"当前连通块被标记了\",{\"1\":{\"228\":1}}],[\"当前连通块大小\",{\"1\":{\"228\":1}}],[\"当前物品\",{\"1\":{\"278\":1,\"279\":1}}],[\"当前位有几种可能\",{\"1\":{\"579\":1}}],[\"当前位能否为0~9\",{\"1\":{\"273\":1}}],[\"当前位置及左边有多少个管子\",{\"1\":{\"260\":1}}],[\"当前位置有东西就直接看下一个位置\",{\"1\":{\"109\":1,\"110\":1}}],[\"当前这一位的上限\",{\"1\":{\"270\":1}}],[\"当前这个人花的时间\",{\"1\":{\"219\":2}}],[\"当前这个人\",{\"1\":{\"196\":1}}],[\"当前要覆盖\",{\"1\":{\"242\":1}}],[\"当前区间完全属于要查询的部分就直接返回\",{\"1\":{\"237\":1,\"239\":1}}],[\"当前区间完全属于要查询的部分就偷个懒\",{\"1\":{\"237\":1,\"239\":1}}],[\"当前节点为\",{\"1\":{\"237\":2,\"239\":2,\"291\":1}}],[\"当前节点对应的区间为\",{\"1\":{\"19\":1,\"20\":1,\"21\":1}}],[\"当前状态为前\",{\"1\":{\"204\":1}}],[\"当前时间大于等于开始营业时间并且结束时间小于开始时间\",{\"1\":{\"527\":1}}],[\"当前时间大于等于开始营业时间并小于结束时间\",{\"1\":{\"527\":1}}],[\"当前时间\",{\"1\":{\"203\":1,\"244\":2}}],[\"当前能活到的时间\",{\"1\":{\"203\":1}}],[\"当前能走到的点多一个\",{\"1\":{\"200\":1}}],[\"当前高度\",{\"1\":{\"203\":1}}],[\"当前染色状态是\",{\"1\":{\"199\":2}}],[\"当前处理第\",{\"1\":{\"196\":1}}],[\"当前需要这么多\",{\"1\":{\"560\":1}}],[\"当前需要\",{\"1\":{\"196\":1}}],[\"当前是第now行\",{\"1\":{\"306\":1}}],[\"当前是第\",{\"1\":{\"196\":1}}],[\"当前考虑第step层放在第几列\",{\"1\":{\"217\":1}}],[\"当前考虑第\",{\"1\":{\"195\":1,\"298\":1}}],[\"当前三个数组处理到的位置\",{\"1\":{\"192\":1}}],[\"当前串全都变成全\",{\"1\":{\"160\":2}}],[\"当前串有\",{\"1\":{\"160\":1}}],[\"当前按键\",{\"1\":{\"158\":1}}],[\"当前行的按键~\",{\"1\":{\"158\":1}}],[\"当前行状态为\",{\"1\":{\"109\":1,\"110\":1}}],[\"当前枚举第一排的第\",{\"1\":{\"154\":1}}],[\"当前匹配的类型\",{\"1\":{\"142\":1}}],[\"当前匹配下标\",{\"1\":{\"142\":2}}],[\"当前\",{\"1\":{\"142\":2}}],[\"当前垃圾类型\",{\"1\":{\"142\":1}}],[\"当前的项数\",{\"1\":{\"146\":1}}],[\"当前的\",{\"1\":{\"135\":1,\"136\":1}}],[\"当前个位为\",{\"1\":{\"131\":1}}],[\"当前长度为\",{\"1\":{\"113\":1,\"116\":1,\"117\":1,\"122\":1,\"123\":1,\"233\":2}}],[\"当前看第\",{\"1\":{\"109\":1,\"110\":1}}],[\"当前栈大小\",{\"1\":{\"105\":1}}],[\"当前队列大小\",{\"1\":{\"104\":1,\"106\":1}}],[\"当前数组大小\",{\"1\":{\"103\":1}}],[\"当前做到了树上的now号节点\",{\"1\":{\"19\":1,\"20\":1,\"21\":1}}],[\"到后面还是相等的两个字符\",{\"1\":{\"601\":1}}],[\"到过的城市必然是某段子段\",{\"1\":{\"493\":1}}],[\"到父节点那条边\",{\"1\":{\"433\":1}}],[\"到了同一个集合\",{\"1\":{\"772\":1}}],[\"到了\",{\"1\":{\"427\":1,\"766\":1}}],[\"到达\",{\"1\":{\"405\":2}}],[\"到每个位置的最小跳跃步数\",{\"1\":{\"260\":1}}],[\"到\",{\"1\":{\"127\":1,\"198\":1,\"405\":1,\"414\":1,\"494\":1,\"504\":1,\"812\":3}}],[\"其余情况需要第二天开始时间再来\",{\"1\":{\"527\":1}}],[\"其实标记一下走过的位置\",{\"1\":{\"909\":1}}],[\"其实是可以的\",{\"1\":{\"909\":1}}],[\"其实也差不多\",{\"1\":{\"835\":1}}],[\"其实也就是\",{\"1\":{\"779\":1}}],[\"其实也就是辗转相除法\",{\"1\":{\"435\":1}}],[\"其实唯一麻烦点是数清楚每个字符几个洞\",{\"1\":{\"805\":1}}],[\"其实没太看懂这\",{\"1\":{\"900\":1}}],[\"其实没必要\",{\"1\":{\"649\":1}}],[\"其实没用\",{\"1\":{\"627\":1}}],[\"其实没有啥特殊的作用\",{\"1\":{\"595\":1}}],[\"其实应该是计算最少几次操作可以让原字符串中出现\",{\"1\":{\"574\":1}}],[\"其实只要能够判断两个事情就好了\",{\"1\":{\"565\":1}}],[\"其实只要在代码中统计有没有\",{\"1\":{\"545\":1}}],[\"其实只需要用字符串类型读入\",{\"1\":{\"564\":1}}],[\"其实只需要用\",{\"1\":{\"562\":1,\"563\":1}}],[\"其实比较容易想到用\",{\"1\":{\"499\":1}}],[\"其实就是个百钱买百鸡的升级版\",{\"1\":{\"611\":1}}],[\"其实就是计算\",{\"1\":{\"544\":1}}],[\"其实就是贪心先用\",{\"1\":{\"488\":1}}],[\"其实就看左边从哪儿开始往右走\",{\"1\":{\"404\":1}}],[\"其实本来准备给\",{\"1\":{\"480\":1}}],[\"其实我们会发现算术平方根只有\",{\"1\":{\"478\":1}}],[\"其实可以先把字符串对应到一个\",{\"1\":{\"465\":1}}],[\"其实第四题是比较简单的\",{\"1\":{\"438\":1}}],[\"其实容易发现\",{\"1\":{\"436\":1}}],[\"其实这题想清楚后就很简单\",{\"1\":{\"480\":1}}],[\"其实这题是为了给初赛服务的\",{\"1\":{\"406\":1}}],[\"其实这道题出题时我是翻\",{\"1\":{\"415\":1}}],[\"其实难度没有那么高\",{\"1\":{\"414\":1}}],[\"其实看看数据范围\",{\"1\":{\"412\":1}}],[\"其实\",{\"1\":{\"329\":1}}],[\"其实不用排序\",{\"1\":{\"241\":1}}],[\"其他情况下很容易发现每次碰撞都是一个\",{\"1\":{\"909\":1}}],[\"其他时候都有\",{\"1\":{\"801\":1}}],[\"其他人都有两个朋友\",{\"1\":{\"726\":1}}],[\"其他常见的代码错误\",{\"1\":{\"477\":1}}],[\"其他常见基础操作\",{\"0\":{\"96\":1}}],[\"其他排序方法都能做\",{\"1\":{\"347\":1}}],[\"其他排序以及\",{\"1\":{\"346\":1}}],[\"其他列变化\",{\"1\":{\"162\":2}}],[\"其他列一共需要几次\",{\"1\":{\"162\":2}}],[\"其中包括桃子的开胃值和开心值\",{\"1\":{\"623\":1}}],[\"其中较大值计入总分即可\",{\"1\":{\"503\":1}}],[\"其中体积最小的那组的体积\",{\"1\":{\"280\":1}}],[\"其中\",{\"1\":{\"126\":1,\"527\":1}}],[\"反向想想\",{\"1\":{\"490\":1}}],[\"反向最长公共子序列\",{\"0\":{\"124\":1}}],[\"反图\",{\"1\":{\"444\":1}}],[\"反间计\",{\"0\":{\"440\":1}}],[\"反客为主\",{\"0\":{\"436\":1}}],[\"反正最多只有\",{\"1\":{\"352\":1}}],[\"反转\",{\"1\":{\"343\":1}}],[\"反转两个操作次数最少的\",{\"1\":{\"343\":1}}],[\"反码\",{\"0\":{\"86\":1},\"1\":{\"86\":1}}],[\"排列的最长公共子序列长度\",{\"0\":{\"121\":1}}],[\"排序和贪心思想\",{\"1\":{\"623\":1}}],[\"排序去重输出\",{\"1\":{\"346\":1}}],[\"排序后的排名\",{\"1\":{\"151\":1}}],[\"排序\",{\"1\":{\"32\":1,\"441\":1,\"521\":1,\"556\":1,\"623\":1}}],[\"排序算法\",{\"0\":{\"25\":1}}],[\"前两项分别是\",{\"1\":{\"838\":1}}],[\"前两个子任务比较简单\",{\"1\":{\"818\":1}}],[\"前两个子任务就不说了\",{\"1\":{\"485\":1}}],[\"前两个字符断开反转的话\",{\"1\":{\"601\":1}}],[\"前后洗牌\",{\"0\":{\"613\":1}}],[\"前导\",{\"1\":{\"530\":1}}],[\"前一个点\",{\"1\":{\"366\":1}}],[\"前一轮能否由别人达成\",{\"1\":{\"196\":1}}],[\"前0行\",{\"1\":{\"306\":1}}],[\"前i行\",{\"1\":{\"306\":1}}],[\"前面的基础上再加一个判断是否有前缀关系就好\",{\"1\":{\"410\":1}}],[\"前面的两步走几次有多种情况\",{\"1\":{\"404\":1}}],[\"前面有多少种\",{\"1\":{\"328\":1}}],[\"前面刚好有\",{\"1\":{\"298\":2}}],[\"前面要变的不变\",{\"1\":{\"286\":2}}],[\"前面\",{\"1\":{\"196\":1,\"328\":1}}],[\"前面是否相等\",{\"1\":{\"168\":1}}],[\"前\",{\"1\":{\"120\":2,\"124\":2,\"125\":2,\"128\":1,\"199\":2,\"221\":1,\"340\":1,\"359\":1,\"361\":1,\"368\":1,\"705\":2}}],[\"前缀和优化\",{\"1\":{\"380\":1}}],[\"前缀最值查询\",{\"1\":{\"216\":1}}],[\"前缀\",{\"1\":{\"101\":1}}],[\"方向\",{\"1\":{\"875\":1}}],[\"方便了很多\",{\"1\":{\"859\":1}}],[\"方案\",{\"1\":{\"115\":1,\"116\":1,\"125\":1,\"162\":2,\"259\":2}}],[\"方法二\",{\"1\":{\"740\":1}}],[\"方法一\",{\"1\":{\"740\":1}}],[\"方法\",{\"0\":{\"89\":1,\"90\":1}}],[\"长度一致时比较字典序即可\",{\"1\":{\"671\":1}}],[\"长度一致时直接用小于号比较两个\",{\"1\":{\"671\":1}}],[\"长度大于等于\",{\"1\":{\"493\":1}}],[\"长度的\",{\"1\":{\"169\":1}}],[\"长度的最小值下标\",{\"1\":{\"13\":1}}],[\"长度\",{\"1\":{\"112\":1,\"113\":1,\"115\":1,\"116\":1,\"117\":1,\"120\":1,\"122\":1,\"123\":1,\"124\":1,\"125\":1,\"233\":2,\"269\":1,\"875\":1}}],[\"卖水果\",{\"0\":{\"111\":1,\"502\":1}}],[\"现在只需要比较\",{\"1\":{\"891\":1}}],[\"现在少了\",{\"1\":{\"705\":1}}],[\"现在时间小于开始时间\",{\"1\":{\"527\":1}}],[\"现在的栈顶就是下一个大于\",{\"1\":{\"475\":1}}],[\"现在的出题人一般都不会说四舍五入\",{\"1\":{\"91\":1}}],[\"现在考虑第\",{\"1\":{\"202\":1,\"203\":1}}],[\"现在来做第col列\",{\"1\":{\"187\":1}}],[\"现在当前位置肯定没东西\",{\"1\":{\"109\":1,\"110\":1}}],[\"铺地毯\",{\"0\":{\"175\":1}}],[\"铺满可以达成\",{\"1\":{\"109\":1,\"110\":1}}],[\"铺砖块\",{\"0\":{\"107\":1}}],[\"说明\",{\"1\":{\"109\":1,\"110\":1}}],[\"判断当前项的余数是否出现过了\",{\"1\":{\"904\":1}}],[\"判断当前的\",{\"1\":{\"196\":1}}],[\"判断相等和不等关系的时候会判断错\",{\"1\":{\"759\":1}}],[\"判断每个人朋友数量\",{\"1\":{\"726\":1}}],[\"判断每天停车时间是否大于\",{\"1\":{\"707\":1}}],[\"判断出来非普通轮就输出\",{\"1\":{\"626\":1}}],[\"判断原理同上\",{\"1\":{\"622\":1}}],[\"判断它是不是偶数位即可\",{\"1\":{\"591\":1}}],[\"判断就好\",{\"1\":{\"568\":1}}],[\"判断最后一位是奇数还是偶数就好了\",{\"1\":{\"564\":1}}],[\"判断最大值在不在右边\",{\"1\":{\"447\":1}}],[\"判断最大值在不在左边\",{\"1\":{\"447\":1}}],[\"判断胜负\",{\"1\":{\"513\":1}}],[\"判断类型与计算数字和\",{\"1\":{\"513\":1}}],[\"判断对应位置是否已落子即可记录出最终的解\",{\"1\":{\"505\":1}}],[\"判断小于等于\",{\"1\":{\"437\":1}}],[\"判断连通性可以上并查集或者简单的搜索都行\",{\"1\":{\"352\":1}}],[\"判断是否有解\",{\"1\":{\"241\":1,\"242\":1}}],[\"判断是否有实根\",{\"1\":{\"129\":1}}],[\"判断是否冲突\",{\"1\":{\"217\":1}}],[\"判断能不能见到当前垃圾\",{\"1\":{\"202\":1,\"203\":1}}],[\"判断\",{\"1\":{\"196\":1}}],[\"判断质数\",{\"1\":{\"180\":1}}],[\"判断以及减法\",{\"1\":{\"109\":1}}],[\"判断用户名密码是否正确\",{\"1\":{\"70\":1,\"74\":1}}],[\"分给的是啥分数\",{\"1\":{\"900\":1}}],[\"分帽子\",{\"0\":{\"896\":1}}],[\"分只要会基础的字符串\",{\"1\":{\"815\":1}}],[\"分只有一层含义\",{\"1\":{\"465\":1}}],[\"分解了一个整数\",{\"0\":{\"791\":1}}],[\"分解质因子\",{\"1\":{\"415\":1}}],[\"分下课\",{\"1\":{\"665\":1}}],[\"分钟通过减\",{\"1\":{\"835\":1}}],[\"分钟数\",{\"1\":{\"822\":1}}],[\"分钟数加上\",{\"1\":{\"822\":1}}],[\"分钟跑出来了这个结果\",{\"1\":{\"735\":1}}],[\"分钟\",{\"1\":{\"665\":2,\"708\":2,\"822\":1}}],[\"分钟之后剩下的部分也是偶数\",{\"1\":{\"665\":1}}],[\"分时课间休息\",{\"1\":{\"665\":1}}],[\"分糖果\",{\"0\":{\"634\":1}}],[\"分析\",{\"0\":{\"512\":1,\"515\":1,\"518\":1,\"521\":1,\"530\":1,\"533\":1,\"537\":1,\"541\":1,\"550\":1,\"553\":1,\"556\":1,\"559\":1,\"568\":1,\"571\":1,\"574\":1,\"578\":1,\"582\":1,\"585\":1,\"588\":1,\"591\":1,\"595\":1,\"598\":1,\"601\":1,\"604\":1,\"608\":1,\"611\":1,\"614\":1,\"617\":1,\"626\":1,\"629\":1,\"639\":1,\"642\":1,\"645\":1,\"648\":1,\"652\":1,\"655\":1,\"658\":1,\"661\":1,\"665\":1,\"668\":1,\"671\":1,\"674\":1,\"678\":1,\"681\":1,\"684\":1,\"687\":1,\"691\":1,\"694\":1,\"697\":1,\"700\":1,\"704\":1,\"707\":1,\"710\":1,\"713\":1,\"717\":1,\"720\":1,\"723\":1,\"726\":1,\"809\":1,\"812\":1,\"815\":1,\"818\":1,\"822\":1,\"825\":1,\"828\":1,\"831\":1,\"835\":1,\"838\":1,\"841\":1,\"846\":1,\"850\":1,\"853\":1,\"856\":1,\"859\":1,\"863\":1,\"866\":1,\"871\":1,\"874\":1,\"878\":1,\"881\":1,\"884\":1,\"887\":1,\"891\":1,\"894\":1,\"897\":1,\"900\":1,\"904\":1,\"909\":1}}],[\"分数据可能会有问题\",{\"1\":{\"485\":1}}],[\"分哈哈哈\",{\"1\":{\"483\":1}}],[\"分在题目描述送了\",{\"1\":{\"445\":1}}],[\"分搜索\",{\"0\":{\"443\":1}}],[\"分纯暴力广搜深搜都可以\",{\"1\":{\"442\":1}}],[\"分来自这一句\",{\"1\":{\"423\":1}}],[\"分就是个分类讨论的暴力枚举\",{\"1\":{\"661\":1}}],[\"分就是一个条件判断的题目\",{\"1\":{\"537\":1}}],[\"分就得到了\",{\"1\":{\"617\":1}}],[\"分就不多说了\",{\"1\":{\"417\":1,\"478\":1}}],[\"分就在嘴边了\",{\"1\":{\"402\":1}}],[\"分很简单\",{\"1\":{\"415\":1}}],[\"分了\",{\"1\":{\"402\":1,\"435\":1,\"453\":1}}],[\"分之后\",{\"1\":{\"402\":1}}],[\"分的基础上\",{\"1\":{\"541\":1}}],[\"分的代码\",{\"1\":{\"484\":1}}],[\"分的\",{\"1\":{\"402\":1}}],[\"分参考代码\",{\"0\":{\"534\":1},\"1\":{\"399\":1}}],[\"分别统计半天和整天上班的数量\",{\"1\":{\"884\":1}}],[\"分别判断\",{\"1\":{\"881\":1}}],[\"分别判断在三个红包的影响下\",{\"1\":{\"809\":1}}],[\"分别用对应的规则进行计算即可\",{\"1\":{\"704\":1}}],[\"分别求解每个文件的空间占用然后求和即可\",{\"1\":{\"642\":1}}],[\"分别取出来个位\",{\"1\":{\"608\":1}}],[\"分别枚举\",{\"1\":{\"598\":1}}],[\"分别的最终价格是多少\",{\"1\":{\"809\":1}}],[\"分别的\",{\"1\":{\"585\":1}}],[\"分别是输入\",{\"1\":{\"585\":1}}],[\"分别记录\",{\"1\":{\"505\":1,\"632\":1}}],[\"分别记录和上下相连的点\",{\"1\":{\"289\":2}}],[\"分别计算出三种方式的收益同时记录最大值输出即可\",{\"1\":{\"502\":1}}],[\"分别尝试去两边修改\",{\"1\":{\"313\":1,\"314\":1}}],[\"分别以\",{\"1\":{\"80\":1}}],[\"分离分别求\",{\"0\":{\"283\":1}}],[\"分算\",{\"1\":{\"181\":1}}],[\"分做法\",{\"0\":{\"172\":1},\"1\":{\"502\":1,\"503\":1,\"504\":1,\"507\":1,\"509\":1,\"622\":1}}],[\"分\",{\"0\":{\"109\":1,\"110\":1,\"115\":1,\"116\":1,\"139\":1,\"140\":1,\"144\":1,\"145\":1,\"150\":1,\"151\":1,\"156\":1,\"157\":1,\"184\":1,\"185\":1,\"186\":1,\"202\":1,\"203\":1,\"204\":1,\"208\":1,\"209\":1,\"210\":1,\"211\":1,\"212\":1,\"248\":1,\"253\":1,\"254\":1,\"257\":1,\"278\":1,\"279\":1,\"317\":1,\"318\":1,\"399\":1,\"402\":1,\"403\":1,\"407\":1,\"408\":1,\"409\":1,\"410\":1,\"422\":1,\"423\":1,\"444\":1,\"448\":1,\"464\":1,\"465\":1,\"466\":1,\"467\":1,\"473\":1,\"474\":1,\"475\":1},\"1\":{\"109\":1,\"172\":1,\"181\":2,\"196\":1,\"388\":1,\"389\":1,\"399\":1,\"415\":2,\"458\":1,\"495\":1,\"502\":2,\"503\":2,\"512\":3,\"515\":3,\"518\":3,\"521\":3,\"524\":3,\"525\":3,\"526\":3,\"527\":3,\"530\":3,\"533\":3,\"537\":3,\"541\":3,\"544\":3,\"545\":3,\"546\":3,\"550\":3,\"553\":3,\"556\":3,\"559\":3,\"562\":3,\"563\":3,\"564\":3,\"565\":3,\"568\":3,\"571\":3,\"578\":3,\"582\":3,\"588\":3,\"591\":3,\"595\":3,\"598\":4,\"601\":3,\"604\":3,\"608\":3,\"611\":3,\"614\":3,\"626\":3,\"629\":3,\"639\":3,\"642\":3,\"645\":3,\"648\":3,\"652\":3,\"655\":3,\"658\":3,\"661\":3,\"665\":3,\"668\":3,\"671\":3,\"674\":2,\"678\":3,\"681\":3,\"684\":3,\"687\":3,\"691\":3,\"700\":3,\"704\":3,\"707\":3,\"720\":3,\"726\":3,\"740\":2,\"759\":1,\"782\":1,\"802\":1,\"809\":3,\"812\":4,\"815\":3,\"818\":5,\"822\":3,\"825\":3,\"828\":3,\"831\":3,\"835\":3,\"838\":3,\"841\":3,\"846\":3,\"850\":3,\"853\":3,\"856\":3,\"859\":3,\"863\":3,\"866\":3,\"871\":3,\"874\":3,\"878\":3,\"881\":3,\"884\":3,\"887\":3,\"891\":3,\"894\":3,\"897\":3,\"900\":1,\"904\":2,\"909\":2}}],[\"答案为\",{\"1\":{\"909\":1}}],[\"答案只有可能是\",{\"1\":{\"909\":1}}],[\"答案只有两种情况\",{\"1\":{\"866\":1}}],[\"答案必然是\",{\"1\":{\"700\":1}}],[\"答案要\",{\"1\":{\"544\":1}}],[\"答案显然就是现在的日期和开始时间\",{\"1\":{\"527\":1}}],[\"答案显然就是输出现在的日期和时间\",{\"1\":{\"527\":1}}],[\"答案显然还是现在的日期和时间\",{\"1\":{\"527\":2}}],[\"答案就是\",{\"1\":{\"591\":1,\"668\":1}}],[\"答案就是符合条件的\",{\"1\":{\"500\":1}}],[\"答案就只\",{\"1\":{\"440\":1}}],[\"答案\",{\"1\":{\"108\":1}}],[\"答案错误\",{\"1\":{\"69\":1}}],[\"问\",{\"1\":{\"108\":1}}],[\"问题就转换成了找到一个\",{\"1\":{\"904\":1}}],[\"问题就变成了判断有几段树的数量达到了\",{\"1\":{\"831\":1}}],[\"问题的代码就能拿到\",{\"1\":{\"818\":1}}],[\"问题目名叫啥\",{\"0\":{\"690\":1}}],[\"问题\",{\"1\":{\"14\":2,\"495\":1,\"831\":1}}],[\"你可以初始化为第一个数或者初始化为补码为全\",{\"1\":{\"866\":1}}],[\"你需要判断当前是子任务\",{\"1\":{\"818\":1}}],[\"你需要用\",{\"1\":{\"108\":1}}],[\"你提交一个\",{\"1\":{\"818\":1}}],[\"你将很快学会\",{\"1\":{\"428\":1}}],[\"你画我猜\",{\"0\":{\"323\":1}}],[\"你好世界\",{\"0\":{\"44\":1},\"1\":{\"47\":1}}],[\"给没学过循环嵌套的同学送点分\",{\"1\":{\"831\":1}}],[\"给大家提供了\",{\"1\":{\"578\":1}}],[\"给一个点染色就会给整个子树染色\",{\"1\":{\"494\":1}}],[\"给个很大的质数就好\",{\"1\":{\"452\":1}}],[\"给你一个\",{\"1\":{\"108\":1}}],[\"给定一棵\",{\"1\":{\"10\":1}}],[\"弹出队头\",{\"1\":{\"106\":1}}],[\"弹出栈顶元素\",{\"1\":{\"105\":1}}],[\"队列\",{\"0\":{\"106\":1}}],[\"队列是空的就返回真\",{\"1\":{\"104\":1,\"106\":1}}],[\"队列是否为空\",{\"1\":{\"104\":1,\"106\":1}}],[\"栈是空的就返回真\",{\"1\":{\"105\":1}}],[\"栈是否为空\",{\"1\":{\"105\":1}}],[\"栈\",{\"0\":{\"105\":1}}],[\"结构体排序的模拟题\",{\"1\":{\"871\":1}}],[\"结算\",{\"1\":{\"732\":1}}],[\"结束时间小于开始时间并且当前时间小于结束时间\",{\"1\":{\"527\":1}}],[\"结束位置迭代器\",{\"1\":{\"103\":1}}],[\"结尾时数\",{\"1\":{\"329\":1}}],[\"结尾是谁达成的\",{\"1\":{\"196\":1}}],[\"结尾\",{\"1\":{\"196\":2,\"303\":1,\"351\":2}}],[\"结尾的最长上升子序列方案数\",{\"1\":{\"119\":1}}],[\"结尾的最长上升子序列长度\",{\"1\":{\"119\":1}}],[\"结尾的最长子序列\",{\"1\":{\"118\":1}}],[\"结尾的\",{\"1\":{\"13\":1,\"112\":1,\"113\":1,\"115\":2,\"116\":2,\"117\":1,\"122\":1,\"123\":1,\"233\":2}}],[\"清空之前的影响\",{\"1\":{\"196\":1}}],[\"清空\",{\"1\":{\"158\":1}}],[\"清空双端队列\",{\"1\":{\"104\":1}}],[\"清空整个数组\",{\"1\":{\"103\":1}}],[\"清空数组\",{\"1\":{\"103\":1}}],[\"访问下标为\",{\"1\":{\"103\":1,\"104\":1}}],[\"访问元素\",{\"1\":{\"103\":1,\"104\":1}}],[\"把死循环改成循环执行\",{\"1\":{\"838\":1}}],[\"把建地铁的位置的树都拔掉\",{\"1\":{\"832\":1}}],[\"把式子转换为\",{\"1\":{\"658\":1}}],[\"把桃子定义成结构体类型\",{\"1\":{\"623\":1}}],[\"把两种情况都计算一下收入即可\",{\"1\":{\"595\":1}}],[\"把多余的次数浪费掉\",{\"1\":{\"574\":1}}],[\"把构造转换成检验\",{\"1\":{\"485\":1}}],[\"把所有\",{\"1\":{\"419\":1}}],[\"把所有单词按照字典序排序\",{\"1\":{\"410\":1}}],[\"把每一块做清楚能省掉更多调试的时间\",{\"1\":{\"874\":1}}],[\"把每一位可能的数量相乘即可\",{\"1\":{\"578\":1}}],[\"把每条线段放入\",{\"1\":{\"312\":1,\"313\":1}}],[\"把每种颜色的下标存入动态数组\",{\"1\":{\"225\":1}}],[\"把位置调整到合适位置\",{\"1\":{\"185\":1}}],[\"把个位去掉\",{\"1\":{\"131\":1}}],[\"把数组大小修改为\",{\"1\":{\"103\":1}}],[\"把\",{\"1\":{\"103\":1,\"105\":1,\"106\":1,\"168\":1,\"209\":3,\"735\":1,\"744\":1,\"875\":1}}],[\"把之前欠的结清\",{\"1\":{\"19\":2,\"21\":3}}],[\"添加到动态数组末尾\",{\"1\":{\"103\":1}}],[\"添加元素\",{\"1\":{\"103\":1}}],[\"添加运算符和下一个数字\",{\"1\":{\"40\":1}}],[\"动态开点权值线段树\",{\"0\":{\"313\":1,\"314\":1},\"1\":{\"313\":1,\"314\":1}}],[\"动态开点线段树初始化\",{\"1\":{\"313\":1,\"314\":1}}],[\"动态开点线段树维护权值数组\",{\"1\":{\"23\":1}}],[\"动态开点线段树\",{\"0\":{\"22\":1}}],[\"动态数组\",{\"0\":{\"103\":1}}],[\"向量\",{\"0\":{\"103\":1}}],[\"上即可\",{\"1\":{\"740\":1}}],[\"上\",{\"1\":{\"444\":2,\"505\":1}}],[\"上跑个拓扑序\",{\"1\":{\"442\":1}}],[\"上屋抽梯\",{\"0\":{\"433\":1}}],[\"上的房子\",{\"1\":{\"331\":2}}],[\"上海月赛\",{\"0\":{\"322\":1}}],[\"上帝造题的七分钟\",{\"0\":{\"290\":1}}],[\"上走到的位置\",{\"1\":{\"268\":2}}],[\"上升跳到\",{\"1\":{\"260\":1}}],[\"上是\",{\"1\":{\"230\":2}}],[\"上下限相等\",{\"1\":{\"878\":1}}],[\"上下左右\",{\"1\":{\"230\":1}}],[\"上下取整\",{\"0\":{\"100\":1}}],[\"上一块的编号\",{\"1\":{\"321\":1}}],[\"上一条线的\",{\"1\":{\"313\":1,\"314\":1}}],[\"上一行是第\",{\"1\":{\"306\":1}}],[\"上一行按键取决于哪些\",{\"1\":{\"158\":1}}],[\"上一次查询的答案+x\",{\"1\":{\"216\":2}}],[\"上一轮能接到\",{\"1\":{\"196\":1}}],[\"上一轮是\",{\"1\":{\"196\":1}}],[\"上一个水果\",{\"1\":{\"321\":1}}],[\"上一个覆盖到的位置\",{\"1\":{\"242\":1}}],[\"上一个同色的位置就是\",{\"1\":{\"199\":2}}],[\"上一个异色的位置是\",{\"1\":{\"199\":4}}],[\"上一个异色为\",{\"1\":{\"199\":2}}],[\"上一个结束的数字\",{\"1\":{\"196\":1}}],[\"上一个人是\",{\"1\":{\"196\":1}}],[\"上一个人接到了\",{\"1\":{\"196\":1}}],[\"上一个可以调整的\",{\"1\":{\"168\":1}}],[\"上面按键\",{\"1\":{\"158\":1}}],[\"上取整\",{\"1\":{\"100\":1,\"250\":2}}],[\"qjf\",{\"1\":{\"732\":2}}],[\"qy\",{\"1\":{\"336\":5}}],[\"qx\",{\"1\":{\"336\":6}}],[\"qp\",{\"1\":{\"268\":8}}],[\"qt\",{\"1\":{\"268\":9,\"336\":5}}],[\"q+n\",{\"1\":{\"251\":1}}],[\"quan\",{\"1\":{\"633\":2}}],[\"quan=\",{\"1\":{\"633\":1}}],[\"quitf\",{\"1\":{\"551\":2}}],[\"quick\",{\"1\":{\"172\":4,\"377\":2}}],[\"queue<string>\",{\"1\":{\"179\":1}}],[\"queue<pair<int\",{\"1\":{\"144\":1,\"147\":1,\"167\":1,\"241\":1,\"259\":1,\"267\":1,\"276\":1,\"342\":1,\"343\":1,\"410\":1,\"421\":1,\"422\":1,\"423\":1,\"438\":1,\"443\":1}}],[\"queue<int>\",{\"1\":{\"106\":1,\"148\":1,\"156\":1,\"157\":1,\"163\":1,\"210\":1,\"230\":1,\"231\":1,\"268\":2,\"336\":3,\"366\":1,\"436\":1,\"444\":1}}],[\"queue\",{\"0\":{\"106\":1}}],[\"query\",{\"0\":{\"18\":1},\"1\":{\"17\":4,\"18\":3,\"19\":4,\"20\":4,\"21\":4,\"23\":4,\"213\":2,\"216\":6,\"236\":4,\"237\":6,\"239\":4,\"258\":3,\"266\":3,\"289\":6,\"291\":4,\"292\":4,\"312\":2,\"313\":4,\"314\":2,\"376\":2,\"446\":2,\"447\":4}}],[\"qq\",{\"1\":{\"163\":14,\"343\":3}}],[\"q\",{\"0\":{\"376\":1,\"729\":1},\"1\":{\"100\":9,\"101\":1,\"104\":12,\"106\":8,\"142\":3,\"144\":7,\"147\":1,\"148\":5,\"150\":3,\"151\":3,\"156\":5,\"157\":5,\"163\":3,\"164\":3,\"167\":6,\"179\":6,\"196\":22,\"216\":2,\"230\":6,\"231\":9,\"235\":1,\"236\":1,\"237\":1,\"239\":1,\"241\":6,\"251\":7,\"259\":6,\"266\":5,\"267\":6,\"276\":6,\"288\":3,\"295\":7,\"319\":3,\"342\":10,\"343\":11,\"410\":8,\"421\":6,\"422\":6,\"423\":6,\"436\":6,\"438\":6,\"443\":9,\"444\":6,\"729\":7,\"764\":2,\"836\":7,\"875\":3,\"902\":2}}],[\"闰年判断\",{\"0\":{\"98\":1},\"1\":{\"98\":1}}],[\"百位\",{\"1\":{\"97\":1,\"608\":1}}],[\"十位\",{\"1\":{\"97\":1,\"507\":1,\"608\":1}}],[\"988244353\",{\"1\":{\"579\":1}}],[\"9893\",{\"1\":{\"484\":1}}],[\"9860\",{\"1\":{\"484\":1}}],[\"9828\",{\"1\":{\"484\":1}}],[\"981\",{\"1\":{\"484\":1}}],[\"96\",{\"1\":{\"816\":10}}],[\"9679\",{\"1\":{\"484\":1}}],[\"9651\",{\"1\":{\"484\":1}}],[\"9621\",{\"1\":{\"484\":1}}],[\"95\",{\"1\":{\"503\":1}}],[\"9527\",{\"1\":{\"484\":1}}],[\"9500\",{\"1\":{\"484\":1}}],[\"9465\",{\"1\":{\"484\":1}}],[\"9440\",{\"1\":{\"484\":1}}],[\"9410\",{\"1\":{\"484\":1}}],[\"9283\",{\"1\":{\"484\":1}}],[\"9257\",{\"1\":{\"484\":1}}],[\"9153\",{\"1\":{\"484\":1}}],[\"9127\",{\"1\":{\"484\":1}}],[\"9348\",{\"1\":{\"484\":1}}],[\"9314\",{\"1\":{\"484\":1}}],[\"9381\",{\"1\":{\"484\":1}}],[\"938\",{\"1\":{\"484\":1}}],[\"939\",{\"1\":{\"419\":1}}],[\"9x9\",{\"0\":{\"334\":1}}],[\"996\",{\"1\":{\"575\":1,\"576\":1}}],[\"9987\",{\"1\":{\"484\":1}}],[\"998244353\",{\"1\":{\"109\":1,\"110\":1,\"302\":1,\"303\":1,\"395\":1,\"633\":1,\"636\":1}}],[\"999999999\",{\"1\":{\"262\":1}}],[\"99999999\",{\"1\":{\"262\":1}}],[\"9999999\",{\"1\":{\"262\":1}}],[\"999999\",{\"1\":{\"262\":1}}],[\"99999\",{\"1\":{\"262\":1}}],[\"9999\",{\"1\":{\"262\":1,\"539\":2}}],[\"999\",{\"1\":{\"262\":1,\"484\":1,\"649\":1,\"727\":1}}],[\"99\",{\"1\":{\"103\":1,\"262\":1,\"649\":1,\"674\":1}}],[\"901\",{\"1\":{\"509\":2}}],[\"9013\",{\"1\":{\"484\":1}}],[\"9095\",{\"1\":{\"484\":1}}],[\"9070\",{\"1\":{\"484\":1}}],[\"9044\",{\"1\":{\"484\":1}}],[\"902\",{\"1\":{\"484\":1}}],[\"90\",{\"0\":{\"186\":1},\"1\":{\"94\":1,\"257\":1,\"478\":1}}],[\"9790\",{\"1\":{\"484\":1}}],[\"9766\",{\"1\":{\"484\":1}}],[\"9739\",{\"1\":{\"484\":1}}],[\"9704\",{\"1\":{\"484\":1}}],[\"97\",{\"1\":{\"94\":1}}],[\"9\",{\"0\":{\"876\":1},\"1\":{\"93\":1,\"168\":2,\"182\":34,\"188\":2,\"195\":1,\"246\":1,\"248\":26,\"249\":16,\"257\":1,\"262\":3,\"263\":1,\"264\":1,\"265\":1,\"270\":2,\"273\":1,\"287\":1,\"334\":4,\"335\":2,\"378\":1,\"425\":3,\"534\":1,\"535\":2,\"572\":1,\"649\":1,\"656\":1,\"732\":10,\"746\":1,\"770\":2}}],[\"舍操作\",{\"1\":{\"91\":1}}],[\"舍和\",{\"1\":{\"91\":1}}],[\"因式分解\",{\"0\":{\"471\":1}}],[\"因此把所有水杯的水量倒成最少的水量即可\",{\"1\":{\"887\":1}}],[\"因此上限为\",{\"1\":{\"878\":1}}],[\"因此最多影响了和这个位置有关的单词\",{\"1\":{\"874\":1}}],[\"因此答案就是只分为一个区间\",{\"1\":{\"866\":1}}],[\"因此可以从小到大枚举数列中的每个数\",{\"1\":{\"904\":1}}],[\"因此可以找到最小公倍数\",{\"1\":{\"668\":1}}],[\"因此可以给个\",{\"1\":{\"453\":1}}],[\"因此\",{\"1\":{\"635\":1}}],[\"因此模拟的总次数不会超过\",{\"1\":{\"632\":1}}],[\"因此后两题稍微出得简单了一点\",{\"1\":{\"515\":1}}],[\"因此不用管小时了\",{\"1\":{\"515\":1}}],[\"因此我们只需要找到第一个\",{\"1\":{\"504\":1}}],[\"因此也无需考虑不能整除的情况\",{\"1\":{\"502\":1}}],[\"因此容易想到位数从高到低贪心\",{\"1\":{\"352\":1}}],[\"因此每一位为\",{\"1\":{\"85\":1}}],[\"因子\",{\"1\":{\"137\":4}}],[\"因为操作的数只有第一个数\",{\"1\":{\"846\":1}}],[\"因为只有操作\",{\"1\":{\"846\":1}}],[\"因为只有一道题\",{\"1\":{\"825\":1}}],[\"因为记得有同学不会\",{\"1\":{\"792\":1}}],[\"因为题目保证语句通顺\",{\"1\":{\"741\":1}}],[\"因为题目中写了数列长度大于等于\",{\"1\":{\"547\":1}}],[\"因为没有\",{\"1\":{\"652\":1}}],[\"因为三个可以拆分成各一个\",{\"1\":{\"635\":1}}],[\"因为我们要先按开胃值从大到小排序\",{\"1\":{\"623\":1}}],[\"因为这样能吃到尽可能多的桃子\",{\"1\":{\"623\":1}}],[\"因为这边分子分母是负数\",{\"1\":{\"198\":1}}],[\"因为排序是随意的\",{\"1\":{\"574\":1}}],[\"因为多出的操作次数可以通过\",{\"1\":{\"574\":1}}],[\"因为保证了编码长度为\",{\"1\":{\"828\":1}}],[\"因为保证了不包含\",{\"1\":{\"828\":1}}],[\"因为保证了\",{\"1\":{\"815\":1,\"825\":1}}],[\"因为保证了字符串长度为\",{\"1\":{\"568\":1}}],[\"因为保留\",{\"1\":{\"91\":1}}],[\"因为数据里存在\",{\"1\":{\"565\":1}}],[\"因为数据范围给得很小\",{\"1\":{\"456\":1}}],[\"因为第二重循环每多执行一次\",{\"1\":{\"559\":1}}],[\"因为如果对更短的区间排序\",{\"1\":{\"556\":1}}],[\"因为后两题相对较难\",{\"1\":{\"553\":1}}],[\"因为不包含标点符号\",{\"1\":{\"518\":1}}],[\"因为余数最多就\",{\"1\":{\"489\":1}}],[\"因为此时肯定是一个个打过去\",{\"1\":{\"474\":1}}],[\"因为并查集是提高组考点\",{\"1\":{\"419\":1}}],[\"因为希望按位与运算后为\",{\"1\":{\"326\":1}}],[\"因为\",{\"1\":{\"98\":1,\"480\":1,\"493\":1,\"494\":1,\"578\":1,\"668\":2,\"818\":1,\"831\":1,\"891\":2}}],[\"但这意义不大\",{\"1\":{\"891\":1}}],[\"但其实意义不大\",{\"1\":{\"831\":1}}],[\"但如果想要拿到\",{\"1\":{\"818\":1}}],[\"但如果舍入位是\",{\"1\":{\"91\":1}}],[\"但现在就太简单了\",{\"1\":{\"806\":1}}],[\"但显然我们不需要枚举前面每个位置来找到最近的同色字符\",{\"1\":{\"782\":1}}],[\"但显然作为语法周赛是朝纲的\",{\"1\":{\"772\":1}}],[\"但容易发现\",{\"1\":{\"772\":1}}],[\"但很容易发现没有障碍物的时候整个路径分为两步\",{\"1\":{\"766\":1}}],[\"但结果相反\",{\"1\":{\"622\":1}}],[\"但考虑到\",{\"1\":{\"604\":1}}],[\"但需要注意一个特殊情况\",{\"1\":{\"601\":1}}],[\"但细节有点多\",{\"1\":{\"488\":1}}],[\"但实际上暴力枚举所有划分方案的代码挺难写\",{\"1\":{\"866\":1}}],[\"但实际上方向是能从\",{\"1\":{\"772\":1}}],[\"但实际上我们只需要记住朋友有谁\",{\"1\":{\"726\":1}}],[\"但实际上控制好三种鸡数量之和为\",{\"1\":{\"611\":1}}],[\"但实际上子任务\",{\"1\":{\"578\":1}}],[\"但实际上可以直接利用每个字符对应的整数值\",{\"1\":{\"518\":1}}],[\"但实际上简单打个\",{\"1\":{\"413\":1}}],[\"但实际先排除无解和都是解之后\",{\"1\":{\"471\":1}}],[\"但反正不超时\",{\"1\":{\"465\":1}}],[\"但要注意耐久度为\",{\"1\":{\"863\":1}}],[\"但要注意这实际上是单向边\",{\"1\":{\"772\":1}}],[\"但要注意根据格式给出多余的\",{\"1\":{\"530\":1}}],[\"但要注意\",{\"1\":{\"451\":1}}],[\"但是细节需要注意\",{\"1\":{\"891\":1}}],[\"但是这里是等于号\",{\"1\":{\"838\":1}}],[\"但是这个就有点麻烦了\",{\"1\":{\"453\":1}}],[\"但是数据范围这么小\",{\"1\":{\"831\":1}}],[\"但是似乎有点过难了\",{\"1\":{\"806\":1}}],[\"但是当前判断的这个数字的这一位不是\",{\"1\":{\"578\":1}}],[\"但是根据题目要求\",{\"1\":{\"509\":1}}],[\"但是如果一天天模拟显然会超时\",{\"1\":{\"515\":1}}],[\"但是如果状态定义为\",{\"1\":{\"499\":1}}],[\"但是如果路途中间遇到了一样近或更近的点就可以停了\",{\"1\":{\"423\":1}}],[\"但是需要注意\",{\"1\":{\"489\":1}}],[\"但是需要注意的是\",{\"1\":{\"91\":1}}],[\"但是\",{\"1\":{\"485\":1}}],[\"但是每个算术平方根都是用二分求的出的问题\",{\"1\":{\"478\":1}}],[\"但是没有注意到\",{\"1\":{\"470\":1}}],[\"但是最终文章也不长\",{\"1\":{\"466\":1}}],[\"但是也要一开始就看看有没有简单的子任务可以做\",{\"1\":{\"438\":1}}],[\"但是一旦开始回头了\",{\"1\":{\"404\":1}}],[\"但是仔细想想会发现一旦某个地方回头了\",{\"1\":{\"403\":1}}],[\"但大胆一点搜搜会发现子任务\",{\"1\":{\"402\":1}}],[\"但我懒得推了\",{\"1\":{\"400\":1}}],[\"但有不少同学这个写错了\",{\"1\":{\"399\":1}}],[\"但最后一组样例数据\",{\"1\":{\"351\":1}}],[\"但随手保留了\",{\"1\":{\"329\":1}}],[\"但作为丙组第三题不可能那么难\",{\"1\":{\"325\":1}}],[\"入的部分是没有问题的\",{\"1\":{\"91\":1}}],[\"入门基础\",{\"0\":{\"33\":1}}],[\"推荐\",{\"0\":{\"90\":1}}],[\"头文件\",{\"1\":{\"89\":1,\"90\":1}}],[\"保留\",{\"0\":{\"88\":1},\"1\":{\"91\":1}}],[\"保证两个油箱\",{\"1\":{\"604\":1}}],[\"保证是正数其实就不用判断负数而已\",{\"1\":{\"565\":1}}],[\"保证以<开始和保证>结束\",{\"1\":{\"526\":1}}],[\"保证做成沙拉收益最高\",{\"1\":{\"502\":1}}],[\"保证做成果酱收益最高\",{\"1\":{\"502\":1}}],[\"保证了第一项为最小值\",{\"1\":{\"887\":1}}],[\"保证了第一天和最后一天都包括了完整的一天\",{\"1\":{\"515\":1}}],[\"保证了最后一项为最小值\",{\"1\":{\"887\":1}}],[\"保证了刚好骑了三天\",{\"1\":{\"881\":1}}],[\"保证了三个数\",{\"1\":{\"720\":1}}],[\"保证了时间是偶数\",{\"1\":{\"665\":1}}],[\"保证了只有一个文件\",{\"1\":{\"642\":1}}],[\"保证了只有女生\",{\"1\":{\"521\":1}}],[\"保证了有解\",{\"1\":{\"601\":1}}],[\"保证了有序\",{\"1\":{\"198\":2}}],[\"保证了每题要么满分要么\",{\"1\":{\"598\":1}}],[\"保证了每个字符都要输出\",{\"1\":{\"541\":1}}],[\"保证了从小到大\",{\"1\":{\"588\":1}}],[\"保证了两个字符串长度都为\",{\"1\":{\"541\":1}}],[\"保证了两个人的组合类型都是\",{\"1\":{\"512\":1}}],[\"保证了不存在跨天\",{\"1\":{\"527\":1}}],[\"保证了是思维场\",{\"1\":{\"626\":1}}],[\"保证了是普通轮\",{\"1\":{\"626\":1}}],[\"保证了是\",{\"1\":{\"527\":1}}],[\"保证了是同一天\",{\"1\":{\"515\":1}}],[\"保证了没有字符\",{\"1\":{\"526\":1}}],[\"保证了\",{\"1\":{\"524\":1,\"525\":1,\"544\":1,\"564\":1,\"595\":1,\"639\":1,\"850\":2,\"853\":2,\"856\":1,\"878\":1,\"881\":1}}],[\"保证了过线顺序就是编号顺序\",{\"1\":{\"521\":1}}],[\"保证了类型一致\",{\"1\":{\"512\":1}}],[\"保证了次大值在最左边\",{\"1\":{\"446\":1}}],[\"保证有左右子节点\",{\"1\":{\"313\":1,\"314\":1}}],[\"保证左边的大小比右边大一个\",{\"1\":{\"210\":1}}],[\"保证\",{\"1\":{\"12\":1,\"267\":1,\"503\":2}}],[\"讨厌的浮点数\",{\"0\":{\"87\":1}}],[\"负数补码在反码基础上加\",{\"1\":{\"86\":1}}],[\"负数反码除最高位之外\",{\"1\":{\"86\":1}}],[\"负数为\",{\"1\":{\"86\":1}}],[\"原样输出即可\",{\"1\":{\"841\":1}}],[\"原图点\",{\"1\":{\"444\":1}}],[\"原题官方题解代码\",{\"1\":{\"448\":1}}],[\"原题\",{\"1\":{\"420\":1}}],[\"原题是\",{\"1\":{\"419\":1}}],[\"原码\",{\"0\":{\"86\":1},\"1\":{\"86\":1}}],[\"原始数位\",{\"1\":{\"85\":1}}],[\"对比肯定是最好的\",{\"1\":{\"818\":1}}],[\"对比\",{\"1\":{\"769\":1}}],[\"对更长的区间排序则有可能会变得更坏\",{\"1\":{\"556\":1}}],[\"对显然就四种情况\",{\"1\":{\"499\":1}}],[\"对朋友选\",{\"1\":{\"499\":1}}],[\"对\",{\"1\":{\"478\":1,\"557\":1}}],[\"对顶堆的\",{\"0\":{\"210\":1}}],[\"对第二个人的价值\",{\"1\":{\"128\":1}}],[\"对应到\",{\"1\":{\"541\":1,\"735\":1}}],[\"对应价值\",{\"1\":{\"293\":1}}],[\"对应区间为\",{\"1\":{\"237\":2,\"239\":2,\"291\":1}}],[\"对应的发奖即可\",{\"1\":{\"798\":1}}],[\"对应的权值相加即可\",{\"1\":{\"744\":1}}],[\"对应的大写字母\",{\"1\":{\"691\":1}}],[\"对应的数为\",{\"1\":{\"658\":1}}],[\"对应的数字除以\",{\"1\":{\"658\":1}}],[\"对应的字符串\",{\"1\":{\"578\":1}}],[\"对应的线段为\",{\"1\":{\"237\":2,\"239\":2,\"291\":1}}],[\"对应的前缀和\",{\"1\":{\"196\":1}}],[\"对应的匹配的位数\",{\"1\":{\"142\":1}}],[\"对应的\",{\"1\":{\"93\":1,\"94\":2,\"126\":1,\"682\":1}}],[\"对应权值\",{\"1\":{\"85\":1}}],[\"对于前期同学一定难度\",{\"1\":{\"818\":1}}],[\"对于数字\",{\"1\":{\"742\":1}}],[\"对于时间类的问题转换为最小单位后在处理\",{\"1\":{\"531\":1}}],[\"对于每种情况通过下标的改变和数组调用\",{\"1\":{\"505\":1}}],[\"对于每一轮来说\",{\"1\":{\"632\":1}}],[\"对于每一个三连来说都有三个位置的棋子\",{\"1\":{\"505\":1}}],[\"对于每一组\",{\"1\":{\"503\":1}}],[\"对于每个人来说\",{\"1\":{\"490\":1}}],[\"对于区间\",{\"1\":{\"447\":1,\"493\":1}}],[\"对于其他的\",{\"1\":{\"415\":1}}],[\"对于质数\",{\"1\":{\"415\":1}}],[\"对于舍入位是\",{\"1\":{\"91\":1}}],[\"对于\",{\"1\":{\"91\":1,\"556\":1,\"622\":2}}],[\"对高精度的转换\",{\"1\":{\"3\":1}}],[\"转换回\",{\"1\":{\"835\":1}}],[\"转换回小时\",{\"1\":{\"531\":2}}],[\"转换到\",{\"1\":{\"835\":1}}],[\"转换为分钟\",{\"1\":{\"531\":2}}],[\"转换为字符是\",{\"1\":{\"507\":1}}],[\"转换成反转后的增益\",{\"1\":{\"150\":1,\"151\":1}}],[\"转换成十进制结果如下\",{\"1\":{\"85\":1}}],[\"转十进制\",{\"1\":{\"85\":1}}],[\"转义符\",{\"0\":{\"51\":1}}],[\"即已分配的块的范围最多是这么多\",{\"1\":{\"900\":1}}],[\"即只需要用\",{\"1\":{\"891\":1}}],[\"即找到所有数的最大值\",{\"1\":{\"859\":1}}],[\"即小于\",{\"1\":{\"802\":1}}],[\"即横\",{\"1\":{\"505\":1}}],[\"即上\",{\"1\":{\"505\":1}}],[\"即两个端点和一个中间点\",{\"1\":{\"505\":1}}],[\"即可算出与运算之和\",{\"1\":{\"869\":1}}],[\"即可把内部两层循环优化为\",{\"1\":{\"812\":1}}],[\"即可找到对应位置了\",{\"1\":{\"766\":1}}],[\"即可完成\",{\"1\":{\"502\":1}}],[\"即可\",{\"1\":{\"329\":1,\"397\":1,\"452\":1,\"494\":1,\"507\":1,\"524\":2,\"525\":1,\"526\":1,\"530\":2,\"541\":1,\"544\":2,\"546\":1,\"550\":1,\"553\":1,\"562\":2,\"563\":1,\"564\":1,\"568\":1,\"578\":1,\"582\":2,\"588\":1,\"598\":1,\"604\":1,\"608\":1,\"614\":1,\"626\":2,\"629\":1,\"639\":1,\"642\":1,\"645\":2,\"648\":1,\"652\":2,\"661\":1,\"668\":1,\"674\":1,\"720\":1,\"723\":1,\"734\":1,\"736\":2,\"750\":1,\"809\":1,\"828\":1,\"841\":1,\"846\":1,\"859\":1,\"863\":1,\"878\":2,\"884\":1}}],[\"即没有全部赋值\",{\"1\":{\"216\":1}}],[\"即\",{\"1\":{\"85\":1,\"91\":1,\"137\":1,\"453\":1,\"504\":1,\"621\":1,\"622\":4,\"661\":1,\"809\":1,\"812\":1,\"822\":1,\"904\":1}}],[\"双重循环枚举所有装油可能性即可\",{\"1\":{\"604\":1}}],[\"双端队列广搜\",{\"0\":{\"295\":1}}],[\"双端队列大小也归零了\",{\"1\":{\"104\":1}}],[\"双端队列\",{\"0\":{\"104\":1}}],[\"双精度浮点数\",{\"1\":{\"83\":1}}],[\"双目逻辑运算\",{\"1\":{\"81\":1}}],[\"有趣的\",{\"0\":{\"865\":1}}],[\"有趣的递归形式实现逆序输出\",{\"0\":{\"844\":1}}],[\"有几段树答案就是几\",{\"1\":{\"831\":1}}],[\"有几个不重叠的三十三\",{\"0\":{\"755\":1}}],[\"有几个完整周和几天零散的\",{\"1\":{\"515\":1}}],[\"有几个大于\",{\"1\":{\"258\":1}}],[\"有几个位置没有被染上\",{\"1\":{\"242\":1}}],[\"有几个连通块\",{\"1\":{\"215\":1}}],[\"有几个\",{\"1\":{\"140\":1,\"329\":2}}],[\"有没有更快的做法\",{\"1\":{\"753\":1}}],[\"有没有被算过\",{\"1\":{\"307\":1}}],[\"有兴趣的同学可以想想\",{\"1\":{\"753\":1}}],[\"有同学会被题面给的时间吓到\",{\"1\":{\"909\":1}}],[\"有同学觉得这是图论\",{\"1\":{\"726\":1}}],[\"有同学可能会想在极限数据下\",{\"1\":{\"900\":1}}],[\"有同学可能会想到建个图然后\",{\"1\":{\"772\":1}}],[\"有同学可能会问这道题有什么意义\",{\"1\":{\"737\":1}}],[\"有同学可能会觉得这是个双重循环会超时\",{\"1\":{\"559\":1}}],[\"有同学可能会以为需要字符串处理\",{\"1\":{\"530\":1}}],[\"有可能出现一段树\",{\"1\":{\"832\":1}}],[\"有可能不做成正方形能赚更多钱\",{\"1\":{\"595\":1}}],[\"有可能会跨越一天时\",{\"1\":{\"530\":1}}],[\"有的同学以为是自己曾经做过这个题\",{\"1\":{\"526\":1}}],[\"有多同学一看到这个就以为要上并查集了\",{\"1\":{\"772\":1}}],[\"有多种做法\",{\"1\":{\"521\":1,\"822\":1}}],[\"有多少个\",{\"1\":{\"668\":1}}],[\"有多少个蛇数\",{\"1\":{\"335\":1}}],[\"有多少个数字\",{\"1\":{\"270\":1}}],[\"有多少种方案\",{\"1\":{\"108\":1}}],[\"有些同学没注意到第二个子任务有四种情况\",{\"1\":{\"485\":1}}],[\"有些同学会在\",{\"1\":{\"460\":1}}],[\"有很多同学错在了\",{\"1\":{\"483\":1}}],[\"有三个小考点\",{\"1\":{\"471\":1}}],[\"有一个朋友\",{\"1\":{\"726\":1}}],[\"有一点点简单的博弈\",{\"1\":{\"432\":1}}],[\"有一点容易出问题的地方\",{\"1\":{\"414\":1}}],[\"有一些小细节的模拟题\",{\"1\":{\"559\":1}}],[\"有一些不正确的写法被我的类似于\",{\"1\":{\"546\":1}}],[\"有一些经典的错误是没注意到小于等于\",{\"1\":{\"418\":1}}],[\"有一些特殊字符需要使用转义符的方式表示\",{\"1\":{\"51\":1}}],[\"有不少同学直接钦定\",{\"1\":{\"413\":1}}],[\"有树苗\",{\"1\":{\"218\":1}}],[\"有树\",{\"1\":{\"218\":1}}],[\"有\",{\"1\":{\"197\":1,\"415\":1,\"502\":1,\"504\":1}}],[\"有大于等于两个人达成\",{\"1\":{\"196\":1}}],[\"有实根\",{\"1\":{\"129\":1}}],[\"有效数字\",{\"1\":{\"83\":2}}],[\"至少能储存\",{\"1\":{\"83\":1}}],[\"约\",{\"1\":{\"83\":4}}],[\"占用内存大小\",{\"1\":{\"83\":1}}],[\"内容\",{\"1\":{\"83\":1}}],[\"gold\",{\"1\":{\"872\":1}}],[\"good\",{\"1\":{\"854\":1}}],[\"g<=3\",{\"1\":{\"630\":1}}],[\"g==3\",{\"1\":{\"630\":1}}],[\"g==2\",{\"1\":{\"630\":1}}],[\"g==1\",{\"1\":{\"630\":1}}],[\"g=0\",{\"1\":{\"630\":1}}],[\"g=z\",{\"1\":{\"507\":1}}],[\"girl\",{\"1\":{\"522\":5}}],[\"girltot\",{\"1\":{\"522\":3}}],[\"gib\",{\"1\":{\"83\":1}}],[\"g+\",{\"1\":{\"507\":1}}],[\"g++\",{\"1\":{\"83\":1,\"575\":2,\"630\":1}}],[\"guo\",{\"1\":{\"857\":1}}],[\"guan\",{\"1\":{\"426\":2}}],[\"guess\",{\"1\":{\"399\":2,\"400\":2}}],[\"green\",{\"1\":{\"836\":1}}],[\"group\",{\"1\":{\"480\":2}}],[\"grouping\",{\"0\":{\"381\":1}}],[\"grid\",{\"0\":{\"367\":1}}],[\"gravity\",{\"0\":{\"342\":1}}],[\"gather\",{\"0\":{\"351\":1}}],[\"gauss\",{\"1\":{\"285\":2}}],[\"ge\",{\"1\":{\"497\":2}}],[\"gen\",{\"1\":{\"282\":2,\"283\":2,\"284\":2,\"413\":2,\"417\":2,\"484\":6}}],[\"getcnt\",{\"1\":{\"875\":2}}],[\"gets\",{\"1\":{\"875\":16}}],[\"getscore\",{\"1\":{\"182\":8}}],[\"getid\",{\"1\":{\"444\":8}}],[\"getline\",{\"1\":{\"265\":3,\"319\":1,\"518\":1,\"519\":1,\"796\":1}}],[\"getnum\",{\"1\":{\"246\":2}}],[\"get33\",{\"1\":{\"182\":15}}],[\"get\",{\"1\":{\"3\":13,\"164\":3,\"190\":2,\"636\":1}}],[\"gcd\",{\"1\":{\"170\":1,\"395\":4,\"437\":3}}],[\"g\",{\"0\":{\"275\":1,\"276\":1,\"277\":1,\"293\":1,\"364\":1},\"1\":{\"109\":5,\"110\":5,\"113\":7,\"116\":6,\"117\":5,\"119\":7,\"122\":7,\"123\":5,\"158\":9,\"175\":3,\"194\":3,\"200\":4,\"202\":7,\"203\":8,\"204\":13,\"233\":12,\"268\":3,\"295\":3,\"317\":12,\"318\":12,\"319\":4,\"336\":6,\"367\":3,\"377\":7,\"383\":5,\"384\":4,\"405\":9,\"421\":5,\"422\":6,\"423\":6,\"438\":6,\"475\":9,\"495\":7,\"505\":7,\"575\":7,\"679\":1,\"701\":4,\"711\":2,\"732\":20,\"875\":4}}],[\"gb\",{\"1\":{\"83\":2}}],[\"位数一样就找数字最小的即可\",{\"1\":{\"769\":1}}],[\"位数一致\",{\"1\":{\"591\":1}}],[\"位数来枚举所有可能性\",{\"1\":{\"604\":1}}],[\"位数有多少在范围里\",{\"1\":{\"591\":1}}],[\"位数有多少个蛇数\",{\"1\":{\"335\":1}}],[\"位二进制数\",{\"1\":{\"478\":1}}],[\"位选\",{\"1\":{\"378\":1}}],[\"位能不能取到上限\",{\"1\":{\"335\":1}}],[\"位是\",{\"1\":{\"335\":1}}],[\"位且最高位就是\",{\"1\":{\"335\":1}}],[\"位且最高位小于\",{\"1\":{\"335\":1}}],[\"位的字符串的所有数字字符对应的数字之和是否是\",{\"1\":{\"856\":1}}],[\"位的\",{\"1\":{\"352\":1}}],[\"位的选择都恰好有\",{\"1\":{\"335\":1}}],[\"位的都行\",{\"1\":{\"335\":1}}],[\"位的数位内容\",{\"1\":{\"3\":1}}],[\"位可以是\",{\"1\":{\"335\":1}}],[\"位运算遍历二进制每一位\",{\"1\":{\"487\":1}}],[\"位运算检查\",{\"1\":{\"248\":1}}],[\"位运算写法\",{\"0\":{\"153\":1}}],[\"位移\",{\"1\":{\"198\":1}}],[\"位置开始\",{\"1\":{\"475\":1}}],[\"位置接王\",{\"1\":{\"259\":1}}],[\"位置的最大得分\",{\"1\":{\"199\":2}}],[\"位置\",{\"1\":{\"167\":1,\"198\":1,\"239\":1}}],[\"位小数就肯定够了\",{\"1\":{\"91\":1}}],[\"位小数输出后\",{\"1\":{\"91\":1}}],[\"位小数输出的会是\",{\"1\":{\"91\":1}}],[\"位小数的情况下\",{\"1\":{\"91\":2}}],[\"位小数\",{\"0\":{\"88\":1},\"1\":{\"91\":1}}],[\"位整数\",{\"1\":{\"83\":4}}],[\"位\",{\"1\":{\"83\":3,\"195\":1,\"270\":1,\"779\":1}}],[\"基础求和算法\",{\"1\":{\"894\":1}}],[\"基础的条件判断语句\",{\"1\":{\"850\":1}}],[\"基础的字符串处理\",{\"1\":{\"795\":1}}],[\"基础的求和\",{\"1\":{\"707\":1}}],[\"基础绘图\",{\"1\":{\"710\":1}}],[\"基础二维数组枚举及位置关系判断\",{\"1\":{\"700\":1}}],[\"基础二进制\",{\"0\":{\"85\":1}}],[\"基础字符串输入输出\",{\"1\":{\"697\":1}}],[\"基础递归\",{\"1\":{\"617\":1}}],[\"基础枚举\",{\"1\":{\"598\":1}}],[\"基础排序后\",{\"1\":{\"798\":1}}],[\"基础排序\",{\"1\":{\"588\":1}}],[\"基础组合数学\",{\"1\":{\"578\":1}}],[\"基础条件判断或者字符运算\",{\"1\":{\"691\":1}}],[\"基础条件判断\",{\"1\":{\"568\":1,\"582\":1,\"595\":1,\"608\":1}}],[\"基础条件条件判断\",{\"1\":{\"512\":1}}],[\"基础循环代码阅读理解\",{\"1\":{\"812\":1}}],[\"基础循环嵌套\",{\"1\":{\"585\":1}}],[\"基础循环嵌套及数学找规律\",{\"1\":{\"533\":1}}],[\"基础循环模拟\",{\"1\":{\"515\":1}}],[\"基础剪枝\",{\"0\":{\"254\":1}}],[\"基础做法就是记录当前连续长度和答案\",{\"1\":{\"324\":1}}],[\"基础做法\",{\"0\":{\"224\":1}}],[\"基础存图\",{\"1\":{\"215\":1}}],[\"基础暴力搜索\",{\"0\":{\"253\":1}}],[\"基础暴力\",{\"1\":{\"187\":1}}],[\"基础算法练习题\",{\"0\":{\"167\":1,\"168\":1}}],[\"基础数据类型\",{\"0\":{\"82\":1}}],[\"基于a\",{\"1\":{\"19\":1,\"20\":1,\"21\":1}}],[\"赋值为\",{\"1\":{\"216\":1}}],[\"赋值运算\",{\"1\":{\"81\":1}}],[\"赋值语句\",{\"0\":{\"63\":1}}],[\"且是\",{\"1\":{\"662\":1}}],[\"且最接近\",{\"1\":{\"413\":2}}],[\"且前一个是后一个的前缀\",{\"1\":{\"410\":1}}],[\"且数越多\",{\"1\":{\"326\":1}}],[\"且不是\",{\"1\":{\"226\":1}}],[\"且再\",{\"1\":{\"226\":1}}],[\"且后没有其他数了\",{\"1\":{\"91\":1}}],[\"且后面还有大于\",{\"1\":{\"91\":1}}],[\"且\",{\"1\":{\"81\":1,\"127\":1,\"405\":4,\"502\":1,\"604\":1,\"622\":2}}],[\"乘以\",{\"1\":{\"705\":1}}],[\"乘起来\",{\"1\":{\"329\":1}}],[\"乘除\",{\"1\":{\"81\":1}}],[\"乘法原理\",{\"1\":{\"498\":1,\"578\":1}}],[\"乘法\",{\"1\":{\"58\":1}}],[\"单看这个式子有点不太好找到突破口\",{\"1\":{\"904\":1}}],[\"单调栈计算每个敌人下一个胆量大于他的在哪儿\",{\"1\":{\"475\":1}}],[\"单词排排序\",{\"0\":{\"517\":1}}],[\"单词数就是\",{\"1\":{\"828\":1}}],[\"单词数\",{\"1\":{\"269\":1}}],[\"单词接龙\",{\"0\":{\"178\":1}}],[\"单独计算能活多久\",{\"1\":{\"204\":1}}],[\"单点变大\",{\"1\":{\"216\":1}}],[\"单点次数\",{\"1\":{\"162\":1}}],[\"单点修改\",{\"0\":{\"17\":1},\"1\":{\"19\":1,\"21\":1,\"237\":1,\"239\":1,\"291\":1}}],[\"单精度浮点数\",{\"1\":{\"83\":1}}],[\"单目运算符\",{\"1\":{\"81\":1}}],[\"假装在洗一副扑克牌\",{\"0\":{\"840\":1}}],[\"假如\",{\"1\":{\"766\":1}}],[\"假设第\",{\"1\":{\"904\":1}}],[\"假设这题需要找到的两个数分别为\",{\"1\":{\"904\":1}}],[\"假设数位分解后三个数为分别是\",{\"1\":{\"691\":1}}],[\"假设数组空间大小为\",{\"1\":{\"451\":1}}],[\"假设\",{\"1\":{\"658\":1,\"753\":1}}],[\"假设在\",{\"1\":{\"556\":1}}],[\"假设救火时间是\",{\"1\":{\"497\":1}}],[\"假设我们肯定希望每只猫咪的救火时间越短越好\",{\"1\":{\"497\":1}}],[\"假痴不癫\",{\"0\":{\"432\":1}}],[\"假道伐虢\",{\"0\":{\"428\":1}}],[\"假\",{\"1\":{\"80\":2}}],[\"真实比赛中第四题可能是最难的\",{\"1\":{\"438\":1}}],[\"真的是毒瘤题吗\",{\"0\":{\"873\":1}}],[\"真的展开九宫格\",{\"0\":{\"231\":1}}],[\"真的修改\",{\"0\":{\"122\":1},\"1\":{\"122\":1,\"233\":1}}],[\"真\",{\"1\":{\"80\":3}}],[\"非常小\",{\"1\":{\"838\":1,\"866\":1}}],[\"非周末\",{\"1\":{\"516\":1}}],[\"非\",{\"1\":{\"73\":1}}],[\"或\",{\"1\":{\"73\":1,\"81\":1,\"85\":1,\"101\":1,\"407\":1,\"413\":1,\"550\":1,\"622\":1,\"707\":1,\"881\":1}}],[\"或者叫做权值数组\",{\"1\":{\"897\":1}}],[\"或者有的同学学到的桶\",{\"1\":{\"897\":1}}],[\"或者有多处连续两个字符一样显然都是无解\",{\"1\":{\"601\":1}}],[\"或者广义的\",{\"1\":{\"735\":1}}],[\"或者十个\",{\"1\":{\"691\":1}}],[\"或者用数学的思路\",{\"1\":{\"591\":1}}],[\"或者数学思路手动处理\",{\"1\":{\"591\":1}}],[\"或者只用\",{\"1\":{\"508\":1}}],[\"或者依据另外\",{\"1\":{\"502\":1}}],[\"或者直接使用一个四维数组标记即可\",{\"1\":{\"815\":1}}],[\"或者直接定义\",{\"1\":{\"530\":1}}],[\"或者直接暴力做\",{\"1\":{\"489\":1}}],[\"或者直接检查这个数是不是二进制下全是\",{\"1\":{\"414\":1}}],[\"或者说当前被除数已经出现过了就循环了\",{\"1\":{\"489\":1}}],[\"或者逐个读字符类似快读的方法拼凑\",{\"1\":{\"478\":1}}],[\"或者高精度\",{\"1\":{\"478\":1}}],[\"或者备份一份即可\",{\"1\":{\"399\":1}}],[\"或者上一轮达成的人就是\",{\"1\":{\"196\":1}}],[\"或者\",{\"1\":{\"73\":1,\"400\":1,\"462\":1,\"574\":1,\"608\":1,\"736\":1,\"866\":1,\"909\":1}}],[\"与运算的初始化比较复杂\",{\"1\":{\"866\":1}}],[\"与运算的结果越不会有多余的数位\",{\"1\":{\"326\":1}}],[\"与对称位置即可\",{\"1\":{\"614\":1}}],[\"与之类似的经典题有\",{\"1\":{\"571\":1}}],[\"与或\",{\"0\":{\"138\":1}}],[\"与\",{\"1\":{\"73\":1,\"126\":1,\"512\":2,\"891\":1}}],[\"逻辑运算符\",{\"0\":{\"73\":1}}],[\"小朋友实际上只有三种\",{\"1\":{\"635\":1}}],[\"小红一共赢了多少局\",{\"1\":{\"632\":1}}],[\"小明\",{\"1\":{\"632\":1}}],[\"小猫向日葵\",{\"0\":{\"628\":1}}],[\"小时数\",{\"1\":{\"822\":1}}],[\"小时\",{\"1\":{\"531\":2,\"665\":2,\"822\":1}}],[\"小根堆\",{\"1\":{\"342\":1}}],[\"小熊的果篮\",{\"0\":{\"321\":1}}],[\"小木棍\",{\"0\":{\"195\":1}}],[\"小\",{\"1\":{\"172\":1}}],[\"小写转大写\",{\"1\":{\"95\":1}}],[\"小写字母映射到\",{\"1\":{\"94\":1}}],[\"小于等于\",{\"1\":{\"72\":1,\"437\":1}}],[\"小于\",{\"1\":{\"72\":1,\"507\":1}}],[\"小数独验证\",{\"0\":{\"673\":1}}],[\"小数点只是用来判断最后乘以\",{\"1\":{\"645\":1}}],[\"小数\",{\"1\":{\"61\":1}}],[\"关门捉贼\",{\"0\":{\"426\":1}}],[\"关灯3\",{\"0\":{\"162\":1}}],[\"关灯2\",{\"0\":{\"159\":1}}],[\"关灯1\",{\"0\":{\"152\":1,\"158\":1}}],[\"关于四舍五入\",{\"0\":{\"91\":1}}],[\"关系\",{\"0\":{\"72\":1}}],[\"关键字\",{\"1\":{\"62\":1}}],[\"新春算法马拉松比赛\",{\"0\":{\"889\":1}}],[\"新图每个点的入度\",{\"1\":{\"444\":1}}],[\"新图的\",{\"1\":{\"444\":1}}],[\"新图存边\",{\"1\":{\"444\":1}}],[\"新图一个点是之前多少个点\",{\"1\":{\"444\":1}}],[\"新图\",{\"1\":{\"444\":1}}],[\"新开一组的转移很好理解\",{\"1\":{\"280\":1}}],[\"新单词\",{\"0\":{\"71\":1}}],[\"新建文件\",{\"0\":{\"43\":1}}],[\"否则变成下一个数\",{\"1\":{\"735\":1}}],[\"否则答案就是\",{\"1\":{\"591\":1}}],[\"否则输出\",{\"1\":{\"582\":1,\"750\":1,\"809\":1}}],[\"否则就说明不可能完成目标了\",{\"1\":{\"556\":1}}],[\"否则就需要在\",{\"1\":{\"556\":1}}],[\"否则就需要\",{\"1\":{\"553\":1}}],[\"否则就需要花费一次\",{\"1\":{\"441\":1}}],[\"否则就需要看后续能不能变为一个先手必败的状态\",{\"1\":{\"432\":1}}],[\"否则将十位数和个位数分别算出来\",{\"1\":{\"507\":1}}],[\"否则说明最大值在右半边\",{\"1\":{\"446\":1}}],[\"否则只要当前局面能操作到一个先手必败的状态\",{\"1\":{\"432\":1}}],[\"否则\",{\"1\":{\"70\":1,\"71\":1,\"759\":1}}],[\"并不是无脑做正方形更好的\",{\"1\":{\"595\":1}}],[\"并在此位置进行操作\",{\"1\":{\"509\":1}}],[\"并计算对应结果计入总分\",{\"1\":{\"503\":1}}],[\"并计数\",{\"1\":{\"331\":2}}],[\"并会使用循环求解次方以及寻找最值就能拿到满分\",{\"1\":{\"503\":1}}],[\"并给子节点改成对应的颜色\",{\"1\":{\"494\":1}}],[\"并排序\",{\"1\":{\"313\":1,\"314\":1}}],[\"并且每次访问的也最多是这些位置\",{\"1\":{\"900\":1}}],[\"并且只能用一种数字\",{\"1\":{\"769\":1}}],[\"并且当前直接为\",{\"1\":{\"740\":1}}],[\"并且了解次方的数学含义\",{\"1\":{\"621\":1}}],[\"并且还是个转移只要\",{\"1\":{\"495\":1}}],[\"并且不可能只待在一个城市\",{\"1\":{\"493\":1}}],[\"并且按照这个理解很多样例数据都能正确解释\",{\"1\":{\"351\":1}}],[\"并且没有前导0\",{\"1\":{\"270\":1}}],[\"并且\",{\"1\":{\"70\":1,\"73\":1,\"818\":1}}],[\"并查集有可能\",{\"1\":{\"772\":1}}],[\"并查集缩点+广搜\",{\"0\":{\"296\":1}}],[\"并查集初始化\",{\"1\":{\"215\":1,\"243\":1,\"251\":1}}],[\"并查集\",{\"1\":{\"14\":1,\"215\":1,\"243\":1,\"251\":1}}],[\"请输入密码\",{\"1\":{\"70\":1,\"74\":1}}],[\"请输入用户名\",{\"1\":{\"70\":1,\"74\":1}}],[\"请输入5个1到10之间的整数\",{\"1\":{\"40\":1}}],[\"网站时输错了密码会怎么样\",{\"1\":{\"70\":1}}],[\"运算\",{\"0\":{\"865\":1}}],[\"运算速度会稍微的慢一丢丢\",{\"1\":{\"478\":1}}],[\"运算符优先级\",{\"0\":{\"81\":1}}],[\"运算符\",{\"0\":{\"72\":1},\"1\":{\"262\":1,\"263\":1,\"264\":1}}],[\"运算结果就会的到小数\",{\"1\":{\"58\":1}}],[\"运算结果也会是整数\",{\"1\":{\"58\":1}}],[\"运行时错误\",{\"1\":{\"69\":1}}],[\"运行时间超限\",{\"1\":{\"69\":1}}],[\"运行内存超限\",{\"1\":{\"69\":1}}],[\"题面中提到的视频是\",{\"1\":{\"726\":1}}],[\"题面写得没有特别清楚\",{\"1\":{\"492\":1}}],[\"题面代码优化\",{\"1\":{\"415\":1}}],[\"题目本身确实非常简单\",{\"1\":{\"759\":1}}],[\"题目规定了\",{\"1\":{\"645\":1}}],[\"题目要求我们输出三个非负整数\",{\"1\":{\"620\":1}}],[\"题目中的排序最多只需要进行一次\",{\"1\":{\"574\":1}}],[\"题目中所写的恰好\",{\"1\":{\"574\":1}}],[\"题目中又保证了\",{\"1\":{\"544\":1}}],[\"题目中一共有三种售卖方式\",{\"1\":{\"502\":1}}],[\"题目来源\",{\"1\":{\"489\":1}}],[\"题目怎么说的就怎么排序就好\",{\"1\":{\"871\":1}}],[\"题目怎么说\",{\"1\":{\"455\":1,\"456\":1,\"460\":1}}],[\"题目问几个数可以得到最大的输出\",{\"1\":{\"399\":1}}],[\"题目\",{\"0\":{\"108\":1}}],[\"题目页面\",{\"0\":{\"68\":1}}],[\"题解\",{\"0\":{\"1\":1,\"353\":1,\"501\":1,\"506\":1,\"510\":1,\"523\":1,\"528\":1,\"543\":1,\"548\":1,\"561\":1,\"566\":1,\"580\":1,\"593\":1,\"606\":1,\"619\":1,\"624\":1,\"632\":1,\"635\":1,\"637\":1,\"650\":1,\"663\":1,\"676\":1,\"689\":1,\"702\":1,\"715\":1,\"728\":1,\"733\":1,\"738\":1,\"743\":1,\"748\":1,\"750\":1,\"753\":1,\"756\":1,\"759\":1,\"761\":1,\"763\":1,\"766\":1,\"769\":1,\"772\":1,\"774\":1,\"776\":1,\"779\":1,\"782\":1,\"785\":1,\"787\":1,\"789\":1,\"792\":1,\"795\":1,\"798\":1,\"800\":1,\"807\":1,\"820\":1,\"833\":1,\"848\":1,\"861\":1,\"876\":1},\"1\":{\"574\":1}}],[\"将上下左右都照亮并标记\",{\"1\":{\"509\":1}}],[\"将两个字符转换为数字相加\",{\"1\":{\"507\":1}}],[\"将\",{\"1\":{\"64\":2,\"503\":1,\"534\":1}}],[\"语法场\",{\"0\":{\"748\":1,\"761\":1,\"774\":1,\"787\":1,\"800\":1}}],[\"语法上只需要输入输出和常用数学函数\",{\"1\":{\"550\":1}}],[\"语法周赛第二题是不能考数组的\",{\"1\":{\"720\":1}}],[\"语法周赛第一题保证了只需要用到条件判断\",{\"1\":{\"568\":1}}],[\"语法周赛\",{\"0\":{\"501\":1,\"506\":1,\"510\":1,\"523\":1,\"528\":1,\"543\":1,\"548\":1,\"561\":1,\"566\":1,\"580\":1,\"593\":1,\"606\":1,\"619\":1,\"624\":1,\"637\":1,\"650\":1,\"663\":1,\"676\":1,\"689\":1,\"702\":1,\"715\":1,\"728\":1,\"733\":1,\"738\":1,\"743\":1,\"807\":1,\"820\":1,\"833\":1,\"848\":1,\"861\":1,\"876\":1}}],[\"语法糖\",{\"0\":{\"64\":1}}],[\"语句判断即可\",{\"1\":{\"822\":1}}],[\"语句判断一下大小关系就好\",{\"1\":{\"563\":1}}],[\"语句判断一下大小关系就好了\",{\"1\":{\"562\":1}}],[\"语句即可\",{\"1\":{\"691\":1}}],[\"语句完成\",{\"1\":{\"691\":1}}],[\"语句也可以\",{\"1\":{\"508\":1}}],[\"语句\",{\"0\":{\"52\":1,\"53\":1,\"54\":1},\"1\":{\"89\":1,\"90\":1}}],[\"以字符串环状的规律来看\",{\"1\":{\"509\":1}}],[\"以逸待劳\",{\"0\":{\"490\":1}}],[\"以上的数据范围开方时精度很大概率不够\",{\"1\":{\"478\":1}}],[\"以内\",{\"1\":{\"838\":1,\"894\":1,\"904\":1}}],[\"以内最多有多少个数恰好是\",{\"1\":{\"437\":1}}],[\"以内就算对\",{\"1\":{\"91\":1}}],[\"以此类推\",{\"1\":{\"329\":1,\"835\":1}}],[\"以此为依据排列所有\",{\"1\":{\"182\":1}}],[\"以\",{\"1\":{\"112\":1,\"113\":1,\"115\":2,\"116\":2,\"117\":1,\"118\":1,\"119\":2,\"122\":1,\"123\":2,\"196\":1,\"198\":1,\"233\":3,\"303\":1,\"320\":2,\"366\":1}}],[\"以下哪些不符合规则\",{\"1\":{\"62\":1}}],[\"以及有没有多余的部分\",{\"1\":{\"642\":1}}],[\"以及\",{\"1\":{\"483\":1,\"753\":1}}],[\"以及朴素的质数判断会不会超时的问题\",{\"1\":{\"452\":1}}],[\"以及编号\",{\"1\":{\"342\":1}}],[\"以及距离上一个站点的路程\",{\"1\":{\"244\":2}}],[\"以及每一个小方块\",{\"1\":{\"182\":1}}],[\"以及基础的线段树上二分\",{\"1\":{\"22\":1}}],[\"以及一级祖先\",{\"1\":{\"12\":1}}],[\"下限为\",{\"1\":{\"878\":1}}],[\"下标从\",{\"1\":{\"505\":1}}],[\"下\",{\"1\":{\"505\":2}}],[\"下能否从\",{\"1\":{\"352\":1}}],[\"下降到\",{\"1\":{\"260\":1}}],[\"下传懒标记\",{\"1\":{\"237\":2,\"239\":2}}],[\"下传一层懒标记\",{\"1\":{\"216\":1,\"237\":1,\"239\":1}}],[\"下一块的编号\",{\"1\":{\"321\":1}}],[\"下一次从哪个位置开始看\",{\"1\":{\"226\":1}}],[\"下一个又出现\",{\"1\":{\"526\":1}}],[\"下一个要查询的字符为\",{\"1\":{\"504\":1}}],[\"下一个要考虑后面的测速点了\",{\"1\":{\"198\":1}}],[\"下一个水果\",{\"1\":{\"321\":1}}],[\"下一个垃圾是吃了还是垫高\",{\"1\":{\"204\":1}}],[\"下一个测速点没超过右端点就变为下一个\",{\"1\":{\"198\":1}}],[\"下一个考虑的测速点下标\",{\"1\":{\"198\":1}}],[\"下一个位置如果也是空的\",{\"1\":{\"109\":1,\"110\":1}}],[\"下一行的按键~\",{\"1\":{\"158\":1}}],[\"下取整\",{\"1\":{\"100\":1}}],[\"下划线\",{\"1\":{\"62\":1}}],[\"下面给出常规做法之外\",{\"1\":{\"841\":1}}],[\"下面给出倍增的构造方法\",{\"1\":{\"453\":1}}],[\"下面的代码会更简洁\",{\"1\":{\"735\":1}}],[\"下面的for最多被执行\",{\"1\":{\"164\":1}}],[\"下面代码会输出什么\",{\"0\":{\"76\":1,\"77\":1,\"78\":1,\"79\":1}}],[\"下面是权值线段树的单点修改\",{\"1\":{\"22\":1}}],[\"下面一跳位\",{\"1\":{\"12\":1}}],[\"只是为了提醒大家要注意读题\",{\"1\":{\"674\":1}}],[\"只是在\",{\"1\":{\"123\":1,\"233\":1}}],[\"只买得起一个小猫向日葵或者一个樱桃辣椒\",{\"1\":{\"629\":1}}],[\"只能用\",{\"1\":{\"445\":1}}],[\"只能从\",{\"1\":{\"405\":1}}],[\"只能包含字母\",{\"1\":{\"62\":1}}],[\"只有操作\",{\"1\":{\"874\":1}}],[\"只有两个数\",{\"1\":{\"866\":1}}],[\"只有一张牌\",{\"1\":{\"841\":1}}],[\"只有一个人\",{\"1\":{\"894\":1}}],[\"只有一个格子\",{\"1\":{\"700\":1}}],[\"只有一个数\",{\"1\":{\"591\":1}}],[\"只有一个数码管\",{\"1\":{\"578\":1}}],[\"只有一个坑点\",{\"1\":{\"458\":1}}],[\"只有一个\",{\"1\":{\"397\":1}}],[\"只有红灯和绿灯\",{\"1\":{\"835\":1}}],[\"只有红灯\",{\"1\":{\"835\":1}}],[\"只有大写字母就需要找一下\",{\"1\":{\"546\":1}}],[\"只有小写字母只要查找是否有小写的\",{\"1\":{\"546\":1}}],[\"只有二连的才去减少一次\",{\"1\":{\"441\":1}}],[\"只有\",{\"1\":{\"362\":1,\"507\":1}}],[\"只要不是系动词就输出\",{\"1\":{\"741\":1}}],[\"只要对应位置的数字相等就输出\",{\"1\":{\"652\":1}}],[\"只要把细节都注意就行了\",{\"1\":{\"527\":1}}],[\"只要判断\",{\"1\":{\"525\":1}}],[\"只要长度合法就行\",{\"1\":{\"409\":1}}],[\"只要选了一个最后的与运算和就肯定得不到\",{\"1\":{\"326\":1}}],[\"只要有一个运算数是小数\",{\"1\":{\"58\":1}}],[\"只需要算出数列前\",{\"1\":{\"904\":1}}],[\"只需要计算\",{\"1\":{\"884\":1}}],[\"只需要计算日期输出\",{\"1\":{\"740\":1}}],[\"只需要判断是否是\",{\"1\":{\"856\":1}}],[\"只需要判断是否小于\",{\"1\":{\"582\":1,\"850\":1}}],[\"只需要按照第二题的做法来循环数位分解即可\",{\"1\":{\"856\":1}}],[\"只需要根据是否为\",{\"1\":{\"853\":1}}],[\"只需要全局记录每种颜色的字符最新出现在哪儿即可\",{\"1\":{\"782\":1}}],[\"只需要先判断是否为周末\",{\"1\":{\"515\":1}}],[\"只需要比较\",{\"1\":{\"512\":2}}],[\"只需要输出\",{\"1\":{\"494\":1,\"828\":1}}],[\"只需要检查最后一行对不对了\",{\"1\":{\"154\":1}}],[\"只需保留\",{\"1\":{\"127\":1}}],[\"只需保留费用最低的\",{\"1\":{\"127\":1}}],[\"只需保留价值最高的\",{\"1\":{\"127\":1}}],[\"字典序大的数值更大\",{\"1\":{\"622\":1}}],[\"字串变换\",{\"0\":{\"179\":1}}],[\"字母的最长公共子序列\",{\"0\":{\"126\":1}}],[\"字母或下划线开头\",{\"1\":{\"62\":1}}],[\"字节\",{\"1\":{\"83\":1}}],[\"字符与整数的对应转换\",{\"0\":{\"92\":1}}],[\"字符输入\",{\"1\":{\"66\":1}}],[\"字符输出\",{\"1\":{\"47\":1,\"66\":1}}],[\"字符\",{\"1\":{\"56\":1,\"61\":1,\"83\":1}}],[\"字符串中仅包含\",{\"1\":{\"884\":1}}],[\"字符串有几个洞\",{\"0\":{\"805\":1}}],[\"字符串长度\",{\"1\":{\"622\":1}}],[\"字符串以及字典序才可以拿到满分\",{\"1\":{\"622\":1}}],[\"字符串下标是从\",{\"1\":{\"509\":1}}],[\"字符串的展开\",{\"0\":{\"188\":1}}],[\"字符串\",{\"1\":{\"56\":3,\"61\":1,\"521\":1,\"574\":1,\"601\":1}}],[\"字符串就是一串字符呗\",{\"1\":{\"56\":1}}],[\"字符串与数学表达式\",{\"0\":{\"55\":1}}],[\"比赛的获奖规则\",{\"0\":{\"870\":1}}],[\"比赛环境\",{\"0\":{\"62\":1}}],[\"比分是\",{\"1\":{\"632\":1}}],[\"比分是多少就是确定的\",{\"1\":{\"632\":1}}],[\"比分是a\",{\"1\":{\"632\":1}}],[\"比大小\",{\"0\":{\"622\":1,\"670\":1,\"683\":1}}],[\"比如如果是\",{\"1\":{\"565\":1}}],[\"比如如果输入\",{\"1\":{\"91\":1}}],[\"比如假设有\",{\"1\":{\"494\":1}}],[\"比如子任务\",{\"1\":{\"492\":1}}],[\"比如初始允许\",{\"1\":{\"453\":1}}],[\"比如\",{\"1\":{\"400\":1,\"601\":1}}],[\"比如第\",{\"1\":{\"109\":1,\"110\":1}}],[\"比如相对或绝对误差在\",{\"1\":{\"91\":1}}],[\"比如在保留\",{\"1\":{\"91\":1}}],[\"比较不好估算规模\",{\"1\":{\"900\":1}}],[\"比较麻烦的二维数组上的模拟\",{\"1\":{\"874\":1}}],[\"比较麻烦的数学题\",{\"1\":{\"704\":1}}],[\"比较基础的日期模拟题\",{\"1\":{\"571\":1}}],[\"比较好想到根据回文数这个限制\",{\"1\":{\"484\":1}}],[\"比较好的做法可能会是像我标程一样直接生成那些位置\",{\"1\":{\"414\":1}}],[\"比较大\",{\"1\":{\"453\":1}}],[\"比较大小\",{\"1\":{\"3\":1}}],[\"比较运算符\",{\"1\":{\"81\":1}}],[\"比较\",{\"0\":{\"72\":1},\"1\":{\"525\":1}}],[\"布尔逻辑体系的\",{\"1\":{\"80\":1}}],[\"布尔逻辑体系\",{\"0\":{\"80\":1}}],[\"布尔\",{\"1\":{\"61\":1}}],[\"不可能提供因子\",{\"1\":{\"904\":1}}],[\"不可能超过\",{\"1\":{\"802\":1}}],[\"不同于\",{\"1\":{\"900\":1}}],[\"不同的是这次只能倒掉了\",{\"1\":{\"887\":1}}],[\"不同\",{\"1\":{\"866\":1}}],[\"不太随机的随机数列\",{\"0\":{\"837\":1}}],[\"不超纲的话那就下面的\",{\"1\":{\"763\":1}}],[\"不超速\",{\"1\":{\"198\":1}}],[\"不符合条件的输出\",{\"1\":{\"723\":1}}],[\"不相等就输出\",{\"1\":{\"652\":1}}],[\"不相等时肯定要变为相等\",{\"1\":{\"441\":1}}],[\"不管怎么样\",{\"1\":{\"645\":1}}],[\"不需要额外求一遍最小值了\",{\"1\":{\"887\":2}}],[\"不需要循环数位分解\",{\"1\":{\"853\":1}}],[\"不需要变化\",{\"1\":{\"648\":1}}],[\"不需要排序了\",{\"1\":{\"588\":1}}],[\"不需要判断\",{\"1\":{\"18\":1}}],[\"不过\",{\"1\":{\"565\":1}}],[\"不如回头再扩展到更长\",{\"1\":{\"556\":1}}],[\"不如最优结果时就不看了\",{\"1\":{\"279\":1}}],[\"不进位加\",{\"0\":{\"483\":1}}],[\"不要在全局变量用这些变量名\",{\"1\":{\"477\":1}}],[\"不要三个一\",{\"0\":{\"397\":1}}],[\"不会超\",{\"1\":{\"894\":1}}],[\"不会超纲的\",{\"1\":{\"568\":1}}],[\"不会的话\",{\"1\":{\"454\":1}}],[\"不会改变数组大小\",{\"1\":{\"349\":1}}],[\"不特判的话会超时\",{\"1\":{\"435\":1}}],[\"不知道有没有后期选手直接上来就\",{\"1\":{\"414\":1}}],[\"不一样就是\",{\"1\":{\"409\":1}}],[\"不考虑取模\",{\"1\":{\"415\":1}}],[\"不考虑取模的代码提供思路\",{\"0\":{\"383\":1}}],[\"不考虑不够用的情况\",{\"0\":{\"134\":1}}],[\"不允许同样的方向\",{\"1\":{\"336\":1}}],[\"不使用\",{\"1\":{\"307\":1}}],[\"不选或者选第一个人或者选第二个人或者都选\",{\"1\":{\"499\":1}}],[\"不选第\",{\"1\":{\"301\":1}}],[\"不选\",{\"1\":{\"298\":3}}],[\"不变的变一下\",{\"1\":{\"286\":2}}],[\"不包括被摧毁的星球\",{\"1\":{\"215\":1}}],[\"不用图快\",{\"1\":{\"874\":1}}],[\"不用数组的做法\",{\"1\":{\"859\":1}}],[\"不用数组直接循环也可以\",{\"1\":{\"859\":1}}],[\"不用担心整型相除自动取整\",{\"1\":{\"734\":1}}],[\"不用担心和猫的位置冲突\",{\"1\":{\"426\":1}}],[\"不用循环\",{\"1\":{\"642\":1}}],[\"不用变化\",{\"1\":{\"553\":1}}],[\"不用管\",{\"1\":{\"453\":1}}],[\"不用手动维护求解顺序了\",{\"1\":{\"365\":1}}],[\"不用第\",{\"1\":{\"359\":1}}],[\"不用新测速点\",{\"1\":{\"198\":1}}],[\"不用改的部分的\",{\"1\":{\"141\":1}}],[\"不枚举\",{\"1\":{\"186\":1}}],[\"不按\",{\"1\":{\"154\":1}}],[\"不修改\",{\"0\":{\"123\":1},\"1\":{\"123\":1,\"233\":1}}],[\"不是很难\",{\"1\":{\"490\":1}}],[\"不是左边的时候\",{\"1\":{\"199\":2}}],[\"不是正确答案\",{\"1\":{\"109\":1,\"110\":1}}],[\"不是\",{\"1\":{\"73\":1,\"622\":3}}],[\"不等于\",{\"1\":{\"72\":1}}],[\"不能保证\",{\"1\":{\"772\":1}}],[\"不能整除向上取整就好\",{\"1\":{\"544\":1}}],[\"不能走\",{\"1\":{\"495\":1}}],[\"不能用自己\",{\"1\":{\"307\":1}}],[\"不能用\",{\"1\":{\"186\":1}}],[\"不能是\",{\"1\":{\"62\":1}}],[\"不能除以0或对0取余\",{\"1\":{\"58\":1}}],[\"浮点数\",{\"1\":{\"58\":1,\"61\":1}}],[\"大家一定要注意\",{\"1\":{\"759\":1}}],[\"大家要学会不要只一味的判断当前情况\",{\"1\":{\"704\":1}}],[\"大家可以想一下\",{\"1\":{\"766\":1}}],[\"大家可以想想怎么实现循环\",{\"1\":{\"453\":1}}],[\"大家可以看看\",{\"1\":{\"477\":1}}],[\"大局的得分都是\",{\"1\":{\"632\":1}}],[\"大的去消耗\",{\"1\":{\"488\":1}}],[\"大纲\",{\"1\":{\"415\":1}}],[\"大师\",{\"0\":{\"300\":1}}],[\"大写转小写\",{\"1\":{\"95\":1}}],[\"大写字母映射到\",{\"1\":{\"94\":1}}],[\"大于字符串长度\",{\"1\":{\"509\":1}}],[\"大于小于号\",{\"1\":{\"81\":1}}],[\"大于等于\",{\"1\":{\"72\":1,\"236\":1,\"237\":1,\"443\":1,\"645\":1}}],[\"大于\",{\"1\":{\"72\":1,\"146\":1}}],[\"大括号在\",{\"1\":{\"58\":1}}],[\"大小的鱼\",{\"1\":{\"147\":1}}],[\"大小的鱼可以无限钓\",{\"1\":{\"147\":1}}],[\"大小写字母之间转换\",{\"0\":{\"95\":1}}],[\"大小写字母映射到\",{\"0\":{\"94\":1}}],[\"大小\",{\"1\":{\"15\":1}}],[\"取整得到每一位即可\",{\"1\":{\"746\":1}}],[\"取决于\",{\"1\":{\"196\":1}}],[\"取出当前位置的数字\",{\"1\":{\"185\":1,\"186\":1}}],[\"取出个位\",{\"1\":{\"97\":1}}],[\"取模\",{\"1\":{\"58\":1}}],[\"取余了\",{\"1\":{\"541\":1}}],[\"取余只能在整数间进行\",{\"1\":{\"58\":1}}],[\"取余\",{\"1\":{\"58\":1}}],[\"取反\",{\"1\":{\"3\":1}}],[\"加一个判断分别处理即可\",{\"1\":{\"878\":1}}],[\"加上判断\",{\"1\":{\"825\":1}}],[\"加到\",{\"1\":{\"740\":1}}],[\"加\",{\"1\":{\"705\":1}}],[\"加速\",{\"0\":{\"600\":1}}],[\"加速度\",{\"1\":{\"198\":3}}],[\"加入总分即可\",{\"1\":{\"503\":1}}],[\"加入下一个垃圾时能否修改状态\",{\"1\":{\"204\":1}}],[\"加1操作\",{\"1\":{\"453\":1}}],[\"加强版\",{\"0\":{\"158\":1,\"225\":1}}],[\"加减\",{\"1\":{\"81\":1}}],[\"加减乘除怎么算出\",{\"1\":{\"39\":1}}],[\"加法\",{\"1\":{\"58\":1}}],[\"钥匙串是一串钥匙\",{\"1\":{\"56\":1}}],[\"定义一个结构体数组存储各个桃子的信息\",{\"1\":{\"623\":1}}],[\"定义一个返回整数的主函数\",{\"1\":{\"48\":1}}],[\"定义成字符串来储存\",{\"1\":{\"622\":1}}],[\"定义了\",{\"1\":{\"103\":1}}],[\"定义了一个名字叫作\",{\"1\":{\"103\":1,\"104\":1,\"105\":1,\"106\":1}}],[\"定义了一个大整数变量\",{\"1\":{\"3\":1}}],[\"标题一致\",{\"1\":{\"761\":1}}],[\"标程如下\",{\"1\":{\"502\":1,\"503\":1,\"505\":1}}],[\"标记完后\",{\"1\":{\"831\":1}}],[\"标记\",{\"1\":{\"815\":1}}],[\"标记每个数还在不在\",{\"0\":{\"393\":1}}],[\"标记每个星球是否被摧毁了\",{\"1\":{\"215\":1}}],[\"标记权值重新排序\",{\"0\":{\"392\":1}}],[\"标记是否还要开方\",{\"0\":{\"291\":1}}],[\"标记当前位置走过了\",{\"1\":{\"200\":1}}],[\"标记永久化\",{\"0\":{\"20\":1}}],[\"标识符\",{\"1\":{\"83\":1}}],[\"标准做法自然是递归地去画这个分形图\",{\"1\":{\"617\":1}}],[\"标准做法就是一个基础的循环嵌套\",{\"1\":{\"585\":1}}],[\"标准做法\",{\"0\":{\"310\":1}}],[\"标准\",{\"1\":{\"47\":1}}],[\"包括只有\",{\"1\":{\"302\":1}}],[\"包括了很多c++自带功能\",{\"1\":{\"47\":1}}],[\"包裹数\",{\"1\":{\"244\":2}}],[\"包裹快递\",{\"0\":{\"244\":1}}],[\"包含了这两个头文件\",{\"1\":{\"90\":1}}],[\"包含了这个头文件\",{\"1\":{\"89\":1}}],[\"包含\",{\"1\":{\"47\":1}}],[\"抓虫\",{\"0\":{\"45\":1}}],[\"6y\",{\"1\":{\"790\":1}}],[\"6951\",{\"1\":{\"484\":1}}],[\"6917\",{\"1\":{\"484\":1}}],[\"6777\",{\"1\":{\"484\":1}}],[\"6746\",{\"1\":{\"484\":1}}],[\"6630\",{\"1\":{\"484\":1}}],[\"6218\",{\"1\":{\"484\":1}}],[\"614\",{\"1\":{\"484\":1}}],[\"61\",{\"1\":{\"461\":3}}],[\"6316\",{\"1\":{\"484\":1}}],[\"63\",{\"1\":{\"414\":2}}],[\"6879\",{\"1\":{\"484\":1}}],[\"6858\",{\"1\":{\"484\":1}}],[\"6835\",{\"1\":{\"484\":1}}],[\"6808\",{\"1\":{\"484\":1}}],[\"688\",{\"1\":{\"195\":1}}],[\"68\",{\"1\":{\"195\":1}}],[\"6528\",{\"1\":{\"484\":1}}],[\"65\",{\"1\":{\"94\":1,\"140\":1}}],[\"640663963\",{\"1\":{\"735\":1}}],[\"6420\",{\"1\":{\"484\":1}}],[\"64\",{\"1\":{\"83\":2,\"414\":1}}],[\"6\",{\"0\":{\"316\":1,\"833\":1},\"1\":{\"41\":684,\"182\":41,\"195\":7,\"246\":7,\"248\":9,\"249\":9,\"262\":1,\"267\":46,\"282\":1,\"283\":1,\"284\":1,\"305\":1,\"306\":2,\"323\":1,\"453\":2,\"460\":4,\"504\":1,\"516\":1,\"572\":1,\"575\":2,\"656\":1,\"718\":1,\"732\":2,\"770\":3,\"790\":1,\"799\":1,\"828\":1}}],[\"60+8\",{\"1\":{\"665\":1}}],[\"6099\",{\"1\":{\"484\":1}}],[\"6000\",{\"1\":{\"368\":1}}],[\"60\",{\"0\":{\"39\":1,\"40\":1,\"115\":1,\"139\":1,\"209\":1,\"317\":1,\"399\":1,\"402\":1,\"422\":1,\"443\":1,\"466\":1,\"474\":1},\"1\":{\"40\":2,\"41\":684,\"78\":2,\"399\":1,\"410\":6,\"442\":1,\"484\":1,\"503\":1,\"527\":3,\"531\":5,\"599\":4,\"661\":1,\"665\":3,\"666\":2,\"823\":3,\"872\":2}}],[\"计数\",{\"1\":{\"426\":1}}],[\"计数排序\",{\"0\":{\"31\":1,\"348\":1},\"1\":{\"31\":1,\"346\":1}}],[\"计算每个颜色有几顶帽子\",{\"1\":{\"897\":1}}],[\"计算每个点到其它点的距离\",{\"1\":{\"259\":1}}],[\"计算选择方案即可\",{\"1\":{\"742\":1}}],[\"计算日同上\",{\"1\":{\"740\":1}}],[\"计算出星\",{\"1\":{\"740\":1}}],[\"计算出结果后直接判断即可\",{\"1\":{\"508\":1}}],[\"计算星可以通过计算得到当前的天数\",{\"1\":{\"740\":1}}],[\"计算年可以通过\",{\"1\":{\"740\":1}}],[\"计算方法有两种\",{\"1\":{\"740\":1}}],[\"计算机整数除整数自动取整\",{\"1\":{\"739\":1}}],[\"计算机储存的基本单位\",{\"1\":{\"83\":1}}],[\"计算机储存的最小单位\",{\"1\":{\"83\":1}}],[\"计算补码\",{\"0\":{\"712\":1}}],[\"计算这个文件占用空间就好\",{\"1\":{\"642\":1}}],[\"计算是否满足条件即可\",{\"1\":{\"611\":1}}],[\"计算两种方案的售价即可\",{\"1\":{\"595\":1}}],[\"计算当前小时的收费\",{\"1\":{\"516\":1}}],[\"计算并加入总分\",{\"1\":{\"503\":1}}],[\"计算从\",{\"1\":{\"475\":1}}],[\"计算答案\",{\"1\":{\"243\":1,\"377\":1}}],[\"计算\",{\"0\":{\"638\":1},\"1\":{\"127\":1,\"131\":1,\"132\":1,\"154\":1,\"270\":1,\"534\":1}}],[\"计算表达式的值\",{\"1\":{\"40\":1}}],[\"用数组存储后直接求\",{\"1\":{\"859\":1}}],[\"用字符串存储高精度数并进行操作\",{\"1\":{\"856\":1}}],[\"用葫芦的次数\",{\"1\":{\"747\":1}}],[\"用类似于前缀和的方式\",{\"1\":{\"658\":1}}],[\"用一个\",{\"1\":{\"815\":1}}],[\"用一个目标类型的数参与运算\",{\"1\":{\"101\":1}}],[\"用一些变量存储以上各种情况\",{\"1\":{\"545\":1}}],[\"用循环计算\",{\"1\":{\"508\":2}}],[\"用埃氏筛就够了\",{\"1\":{\"462\":1}}],[\"用了\",{\"1\":{\"461\":1}}],[\"用来跳转到程序的部分\",{\"1\":{\"453\":1}}],[\"用来求拓扑序\",{\"1\":{\"366\":1}}],[\"用来求解\",{\"1\":{\"366\":1}}],[\"用多少开多少\",{\"1\":{\"422\":1}}],[\"用这个代码来跑一跑\",{\"1\":{\"402\":1}}],[\"用第\",{\"1\":{\"359\":1}}],[\"用区间和判断\",{\"0\":{\"292\":1}}],[\"用二分来算区间数量\",{\"1\":{\"225\":1}}],[\"用前缀和来加速\",{\"1\":{\"224\":1}}],[\"用到了\",{\"1\":{\"126\":1,\"508\":1}}],[\"用\",{\"1\":{\"101\":1,\"440\":1,\"442\":1,\"525\":1,\"564\":1,\"582\":1}}],[\"用户名密码验证\",{\"0\":{\"74\":1}}],[\"用户名密码不正确\",{\"1\":{\"70\":1,\"74\":1}}],[\"用户名密码正确\",{\"1\":{\"70\":1,\"74\":1}}],[\"用于浮点数比较的误差范围\",{\"1\":{\"40\":1}}],[\"用小括号\",{\"1\":{\"39\":1}}],[\"8y\",{\"1\":{\"790\":1}}],[\"8x\",{\"1\":{\"790\":1}}],[\"8784\",{\"1\":{\"484\":1}}],[\"8751\",{\"1\":{\"484\":1}}],[\"8718\",{\"1\":{\"484\":1}}],[\"8694\",{\"1\":{\"484\":1}}],[\"8666\",{\"1\":{\"484\":1}}],[\"8636\",{\"1\":{\"484\":1}}],[\"8611\",{\"1\":{\"484\":1}}],[\"8585\",{\"1\":{\"484\":1}}],[\"8562\",{\"1\":{\"484\":1}}],[\"8531\",{\"1\":{\"484\":1}}],[\"859\",{\"1\":{\"484\":1}}],[\"8435\",{\"1\":{\"484\":1}}],[\"8408\",{\"1\":{\"484\":1}}],[\"8286\",{\"1\":{\"484\":1}}],[\"8258\",{\"1\":{\"484\":1}}],[\"8229\",{\"1\":{\"484\":1}}],[\"829\",{\"1\":{\"484\":11}}],[\"8193\",{\"1\":{\"484\":1}}],[\"8161\",{\"1\":{\"484\":1}}],[\"8978\",{\"1\":{\"484\":1}}],[\"8942\",{\"1\":{\"484\":1}}],[\"8922\",{\"1\":{\"484\":1}}],[\"89\",{\"1\":{\"484\":2}}],[\"8375\",{\"1\":{\"484\":1}}],[\"8349\",{\"1\":{\"484\":1}}],[\"8319\",{\"1\":{\"484\":1}}],[\"83\",{\"1\":{\"453\":1}}],[\"8890\",{\"1\":{\"484\":1}}],[\"88\",{\"1\":{\"195\":1,\"490\":3}}],[\"800\",{\"1\":{\"799\":1}}],[\"8004\",{\"1\":{\"484\":1}}],[\"8060\",{\"1\":{\"484\":1}}],[\"8037\",{\"1\":{\"484\":1}}],[\"80\",{\"1\":{\"176\":1}}],[\"8个连续的二进制位\",{\"1\":{\"83\":1}}],[\"8\",{\"0\":{\"861\":1},\"1\":{\"40\":1,\"41\":684,\"61\":1,\"83\":3,\"85\":2,\"182\":25,\"195\":3,\"230\":3,\"246\":1,\"248\":9,\"249\":9,\"253\":1,\"259\":1,\"262\":1,\"267\":3,\"276\":1,\"285\":1,\"288\":1,\"305\":1,\"323\":1,\"438\":1,\"460\":4,\"505\":2,\"516\":1,\"640\":1,\"656\":1,\"666\":1,\"718\":1,\"732\":3,\"744\":1,\"790\":1}}],[\"算平均数上取整即可\",{\"1\":{\"894\":1}}],[\"算法\",{\"1\":{\"772\":1}}],[\"算利润\",{\"0\":{\"739\":1}}],[\"算入答案\",{\"1\":{\"534\":1}}],[\"算一下多少天花额外的\",{\"1\":{\"524\":1}}],[\"算得分\",{\"0\":{\"503\":1}}],[\"算输入的文章总长度\",{\"1\":{\"410\":1}}],[\"算答案\",{\"1\":{\"351\":1}}],[\"算两次最长连续非零子串\",{\"1\":{\"324\":1}}],[\"算组合的方案\",{\"1\":{\"298\":2}}],[\"算过了没贴边的结果的话就直接返回\",{\"1\":{\"270\":1}}],[\"算算这两个有几个装油量小于\",{\"1\":{\"604\":1}}],[\"算算有多少个\",{\"1\":{\"462\":1}}],[\"算算哪些数字最后一次被命中\",{\"1\":{\"400\":1}}],[\"算算最后一行有几个位置不可以\",{\"1\":{\"241\":1}}],[\"算算最后的超速位置\",{\"1\":{\"198\":1}}],[\"算算走多久之后开始超过\",{\"1\":{\"198\":1}}],[\"算算啥时候开始超速\",{\"1\":{\"198\":1}}],[\"算算按了几个位置\",{\"1\":{\"154\":1}}],[\"算出每个人的排名\",{\"1\":{\"798\":1}}],[\"算出了几个i9\",{\"0\":{\"788\":1}}],[\"算出走到了边界的什么位置\",{\"1\":{\"766\":1}}],[\"算出中心点\",{\"1\":{\"723\":1}}],[\"算出\",{\"1\":{\"658\":1,\"723\":1}}],[\"算出答案了\",{\"1\":{\"658\":1}}],[\"算出的结果作比较\",{\"1\":{\"503\":1}}],[\"算出要走的距离\",{\"1\":{\"267\":1}}],[\"算出所有超速区间\",{\"1\":{\"198\":1}}],[\"算出来每个含义的值\",{\"1\":{\"466\":1,\"467\":1}}],[\"算出来下一个位置的行列编号\",{\"1\":{\"248\":1,\"249\":1}}],[\"算出来第一行每个位置能覆盖哪个区间\",{\"1\":{\"242\":1}}],[\"算出来\",{\"1\":{\"158\":1}}],[\"算出一共钓了多少条鱼\",{\"1\":{\"146\":1}}],[\"算\",{\"0\":{\"40\":1},\"1\":{\"250\":2,\"410\":1}}],[\"点外卖\",{\"0\":{\"808\":1}}],[\"点数\",{\"1\":{\"215\":1}}],[\"点\",{\"1\":{\"202\":1,\"203\":1,\"295\":1,\"665\":1}}],[\"点的程序\",{\"0\":{\"40\":1}}],[\"点的编号>\",{\"1\":{\"13\":1}}],[\"点游戏\",{\"0\":{\"39\":1}}],[\"高级循环控制\",{\"1\":{\"881\":1}}],[\"高级语言\",{\"0\":{\"38\":1}}],[\"高兴\",{\"0\":{\"594\":1}}],[\"高\",{\"1\":{\"260\":1}}],[\"高度\",{\"1\":{\"167\":1}}],[\"高斯消元模板\",{\"1\":{\"285\":2}}],[\"高斯消元法\",{\"0\":{\"285\":1}}],[\"高斯消元\",{\"1\":{\"158\":1}}],[\"高精度取模\",{\"1\":{\"3\":1}}],[\"高精度除法\",{\"1\":{\"3\":1}}],[\"高精度乘法\",{\"1\":{\"3\":1}}],[\"高精度减法\",{\"1\":{\"3\":1}}],[\"高精度加法\",{\"0\":{\"6\":1},\"1\":{\"3\":1}}],[\"高精度模板\",{\"0\":{\"2\":1}}],[\"o++\",{\"1\":{\"575\":2}}],[\"ouf\",{\"1\":{\"551\":1}}],[\"output\",{\"1\":{\"695\":1}}],[\"outint128\",{\"1\":{\"478\":3}}],[\"outans\",{\"1\":{\"447\":4}}],[\"out\",{\"1\":{\"37\":1,\"66\":1,\"176\":3,\"198\":1,\"321\":1,\"397\":1,\"399\":1,\"400\":1,\"402\":2,\"405\":1,\"410\":1,\"412\":1,\"413\":2,\"415\":4,\"421\":1,\"422\":1,\"423\":1,\"425\":1,\"426\":1,\"427\":1,\"428\":1,\"430\":1,\"431\":1,\"432\":1,\"433\":1,\"435\":1,\"436\":2,\"437\":1,\"438\":1,\"450\":1,\"452\":1,\"453\":1,\"455\":1,\"456\":1,\"457\":1,\"458\":1,\"480\":1,\"482\":1,\"483\":1,\"484\":1,\"487\":1,\"488\":1,\"489\":1,\"490\":1,\"492\":1,\"493\":1,\"494\":1,\"495\":1,\"497\":1,\"498\":1,\"499\":1,\"500\":1,\"698\":1,\"705\":1,\"708\":1,\"711\":1,\"714\":1,\"718\":1,\"721\":1,\"724\":1,\"727\":1}}],[\"olz34sb78q\",{\"1\":{\"487\":1}}],[\"oi\",{\"1\":{\"485\":1}}],[\"october\",{\"1\":{\"455\":1}}],[\"of\",{\"0\":{\"276\":1}}],[\"odd\",{\"1\":{\"274\":5,\"564\":1}}],[\"ok\",{\"1\":{\"170\":2,\"196\":5,\"257\":7,\"269\":1,\"352\":3,\"393\":5,\"551\":1}}],[\"o\",{\"0\":{\"374\":1},\"1\":{\"164\":1,\"287\":1,\"317\":2,\"318\":1,\"320\":2,\"369\":3,\"413\":1,\"504\":1,\"541\":1,\"542\":1,\"575\":7,\"736\":2,\"884\":1,\"885\":1}}],[\"on\",{\"0\":{\"294\":1}}],[\"one++\",{\"1\":{\"885\":1}}],[\"one\",{\"1\":{\"246\":1,\"351\":1,\"885\":3}}],[\"oneb\",{\"1\":{\"158\":2}}],[\"online\",{\"1\":{\"67\":1}}],[\"order\",{\"1\":{\"444\":3}}],[\"or\",{\"0\":{\"352\":1},\"1\":{\"73\":1,\"81\":1,\"165\":1,\"329\":1}}],[\"oj\",{\"0\":{\"67\":1},\"1\":{\"67\":1,\"70\":1}}],[\"op2\",{\"1\":{\"127\":10}}],[\"op1\",{\"1\":{\"127\":10}}],[\"ops\",{\"1\":{\"40\":5,\"453\":6}}],[\"op\",{\"1\":{\"17\":4,\"19\":3,\"20\":3,\"21\":5,\"40\":5,\"142\":4,\"165\":6,\"174\":5,\"216\":8,\"218\":4,\"235\":5,\"236\":5,\"237\":5,\"239\":5,\"251\":4,\"262\":11,\"263\":11,\"264\":11,\"287\":3,\"291\":3,\"292\":3,\"309\":3,\"310\":3,\"331\":6,\"456\":4,\"541\":1,\"542\":5,\"688\":4,\"745\":4,\"847\":4,\"875\":4}}],[\"operator>=\",{\"1\":{\"3\":1}}],[\"operator>\",{\"1\":{\"3\":1}}],[\"operator+\",{\"1\":{\"3\":1}}],[\"operator+=\",{\"1\":{\"3\":1}}],[\"operator<=\",{\"1\":{\"3\":1}}],[\"operator<\",{\"1\":{\"3\":1}}],[\"operator==\",{\"1\":{\"3\":1}}],[\"operator=\",{\"1\":{\"3\":1}}],[\"operator\",{\"1\":{\"3\":6,\"377\":1}}],[\"7981\",{\"1\":{\"484\":1}}],[\"7952\",{\"1\":{\"484\":1}}],[\"7930\",{\"1\":{\"484\":1}}],[\"790\",{\"1\":{\"484\":1}}],[\"789\",{\"1\":{\"656\":1}}],[\"7897\",{\"1\":{\"484\":1}}],[\"7866\",{\"1\":{\"484\":1}}],[\"7833\",{\"1\":{\"484\":1}}],[\"7803\",{\"1\":{\"484\":1}}],[\"76\",{\"1\":{\"839\":1}}],[\"7695\",{\"1\":{\"484\":1}}],[\"7665\",{\"1\":{\"484\":1}}],[\"7628\",{\"1\":{\"484\":1}}],[\"7605\",{\"1\":{\"484\":1}}],[\"7481\",{\"1\":{\"484\":101}}],[\"7458\",{\"1\":{\"484\":1}}],[\"7428\",{\"1\":{\"484\":1}}],[\"7312\",{\"1\":{\"484\":1}}],[\"7287\",{\"1\":{\"484\":1}}],[\"7265\",{\"1\":{\"484\":1}}],[\"7233\",{\"1\":{\"484\":1}}],[\"7202\",{\"1\":{\"484\":1}}],[\"7174\",{\"1\":{\"484\":1}}],[\"7149\",{\"1\":{\"484\":1}}],[\"7121\",{\"1\":{\"484\":1}}],[\"7535\",{\"1\":{\"484\":1}}],[\"7516\",{\"1\":{\"484\":1}}],[\"755\",{\"1\":{\"484\":1}}],[\"7569\",{\"1\":{\"484\":1}}],[\"756\",{\"1\":{\"469\":1}}],[\"75\",{\"0\":{\"172\":1},\"1\":{\"172\":1}}],[\"7089\",{\"1\":{\"484\":1}}],[\"7061\",{\"1\":{\"484\":1}}],[\"70\",{\"0\":{\"144\":1,\"254\":1},\"1\":{\"109\":1,\"196\":1}}],[\"7\",{\"0\":{\"848\":1},\"1\":{\"37\":1,\"119\":1,\"182\":33,\"195\":9,\"246\":1,\"248\":9,\"249\":9,\"262\":1,\"267\":12,\"305\":1,\"306\":1,\"329\":1,\"367\":1,\"372\":1,\"374\":1,\"375\":1,\"377\":1,\"378\":1,\"379\":1,\"380\":1,\"402\":2,\"405\":1,\"414\":1,\"415\":4,\"461\":3,\"464\":1,\"465\":1,\"466\":1,\"467\":1,\"484\":2,\"503\":1,\"516\":4,\"524\":1,\"572\":1,\"579\":1,\"656\":1,\"718\":1,\"732\":3,\"770\":1,\"887\":1}}],[\"汇编语言\",{\"0\":{\"37\":1}}],[\"机器语言\",{\"0\":{\"36\":1}}],[\"数列最多前\",{\"1\":{\"904\":1}}],[\"数数放了几天假\",{\"0\":{\"883\":1}}],[\"数论\",{\"1\":{\"668\":1}}],[\"数串质数\",{\"0\":{\"536\":1}}],[\"数\",{\"0\":{\"273\":1}}],[\"数独\",{\"0\":{\"247\":1}}],[\"数据范围比较大\",{\"1\":{\"874\":1}}],[\"数据范围非常小\",{\"1\":{\"753\":1}}],[\"数据范围又小\",{\"1\":{\"617\":1}}],[\"数据范围很小\",{\"1\":{\"533\":1,\"726\":1,\"874\":1}}],[\"数据卡掉了\",{\"1\":{\"546\":1}}],[\"数据的开始和结束在\",{\"1\":{\"509\":1}}],[\"数据中有\",{\"1\":{\"503\":1}}],[\"数据\",{\"1\":{\"502\":2}}],[\"数据初始是\",{\"1\":{\"453\":1}}],[\"数据组数\",{\"1\":{\"196\":5}}],[\"数据类型名\",{\"1\":{\"83\":1}}],[\"数据类型对应的范围\",{\"0\":{\"83\":1}}],[\"数对\",{\"0\":{\"189\":1}}],[\"数中最小的\",{\"1\":{\"168\":1}}],[\"数量加一\",{\"1\":{\"828\":1}}],[\"数量次数为\",{\"1\":{\"742\":1}}],[\"数量和匹配一定是对的\",{\"1\":{\"741\":1}}],[\"数量\",{\"1\":{\"438\":2}}],[\"数量刚好和之前相反\",{\"1\":{\"160\":1}}],[\"数量的搞不完\",{\"1\":{\"147\":1}}],[\"数量的都能搞完\",{\"1\":{\"147\":1}}],[\"数组综合运用\",{\"1\":{\"897\":1}}],[\"数组综合应用\",{\"1\":{\"831\":1}}],[\"数组即可\",{\"1\":{\"521\":1}}],[\"数组初始化\",{\"1\":{\"259\":1}}],[\"数组里面的这些区间最少用几个能覆盖\",{\"1\":{\"241\":1}}],[\"数组\",{\"1\":{\"109\":1,\"110\":1,\"521\":2,\"887\":1}}],[\"数组是空的就返回真\",{\"1\":{\"103\":1}}],[\"数组是否为空\",{\"1\":{\"103\":1}}],[\"数组大小也归零了\",{\"1\":{\"103\":1}}],[\"数组的\",{\"1\":{\"13\":1}}],[\"数位分解后依次算出每一位对应的字符即可\",{\"1\":{\"691\":1}}],[\"数位分解计算位数\",{\"0\":{\"264\":1}}],[\"数位分解\",{\"0\":{\"97\":1},\"1\":{\"648\":1}}],[\"数位的权值分别为\",{\"1\":{\"85\":1}}],[\"数字对应的也是\",{\"1\":{\"578\":1}}],[\"数字又不一样\",{\"1\":{\"562\":2}}],[\"数字计数\",{\"0\":{\"270\":1}}],[\"数字上操作\",{\"0\":{\"230\":1}}],[\"数字转换为对应字符\",{\"1\":{\"93\":1}}],[\"数字字符转换为对应整数\",{\"1\":{\"93\":1}}],[\"数字字符与对应整数\",{\"0\":{\"93\":1}}],[\"数字\",{\"1\":{\"62\":1,\"164\":1}}],[\"数字电路\",{\"0\":{\"35\":1}}],[\"数学好一点容易直到实际上项数少得多\",{\"1\":{\"802\":1}}],[\"数学中的小括号\",{\"1\":{\"58\":1}}],[\"数学运算符\",{\"0\":{\"58\":1},\"1\":{\"81\":1}}],[\"数学表达式\",{\"0\":{\"57\":1}}],[\"冒泡排序步骤\",{\"0\":{\"737\":1}}],[\"冒泡排序\",{\"0\":{\"29\":1},\"1\":{\"29\":1}}],[\"输出其中较小的即可\",{\"1\":{\"866\":1}}],[\"输出他们的和即可\",{\"1\":{\"818\":1}}],[\"输出他的算术平方根即可\",{\"1\":{\"550\":1}}],[\"输出特定内容即可\",{\"1\":{\"697\":1}}],[\"输出的必然是\",{\"1\":{\"678\":1}}],[\"输出的是在\",{\"1\":{\"399\":1}}],[\"输出体重和\",{\"1\":{\"639\":1}}],[\"输出样例即可\",{\"1\":{\"639\":1}}],[\"输出每一位\",{\"1\":{\"483\":1}}],[\"输出每个块的第一个水果\",{\"1\":{\"321\":1}}],[\"输出时可以像我下面代码一样递归一位位转成可以输出的类型输出即可\",{\"1\":{\"478\":1}}],[\"输出两个字符\",{\"1\":{\"507\":1}}],[\"输出两个\",{\"1\":{\"452\":1}}],[\"输出消除方案\",{\"1\":{\"192\":1}}],[\"输出消除完的字符串\",{\"1\":{\"192\":1}}],[\"输出\",{\"1\":{\"27\":1,\"29\":1,\"30\":1,\"31\":1,\"32\":1,\"48\":1,\"142\":1,\"196\":1,\"295\":1,\"410\":1,\"426\":1,\"452\":1,\"544\":1,\"550\":1,\"562\":2,\"563\":1,\"568\":1,\"582\":1,\"598\":1,\"622\":1,\"645\":1,\"648\":1,\"652\":1,\"658\":1,\"661\":1,\"674\":1,\"720\":1,\"734\":1,\"736\":2,\"739\":1,\"744\":1,\"835\":1,\"863\":1,\"878\":1,\"884\":1}}],[\"输入五个\",{\"1\":{\"744\":2}}],[\"输入完成后\",{\"1\":{\"741\":1}}],[\"输入完成之后因为保证了时间不会跨越一天\",{\"1\":{\"530\":1}}],[\"输入范围很小\",{\"1\":{\"694\":1}}],[\"输入一个数\",{\"1\":{\"550\":1}}],[\"输入时有一些小技巧\",{\"1\":{\"530\":1}}],[\"输入可以用\",{\"1\":{\"471\":1}}],[\"输入输出优化的\",{\"1\":{\"445\":1}}],[\"输入这些分别会输出什么\",{\"1\":{\"66\":1}}],[\"输入语句与条件判断\",{\"0\":{\"65\":1}}],[\"输入\",{\"1\":{\"27\":1,\"29\":1,\"30\":1,\"31\":1,\"32\":1,\"200\":1,\"259\":1,\"260\":1,\"312\":1,\"313\":1}}],[\"k2\",{\"1\":{\"764\":16}}],[\"k1\",{\"1\":{\"764\":12}}],[\"kk\",{\"1\":{\"662\":4}}],[\"kong\",{\"1\":{\"438\":2}}],[\"k+1\",{\"1\":{\"369\":1}}],[\"k++\",{\"1\":{\"168\":2,\"179\":3,\"204\":1,\"232\":1,\"253\":1,\"257\":1,\"275\":2,\"280\":1,\"335\":1,\"369\":1,\"377\":1,\"379\":2,\"475\":1,\"480\":1,\"490\":1,\"505\":2,\"557\":1,\"612\":1,\"812\":1}}],[\"knapsack\",{\"0\":{\"357\":1,\"360\":1}}],[\"knighty\",{\"1\":{\"259\":7}}],[\"knightx\",{\"1\":{\"259\":7}}],[\"kamen\",{\"0\":{\"316\":1}}],[\"kmp\",{\"0\":{\"281\":1}}],[\"kitten\",{\"1\":{\"432\":1,\"493\":1,\"495\":1,\"668\":4,\"764\":1}}],[\"kingy\",{\"1\":{\"259\":6}}],[\"kingx\",{\"1\":{\"259\":6}}],[\"kib\",{\"1\":{\"83\":1}}],[\"kth\",{\"1\":{\"213\":2,\"214\":2}}],[\"kb\",{\"1\":{\"83\":2,\"642\":1}}],[\"k\",{\"0\":{\"370\":1,\"660\":2},\"1\":{\"23\":2,\"24\":6,\"127\":3,\"131\":3,\"132\":3,\"137\":24,\"139\":4,\"140\":4,\"150\":3,\"151\":3,\"160\":18,\"161\":3,\"162\":4,\"168\":8,\"169\":3,\"172\":2,\"175\":3,\"178\":6,\"179\":10,\"180\":3,\"181\":10,\"194\":3,\"196\":23,\"199\":1,\"204\":4,\"212\":1,\"215\":8,\"219\":6,\"224\":3,\"225\":2,\"226\":2,\"232\":19,\"245\":4,\"253\":7,\"255\":3,\"256\":4,\"257\":8,\"260\":3,\"266\":2,\"275\":15,\"280\":10,\"285\":4,\"286\":10,\"335\":2,\"355\":3,\"369\":20,\"370\":4,\"372\":6,\"377\":7,\"378\":4,\"379\":6,\"415\":14,\"418\":4,\"421\":3,\"422\":3,\"423\":3,\"432\":3,\"437\":4,\"450\":6,\"473\":4,\"475\":19,\"480\":6,\"488\":7,\"490\":5,\"497\":11,\"499\":5,\"500\":6,\"505\":12,\"557\":4,\"560\":4,\"612\":5,\"618\":5,\"633\":1,\"653\":4,\"662\":19,\"679\":1,\"724\":3,\"732\":3,\"764\":2,\"767\":3,\"780\":3,\"812\":3}}],[\"找整段的树\",{\"1\":{\"832\":1}}],[\"找找\",{\"1\":{\"557\":1}}],[\"找\",{\"1\":{\"546\":1}}],[\"找子序列\",{\"0\":{\"326\":1}}],[\"找系数最大的一行\",{\"1\":{\"285\":1}}],[\"找个骑士去接王\",{\"1\":{\"259\":1}}],[\"找上一个同色的位置\",{\"1\":{\"199\":2}}],[\"找最大值\",{\"1\":{\"444\":1}}],[\"找最近的同色\",{\"1\":{\"199\":2}}],[\"找最小的能被\",{\"1\":{\"197\":1}}],[\"找一个最小的\",{\"1\":{\"126\":1,\"343\":1}}],[\"找中位数\",{\"1\":{\"23\":1}}],[\"找到后判断其下一个是否为\",{\"1\":{\"526\":1}}],[\"找到所有每两个\",{\"1\":{\"440\":1}}],[\"找到一个操作次数最多的\",{\"1\":{\"343\":1}}],[\"找到当前最后一行啥时候能消除\",{\"1\":{\"342\":1}}],[\"找到第一个满足\",{\"1\":{\"621\":1}}],[\"找到第一个权值前缀和大于等于\",{\"1\":{\"239\":1}}],[\"找到第一个\",{\"1\":{\"236\":1,\"237\":1}}],[\"找到第一个前缀和大于等于\",{\"1\":{\"213\":1}}],[\"找到最少时间\",{\"1\":{\"219\":2}}],[\"找到最后一个可行的测速点\",{\"1\":{\"198\":1}}],[\"找到每个数最终应该被交换到哪儿\",{\"1\":{\"173\":1}}],[\"找到两个数的\",{\"1\":{\"170\":1}}],[\"找到了最小的之后再交换\",{\"0\":{\"28\":1}}],[\"找到排名为k的数是几\",{\"1\":{\"23\":1,\"24\":1}}],[\"找到\",{\"1\":{\"13\":1,\"172\":1,\"504\":1}}],[\"左转右转就是\",{\"1\":{\"541\":1}}],[\"左斜\",{\"1\":{\"505\":1}}],[\"左上\",{\"1\":{\"505\":2,\"675\":1}}],[\"左上开始\",{\"1\":{\"166\":1}}],[\"左\",{\"1\":{\"505\":2}}],[\"左下\",{\"1\":{\"505\":2,\"675\":1}}],[\"左半边是\",{\"1\":{\"400\":1}}],[\"左右的区间\",{\"1\":{\"320\":1}}],[\"左右子节点\",{\"1\":{\"23\":1}}],[\"左子节点\",{\"1\":{\"237\":2,\"239\":2}}],[\"左子树\",{\"1\":{\"19\":3,\"20\":2,\"21\":4}}],[\"左边先走的最大的分减去\",{\"1\":{\"495\":2}}],[\"左边先走的最大得分\",{\"1\":{\"495\":1}}],[\"左边只有次大值\",{\"1\":{\"447\":1}}],[\"左边除了次大值还有其他的\",{\"1\":{\"447\":1}}],[\"左边直达\",{\"1\":{\"405\":1}}],[\"左边没走过\",{\"1\":{\"405\":1}}],[\"左边没有房子被摧毁时\",{\"1\":{\"236\":2,\"237\":2,\"239\":2}}],[\"左边回撤一步再往前\",{\"1\":{\"405\":1}}],[\"左边走过\",{\"1\":{\"405\":1}}],[\"左边位置要么\",{\"1\":{\"351\":1}}],[\"左边少了一个\",{\"1\":{\"320\":1}}],[\"左边多了一个\",{\"1\":{\"320\":1}}],[\"左边线\",{\"1\":{\"313\":1,\"314\":1}}],[\"左边按键\",{\"1\":{\"158\":1}}],[\"中最大的数来和\",{\"1\":{\"818\":1}}],[\"中最大的一个\",{\"1\":{\"500\":1}}],[\"中\",{\"1\":{\"661\":2,\"812\":1}}],[\"中仅有一个子序列是\",{\"1\":{\"504\":1}}],[\"中间有八个数字\",{\"1\":{\"700\":1}}],[\"中间有\",{\"1\":{\"485\":1}}],[\"中间的情况也会非常复杂\",{\"1\":{\"704\":1}}],[\"中间的\",{\"1\":{\"400\":2}}],[\"中有定义\",{\"1\":{\"477\":1}}],[\"中有没有出现过就可以了\",{\"1\":{\"457\":1}}],[\"中的较大值就好\",{\"1\":{\"825\":1}}],[\"中的所有数字字符\",{\"1\":{\"645\":1}}],[\"中的有可能得到\",{\"1\":{\"608\":1}}],[\"中的一个的倍数\",{\"1\":{\"437\":1}}],[\"中的一个\",{\"1\":{\"413\":1,\"588\":1}}],[\"中的合适位置\",{\"1\":{\"209\":1}}],[\"中找几次能找到\",{\"1\":{\"399\":1}}],[\"中只有右边有\",{\"1\":{\"351\":1}}],[\"中维生素达到\",{\"1\":{\"340\":1}}],[\"中该选哪些呢\",{\"1\":{\"326\":1}}],[\"中国象棋\",{\"0\":{\"304\":1}}],[\"中之前有\",{\"1\":{\"211\":1}}],[\"中所有超过了\",{\"1\":{\"146\":1}}],[\"中每个字母的所有出现位置\",{\"1\":{\"126\":1}}],[\"中统统用小括号\",{\"1\":{\"58\":1}}],[\"中括号\",{\"1\":{\"58\":1}}],[\"中位数\",{\"0\":{\"206\":1,\"207\":1},\"1\":{\"22\":1}}],[\"中第一次出现的下标\",{\"1\":{\"13\":1}}],[\"~s\",{\"1\":{\"329\":2}}],[\"~~~~~\",{\"1\":{\"302\":1}}],[\"~y\",{\"1\":{\"298\":3}}],[\"~d\",{\"1\":{\"270\":2}}],[\"~cnt\",{\"1\":{\"258\":1}}],[\"~x\",{\"1\":{\"146\":2,\"298\":1,\"645\":1}}],[\"~b\",{\"1\":{\"126\":1}}],[\"~\",{\"0\":{\"396\":1,\"411\":1,\"416\":1,\"424\":1,\"429\":1,\"434\":1,\"439\":1,\"449\":1,\"454\":1,\"459\":1,\"468\":1,\"476\":1,\"481\":1,\"486\":1,\"491\":1,\"496\":1},\"1\":{\"64\":7,\"67\":2,\"93\":2,\"94\":4,\"126\":1,\"157\":2,\"173\":2,\"178\":1,\"196\":5,\"198\":1,\"215\":1,\"241\":1,\"251\":3,\"258\":1,\"312\":1,\"313\":2,\"314\":1,\"321\":1,\"340\":2,\"372\":1,\"504\":1,\"884\":1,\"885\":1}}],[\"~a\",{\"1\":{\"19\":1,\"20\":1,\"21\":1,\"103\":1,\"126\":2,\"140\":1,\"151\":1,\"172\":1,\"209\":3,\"216\":2,\"236\":1,\"237\":1,\"239\":1,\"246\":1,\"258\":1,\"291\":1,\"320\":2,\"351\":2}}],[\"~pos\",{\"1\":{\"13\":1}}],[\"z+\",{\"1\":{\"507\":1}}],[\"z++\",{\"1\":{\"196\":2,\"425\":1}}],[\"z<10\",{\"1\":{\"507\":1}}],[\"z=y\",{\"1\":{\"509\":1}}],[\"z=a+b\",{\"1\":{\"507\":1}}],[\"z==0\",{\"1\":{\"483\":1}}],[\"z>0\",{\"1\":{\"483\":1}}],[\"zhouqi\",{\"1\":{\"633\":2}}],[\"zhouqi=tim\",{\"1\":{\"633\":1}}],[\"zhi\",{\"1\":{\"431\":2}}],[\"zhuan\",{\"1\":{\"299\":5}}],[\"zjoi2010\",{\"0\":{\"270\":1}}],[\"zz\",{\"1\":{\"196\":17}}],[\"zero++\",{\"1\":{\"907\":2}}],[\"zero=0\",{\"1\":{\"907\":1}}],[\"zero==false\",{\"1\":{\"483\":1}}],[\"zerob\",{\"1\":{\"158\":2}}],[\"zero\",{\"1\":{\"40\":1,\"270\":9,\"366\":6,\"378\":5,\"483\":4,\"487\":3,\"907\":2}}],[\"z\",{\"1\":{\"19\":9,\"20\":9,\"21\":17,\"94\":2,\"188\":6,\"196\":22,\"216\":6,\"237\":6,\"239\":6,\"246\":1,\"289\":16,\"291\":1,\"292\":5,\"299\":3,\"312\":4,\"313\":8,\"314\":4,\"425\":4,\"483\":4,\"509\":4,\"513\":12,\"546\":1,\"576\":1,\"653\":4,\"656\":16,\"692\":1,\"734\":5,\"777\":3,\"796\":2,\"836\":4}}],[\"zip\",{\"1\":{\"3\":3}}],[\"这么多分钟\",{\"1\":{\"822\":1}}],[\"这么多种方案\",{\"1\":{\"335\":1}}],[\"这场为了和\",{\"1\":{\"761\":1}}],[\"这场其实难度很低\",{\"1\":{\"454\":1}}],[\"这在极端情况下会出现错误\",{\"1\":{\"759\":1}}],[\"这种情况说明仅仅提交了当前这次\",{\"1\":{\"503\":1}}],[\"这种方式并不是我们直观中的四舍五入\",{\"1\":{\"91\":1}}],[\"这边给一个类似于\",{\"1\":{\"487\":1}}],[\"这块没有绑定子任务依赖\",{\"1\":{\"458\":1}}],[\"这实际上就是一个简陋的汇编语言了\",{\"1\":{\"453\":1}}],[\"这条路径上的点\",{\"1\":{\"414\":1}}],[\"这就很好做了\",{\"1\":{\"499\":1}}],[\"这就变成了子任务\",{\"1\":{\"448\":1}}],[\"这就是题解部分说的先剔除因子\",{\"1\":{\"907\":1}}],[\"这就是\",{\"1\":{\"413\":1}}],[\"这就有了\",{\"1\":{\"329\":1}}],[\"这道题就这么做完了\",{\"1\":{\"405\":1}}],[\"这道题我觉得最好的是我这个配图用\",{\"1\":{\"401\":1}}],[\"这样所有相同颜色的帽子就排到一起了\",{\"1\":{\"897\":1}}],[\"这样最后输出某个排名区间的队伍会方便一点\",{\"1\":{\"871\":1}}],[\"这样最多\",{\"1\":{\"655\":1}}],[\"这样能把数据缩小到\",{\"1\":{\"838\":1}}],[\"这样在同一天内就可以直接减去\",{\"1\":{\"822\":1}}],[\"这样在预处理完后就可以\",{\"1\":{\"658\":1}}],[\"这样就能\",{\"1\":{\"904\":1}}],[\"这样就能保证检查到的全都是质因子\",{\"1\":{\"792\":1}}],[\"这样就只需要枚举前面的几个\",{\"1\":{\"904\":1}}],[\"这样就变成了和前一个相等\",{\"1\":{\"441\":1}}],[\"这样排布就可以让\",{\"1\":{\"779\":1}}],[\"这样是一个简化的\",{\"1\":{\"772\":1}}],[\"这样情况就简单了非常多\",{\"1\":{\"704\":1}}],[\"这样代码就大错特错了\",{\"1\":{\"526\":1}}],[\"这样这题就转换成了灵感来源那道题了\",{\"1\":{\"494\":1}}],[\"这样\",{\"1\":{\"490\":1,\"658\":1}}],[\"这样一共需要\",{\"1\":{\"447\":1}}],[\"这样安排是为了在考前提醒大家不要被前面题目卡到\",{\"1\":{\"438\":1}}],[\"这样问题就转换成了\",{\"1\":{\"437\":1}}],[\"这样或者\",{\"1\":{\"404\":1}}],[\"这样的模式\",{\"1\":{\"904\":1}}],[\"这样的时间复杂度为\",{\"1\":{\"815\":1}}],[\"这样的两个对子的数据点挂掉\",{\"1\":{\"460\":1}}],[\"这样的格式\",{\"1\":{\"397\":1}}],[\"这样的中间留一个位置的\",{\"1\":{\"351\":1}}],[\"这样每个位置最多只被看一次\",{\"1\":{\"226\":1}}],[\"这题保证了分配时数据保证不会有重合\",{\"1\":{\"900\":1}}],[\"这题主要目的就是给大家强化从\",{\"1\":{\"835\":1}}],[\"这题主要卡了一个没学好\",{\"1\":{\"759\":1}}],[\"这题没要求恰好\",{\"1\":{\"769\":1}}],[\"这题可以进一步扩展数据范围\",{\"1\":{\"658\":1}}],[\"这题是不会超源文件长度限制的\",{\"1\":{\"617\":1}}],[\"这题是在原题的基础上做了一点点小加强\",{\"1\":{\"437\":1}}],[\"这题我有一点点锅\",{\"1\":{\"492\":1}}],[\"这题我给的数据范围的编码直接用一个\",{\"1\":{\"406\":1}}],[\"这题其实是作为教学题出的\",{\"1\":{\"484\":1}}],[\"这题最高\",{\"1\":{\"485\":1}}],[\"这题最后\",{\"1\":{\"478\":1}}],[\"这题最大的难点在于题意容易理解错误\",{\"1\":{\"351\":1}}],[\"这题似乎有同学因为使用了\",{\"1\":{\"477\":1}}],[\"这题的精度直接用\",{\"1\":{\"746\":1}}],[\"这题的\",{\"1\":{\"537\":1}}],[\"这题的原题是我收藏已久的\",{\"1\":{\"472\":1}}],[\"这题的数不会变为\",{\"1\":{\"292\":1}}],[\"这题给的数据范围直接暴力找就好\",{\"1\":{\"428\":1}}],[\"这题数据范围小\",{\"1\":{\"410\":1}}],[\"这题数据范围小也可以直接纯暴力找俩权值小的节点建树就好了\",{\"1\":{\"406\":1}}],[\"这题\",{\"1\":{\"347\":1,\"766\":1}}],[\"这题读题容易读错导致觉得是很难的题\",{\"1\":{\"325\":1}}],[\"这每个体积都是能达成的最小体积\",{\"1\":{\"280\":1}}],[\"这一部分也可以直接生成\",{\"1\":{\"458\":1}}],[\"这一本书\",{\"1\":{\"219\":2}}],[\"这一轮才能接到\",{\"1\":{\"196\":1}}],[\"这辆车会被检测超速\",{\"1\":{\"198\":1}}],[\"这次开始的数字是\",{\"1\":{\"196\":1}}],[\"这个数据范围就是一个简单的模拟题\",{\"1\":{\"785\":1}}],[\"这个数必然可以被拆分成\",{\"1\":{\"620\":1}}],[\"这个次数如果不想推可以给一个不超时的大数就好\",{\"1\":{\"772\":1}}],[\"这个做法时间复杂度不太好算\",{\"1\":{\"802\":1}}],[\"这个做法我们一般叫\",{\"1\":{\"735\":1}}],[\"这个做法可以做更大数据范围\",{\"1\":{\"668\":1}}],[\"这个方式在字符串哈希算法的求子串哈希值时也会用到\",{\"1\":{\"658\":1}}],[\"这个时候\",{\"1\":{\"632\":1}}],[\"这个时候可以随便输出一种答案\",{\"1\":{\"563\":1}}],[\"这个月的天数\",{\"1\":{\"572\":1}}],[\"这个子任务最大的作用是隐含的\",{\"1\":{\"891\":1}}],[\"这个子任务保证了没有\",{\"1\":{\"856\":1}}],[\"这个子任务保证了互不为前缀\",{\"1\":{\"409\":1}}],[\"这个子串中存在子序列\",{\"1\":{\"504\":1}}],[\"这个检查也是个经典的套路\",{\"1\":{\"500\":1}}],[\"这个限制\",{\"1\":{\"480\":1}}],[\"这个浮点数会量化编码为\",{\"1\":{\"458\":1}}],[\"这个二分保证答案在区间中\",{\"1\":{\"447\":1}}],[\"这个就可以容斥处理了\",{\"1\":{\"437\":1}}],[\"这个过程其实比较容易想到就是辗转相减法\",{\"1\":{\"435\":1}}],[\"这个过程显然可以用深搜或者广搜跑完\",{\"1\":{\"400\":1}}],[\"这个点\",{\"1\":{\"427\":1}}],[\"这个点现在没有被摧毁\",{\"1\":{\"215\":1}}],[\"这个应该都很好推\",{\"1\":{\"413\":1}}],[\"这个位置且能继续往右\",{\"1\":{\"404\":1}}],[\"这个人考多少分就收多少报名费就好\",{\"1\":{\"894\":1}}],[\"这个人达成的\",{\"1\":{\"196\":1}}],[\"这个人可以把\",{\"1\":{\"196\":2}}],[\"这个人能达成\",{\"1\":{\"196\":2}}],[\"这个人接的龙\",{\"1\":{\"196\":1}}],[\"这个代码把你要测试的排列输进去\",{\"1\":{\"174\":1}}],[\"这个前缀会把紧跟着的数变为\",{\"1\":{\"101\":1}}],[\"这些公倍数都被多加了两次\",{\"1\":{\"437\":1}}],[\"这些公倍数都是\",{\"1\":{\"437\":1}}],[\"这些折返点\",{\"1\":{\"404\":1}}],[\"这些数据\",{\"1\":{\"402\":1}}],[\"这些数都加\",{\"1\":{\"19\":1,\"20\":1,\"21\":1}}],[\"这些除以\",{\"1\":{\"397\":1}}],[\"这些人匹配的方案数\",{\"1\":{\"374\":1}}],[\"这些最小体积中的最小值肯定就是最优的了\",{\"1\":{\"280\":1}}],[\"这些物品\",{\"1\":{\"280\":1}}],[\"这些位置都安置好了\",{\"1\":{\"109\":1,\"110\":1}}],[\"这里不能再开计数数组了\",{\"1\":{\"897\":1}}],[\"这里就不展开推了\",{\"1\":{\"802\":1}}],[\"这里提供高精度的做法\",{\"1\":{\"746\":1}}],[\"这里重复计算了既是\",{\"1\":{\"661\":1}}],[\"这里给出张昊宇同学的四维数组标记的做法\",{\"1\":{\"816\":1}}],[\"这里给出两种方法\",{\"1\":{\"574\":1}}],[\"这里给个满分代码\",{\"1\":{\"417\":1}}],[\"这里为了避免使用循环后面的知识点\",{\"1\":{\"571\":1}}],[\"这里可以直接用\",{\"1\":{\"546\":1}}],[\"这里我没有偷懒使用\",{\"1\":{\"874\":1}}],[\"这里我没有用\",{\"1\":{\"726\":1}}],[\"这里我们设为\",{\"1\":{\"574\":1}}],[\"这里我们只讨论\",{\"1\":{\"100\":1}}],[\"这里我采用了更暴力的直接把每个字符和对应的次数构建了一个结构体\",{\"1\":{\"518\":1}}],[\"这里细节比较多\",{\"1\":{\"515\":1}}],[\"这里把几种写法都给大家看看\",{\"1\":{\"346\":1}}],[\"这里数据范围也很友好\",{\"1\":{\"346\":1}}],[\"这里\",{\"1\":{\"117\":1}}],[\"这里会放比赛题解以及题目题解\",{\"1\":{\"1\":1}}],[\"这段程序会输出什么\",{\"0\":{\"50\":1}}],[\"右斜\",{\"1\":{\"505\":1}}],[\"右下斜着3\",{\"1\":{\"875\":1}}],[\"右下\",{\"1\":{\"505\":2,\"675\":1}}],[\"右\",{\"1\":{\"505\":2}}],[\"右上\",{\"1\":{\"505\":2,\"675\":1}}],[\"右面都没走过\",{\"1\":{\"405\":1}}],[\"右边先走的最小得分\",{\"1\":{\"495\":1}}],[\"右边先走的最小的分加\",{\"1\":{\"495\":2}}],[\"右边只有次大值\",{\"1\":{\"447\":1}}],[\"右边除了次大值还有其他的\",{\"1\":{\"447\":1}}],[\"右边都没走过\",{\"1\":{\"405\":1}}],[\"右边线\",{\"1\":{\"313\":1,\"314\":1}}],[\"右边按键\",{\"1\":{\"158\":1}}],[\"右子节点\",{\"1\":{\"237\":2,\"239\":2}}],[\"右子树\",{\"1\":{\"19\":3,\"20\":2,\"21\":4,\"406\":1}}],[\"右半边有重叠\",{\"1\":{\"18\":1}}],[\"区间开方和\",{\"0\":{\"478\":1}}],[\"区间次大值位置\",{\"1\":{\"447\":1}}],[\"区间最值查询\",{\"1\":{\"216\":1}}],[\"区间赋值\",{\"1\":{\"216\":1}}],[\"区间乘\",{\"0\":{\"21\":1}}],[\"区间加一\",{\"1\":{\"350\":1}}],[\"区间加\",{\"0\":{\"21\":1}}],[\"区间和查询\",{\"0\":{\"21\":1}}],[\"区间和\",{\"1\":{\"19\":1,\"21\":1}}],[\"区间修改\",{\"0\":{\"19\":1},\"1\":{\"313\":1,\"314\":1}}],[\"区间查询\",{\"0\":{\"17\":1,\"19\":1},\"1\":{\"19\":1,\"21\":1,\"22\":1}}],[\"是数列的第几项\",{\"1\":{\"904\":1}}],[\"是奇数\",{\"1\":{\"850\":1}}],[\"是黄灯\",{\"1\":{\"835\":1}}],[\"是红灯\",{\"1\":{\"835\":1}}],[\"是超过了\",{\"1\":{\"825\":1}}],[\"是质数就停\",{\"1\":{\"735\":1}}],[\"是不会影响正常的整数输入的\",{\"1\":{\"671\":1}}],[\"是不会影响这一轮结果的\",{\"1\":{\"632\":1}}],[\"是不是最小值即可\",{\"1\":{\"525\":1}}],[\"是不是\",{\"1\":{\"414\":1}}],[\"是偶数位的\",{\"1\":{\"591\":1}}],[\"是偶数就不用变\",{\"1\":{\"553\":1}}],[\"是每一根发光二极管都亮着\",{\"1\":{\"578\":1}}],[\"是一个四位数\",{\"1\":{\"853\":1}}],[\"是一个一位数\",{\"1\":{\"853\":1}}],[\"是一个周期\",{\"1\":{\"838\":1}}],[\"是一个定值的话\",{\"1\":{\"658\":1}}],[\"是一个提示性的子任务\",{\"1\":{\"578\":1}}],[\"是一个经典的数数题\",{\"1\":{\"328\":1}}],[\"是检查\",{\"1\":{\"500\":1}}],[\"是贝塞尔函数的解\",{\"1\":{\"477\":1}}],[\"是有可能超过\",{\"1\":{\"451\":1,\"891\":1}}],[\"是没区别的\",{\"1\":{\"419\":1}}],[\"是最优方案\",{\"1\":{\"413\":1}}],[\"是最终这些数希望达成的顺序\",{\"1\":{\"173\":1}}],[\"是大于\",{\"1\":{\"413\":2}}],[\"是能拿到\",{\"1\":{\"402\":1}}],[\"是第一个大于\",{\"1\":{\"298\":2}}],[\"是离散化后的i在离散化之前的数\",{\"1\":{\"213\":1,\"214\":1}}],[\"是否大于等于\",{\"1\":{\"881\":1}}],[\"是否大于等于全国基准线\",{\"1\":{\"750\":1}}],[\"是否打星\",{\"1\":{\"872\":1}}],[\"是否可能是\",{\"1\":{\"579\":1}}],[\"是否相等\",{\"1\":{\"622\":1}}],[\"是否相等即可\",{\"1\":{\"565\":1}}],[\"是否相连\",{\"1\":{\"428\":1}}],[\"是否等于\",{\"1\":{\"525\":1}}],[\"是否等差\",{\"1\":{\"301\":1}}],[\"是否为前缀\",{\"1\":{\"410\":1}}],[\"是否往左一段\",{\"0\":{\"404\":1}}],[\"是否存在第\",{\"1\":{\"374\":1}}],[\"是否还需要开方\",{\"1\":{\"291\":1}}],[\"是否搞定了\",{\"1\":{\"276\":1}}],[\"是否顶到了上限\",{\"1\":{\"270\":1}}],[\"是否所有骑士都能到\",{\"1\":{\"259\":1}}],[\"是否能完成\",{\"1\":{\"196\":1}}],[\"是否出现过\",{\"1\":{\"182\":4}}],[\"是否要整体取反\",{\"1\":{\"158\":2}}],[\"是否和左\",{\"1\":{\"18\":1}}],[\"是\",{\"1\":{\"19\":1,\"20\":1,\"21\":1,\"170\":1,\"415\":1,\"478\":1,\"494\":1,\"595\":1,\"622\":3,\"661\":1,\"668\":1}}],[\"是根节点\",{\"1\":{\"10\":1}}],[\"yacs\",{\"0\":{\"913\":1}}],[\"you\",{\"1\":{\"741\":1}}],[\"y4\",{\"1\":{\"477\":3}}],[\"y3\",{\"1\":{\"477\":3}}],[\"ynyyyyy\",{\"1\":{\"579\":1}}],[\"ynyynyy\",{\"1\":{\"579\":1}}],[\"yn\",{\"1\":{\"477\":1}}],[\"y0\",{\"1\":{\"477\":1}}],[\"y+n\",{\"1\":{\"739\":1}}],[\"y+a\",{\"1\":{\"443\":1}}],[\"y++\",{\"1\":{\"166\":1,\"196\":2,\"259\":1,\"317\":1,\"388\":1,\"425\":1,\"444\":2,\"701\":1}}],[\"yx\",{\"1\":{\"438\":3}}],[\"yuan\",{\"1\":{\"427\":2}}],[\"yu\",{\"1\":{\"415\":8}}],[\"yi\",{\"1\":{\"342\":3,\"490\":2}}],[\"yellow\",{\"1\":{\"836\":2}}],[\"year\",{\"0\":{\"333\":1}}],[\"yes\",{\"1\":{\"76\":1,\"131\":1,\"132\":1,\"168\":1,\"287\":1,\"289\":2,\"323\":1,\"326\":1,\"342\":1,\"345\":1,\"409\":1,\"410\":2,\"451\":1,\"525\":1,\"526\":1,\"546\":1,\"557\":1,\"562\":1,\"565\":1,\"568\":1,\"569\":1,\"574\":1,\"575\":3,\"576\":2,\"589\":1,\"674\":1,\"675\":1,\"734\":2,\"773\":1,\"801\":1}}],[\"ytot\",{\"1\":{\"298\":5}}],[\"yr\",{\"1\":{\"259\":2}}],[\"yl\",{\"1\":{\"259\":2}}],[\"yscore++\",{\"1\":{\"227\":1}}],[\"yscore\",{\"1\":{\"227\":2}}],[\"y2\",{\"1\":{\"181\":2,\"477\":3}}],[\"y1\",{\"1\":{\"181\":2,\"477\":5}}],[\"y1+y2+y3\",{\"1\":{\"181\":2}}],[\"yyynnnn\",{\"1\":{\"579\":1}}],[\"yyyynyy\",{\"1\":{\"579\":1}}],[\"yyyynny\",{\"1\":{\"579\":1}}],[\"yyyyyyy\",{\"1\":{\"579\":1}}],[\"yyyyyyn\",{\"1\":{\"579\":1}}],[\"yynyyny\",{\"1\":{\"579\":1}}],[\"yy++\",{\"1\":{\"527\":1,\"572\":1,\"767\":1}}],[\"yy\",{\"1\":{\"139\":5,\"140\":5,\"175\":3,\"194\":5,\"196\":13,\"227\":2,\"242\":12,\"256\":4,\"312\":10,\"313\":17,\"314\":7,\"331\":6,\"421\":6,\"422\":6,\"423\":6,\"443\":25,\"505\":4,\"527\":6,\"572\":7,\"767\":5}}],[\"y\",{\"1\":{\"17\":14,\"18\":6,\"19\":18,\"20\":19,\"21\":25,\"23\":9,\"98\":6,\"111\":3,\"139\":2,\"140\":2,\"150\":2,\"151\":4,\"154\":8,\"158\":12,\"163\":2,\"164\":2,\"166\":4,\"167\":2,\"169\":6,\"170\":10,\"172\":4,\"173\":6,\"174\":5,\"175\":7,\"182\":32,\"191\":3,\"194\":7,\"196\":9,\"200\":10,\"216\":14,\"227\":3,\"231\":20,\"236\":2,\"237\":12,\"239\":12,\"241\":14,\"242\":11,\"244\":6,\"253\":7,\"255\":11,\"256\":9,\"258\":2,\"259\":18,\"272\":10,\"287\":3,\"289\":20,\"291\":19,\"292\":18,\"298\":21,\"299\":11,\"305\":7,\"306\":9,\"312\":15,\"313\":29,\"314\":14,\"317\":14,\"319\":9,\"325\":2,\"331\":10,\"336\":3,\"376\":2,\"388\":3,\"389\":5,\"395\":2,\"410\":3,\"419\":3,\"421\":5,\"422\":5,\"423\":5,\"425\":4,\"426\":12,\"435\":9,\"438\":11,\"443\":19,\"444\":13,\"477\":3,\"483\":2,\"502\":4,\"505\":4,\"507\":1,\"509\":2,\"513\":14,\"516\":5,\"524\":3,\"525\":4,\"527\":4,\"544\":4,\"578\":4,\"579\":1,\"653\":4,\"656\":16,\"679\":3,\"688\":3,\"695\":4,\"701\":3,\"708\":7,\"734\":4,\"739\":1,\"767\":5,\"777\":4,\"790\":4,\"836\":6,\"872\":14,\"875\":25,\"879\":5,\"911\":1}}],[\"树上开花\",{\"0\":{\"435\":1}}],[\"树状数组写法\",{\"0\":{\"236\":1,\"238\":1}}],[\"树状数组中就是从最后位置m倒序的第len个\",{\"1\":{\"216\":1}}],[\"树状数组求中位数\",{\"1\":{\"213\":1,\"214\":1}}],[\"树状数组\",{\"1\":{\"17\":1,\"236\":1,\"258\":1,\"266\":1}}],[\"树链剖分\",{\"0\":{\"15\":1}}],[\"线段树写法\",{\"0\":{\"237\":1,\"239\":1}}],[\"线段树\",{\"0\":{\"16\":1},\"1\":{\"19\":2,\"20\":1,\"21\":1,\"237\":1,\"239\":1,\"312\":1,\"313\":1}}],[\"序列染色\",{\"0\":{\"155\":1}}],[\"序\",{\"1\":{\"15\":1}}],[\"重复两次\",{\"1\":{\"822\":1}}],[\"重点是判断第三行的每个字符串是否在第二行出现过\",{\"1\":{\"815\":1}}],[\"重新计算当前的\",{\"1\":{\"312\":1,\"313\":1}}],[\"重量限制下的最大价值\",{\"1\":{\"359\":1}}],[\"重量下的最大价值\",{\"1\":{\"293\":1}}],[\"重量\",{\"1\":{\"293\":1,\"358\":1,\"362\":1}}],[\"重边优先的\",{\"1\":{\"15\":1}}],[\"重子节点\",{\"1\":{\"15\":1}}],[\"所属轮数\",{\"1\":{\"627\":1}}],[\"所有颜色的帽子数整除以\",{\"1\":{\"897\":1}}],[\"所有数进行与运算的结果\",{\"1\":{\"866\":1}}],[\"所有数字的次数和即为答案\",{\"1\":{\"742\":1}}],[\"所有数都相等\",{\"1\":{\"720\":1}}],[\"所有数都是\",{\"1\":{\"661\":1}}],[\"所有的枚举优化第一个要找的突破口就是限制条件\",{\"1\":{\"484\":1}}],[\"所有相等的只要减一次即可\",{\"1\":{\"441\":1}}],[\"所有小于\",{\"1\":{\"335\":1}}],[\"所有只有\",{\"1\":{\"302\":1}}],[\"所有产生的数丢进\",{\"1\":{\"298\":1}}],[\"所有骑士到汇合点的路程\",{\"1\":{\"259\":1}}],[\"所有人和王自己去\",{\"1\":{\"259\":1}}],[\"所有衣服需要的烘干机时间\",{\"1\":{\"250\":2}}],[\"所有超速区间\",{\"1\":{\"198\":1}}],[\"所有为\",{\"1\":{\"182\":2}}],[\"所有\",{\"1\":{\"170\":1,\"182\":3,\"500\":1}}],[\"所有其中不能翻转的贡献之和\",{\"1\":{\"151\":1}}],[\"所在的位置是\",{\"1\":{\"164\":1}}],[\"所在链的链顶\",{\"1\":{\"15\":1}}],[\"所以余数最大范围是\",{\"1\":{\"904\":1}}],[\"所以必然是第\",{\"1\":{\"881\":1}}],[\"所以第一座桥的耐久度是最低的\",{\"1\":{\"863\":1}}],[\"所以第二题给了个相对简单的题目\",{\"1\":{\"553\":1}}],[\"所以至少要输出\",{\"1\":{\"863\":1}}],[\"所以炸掉谁都一样\",{\"1\":{\"863\":1}}],[\"所以需要用\",{\"1\":{\"891\":1}}],[\"所以需要用字符串存储\",{\"1\":{\"856\":1}}],[\"所以需要满足\",{\"1\":{\"497\":1}}],[\"所以每个版本的两个数都一样\",{\"1\":{\"846\":1}}],[\"所以倒也无所谓了\",{\"1\":{\"842\":1}}],[\"所以建议如果要减\",{\"1\":{\"842\":1}}],[\"所以当字符串为空\",{\"1\":{\"842\":1}}],[\"所以当你求\",{\"1\":{\"495\":1}}],[\"所以在完成了基础的暴力枚举标记所有有数的位置后\",{\"1\":{\"831\":1}}],[\"所以答案从三个变成两个了\",{\"1\":{\"891\":1}}],[\"所以答案就是\",{\"1\":{\"828\":1}}],[\"所以答案只有\",{\"1\":{\"461\":1}}],[\"所以整个内层循环可以优化成一句\",{\"1\":{\"812\":1}}],[\"所以红包都用不了\",{\"1\":{\"809\":1}}],[\"所以就是个一维数组的模拟了\",{\"1\":{\"846\":1}}],[\"所以就改成直接放到末尾了\",{\"1\":{\"806\":1}}],[\"所以就按照子任务\",{\"1\":{\"665\":1}}],[\"所以时间复杂度显然小于\",{\"1\":{\"802\":1}}],[\"所以出一下\",{\"1\":{\"792\":1}}],[\"所以非常简单\",{\"1\":{\"769\":1}}],[\"所以计算年星日的时候一定要注意这个满星\",{\"1\":{\"740\":1}}],[\"所以计算结果会在\",{\"1\":{\"507\":1}}],[\"所以一共可以盈利\",{\"1\":{\"739\":1}}],[\"所以一定是没办法满足从大到小的\",{\"1\":{\"562\":2}}],[\"所以此时保证了每个整数时间\",{\"1\":{\"668\":1}}],[\"所以课间休息时间应该是\",{\"1\":{\"665\":1}}],[\"所以根据轮数\",{\"1\":{\"626\":1}}],[\"所以我们只需要从小到大枚举\",{\"1\":{\"621\":1}}],[\"所以我是\",{\"1\":{\"405\":1}}],[\"所以显然不能真的把地图二维数组真的开出来\",{\"1\":{\"766\":1}}],[\"所以显然不会有无解情况\",{\"1\":{\"578\":1}}],[\"所以显然\",{\"1\":{\"668\":1}}],[\"所以显然可以考虑从小到大考虑每个位置作为左端点时需要做到多少\",{\"1\":{\"556\":1}}],[\"所以很输出\",{\"1\":{\"574\":1}}],[\"所以既然排序了肯定是要把自己要的东西\",{\"1\":{\"574\":1}}],[\"所以变成了一个简单的条件判断的题目\",{\"1\":{\"553\":1}}],[\"所以如果错了需要再次提交\",{\"1\":{\"550\":1}}],[\"所以如果能达成\",{\"1\":{\"493\":1}}],[\"所以输出\",{\"1\":{\"545\":1}}],[\"所以四个方向上都要进行判断\",{\"1\":{\"509\":1}}],[\"所以较短的那条边必然小于\",{\"1\":{\"470\":1}}],[\"所以没有注意到这个的应该也只会丢\",{\"1\":{\"458\":1}}],[\"所以完全不用什么\",{\"1\":{\"456\":1}}],[\"所以要么不额外开销\",{\"1\":{\"524\":1}}],[\"所以要用\",{\"1\":{\"451\":1}}],[\"所以要统计前面\",{\"1\":{\"328\":1}}],[\"所以两次询问就可以把区间二分了\",{\"1\":{\"447\":1}}],[\"所以三连的不管\",{\"1\":{\"441\":1}}],[\"所以去掉两倍的即可\",{\"1\":{\"437\":1}}],[\"所以给一个合法方案就好\",{\"1\":{\"426\":1}}],[\"所以这个过程最多执行两次就可以\",{\"1\":{\"822\":1}}],[\"所以这里给的也是不用数组记录的方式\",{\"1\":{\"720\":1}}],[\"所以这里就需要把哈夫曼编码给先求出来\",{\"1\":{\"409\":1}}],[\"所以这样显然不好做\",{\"1\":{\"499\":1}}],[\"所以这题给的是染色做法的标程\",{\"1\":{\"419\":1}}],[\"所以路径是唯一的\",{\"1\":{\"414\":1}}],[\"所以用自己的编码算一个文章长度\",{\"1\":{\"409\":1}}],[\"所以从\",{\"1\":{\"404\":1}}],[\"所以只有一个单词\",{\"1\":{\"828\":1}}],[\"所以只有三种情况\",{\"1\":{\"403\":1}}],[\"所以只需要计算\",{\"1\":{\"856\":1}}],[\"所以只需要判断能不能使用任何一个红包就好\",{\"1\":{\"809\":1}}],[\"所以只需要统计英文字母和数字即可\",{\"1\":{\"518\":1}}],[\"所以只需要统计前缀\",{\"1\":{\"329\":1}}],[\"所以只要判断输入的\",{\"1\":{\"565\":1}}],[\"所以只要文章长度对了就行\",{\"1\":{\"409\":1}}],[\"所以只给有猫的那些行列放稻草人即可\",{\"1\":{\"426\":1}}],[\"所以可以保证系统词只是位置不对\",{\"1\":{\"741\":1}}],[\"所以可以过滤掉有相同的情况\",{\"1\":{\"655\":1}}],[\"所以可以长度为\",{\"1\":{\"547\":1}}],[\"所以可以从根节点开始\",{\"1\":{\"494\":1}}],[\"所以可以直接处理个前缀和\",{\"1\":{\"474\":1}}],[\"所以可以直接二分\",{\"1\":{\"446\":1}}],[\"所以可以把\",{\"1\":{\"451\":1,\"904\":1}}],[\"所以可以生成中序遍历后拿最远的\",{\"1\":{\"427\":1}}],[\"所以可以先把样例给的五个点打表\",{\"1\":{\"617\":1}}],[\"所以可以先把人调整到左边\",{\"1\":{\"403\":1}}],[\"所以可以先算出一共多少天\",{\"1\":{\"515\":1}}],[\"所以可以先打个质数表\",{\"1\":{\"462\":1}}],[\"所以可以先学学咋求哈夫曼编码\",{\"1\":{\"406\":1}}],[\"所以可以根据是否还有\",{\"1\":{\"397\":1}}],[\"所以子任务\",{\"1\":{\"402\":1,\"518\":1}}],[\"所以直接输入前两个数\",{\"1\":{\"818\":1}}],[\"所以直接输出所有\",{\"1\":{\"825\":1}}],[\"所以直接输出\",{\"1\":{\"507\":1,\"822\":2,\"825\":1}}],[\"所以直接判断\",{\"1\":{\"815\":1}}],[\"所以直接算出一共往后面放了\",{\"1\":{\"806\":1}}],[\"所以直接模拟走\",{\"1\":{\"766\":1}}],[\"所以直接用\",{\"1\":{\"568\":1}}],[\"所以直接根据\",{\"1\":{\"541\":1}}],[\"所以直接比较\",{\"1\":{\"525\":1}}],[\"所以直接计算\",{\"1\":{\"524\":1,\"544\":1}}],[\"所以直接枚举就好了\",{\"1\":{\"470\":1}}],[\"所以直接暴力递归算就好了\",{\"1\":{\"466\":1}}],[\"所以直接\",{\"1\":{\"402\":1,\"818\":1}}],[\"所以直接贪心充的快的充容量大的就好了\",{\"1\":{\"325\":1}}],[\"所以外面枚举\",{\"1\":{\"399\":1}}],[\"所以\",{\"1\":{\"397\":1,\"413\":1,\"415\":1,\"480\":1,\"544\":1,\"620\":1,\"838\":1,\"900\":1}}],[\"所以会有一个简单的做法\",{\"1\":{\"328\":1}}],[\"所以所有比较函数写\",{\"1\":{\"759\":1}}],[\"所以所有\",{\"1\":{\"326\":1}}],[\"所以仔细读题后会注意到只能配对一次\",{\"1\":{\"325\":1}}],[\"所以不需要实时算出这一项\",{\"1\":{\"838\":1}}],[\"所以不需要开方的条件就是区间和等于区间长度\",{\"1\":{\"292\":1}}],[\"所以不能直接来并查集\",{\"1\":{\"772\":1}}],[\"所以不能存下来每个随机数\",{\"1\":{\"457\":1}}],[\"所以不做买卖\",{\"1\":{\"739\":1}}],[\"所以不写那个小括号也可以\",{\"1\":{\"98\":1}}],[\"所以加减乘除都能直接高精对低精运算\",{\"1\":{\"3\":1}}],[\"hld\",{\"1\":{\"732\":2}}],[\"hh\",{\"1\":{\"527\":4,\"666\":4}}],[\"hh的项链\",{\"0\":{\"266\":1}}],[\"hour++\",{\"1\":{\"516\":1}}],[\"hour\",{\"1\":{\"516\":10}}],[\"hong\",{\"1\":{\"453\":2}}],[\"h=x\",{\"1\":{\"509\":1}}],[\"hun\",{\"1\":{\"421\":2,\"422\":2,\"423\":2}}],[\"huffman\",{\"1\":{\"410\":4}}],[\"https\",{\"1\":{\"419\":1,\"420\":1,\"437\":1,\"445\":1,\"489\":1,\"494\":1,\"726\":1}}],[\"hierarchical\",{\"0\":{\"343\":1}}],[\"h+0\",{\"1\":{\"338\":1}}],[\"hnoi2006\",{\"0\":{\"267\":1}}],[\"hnoi2004\",{\"0\":{\"232\":1}}],[\"helper\",{\"1\":{\"902\":1}}],[\"hello\",{\"1\":{\"46\":1,\"47\":1,\"48\":2,\"50\":3,\"52\":3,\"53\":3,\"54\":2}}],[\"health\",{\"1\":{\"473\":4,\"475\":3}}],[\"head\",{\"1\":{\"321\":12,\"391\":6}}],[\"height\",{\"1\":{\"167\":4}}],[\"half++\",{\"1\":{\"885\":1}}],[\"half\",{\"1\":{\"885\":4}}],[\"half1000\",{\"1\":{\"484\":2}}],[\"have\",{\"1\":{\"519\":2}}],[\"happy==0\",{\"1\":{\"545\":1}}],[\"happy==1\",{\"1\":{\"545\":1}}],[\"happy=0\",{\"1\":{\"545\":1}}],[\"happy=1\",{\"1\":{\"545\":2}}],[\"happy\",{\"0\":{\"333\":1},\"1\":{\"545\":1}}],[\"hack数据\",{\"1\":{\"161\":1}}],[\"hash\",{\"1\":{\"142\":3}}],[\"hsh\",{\"1\":{\"142\":12,\"190\":8}}],[\"hson\",{\"1\":{\"15\":9}}],[\"h\",{\"0\":{\"367\":1},\"1\":{\"47\":1,\"202\":9,\"203\":18,\"204\":3,\"289\":6,\"325\":3,\"336\":4,\"338\":6,\"354\":6,\"355\":4,\"376\":4,\"509\":4,\"551\":1,\"764\":2,\"823\":3}}],[\"h>\",{\"1\":{\"11\":1,\"12\":1,\"13\":1,\"14\":1,\"15\":1,\"17\":1,\"19\":1,\"20\":1,\"21\":1,\"23\":1,\"27\":1,\"29\":1,\"30\":1,\"31\":1,\"32\":1,\"40\":1,\"46\":1,\"48\":1,\"49\":1,\"50\":1,\"52\":1,\"53\":1,\"54\":1,\"57\":1,\"59\":1,\"60\":1,\"61\":1,\"63\":3,\"64\":1,\"66\":1,\"70\":1,\"74\":1,\"89\":1,\"90\":1,\"109\":1,\"110\":1,\"111\":1,\"112\":1,\"113\":1,\"115\":1,\"116\":1,\"117\":1,\"118\":1,\"119\":1,\"120\":1,\"122\":1,\"123\":1,\"124\":1,\"125\":1,\"126\":1,\"127\":1,\"128\":1,\"129\":1,\"131\":1,\"132\":1,\"134\":1,\"135\":1,\"136\":1,\"137\":1,\"139\":1,\"140\":1,\"141\":1,\"142\":1,\"144\":1,\"146\":1,\"147\":1,\"148\":1,\"150\":1,\"151\":1,\"153\":1,\"154\":1,\"156\":1,\"157\":1,\"158\":1,\"160\":1,\"161\":1,\"162\":1,\"163\":1,\"164\":1,\"165\":1,\"166\":1,\"167\":1,\"168\":1,\"169\":1,\"170\":1,\"172\":1,\"173\":1,\"174\":1,\"175\":1,\"176\":1,\"177\":1,\"178\":1,\"179\":1,\"180\":1,\"181\":2,\"182\":2,\"184\":1,\"185\":1,\"186\":1,\"187\":1,\"190\":1,\"191\":1,\"192\":1,\"193\":4,\"194\":1,\"195\":2,\"196\":5,\"197\":4,\"198\":3,\"199\":4,\"200\":1,\"202\":1,\"203\":1,\"204\":1,\"205\":2,\"208\":2,\"209\":1,\"210\":1,\"211\":1,\"213\":1,\"214\":1,\"215\":1,\"216\":2,\"217\":1,\"218\":1,\"219\":2,\"221\":1,\"222\":1,\"224\":1,\"225\":1,\"226\":1,\"227\":1,\"228\":1,\"230\":1,\"231\":1,\"232\":1,\"233\":2,\"235\":1,\"236\":1,\"237\":1,\"239\":1,\"241\":1,\"242\":1,\"243\":1,\"244\":2,\"245\":1,\"246\":1,\"248\":1,\"249\":1,\"250\":2,\"251\":1,\"253\":1,\"255\":1,\"256\":1,\"257\":1,\"258\":1,\"259\":1,\"260\":1,\"262\":1,\"263\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":2,\"268\":1,\"269\":1,\"270\":1,\"272\":1,\"273\":1,\"274\":1,\"275\":2,\"276\":2,\"278\":1,\"279\":1,\"280\":1,\"282\":1,\"283\":1,\"284\":1,\"285\":1,\"286\":2,\"287\":1,\"288\":1,\"289\":2,\"291\":1,\"292\":1,\"293\":1,\"295\":1,\"298\":2,\"299\":1,\"301\":1,\"302\":1,\"303\":1,\"305\":1,\"306\":1,\"307\":2,\"309\":1,\"310\":1,\"312\":1,\"313\":2,\"314\":1,\"317\":1,\"318\":1,\"319\":1,\"320\":3,\"321\":1,\"323\":1,\"324\":1,\"325\":1,\"326\":1,\"329\":1,\"331\":1,\"333\":1,\"334\":1,\"335\":1,\"336\":1,\"338\":1,\"340\":1,\"342\":1,\"343\":1,\"345\":1,\"347\":1,\"348\":1,\"349\":1,\"350\":1,\"351\":1,\"352\":1,\"354\":1,\"355\":1,\"356\":1,\"358\":1,\"359\":1,\"361\":1,\"362\":1,\"363\":1,\"365\":1,\"366\":1,\"367\":1,\"368\":1,\"369\":1,\"370\":1,\"371\":1,\"372\":1,\"373\":1,\"374\":1,\"375\":1,\"376\":1,\"377\":1,\"378\":1,\"379\":1,\"380\":1,\"381\":1,\"383\":1,\"384\":1,\"386\":1,\"388\":1,\"389\":1,\"391\":1,\"392\":1,\"393\":1,\"394\":1,\"395\":1,\"397\":1,\"399\":1,\"400\":1,\"402\":2,\"405\":1,\"410\":1,\"412\":1,\"413\":2,\"414\":1,\"415\":4,\"417\":1,\"418\":1,\"419\":1,\"421\":1,\"422\":1,\"423\":1,\"425\":1,\"426\":1,\"427\":1,\"428\":1,\"430\":1,\"431\":1,\"432\":1,\"433\":1,\"435\":1,\"436\":2,\"437\":1,\"438\":1,\"440\":1,\"441\":1,\"443\":1,\"444\":1,\"446\":1,\"447\":1,\"448\":1,\"450\":1,\"451\":1,\"452\":1,\"453\":1,\"455\":1,\"456\":1,\"457\":1,\"458\":1,\"460\":1,\"461\":1,\"462\":1,\"464\":1,\"465\":1,\"466\":1,\"467\":1,\"469\":1,\"470\":1,\"471\":1,\"473\":1,\"475\":1,\"477\":1,\"478\":1,\"479\":1,\"480\":1,\"482\":1,\"483\":1,\"484\":2,\"485\":1,\"487\":1,\"488\":1,\"489\":1,\"490\":1,\"492\":1,\"493\":1,\"494\":1,\"495\":1,\"497\":1,\"498\":1,\"499\":1,\"500\":1,\"502\":1,\"503\":1,\"504\":1,\"505\":1,\"507\":1,\"508\":1,\"509\":2,\"513\":1,\"516\":1,\"519\":1,\"522\":1,\"524\":1,\"525\":1,\"526\":1,\"527\":1,\"531\":1,\"534\":1,\"535\":1,\"538\":1,\"539\":1,\"542\":1,\"544\":1,\"545\":1,\"546\":1,\"547\":1,\"551\":1,\"554\":1,\"557\":1,\"560\":1,\"562\":1,\"563\":1,\"564\":1,\"565\":1,\"569\":1,\"572\":1,\"575\":1,\"576\":1,\"579\":1,\"583\":1,\"586\":1,\"589\":1,\"592\":1,\"596\":1,\"599\":1,\"602\":1,\"605\":1,\"609\":1,\"612\":1,\"615\":1,\"618\":1,\"620\":1,\"621\":1,\"622\":1,\"623\":1,\"627\":1,\"630\":1,\"633\":1,\"636\":1,\"640\":1,\"643\":1,\"646\":1,\"649\":1,\"653\":1,\"656\":1,\"659\":1,\"662\":1,\"666\":1,\"669\":1,\"672\":1,\"675\":1,\"679\":1,\"682\":1,\"685\":1,\"688\":1,\"692\":1,\"695\":1,\"698\":1,\"701\":1,\"705\":1,\"708\":1,\"711\":1,\"714\":1,\"718\":1,\"721\":1,\"724\":1,\"727\":1,\"729\":1,\"730\":1,\"731\":1,\"732\":1,\"734\":1,\"735\":1,\"736\":1,\"737\":1,\"739\":1,\"741\":1,\"744\":1,\"745\":1,\"746\":1,\"747\":1,\"751\":1,\"754\":1,\"757\":1,\"760\":1,\"764\":1,\"767\":1,\"770\":1,\"773\":1,\"777\":1,\"780\":1,\"783\":1,\"786\":1,\"790\":1,\"793\":1,\"796\":1,\"799\":1,\"801\":1,\"803\":1,\"804\":1,\"805\":1,\"806\":1,\"810\":1,\"813\":1,\"816\":1,\"819\":1,\"823\":1,\"826\":1,\"829\":1,\"832\":1,\"836\":1,\"839\":1,\"844\":1,\"847\":1,\"851\":1,\"854\":1,\"857\":1,\"860\":1,\"864\":1,\"868\":1,\"869\":1,\"872\":1,\"875\":1,\"879\":1,\"882\":1,\"885\":1,\"888\":1,\"892\":1,\"895\":1,\"898\":1,\"902\":1,\"906\":1,\"907\":1,\"911\":1}}],[\"父节点方向小于它的有\",{\"1\":{\"427\":1}}],[\"父节点去掉\",{\"1\":{\"384\":1}}],[\"父节点\",{\"1\":{\"15\":1}}],[\"x<y\",{\"1\":{\"739\":1}}],[\"x==y\",{\"1\":{\"911\":1}}],[\"x==3\",{\"1\":{\"545\":1}}],[\"x==2\",{\"1\":{\"545\":1}}],[\"x==1\",{\"1\":{\"545\":2}}],[\"x==n+1\",{\"1\":{\"253\":1}}],[\"x==n\",{\"1\":{\"241\":1}}],[\"x^2\",{\"1\":{\"471\":1}}],[\"xy\",{\"1\":{\"438\":3}}],[\"x>1\",{\"1\":{\"415\":1}}],[\"xtot++\",{\"1\":{\"298\":1}}],[\"xtot\",{\"1\":{\"298\":6}}],[\"x+y==n+1\",{\"1\":{\"911\":1}}],[\"x+a\",{\"1\":{\"443\":1,\"544\":1}}],[\"x+1\",{\"1\":{\"286\":4}}],[\"x++\",{\"1\":{\"166\":1,\"188\":1,\"196\":3,\"253\":1,\"255\":1,\"256\":1,\"259\":1,\"305\":1,\"317\":3,\"388\":1,\"415\":1,\"425\":1,\"444\":2,\"469\":1,\"701\":1}}],[\"xr\",{\"1\":{\"259\":2}}],[\"xl\",{\"1\":{\"259\":2}}],[\"xlty\",{\"1\":{\"173\":2}}],[\"x及左边有多少个房子被摧毁了\",{\"1\":{\"236\":1,\"237\":1,\"239\":1}}],[\"x左边右边的第一个被摧毁的位置\",{\"1\":{\"235\":1,\"236\":1,\"237\":1,\"239\":1}}],[\"xscore++\",{\"1\":{\"227\":1}}],[\"xscore\",{\"1\":{\"227\":2}}],[\"xor\",{\"1\":{\"165\":1}}],[\"x0\",{\"1\":{\"164\":4}}],[\"xiao\",{\"1\":{\"498\":2}}],[\"xi\",{\"0\":{\"141\":1,\"142\":1},\"1\":{\"342\":3,\"391\":13,\"393\":5,\"452\":2}}],[\"xx++\",{\"1\":{\"767\":1}}],[\"xxxxxxx\",{\"1\":{\"497\":2}}],[\"xxxxxxjxx\",{\"1\":{\"306\":1}}],[\"xxxx\",{\"1\":{\"465\":1}}],[\"xxxxixxxx\",{\"1\":{\"306\":1}}],[\"xxxxixx\",{\"1\":{\"306\":1}}],[\"xxjxxxx\",{\"1\":{\"306\":1}}],[\"xx\",{\"1\":{\"139\":4,\"140\":4,\"175\":3,\"190\":9,\"194\":5,\"196\":5,\"227\":2,\"242\":12,\"256\":4,\"312\":3,\"313\":6,\"314\":3,\"331\":6,\"421\":6,\"422\":6,\"423\":6,\"443\":25,\"484\":8,\"505\":4,\"767\":5}}],[\"xf\",{\"1\":{\"89\":1}}],[\"x4\",{\"1\":{\"62\":1,\"477\":3,\"599\":3}}],[\"x33\",{\"1\":{\"182\":10}}],[\"x3\",{\"1\":{\"38\":3,\"62\":1,\"477\":3,\"599\":3}}],[\"x2=\",{\"1\":{\"129\":1}}],[\"x2\",{\"1\":{\"38\":3,\"129\":7,\"181\":2,\"477\":3,\"599\":3}}],[\"x1+x2+x3\",{\"1\":{\"181\":2}}],[\"x1~xm\",{\"1\":{\"158\":1}}],[\"x1=\",{\"1\":{\"129\":1}}],[\"x1=x2=\",{\"1\":{\"129\":1}}],[\"x1\",{\"1\":{\"38\":3,\"129\":9,\"181\":2,\"477\":3,\"599\":3}}],[\"x\",{\"0\":{\"730\":1},\"1\":{\"14\":6,\"17\":15,\"18\":6,\"19\":18,\"20\":19,\"21\":25,\"23\":10,\"40\":2,\"78\":3,\"79\":2,\"80\":2,\"90\":1,\"100\":6,\"103\":2,\"104\":4,\"105\":2,\"106\":2,\"111\":3,\"127\":3,\"134\":3,\"135\":4,\"136\":4,\"137\":27,\"139\":2,\"140\":3,\"141\":2,\"142\":5,\"144\":4,\"146\":6,\"147\":4,\"148\":3,\"150\":2,\"151\":4,\"153\":8,\"154\":8,\"156\":3,\"157\":3,\"158\":13,\"163\":2,\"164\":9,\"166\":4,\"167\":2,\"169\":4,\"170\":15,\"172\":4,\"173\":6,\"174\":5,\"175\":7,\"176\":4,\"180\":7,\"182\":32,\"188\":7,\"190\":7,\"191\":9,\"194\":8,\"195\":5,\"196\":24,\"198\":3,\"200\":11,\"211\":3,\"213\":11,\"214\":7,\"215\":6,\"216\":30,\"217\":2,\"219\":8,\"227\":3,\"230\":4,\"231\":20,\"235\":8,\"236\":21,\"237\":25,\"239\":27,\"241\":12,\"242\":11,\"243\":6,\"244\":8,\"245\":3,\"251\":6,\"253\":5,\"255\":10,\"256\":8,\"258\":7,\"259\":18,\"260\":5,\"262\":22,\"263\":5,\"264\":7,\"266\":7,\"270\":3,\"272\":10,\"273\":4,\"274\":10,\"275\":6,\"278\":6,\"279\":6,\"285\":9,\"286\":14,\"287\":2,\"289\":32,\"291\":19,\"292\":18,\"298\":14,\"299\":11,\"305\":6,\"306\":4,\"307\":2,\"309\":6,\"310\":7,\"312\":16,\"313\":34,\"314\":18,\"317\":14,\"318\":2,\"319\":17,\"324\":5,\"325\":2,\"331\":10,\"335\":4,\"336\":3,\"340\":7,\"343\":5,\"369\":3,\"374\":9,\"376\":8,\"388\":3,\"389\":5,\"392\":3,\"394\":5,\"395\":2,\"399\":4,\"410\":9,\"413\":6,\"414\":2,\"415\":6,\"417\":4,\"419\":3,\"421\":5,\"422\":5,\"423\":5,\"425\":3,\"426\":12,\"435\":9,\"438\":11,\"443\":19,\"444\":13,\"465\":2,\"466\":4,\"467\":4,\"469\":4,\"471\":1,\"477\":3,\"478\":4,\"479\":3,\"482\":5,\"483\":2,\"484\":42,\"485\":5,\"494\":4,\"500\":2,\"502\":4,\"505\":4,\"507\":1,\"509\":2,\"513\":12,\"516\":5,\"524\":3,\"525\":4,\"538\":4,\"539\":4,\"544\":3,\"545\":2,\"547\":4,\"551\":3,\"565\":3,\"575\":6,\"576\":4,\"592\":3,\"605\":6,\"636\":4,\"643\":4,\"645\":3,\"649\":11,\"653\":4,\"656\":16,\"662\":12,\"679\":5,\"688\":8,\"695\":6,\"701\":3,\"708\":3,\"721\":8,\"724\":4,\"729\":9,\"730\":4,\"732\":3,\"734\":4,\"739\":4,\"744\":11,\"745\":4,\"747\":6,\"751\":5,\"767\":5,\"777\":4,\"780\":3,\"790\":3,\"823\":3,\"832\":5,\"836\":6,\"839\":9,\"872\":8,\"875\":25,\"879\":5,\"907\":4,\"911\":1}}],[\"每年\",{\"1\":{\"740\":1}}],[\"每天都放假\",{\"1\":{\"884\":1}}],[\"每天的停车时长算出属于哪一档\",{\"1\":{\"707\":1}}],[\"每天只有两种费用\",{\"1\":{\"707\":1}}],[\"每数一位\",{\"0\":{\"532\":1}}],[\"每种第\",{\"1\":{\"335\":1}}],[\"每种字符串的最小类型值\",{\"1\":{\"142\":1}}],[\"每\",{\"1\":{\"286\":4,\"484\":1}}],[\"每一步都去检查一下有没有可能导致前面的式子答案必然错误\",{\"1\":{\"187\":1}}],[\"每一列的进位\",{\"1\":{\"187\":1}}],[\"每一列的被进位的值\",{\"1\":{\"186\":1}}],[\"每一列以及相反列\",{\"1\":{\"162\":1}}],[\"每一个方块有几个\",{\"1\":{\"182\":1}}],[\"每行每列每个3x3\",{\"1\":{\"182\":4}}],[\"每次最多\",{\"1\":{\"900\":1}}],[\"每次查询不能纯暴力枚举了\",{\"1\":{\"874\":1}}],[\"每次操作前先复制一份\",{\"1\":{\"846\":1}}],[\"每次先\",{\"1\":{\"846\":1}}],[\"每次询问时根据\",{\"1\":{\"846\":1}}],[\"每次询问点两个点的\",{\"1\":{\"10\":1}}],[\"每次不再是区间修改而是单点修改了\",{\"1\":{\"831\":1}}],[\"每次循环都给\",{\"1\":{\"812\":1}}],[\"每次满日或者满星是不进位的\",{\"1\":{\"740\":1}}],[\"每次猜的时候三个数独立变化\",{\"1\":{\"655\":1}}],[\"每次只能选一个人\",{\"1\":{\"559\":1}}],[\"每次只能发一颗糖\",{\"1\":{\"559\":1}}],[\"每次提交都有\",{\"1\":{\"550\":1}}],[\"每次问\",{\"1\":{\"446\":1}}],[\"每次遇到\",{\"1\":{\"329\":1}}],[\"每次放完后把周边改为不能放\",{\"1\":{\"256\":1}}],[\"每次放国王之前判断一下\",{\"1\":{\"255\":1}}],[\"每次求的范围也是递增的\",{\"1\":{\"226\":1}}],[\"每次都是\",{\"1\":{\"164\":1}}],[\"每个周期只有两种颜色了\",{\"1\":{\"835\":1}}],[\"每个周期内\",{\"1\":{\"632\":1}}],[\"每个油箱容量都是\",{\"1\":{\"604\":1}}],[\"每个月的天数我是用条件判断实现的\",{\"1\":{\"571\":1}}],[\"每个非周末的天都需要收费\",{\"1\":{\"515\":1}}],[\"每个群两个人\",{\"1\":{\"480\":1}}],[\"每个群都能放进去所有人\",{\"1\":{\"480\":1}}],[\"每个词都没有含义\",{\"1\":{\"464\":1}}],[\"每个单词数量乘以编码长度\",{\"1\":{\"408\":1}}],[\"每个数和最小值的差\",{\"1\":{\"887\":1}}],[\"每个数与最后一个数的差\",{\"1\":{\"859\":1}}],[\"每个数与最大值的差\",{\"1\":{\"859\":2}}],[\"每个数位都从\",{\"1\":{\"655\":1}}],[\"每个数的因子个数\",{\"1\":{\"462\":1}}],[\"每个数有没有输出\",{\"1\":{\"394\":1}}],[\"每个数字选了多少\",{\"1\":{\"187\":1}}],[\"每个数字对应的是多少\",{\"1\":{\"187\":1}}],[\"每个数字都没被用过\",{\"1\":{\"185\":1,\"186\":1}}],[\"每个数字有没有被用过\",{\"1\":{\"185\":1,\"186\":1,\"187\":1}}],[\"每个价值的最小重量\",{\"1\":{\"362\":1}}],[\"每个容量下的最大价值\",{\"1\":{\"358\":1}}],[\"每个格点对应的编号\",{\"1\":{\"295\":1}}],[\"每个人的得分在\",{\"1\":{\"894\":1}}],[\"每个人几个朋友\",{\"1\":{\"726\":1}}],[\"每个人都有\",{\"1\":{\"726\":1}}],[\"每个人\",{\"1\":{\"196\":1}}],[\"每个位置\",{\"1\":{\"723\":1}}],[\"每个位置上升与下降的高度\",{\"1\":{\"260\":1}}],[\"每个位置的数前一轮能否达成\",{\"1\":{\"196\":1}}],[\"每个位置把正确的数交换过来\",{\"1\":{\"173\":1}}],[\"每个字母对应的都是没确定\",{\"1\":{\"185\":1,\"186\":1}}],[\"每个字母转成对应的数字\",{\"1\":{\"184\":1,\"185\":1,\"186\":1}}],[\"每个字母选了哪个数字\",{\"1\":{\"184\":1,\"185\":1,\"186\":1}}],[\"每个\",{\"1\":{\"151\":1,\"328\":1,\"498\":1}}],[\"每个点能到哪些点\",{\"1\":{\"444\":1}}],[\"每个点为起点检查能走多少个点\",{\"1\":{\"442\":1}}],[\"每个点的\",{\"1\":{\"15\":2}}],[\"每个点是否搜过了\",{\"1\":{\"14\":1}}],[\"和平均朋友数量了\",{\"1\":{\"726\":1}}],[\"和为\",{\"1\":{\"605\":1}}],[\"和为多少\",{\"1\":{\"258\":1}}],[\"和要等于\",{\"1\":{\"565\":1}}],[\"和后面的数字组合形成的\",{\"1\":{\"537\":1}}],[\"和后面每组的\",{\"1\":{\"525\":1}}],[\"和其唯一的对手谁更小即可\",{\"1\":{\"525\":1}}],[\"和他去掉了最高位之后的剩余部分\",{\"1\":{\"494\":1}}],[\"和哪些人已经在一个群了\",{\"1\":{\"480\":1}}],[\"和最多\",{\"1\":{\"453\":1}}],[\"和最终\",{\"1\":{\"350\":1}}],[\"和前前一个也相等\",{\"1\":{\"441\":1}}],[\"和把所有的\",{\"1\":{\"419\":1}}],[\"和右半边的\",{\"1\":{\"400\":1}}],[\"和上面简化版题目的做法类似\",{\"1\":{\"329\":1}}],[\"和积和\",{\"0\":{\"315\":1}}],[\"和\",{\"1\":{\"13\":1,\"80\":1,\"108\":1,\"158\":1,\"270\":1,\"329\":1,\"397\":1,\"403\":1,\"451\":2,\"453\":1,\"485\":1,\"503\":1,\"525\":1,\"530\":1,\"546\":1,\"565\":1,\"604\":1,\"734\":1,\"763\":1,\"822\":2,\"838\":1,\"887\":1,\"891\":1,\"900\":1,\"904\":1}}],[\"开胃值相等时再按开心值从大到小排序\",{\"1\":{\"623\":1}}],[\"开三方\",{\"0\":{\"621\":1}}],[\"开\",{\"1\":{\"457\":1}}],[\"开方\",{\"1\":{\"291\":1}}],[\"开头最短的子串\",{\"1\":{\"504\":1}}],[\"开头\",{\"1\":{\"196\":1}}],[\"开头的数\",{\"1\":{\"608\":1}}],[\"开头的\",{\"1\":{\"13\":1,\"335\":1}}],[\"开始和从\",{\"1\":{\"835\":1}}],[\"开始依次检查每个数是否是因子即可\",{\"1\":{\"792\":1}}],[\"开始时候两个人的当前局得分如果都的话\",{\"1\":{\"632\":1}}],[\"开始输入\",{\"1\":{\"505\":1}}],[\"开始后面的\",{\"1\":{\"475\":1}}],[\"开始存储程序部分\",{\"1\":{\"453\":1}}],[\"开始程序\",{\"1\":{\"453\":1}}],[\"开始\",{\"1\":{\"139\":1,\"140\":1,\"505\":1,\"740\":1}}],[\"开始的区别\",{\"1\":{\"835\":1}}],[\"开始的游戏结局\",{\"1\":{\"473\":1}}],[\"开始的\",{\"1\":{\"13\":1,\"509\":1}}],[\"最内层的循环中\",{\"1\":{\"812\":1}}],[\"最常见的极端情况就是有大量相等数据的时候\",{\"1\":{\"759\":1}}],[\"最早什么时候\",{\"1\":{\"632\":1}}],[\"最暴力的做法显然是直接枚举所有选择方案\",{\"1\":{\"490\":1}}],[\"最暴力枚举的代码\",{\"1\":{\"248\":1,\"249\":1}}],[\"最下面的\",{\"1\":{\"477\":1}}],[\"最后计算结果\",{\"1\":{\"884\":1}}],[\"最后计算出来的数据量会超出\",{\"1\":{\"508\":1}}],[\"最后输出的就是排在前面金牌区的选手\",{\"1\":{\"871\":1}}],[\"最后输出对应的排名即可\",{\"1\":{\"871\":1}}],[\"最后的加\",{\"1\":{\"713\":1}}],[\"最后答案就是所有数百位上的数之和\",{\"1\":{\"648\":1}}],[\"最后算出最大的开心程度即可得到答案\",{\"1\":{\"623\":1}}],[\"最后根据获胜次数进行输出即可\",{\"1\":{\"563\":1}}],[\"最后判断\",{\"1\":{\"525\":1}}],[\"最后比较起来就很简单了\",{\"1\":{\"512\":1}}],[\"最后在二维数组中判断有多少点被标记了\",{\"1\":{\"509\":1}}],[\"最后得分为\",{\"1\":{\"495\":4}}],[\"最后满分代码就好写了\",{\"1\":{\"484\":1}}],[\"最后代码非常短\",{\"1\":{\"458\":1}}],[\"最后可以到\",{\"1\":{\"451\":1}}],[\"最后一列是最方便的\",{\"1\":{\"426\":1}}],[\"最后一行\",{\"1\":{\"426\":1}}],[\"最后一个数才是最大值\",{\"1\":{\"859\":1}}],[\"最后一个小于等于\",{\"1\":{\"462\":1}}],[\"最后一个点在第lastrow\",{\"1\":{\"318\":1}}],[\"最后一个大于等于\",{\"1\":{\"225\":1}}],[\"最后一个测速点就是\",{\"1\":{\"198\":2}}],[\"最后一次\",{\"1\":{\"147\":1}}],[\"最坏情况\",{\"1\":{\"351\":1}}],[\"最坏节点个数\",{\"1\":{\"269\":1}}],[\"最少花几次\",{\"1\":{\"351\":1}}],[\"最少区间覆盖\",{\"1\":{\"242\":1}}],[\"最少区间覆盖问题\",{\"1\":{\"241\":1}}],[\"最短路\",{\"0\":{\"297\":1}}],[\"最终必然就对称回原点了\",{\"1\":{\"909\":1}}],[\"最终得分也只有\",{\"1\":{\"900\":1}}],[\"最终输出总分\",{\"1\":{\"503\":1}}],[\"最终打败的是谁\",{\"1\":{\"475\":1}}],[\"最终展开求出来的值是一样的\",{\"1\":{\"467\":1}}],[\"最终有多少棵树苗\",{\"1\":{\"218\":1}}],[\"最终会变成\",{\"1\":{\"165\":1}}],[\"最大逆序对和\",{\"0\":{\"817\":1}}],[\"最大的那个需要看看是否超过了\",{\"1\":{\"661\":1}}],[\"最大\",{\"1\":{\"440\":1}}],[\"最大数\",{\"0\":{\"216\":1}}],[\"最大得分\",{\"1\":{\"182\":2}}],[\"最多\",{\"1\":{\"655\":1,\"904\":1}}],[\"最多能拿到多少维生素量\",{\"1\":{\"340\":1}}],[\"最多活到几点钟\",{\"1\":{\"202\":1,\"203\":1}}],[\"最多吃一半\",{\"1\":{\"128\":1}}],[\"最新选上的测速点位置\",{\"1\":{\"198\":1}}],[\"最右能走到\",{\"1\":{\"146\":1}}],[\"最接近的类型\",{\"1\":{\"142\":1}}],[\"最长平台\",{\"1\":{\"831\":1}}],[\"最长连签\",{\"0\":{\"324\":1}}],[\"最长\",{\"1\":{\"196\":4}}],[\"最长的y\",{\"0\":{\"169\":1}}],[\"最长公共子序列\",{\"0\":{\"233\":1}}],[\"最长公共子序列方案\",{\"0\":{\"125\":1}}],[\"最长公共子序列长度\",{\"0\":{\"120\":1}}],[\"最长上升奇偶子序列\",{\"0\":{\"118\":1}}],[\"最长上升子序列的方案数\",{\"1\":{\"119\":1}}],[\"最长上升子序列的长度\",{\"1\":{\"119\":1}}],[\"最长上升子序列方案数\",{\"0\":{\"119\":1}}],[\"最长上升子序列方案\",{\"0\":{\"114\":1}}],[\"最长上升子序列长度\",{\"0\":{\"112\":1,\"113\":1}}],[\"最长不上升子序列长度\",{\"0\":{\"117\":1}}],[\"最小单元为\",{\"1\":{\"642\":1}}],[\"最小生成树算法\",{\"1\":{\"428\":1}}],[\"最小结尾的元素下标\",{\"1\":{\"116\":1}}],[\"最小的下标\",{\"1\":{\"13\":1}}],[\"最高位为符号位\",{\"1\":{\"86\":1}}],[\"最近公共祖先\",{\"0\":{\"9\":1}}],[\"之类的区间覆盖题目\",{\"1\":{\"900\":1}}],[\"之内的每个整数\",{\"1\":{\"533\":1}}],[\"之后且父节点涂黑的方案数\",{\"1\":{\"384\":1}}],[\"之后再减\",{\"1\":{\"349\":1}}],[\"之前是否都填的\",{\"1\":{\"270\":1}}],[\"之前\",{\"1\":{\"226\":1}}],[\"之前高度为\",{\"1\":{\"202\":1,\"203\":1}}],[\"之前凑出来了\",{\"1\":{\"195\":1}}],[\"之前用了\",{\"1\":{\"195\":1}}],[\"之前已经确定了\",{\"1\":{\"187\":1}}],[\"之前的所有数之和为\",{\"1\":{\"298\":1}}],[\"之前的\",{\"1\":{\"0\":1}}],[\"之和就好\",{\"1\":{\"825\":1}}],[\"之和即可\",{\"1\":{\"533\":1,\"859\":3,\"887\":1}}],[\"之和\",{\"1\":{\"141\":1,\"151\":1,\"250\":2,\"408\":1}}],[\"之间\",{\"1\":{\"13\":1,\"440\":1,\"509\":1}}],[\"为止\",{\"1\":{\"792\":1}}],[\"为数字\",{\"1\":{\"742\":1}}],[\"为连续上升\",{\"1\":{\"705\":1}}],[\"为一位数时\",{\"1\":{\"533\":1}}],[\"为开头的包含wotojo\",{\"1\":{\"504\":1}}],[\"为右下角的刀的方案数为上方连续\",{\"1\":{\"498\":1}}],[\"为能消耗多少\",{\"1\":{\"488\":1}}],[\"为质数\",{\"1\":{\"462\":1}}],[\"为了方便理解这里我用\",{\"1\":{\"904\":1}}],[\"为了方便处理\",{\"1\":{\"661\":1}}],[\"为了吃到最多的桃子\",{\"1\":{\"623\":1}}],[\"为了避免减\",{\"1\":{\"505\":1}}],[\"为了避免细节推错了\",{\"1\":{\"450\":1}}],[\"为了考线性筛来构造的函数\",{\"1\":{\"415\":1}}],[\"为了给大家科普下\",{\"1\":{\"406\":1}}],[\"为了保证四舍五入正确\",{\"1\":{\"181\":1}}],[\"为黑色的涂色方案数\",{\"1\":{\"383\":1,\"384\":1}}],[\"为黑色\",{\"1\":{\"383\":1,\"384\":1}}],[\"为根节点时\",{\"1\":{\"383\":2,\"384\":2}}],[\"为根节点时的深度\",{\"1\":{\"11\":1}}],[\"为终点的路径数量\",{\"1\":{\"366\":1}}],[\"为假时记忆化搜索\",{\"1\":{\"270\":1}}],[\"为递推顺序做准备\",{\"1\":{\"241\":1}}],[\"为什么是上取整减一\",{\"1\":{\"198\":1}}],[\"为公差\",{\"1\":{\"141\":1}}],[\"为首项\",{\"1\":{\"141\":1}}],[\"为首项都会超过\",{\"1\":{\"141\":1}}],[\"为周期\",{\"1\":{\"137\":1}}],[\"为依据进行比较\",{\"1\":{\"123\":1,\"233\":1}}],[\"为\",{\"1\":{\"14\":1,\"93\":1,\"94\":2,\"101\":1,\"216\":1,\"251\":1,\"443\":1,\"507\":1,\"537\":3,\"611\":1,\"639\":1,\"812\":1,\"815\":1,\"842\":1,\"891\":1}}],[\"为起点能走的最长路径\",{\"1\":{\"365\":1}}],[\"为起点的路径\",{\"1\":{\"318\":2}}],[\"为起点\",{\"1\":{\"13\":1}}],[\"l+=helper\",{\"1\":{\"902\":1}}],[\"l++\",{\"1\":{\"156\":1,\"157\":1,\"169\":1,\"176\":1,\"371\":1,\"373\":1,\"495\":1,\"615\":1}}],[\"l=0\",{\"1\":{\"902\":1}}],[\"l=r\",{\"1\":{\"816\":1}}],[\"l=a\",{\"1\":{\"816\":1}}],[\"ld\",{\"1\":{\"575\":1,\"576\":1}}],[\"luogu\",{\"1\":{\"437\":1,\"489\":1,\"494\":1}}],[\"lum\",{\"1\":{\"384\":9}}],[\"ln\",{\"1\":{\"415\":1}}],[\"lnk\",{\"1\":{\"178\":6}}],[\"l~r\",{\"1\":{\"331\":2,\"495\":2}}],[\"leez\",{\"0\":{\"558\":1}}],[\"le\",{\"1\":{\"498\":7}}],[\"leftpos\",{\"1\":{\"447\":2}}],[\"left\",{\"1\":{\"320\":18}}],[\"len=\",{\"1\":{\"546\":1}}],[\"len=s\",{\"1\":{\"509\":1}}],[\"len2\",{\"1\":{\"259\":2}}],[\"len1\",{\"1\":{\"259\":5}}],[\"len++\",{\"1\":{\"176\":1,\"216\":2,\"286\":2,\"371\":1,\"373\":1,\"495\":1,\"497\":1,\"875\":5}}],[\"length\",{\"1\":{\"161\":1,\"168\":6,\"178\":5,\"188\":2,\"265\":1,\"268\":2,\"269\":2,\"282\":1,\"283\":2,\"284\":1,\"319\":1,\"509\":1,\"622\":8}}],[\"len\",{\"1\":{\"13\":6,\"113\":5,\"116\":7,\"117\":6,\"122\":5,\"123\":6,\"157\":3,\"169\":4,\"176\":7,\"178\":3,\"216\":8,\"233\":11,\"267\":2,\"273\":3,\"286\":12,\"288\":3,\"331\":10,\"335\":17,\"371\":5,\"373\":5,\"378\":5,\"410\":4,\"447\":3,\"495\":6,\"497\":9,\"509\":1,\"516\":3,\"526\":3,\"564\":2,\"575\":3,\"576\":3,\"746\":7,\"875\":31}}],[\"lamp\",{\"0\":{\"294\":1}}],[\"lastrow\",{\"1\":{\"318\":4}}],[\"lastx\",{\"1\":{\"312\":3,\"313\":6,\"314\":3}}],[\"last++\",{\"1\":{\"284\":1}}],[\"last+1\",{\"1\":{\"242\":2}}],[\"lastp\",{\"1\":{\"224\":5,\"225\":4,\"226\":4}}],[\"last\",{\"1\":{\"168\":10,\"196\":6,\"198\":3,\"219\":8,\"242\":5,\"284\":7,\"301\":4,\"345\":4,\"485\":12,\"565\":6,\"741\":5,\"783\":3}}],[\"lazymul\",{\"1\":{\"21\":10}}],[\"lazyadd\",{\"1\":{\"21\":16}}],[\"lazysum\",{\"1\":{\"20\":5}}],[\"lazy\",{\"0\":{\"291\":1},\"1\":{\"19\":9,\"20\":3,\"237\":10,\"239\":10,\"291\":7,\"292\":1,\"312\":4,\"313\":8,\"314\":4}}],[\"lcm13\",{\"1\":{\"437\":3}}],[\"lcm123\",{\"1\":{\"437\":3}}],[\"lcm12\",{\"1\":{\"437\":6}}],[\"lcm23\",{\"1\":{\"437\":4}}],[\"lcm\",{\"1\":{\"412\":1,\"437\":6,\"668\":2}}],[\"lcs\",{\"0\":{\"363\":1},\"1\":{\"120\":1,\"124\":1,\"125\":1,\"126\":1}}],[\"lca\",{\"1\":{\"10\":1,\"11\":2,\"12\":4,\"13\":2,\"15\":2,\"414\":1}}],[\"li\",{\"1\":{\"196\":15,\"499\":2}}],[\"line\",{\"1\":{\"191\":3,\"198\":14,\"312\":13,\"313\":29,\"314\":16}}],[\"lis\",{\"1\":{\"112\":1,\"113\":2,\"115\":2,\"116\":3,\"117\":3,\"122\":3,\"123\":3,\"233\":6}}],[\"limit\",{\"1\":{\"69\":2,\"168\":7,\"270\":10,\"273\":7,\"378\":5}}],[\"lllll\",{\"1\":{\"705\":1}}],[\"ll\",{\"1\":{\"101\":2,\"164\":2,\"318\":1,\"524\":2,\"525\":1,\"526\":1,\"527\":1,\"575\":4,\"576\":4,\"633\":9,\"636\":1,\"907\":2}}],[\"llu\",{\"1\":{\"83\":2}}],[\"lld\",{\"1\":{\"83\":2}}],[\"lf\",{\"1\":{\"83\":1}}],[\"lson\",{\"1\":{\"23\":7,\"24\":3,\"313\":5,\"314\":5}}],[\"loc\",{\"1\":{\"847\":5}}],[\"low\",{\"1\":{\"340\":5,\"444\":8}}],[\"lowbit\",{\"1\":{\"213\":3,\"214\":2,\"236\":3,\"258\":3,\"266\":3,\"376\":3}}],[\"lowerbound\",{\"1\":{\"239\":5}}],[\"lower\",{\"1\":{\"113\":1,\"122\":1,\"126\":1,\"213\":1,\"214\":1,\"233\":1,\"236\":3,\"237\":3,\"258\":1,\"310\":1,\"312\":2,\"313\":2,\"331\":2,\"457\":1}}],[\"load\",{\"1\":{\"37\":1,\"453\":4}}],[\"longest\",{\"0\":{\"364\":1}}],[\"long>\",{\"1\":{\"141\":1}}],[\"long\",{\"1\":{\"19\":2,\"20\":2,\"21\":2,\"61\":2,\"83\":4,\"101\":2,\"109\":2,\"110\":2,\"119\":2,\"127\":2,\"128\":2,\"139\":2,\"140\":2,\"141\":9,\"144\":2,\"146\":2,\"147\":2,\"148\":2,\"150\":4,\"151\":8,\"163\":2,\"164\":2,\"167\":2,\"169\":2,\"176\":2,\"181\":4,\"190\":2,\"195\":4,\"216\":6,\"224\":2,\"225\":2,\"226\":2,\"241\":2,\"244\":5,\"245\":2,\"257\":2,\"258\":2,\"266\":2,\"270\":2,\"273\":12,\"289\":8,\"291\":2,\"292\":2,\"293\":2,\"298\":4,\"303\":2,\"305\":2,\"312\":4,\"313\":6,\"314\":2,\"318\":2,\"320\":24,\"329\":2,\"331\":2,\"335\":2,\"338\":2,\"358\":2,\"359\":2,\"362\":2,\"371\":2,\"373\":2,\"375\":2,\"376\":12,\"377\":2,\"381\":2,\"383\":2,\"384\":2,\"395\":2,\"402\":2,\"405\":2,\"406\":2,\"410\":2,\"413\":4,\"414\":6,\"415\":8,\"418\":2,\"419\":8,\"428\":2,\"435\":2,\"437\":2,\"451\":12,\"457\":10,\"461\":2,\"470\":4,\"471\":2,\"475\":2,\"478\":8,\"483\":2,\"484\":4,\"485\":2,\"488\":2,\"493\":2,\"495\":2,\"498\":2,\"508\":4,\"516\":16,\"524\":4,\"525\":2,\"526\":2,\"527\":2,\"533\":2,\"534\":10,\"535\":6,\"553\":4,\"554\":2,\"564\":4,\"565\":5,\"575\":5,\"576\":5,\"579\":2,\"582\":6,\"583\":4,\"585\":2,\"586\":4,\"621\":4,\"622\":2,\"633\":2,\"636\":2,\"659\":2,\"679\":2,\"682\":4,\"695\":4,\"705\":2,\"708\":2,\"729\":2,\"730\":6,\"742\":2,\"745\":2,\"783\":2,\"803\":2,\"804\":2,\"806\":4,\"812\":8,\"813\":6,\"825\":2,\"826\":2,\"839\":6,\"878\":2,\"879\":4,\"891\":2,\"892\":4,\"895\":2,\"907\":2}}],[\"log2n\",{\"1\":{\"214\":3}}],[\"log2\",{\"1\":{\"13\":1,\"214\":1}}],[\"l\",{\"0\":{\"371\":1},\"1\":{\"13\":6,\"17\":13,\"18\":5,\"19\":24,\"20\":19,\"21\":30,\"23\":12,\"24\":5,\"116\":4,\"117\":4,\"123\":4,\"146\":4,\"147\":4,\"156\":5,\"157\":5,\"163\":6,\"165\":7,\"169\":10,\"172\":5,\"173\":7,\"176\":9,\"181\":9,\"198\":11,\"205\":5,\"213\":4,\"216\":17,\"218\":4,\"219\":8,\"233\":4,\"235\":4,\"236\":8,\"237\":34,\"239\":35,\"241\":16,\"242\":6,\"244\":5,\"245\":8,\"266\":5,\"270\":3,\"286\":4,\"287\":4,\"291\":15,\"292\":14,\"293\":4,\"312\":9,\"313\":18,\"314\":9,\"331\":5,\"335\":3,\"340\":8,\"350\":3,\"371\":15,\"372\":3,\"373\":14,\"384\":3,\"399\":10,\"400\":9,\"410\":3,\"427\":5,\"430\":3,\"437\":4,\"446\":8,\"447\":19,\"448\":12,\"458\":2,\"470\":3,\"478\":10,\"484\":4,\"485\":4,\"495\":18,\"500\":4,\"516\":5,\"542\":1,\"592\":3,\"612\":4,\"615\":5,\"659\":3,\"662\":3,\"704\":1,\"705\":8,\"729\":4,\"786\":3,\"803\":4,\"816\":2,\"832\":7,\"844\":6,\"872\":6}}],[\"表达式\",{\"0\":{\"319\":1}}],[\"表示即可\",{\"1\":{\"828\":1}}],[\"表示前\",{\"1\":{\"499\":1}}],[\"表示往右走到了\",{\"1\":{\"405\":2}}],[\"表示什么就好了\",{\"1\":{\"329\":1}}],[\"表示每个\",{\"1\":{\"307\":1}}],[\"表示当前位最多只能是d\",{\"1\":{\"273\":1}}],[\"表示当前节点对应区间全部都要赋值为\",{\"1\":{\"216\":1}}],[\"表示没被摧毁\",{\"1\":{\"235\":1,\"236\":1,\"237\":1,\"239\":1}}],[\"表示没有异色\",{\"1\":{\"199\":2}}],[\"表示被摧毁了\",{\"1\":{\"235\":1,\"236\":1,\"237\":1,\"239\":1}}],[\"表示无解\",{\"1\":{\"126\":1}}],[\"表示\",{\"1\":{\"122\":1,\"123\":1,\"233\":2,\"280\":1,\"307\":1}}],[\"表示成功运行结束\",{\"1\":{\"47\":1}}],[\"表\",{\"1\":{\"13\":1}}],[\"处理就好\",{\"1\":{\"891\":1}}],[\"处理起来会方便一点\",{\"1\":{\"835\":1}}],[\"处理最方便\",{\"1\":{\"763\":1}}],[\"处理的时候大家不用想复杂了\",{\"1\":{\"717\":1}}],[\"处理即可\",{\"1\":{\"588\":1}}],[\"处理出来\",{\"1\":{\"462\":1}}],[\"处理边界情况\",{\"1\":{\"306\":1}}],[\"处理每个询问\",{\"1\":{\"200\":1}}],[\"处理基础得分\",{\"1\":{\"182\":2}}],[\"处理当前列的情况\",{\"1\":{\"160\":1}}],[\"处理\",{\"1\":{\"13\":1,\"196\":2,\"243\":1,\"444\":1,\"475\":1,\"897\":1}}],[\"存反向边\",{\"1\":{\"366\":1}}],[\"存维生素\",{\"1\":{\"340\":1}}],[\"存图\",{\"1\":{\"318\":1,\"726\":1}}],[\"存值\",{\"1\":{\"307\":1}}],[\"存第一行能访问到的所有区间\",{\"1\":{\"242\":1}}],[\"存第\",{\"1\":{\"196\":4,\"342\":1}}],[\"存每条线段\",{\"1\":{\"312\":1,\"313\":1}}],[\"存每条竖线\",{\"1\":{\"312\":1,\"313\":1}}],[\"存每个位置为右端点的询问<询问的左端点\",{\"1\":{\"266\":1}}],[\"存每个位置是否被消掉了\",{\"1\":{\"192\":1}}],[\"存每组被消除的位置\",{\"1\":{\"192\":1}}],[\"存入\",{\"1\":{\"172\":1}}],[\"存入一个目标类型的变量\",{\"1\":{\"101\":1}}],[\"存数量\",{\"1\":{\"169\":1}}],[\"存的钱\",{\"1\":{\"134\":1,\"135\":1,\"136\":1}}],[\"存所有单词出现次数\",{\"1\":{\"874\":1}}],[\"存所有合法状态\",{\"1\":{\"257\":1}}],[\"存所有点\",{\"1\":{\"241\":1}}],[\"存所有\",{\"1\":{\"110\":1,\"215\":1}}],[\"存所有可以达成\",{\"1\":{\"109\":1}}],[\"存\",{\"1\":{\"13\":3,\"126\":1,\"258\":1,\"293\":1,\"444\":1,\"480\":1}}],[\"在循环的过程中对输入的变量求和\",{\"1\":{\"881\":1}}],[\"在找到最大值后就不能回过头去看每个数了\",{\"1\":{\"859\":1}}],[\"在做子任务\",{\"1\":{\"856\":1}}],[\"在基础的数位分解的循环基础上配合上计数即可\",{\"1\":{\"853\":1}}],[\"在遇到\",{\"1\":{\"842\":1}}],[\"在子任务\",{\"1\":{\"825\":1,\"846\":1}}],[\"在中间的循环里\",{\"1\":{\"812\":1}}],[\"在边界上绕圈\",{\"1\":{\"766\":1}}],[\"在起点时\",{\"1\":{\"668\":1}}],[\"在那一场比赛中的题号\",{\"1\":{\"627\":1}}],[\"在排序之后\",{\"1\":{\"623\":1}}],[\"在哪儿\",{\"1\":{\"557\":1}}],[\"在看同学们代码的时候\",{\"1\":{\"546\":1}}],[\"在输入整数时\",{\"1\":{\"530\":1}}],[\"在最后一个\",{\"1\":{\"526\":1}}],[\"在完成输入的同时去判断\",{\"1\":{\"503\":1}}],[\"在信息学竞赛中几乎可以当作是\",{\"1\":{\"461\":1}}],[\"在不在那条路径上\",{\"1\":{\"414\":1}}],[\"在多少个序列中出现过\",{\"1\":{\"329\":1}}],[\"在文本中去找到所有和模式匹配的位置\",{\"1\":{\"283\":1}}],[\"在当前节点中的部分之和\",{\"1\":{\"237\":1,\"239\":1}}],[\"在当前按键情况下的亮灯情况\",{\"1\":{\"154\":1}}],[\"在上次求到的位置往后看就好\",{\"1\":{\"226\":1}}],[\"在上面\",{\"1\":{\"12\":1}}],[\"在末尾插入一个数\",{\"1\":{\"216\":2}}],[\"在后面加上\",{\"1\":{\"101\":1}}],[\"在原码基础上取反\",{\"1\":{\"86\":1}}],[\"在线评测\",{\"1\":{\"67\":1}}],[\"在\",{\"1\":{\"13\":1,\"122\":1,\"123\":1,\"140\":1,\"147\":1,\"233\":2,\"259\":2,\"268\":2,\"340\":1,\"477\":1,\"541\":1,\"856\":1,\"904\":1}}],[\"在下面\",{\"1\":{\"12\":1}}],[\"返回子树大小\",{\"1\":{\"427\":1}}],[\"返回<变成了几\",{\"1\":{\"343\":1}}],[\"返回总长度和\",{\"1\":{\"312\":1,\"313\":1}}],[\"返回从\",{\"1\":{\"302\":1,\"473\":1}}],[\"返回前x个数的和\",{\"1\":{\"266\":1}}],[\"返回能不能切出来\",{\"1\":{\"245\":1}}],[\"返回能钓多少条\",{\"1\":{\"146\":1}}],[\"返回当前属性下的超速区间\",{\"1\":{\"198\":1}}],[\"返回栈顶\",{\"1\":{\"105\":1}}],[\"返回队尾\",{\"1\":{\"104\":1,\"106\":1}}],[\"返回队头\",{\"1\":{\"104\":1,\"106\":1}}],[\"返回\",{\"1\":{\"12\":1,\"47\":1,\"48\":1,\"172\":2,\"173\":2,\"250\":2,\"335\":1,\"413\":1,\"875\":1}}],[\"级别祖先的\",{\"1\":{\"12\":1}}],[\"级别祖先\",{\"1\":{\"12\":3}}],[\"j>vis\",{\"1\":{\"906\":1}}],[\"j>=1\",{\"1\":{\"509\":2,\"906\":1}}],[\"jonny\",{\"0\":{\"893\":1}}],[\"jonnyyuan\",{\"1\":{\"804\":1}}],[\"joi\",{\"0\":{\"320\":1}}],[\"ja\",{\"1\":{\"551\":6}}],[\"january\",{\"1\":{\"455\":1}}],[\"jn\",{\"1\":{\"477\":1}}],[\"j1\",{\"1\":{\"477\":1}}],[\"j0\",{\"1\":{\"477\":1}}],[\"jx+m\",{\"1\":{\"471\":2}}],[\"july\",{\"1\":{\"455\":1}}],[\"june\",{\"1\":{\"455\":1}}],[\"judge\",{\"1\":{\"67\":1,\"527\":2,\"551\":1}}],[\"jmp\",{\"1\":{\"453\":1}}],[\"je\",{\"1\":{\"453\":1}}],[\"jia\",{\"1\":{\"428\":2,\"432\":2}}],[\"jin\",{\"1\":{\"425\":2}}],[\"jie\",{\"1\":{\"413\":4,\"489\":2}}],[\"jp\",{\"1\":{\"420\":1}}],[\"j+1\",{\"1\":{\"369\":1,\"526\":2}}],[\"j+3000\",{\"1\":{\"368\":1}}],[\"j++\",{\"1\":{\"12\":1,\"13\":1,\"27\":1,\"29\":1,\"31\":1,\"112\":1,\"115\":1,\"118\":1,\"119\":2,\"120\":1,\"124\":1,\"125\":1,\"126\":2,\"128\":1,\"140\":1,\"150\":1,\"153\":1,\"154\":5,\"158\":7,\"160\":1,\"161\":1,\"162\":5,\"164\":2,\"166\":4,\"167\":1,\"168\":2,\"177\":2,\"178\":1,\"179\":1,\"182\":6,\"193\":2,\"194\":2,\"196\":13,\"197\":3,\"199\":6,\"200\":1,\"204\":2,\"208\":1,\"217\":1,\"221\":1,\"222\":1,\"224\":1,\"227\":1,\"231\":5,\"232\":2,\"241\":6,\"242\":4,\"248\":5,\"249\":2,\"253\":1,\"257\":2,\"259\":3,\"260\":4,\"262\":1,\"263\":2,\"264\":1,\"267\":2,\"269\":1,\"272\":1,\"274\":2,\"275\":1,\"276\":6,\"280\":1,\"282\":1,\"283\":2,\"284\":1,\"285\":2,\"289\":4,\"295\":3,\"299\":4,\"306\":2,\"307\":2,\"317\":2,\"318\":2,\"334\":1,\"335\":2,\"336\":1,\"340\":1,\"359\":1,\"361\":2,\"363\":1,\"367\":2,\"368\":1,\"369\":1,\"370\":1,\"372\":2,\"374\":2,\"377\":3,\"379\":1,\"380\":2,\"381\":2,\"386\":3,\"395\":1,\"410\":1,\"412\":1,\"413\":1,\"415\":2,\"419\":1,\"421\":2,\"422\":2,\"423\":2,\"428\":1,\"430\":1,\"432\":1,\"436\":2,\"438\":3,\"443\":2,\"444\":5,\"451\":1,\"453\":1,\"479\":2,\"480\":3,\"488\":1,\"490\":3,\"492\":1,\"498\":4,\"499\":2,\"500\":2,\"504\":1,\"505\":2,\"509\":4,\"526\":1,\"557\":2,\"560\":1,\"575\":1,\"586\":1,\"605\":4,\"612\":1,\"636\":1,\"672\":1,\"675\":3,\"685\":1,\"688\":1,\"701\":2,\"711\":1,\"724\":1,\"732\":1,\"735\":1,\"746\":2,\"754\":1,\"772\":1,\"773\":1,\"786\":1,\"812\":1,\"816\":2,\"832\":1,\"875\":2}}],[\"j2020\",{\"0\":{\"319\":1}}],[\"j<=c\",{\"1\":{\"816\":2}}],[\"j<=2\",{\"1\":{\"636\":1}}],[\"j<=n\",{\"1\":{\"509\":4}}],[\"j<=m\",{\"1\":{\"241\":1}}],[\"j<=3\",{\"1\":{\"241\":1}}],[\"j<60\",{\"1\":{\"140\":1}}],[\"jsoi2008\",{\"0\":{\"215\":1,\"216\":1}}],[\"j~j+a\",{\"1\":{\"204\":1}}],[\"j=vis\",{\"1\":{\"906\":1}}],[\"j=i\",{\"1\":{\"906\":1}}],[\"j=z\",{\"1\":{\"509\":2}}],[\"j=h\",{\"1\":{\"509\":2}}],[\"j=pret\",{\"1\":{\"321\":1}}],[\"j=1\",{\"1\":{\"241\":1,\"509\":2,\"816\":2}}],[\"j==0\",{\"1\":{\"199\":2}}],[\"j=0\",{\"1\":{\"140\":1,\"241\":1,\"636\":1}}],[\"jj++\",{\"1\":{\"177\":1,\"196\":4}}],[\"jj\",{\"1\":{\"177\":20,\"196\":15,\"253\":2,\"293\":3}}],[\"j\",{\"0\":{\"193\":1,\"194\":1,\"195\":1,\"196\":1,\"321\":1,\"369\":1,\"396\":1,\"411\":1,\"416\":1,\"424\":1,\"429\":1,\"434\":1,\"439\":1,\"449\":1,\"454\":1,\"459\":1,\"468\":1,\"476\":1,\"481\":1,\"486\":1,\"491\":1,\"496\":1},\"1\":{\"12\":20,\"13\":13,\"27\":4,\"29\":6,\"30\":7,\"31\":2,\"112\":4,\"115\":6,\"118\":5,\"119\":9,\"120\":10,\"124\":10,\"125\":20,\"126\":20,\"127\":3,\"128\":14,\"140\":4,\"150\":2,\"153\":2,\"154\":16,\"158\":39,\"160\":3,\"161\":3,\"162\":39,\"164\":7,\"166\":17,\"167\":8,\"168\":8,\"177\":24,\"178\":5,\"179\":8,\"182\":27,\"193\":6,\"194\":7,\"196\":55,\"197\":18,\"199\":48,\"200\":3,\"203\":8,\"204\":16,\"208\":3,\"217\":10,\"221\":12,\"222\":19,\"224\":4,\"227\":5,\"231\":16,\"232\":38,\"241\":21,\"242\":14,\"248\":16,\"249\":15,\"253\":4,\"257\":8,\"259\":16,\"260\":23,\"262\":3,\"263\":5,\"264\":3,\"267\":6,\"269\":6,\"272\":3,\"274\":6,\"275\":5,\"276\":30,\"280\":10,\"282\":7,\"283\":15,\"284\":7,\"285\":23,\"289\":26,\"293\":6,\"295\":14,\"299\":15,\"303\":7,\"306\":15,\"307\":8,\"317\":6,\"318\":8,\"321\":2,\"334\":4,\"335\":12,\"336\":7,\"340\":10,\"355\":5,\"358\":6,\"359\":3,\"361\":13,\"362\":6,\"363\":15,\"367\":11,\"368\":6,\"369\":20,\"370\":4,\"372\":15,\"374\":6,\"377\":11,\"379\":9,\"380\":12,\"381\":7,\"386\":6,\"395\":4,\"406\":1,\"410\":8,\"412\":3,\"413\":7,\"415\":12,\"419\":6,\"421\":7,\"422\":6,\"423\":6,\"428\":4,\"430\":3,\"432\":7,\"436\":11,\"438\":11,\"443\":10,\"444\":44,\"451\":2,\"453\":2,\"458\":4,\"462\":4,\"470\":5,\"471\":6,\"475\":2,\"479\":5,\"480\":15,\"488\":5,\"490\":12,\"492\":3,\"498\":22,\"499\":19,\"500\":9,\"504\":6,\"505\":10,\"509\":13,\"526\":3,\"557\":9,\"560\":7,\"575\":30,\"586\":2,\"605\":14,\"612\":6,\"636\":3,\"653\":4,\"672\":3,\"675\":11,\"685\":3,\"688\":3,\"701\":8,\"711\":2,\"717\":1,\"724\":3,\"732\":8,\"735\":4,\"746\":8,\"754\":3,\"761\":1,\"764\":2,\"769\":1,\"772\":4,\"773\":4,\"786\":4,\"803\":4,\"812\":5,\"832\":3,\"872\":9,\"875\":8,\"906\":2}}],[\"倍增\",{\"0\":{\"12\":1}}],[\"的语法来描述\",{\"1\":{\"904\":1}}],[\"的标记会不会超时呢\",{\"1\":{\"900\":1}}],[\"的标程也确确实实就是\",{\"1\":{\"565\":1}}],[\"的标程写法可以忽略掉负数的判断\",{\"1\":{\"565\":1}}],[\"的做法通过\",{\"1\":{\"897\":1}}],[\"的关系\",{\"1\":{\"891\":1}}],[\"的出现次数\",{\"1\":{\"875\":1}}],[\"的出现次数加上\",{\"1\":{\"875\":1}}],[\"的特性\",{\"1\":{\"869\":1}}],[\"的补码为全\",{\"1\":{\"869\":1}}],[\"的差乘以\",{\"1\":{\"859\":1}}],[\"的返回值是无符号整型\",{\"1\":{\"842\":1}}],[\"的形式时大家需要注意\",{\"1\":{\"842\":1}}],[\"的方式处理即可\",{\"1\":{\"838\":1}}],[\"的方案数和前部分从\",{\"1\":{\"405\":1}}],[\"的方案就是\",{\"1\":{\"405\":1}}],[\"的方案是就是\",{\"1\":{\"405\":1}}],[\"的方案\",{\"1\":{\"352\":1,\"740\":1}}],[\"的超速检测\",{\"0\":{\"784\":1}}],[\"的染色\",{\"0\":{\"781\":1}}],[\"的实力低的选手共\",{\"1\":{\"779\":1}}],[\"的擂台游戏\",{\"0\":{\"778\":1}}],[\"的决斗\",{\"0\":{\"775\":1}}],[\"的接龙\",{\"0\":{\"771\":1}}],[\"的小木棍\",{\"0\":{\"768\":1}}],[\"的地图探险\",{\"0\":{\"765\":1}}],[\"的地板\",{\"1\":{\"108\":1}}],[\"的扑克牌\",{\"0\":{\"762\":1}}],[\"的都被卡成了\",{\"1\":{\"759\":1}}],[\"的都等价于\",{\"1\":{\"443\":1}}],[\"的同学可以直接用\",{\"1\":{\"815\":1}}],[\"的同学\",{\"1\":{\"759\":1}}],[\"的同色下标\",{\"1\":{\"225\":1}}],[\"的排列打包成一个函数来简化代码\",{\"1\":{\"674\":1}}],[\"的排名\",{\"1\":{\"122\":1,\"123\":1,\"233\":2}}],[\"的字典序即可\",{\"1\":{\"671\":1}}],[\"的字符\",{\"1\":{\"509\":1}}],[\"的公倍数\",{\"1\":{\"668\":1}}],[\"的式子也是对的\",{\"1\":{\"665\":1}}],[\"的贡献后的内容\",{\"1\":{\"662\":1}}],[\"的每个数检查即可\",{\"1\":{\"661\":1}}],[\"的每个数字即可\",{\"1\":{\"655\":1}}],[\"的幂次模\",{\"1\":{\"658\":1}}],[\"的三个位置各不相同\",{\"1\":{\"655\":1}}],[\"的多少次方的\",{\"1\":{\"645\":1}}],[\"的余数\",{\"1\":{\"904\":3}}],[\"的余数等于之前某个小于\",{\"1\":{\"904\":1}}],[\"的余数为\",{\"1\":{\"668\":2,\"904\":1}}],[\"的余数即可\",{\"1\":{\"658\":1}}],[\"的余数是否为\",{\"1\":{\"642\":1}}],[\"的余数都减掉\",{\"1\":{\"553\":1}}],[\"的计算按照公式来就好\",{\"1\":{\"639\":1}}],[\"的计算方法一样\",{\"1\":{\"405\":1}}],[\"的阳光有多少种种植方案即可\",{\"1\":{\"629\":1}}],[\"的基础上\",{\"1\":{\"825\":1,\"846\":1,\"856\":1}}],[\"的基础上往后数\",{\"1\":{\"735\":1}}],[\"的基础上中间的位置只输出依次就好\",{\"1\":{\"614\":1}}],[\"的基础上开好\",{\"1\":{\"553\":1}}],[\"的话\",{\"1\":{\"611\":1,\"668\":2}}],[\"的话只需要关注数字发生了几次改变即可\",{\"1\":{\"545\":1}}],[\"的藤条\",{\"1\":{\"595\":1}}],[\"的正整数\",{\"1\":{\"620\":1}}],[\"的正方形\",{\"1\":{\"595\":1}}],[\"的正确输出是\",{\"1\":{\"351\":1}}],[\"的测试\",{\"1\":{\"585\":1}}],[\"的概率拿到满分\",{\"1\":{\"550\":1}}],[\"的美食之旅\",{\"0\":{\"545\":1}}],[\"的循环\",{\"1\":{\"533\":1}}],[\"的大小关系了\",{\"1\":{\"891\":1}}],[\"的大小关系就好\",{\"1\":{\"512\":2}}],[\"的大小不一定\",{\"1\":{\"524\":1,\"878\":1}}],[\"的是\",{\"1\":{\"503\":1}}],[\"的区间\",{\"1\":{\"495\":1}}],[\"的父子关系\",{\"1\":{\"494\":1}}],[\"的父节点\",{\"1\":{\"11\":1}}],[\"的遍历十进制每一位的小技巧\",{\"1\":{\"487\":1}}],[\"的枚举\",{\"1\":{\"484\":1,\"812\":2}}],[\"的枚举单词对\",{\"1\":{\"410\":1}}],[\"的精度不够\",{\"1\":{\"478\":1}}],[\"的用法\",{\"1\":{\"478\":1}}],[\"的代码求出\",{\"1\":{\"533\":1}}],[\"的代码\",{\"0\":{\"902\":1,\"906\":1,\"911\":1},\"1\":{\"465\":1}}],[\"的代码了\",{\"1\":{\"413\":1}}],[\"的比较函数是用来代替小于号\",{\"1\":{\"759\":1}}],[\"的比较\",{\"1\":{\"451\":1}}],[\"的比较改为\",{\"1\":{\"451\":1}}],[\"的范围之内\",{\"1\":{\"622\":1}}],[\"的范围的\",{\"1\":{\"451\":1}}],[\"的范围也跑的飞快\",{\"1\":{\"402\":1}}],[\"的模式\",{\"1\":{\"448\":1}}],[\"的询问次数\",{\"1\":{\"447\":1}}],[\"的缓冲区\",{\"1\":{\"445\":1}}],[\"的拓扑排序\",{\"1\":{\"444\":1}}],[\"的根\",{\"1\":{\"444\":1}}],[\"的倍数即可\",{\"1\":{\"856\":2}}],[\"的倍数时\",{\"1\":{\"812\":1}}],[\"的倍数的情况\",{\"1\":{\"661\":1}}],[\"的倍数或个位是\",{\"0\":{\"660\":1}}],[\"的倍数\",{\"1\":{\"437\":1,\"502\":1,\"595\":1,\"611\":1,\"661\":2,\"662\":2,\"668\":1,\"856\":2}}],[\"的倍数有\",{\"1\":{\"437\":2,\"661\":1,\"812\":1}}],[\"的倍数放入\",{\"1\":{\"170\":1}}],[\"的过程中\",{\"1\":{\"427\":1}}],[\"的因子\",{\"1\":{\"415\":1,\"904\":1}}],[\"的路程\",{\"1\":{\"414\":1}}],[\"的整数次幂\",{\"1\":{\"414\":2}}],[\"的表就容易发现这个结论是错的了\",{\"1\":{\"413\":1}}],[\"的结果与通过循环\",{\"1\":{\"503\":1}}],[\"的结果\",{\"1\":{\"413\":1,\"508\":2}}],[\"的答案\",{\"1\":{\"662\":1}}],[\"的答案一样\",{\"1\":{\"403\":1}}],[\"的答案等于前三个答案之和\",{\"1\":{\"402\":1}}],[\"的答案可以等价对应到\",{\"1\":{\"400\":1}}],[\"的值决定是否输出即可\",{\"1\":{\"541\":1}}],[\"的值决定输出\",{\"1\":{\"541\":1}}],[\"的值确认是否要\",{\"1\":{\"530\":1}}],[\"的值\",{\"1\":{\"399\":1,\"621\":1,\"658\":1}}],[\"的涂色方案数\",{\"1\":{\"383\":1,\"384\":1}}],[\"的点\",{\"1\":{\"366\":1}}],[\"的点一共有多少次\",{\"1\":{\"146\":1}}],[\"的点一共钓了多少次\",{\"1\":{\"146\":1}}],[\"的点一共钓了多少条\",{\"1\":{\"146\":1}}],[\"的时候有没有更快的做法\",{\"1\":{\"753\":1}}],[\"的时候只要给\",{\"1\":{\"494\":1}}],[\"的时候表示当前这轮访问过了\",{\"1\":{\"443\":1}}],[\"的时候不能也用变量\",{\"1\":{\"399\":1}}],[\"的时候的最小代价\",{\"1\":{\"354\":1,\"355\":1}}],[\"的时间描述法转换为只有分钟的\",{\"1\":{\"822\":1}}],[\"的时间是\",{\"1\":{\"202\":1,\"203\":1}}],[\"的时间最多钓多少条\",{\"1\":{\"147\":1}}],[\"的右边\",{\"1\":{\"351\":1}}],[\"的右边堆积了\",{\"1\":{\"351\":1}}],[\"的卡路里以内完成\",{\"1\":{\"340\":1}}],[\"的卡路里时\",{\"1\":{\"340\":1}}],[\"的板子\",{\"1\":{\"335\":1}}],[\"的总数即可\",{\"1\":{\"328\":1}}],[\"的总数就根据每个\",{\"1\":{\"328\":1}}],[\"的总数\",{\"1\":{\"328\":1}}],[\"的状态\",{\"1\":{\"306\":1}}],[\"的摆放方案数\",{\"1\":{\"306\":1}}],[\"的等差数列\",{\"0\":{\"547\":1}}],[\"的等差数列求和\",{\"1\":{\"169\":1}}],[\"的等差子序列方案数\",{\"1\":{\"303\":1}}],[\"的敌人对应的集合\",{\"1\":{\"251\":1}}],[\"的当前位置没超过范围\",{\"1\":{\"226\":1}}],[\"的客栈编号\",{\"1\":{\"225\":1,\"226\":1}}],[\"的连接关系\",{\"1\":{\"215\":1}}],[\"的后面\",{\"1\":{\"211\":1}}],[\"的合适位置\",{\"1\":{\"209\":2}}],[\"的暴力\",{\"0\":{\"208\":1}}],[\"的速度\",{\"1\":{\"198\":1}}],[\"的加速度\",{\"1\":{\"198\":1}}],[\"的初速度\",{\"1\":{\"198\":1}}],[\"的人被攻击了\",{\"1\":{\"197\":1}}],[\"的人全都被攻击了\",{\"1\":{\"197\":1}}],[\"的子节点\",{\"1\":{\"433\":1}}],[\"的子序列数量\",{\"1\":{\"302\":1}}],[\"的子序列\",{\"1\":{\"196\":4}}],[\"的子区间\",{\"1\":{\"19\":1,\"20\":1,\"21\":1}}],[\"的下标\",{\"1\":{\"192\":1}}],[\"的所有可能性\",{\"1\":{\"248\":1,\"249\":1}}],[\"的所有可能\",{\"1\":{\"184\":1}}],[\"的所有条数之和\",{\"1\":{\"146\":1}}],[\"的第\",{\"1\":{\"172\":1}}],[\"的位置时六个字符都找到了\",{\"1\":{\"504\":1}}],[\"的位置便能求得答案\",{\"1\":{\"504\":1}}],[\"的位置和最后一个\",{\"1\":{\"504\":1}}],[\"的位置中\",{\"1\":{\"397\":1}}],[\"的位置有马\",{\"1\":{\"306\":4}}],[\"的位置的时候是否会超速\",{\"1\":{\"198\":1}}],[\"的位置开始搜索\",{\"1\":{\"248\":1,\"249\":1}}],[\"的位置开始\",{\"1\":{\"198\":1}}],[\"的位置放入数组\",{\"1\":{\"182\":2}}],[\"的位置\",{\"1\":{\"168\":1,\"213\":1,\"230\":1,\"260\":2,\"312\":1,\"313\":1,\"436\":1,\"475\":1,\"556\":1,\"578\":1,\"671\":1}}],[\"的钓鱼点有无限次\",{\"1\":{\"146\":1}}],[\"的类型为\",{\"1\":{\"142\":1}}],[\"的数就是固定个位为\",{\"1\":{\"661\":1}}],[\"的数字永远无法超过\",{\"1\":{\"544\":1}}],[\"的数字游戏\",{\"0\":{\"544\":1,\"716\":1}}],[\"的数位和\",{\"1\":{\"534\":1}}],[\"的数位时也是没有问题的\",{\"1\":{\"91\":1}}],[\"的数的数量了\",{\"1\":{\"500\":1}}],[\"的数看作\",{\"1\":{\"500\":2}}],[\"的数有贡献\",{\"1\":{\"500\":1}}],[\"的数不少于\",{\"1\":{\"500\":1}}],[\"的数据范围保证了不需要使用\",{\"1\":{\"553\":1}}],[\"的数据范围就给了那么宽松的范围\",{\"1\":{\"480\":1}}],[\"的数据能保证\",{\"1\":{\"507\":1}}],[\"的数据保证\",{\"1\":{\"504\":1}}],[\"的数据\",{\"1\":{\"452\":1,\"622\":2}}],[\"的数中\",{\"1\":{\"437\":2}}],[\"的数组\",{\"1\":{\"422\":1}}],[\"的数\",{\"1\":{\"258\":1,\"298\":4,\"413\":2,\"462\":1,\"662\":1}}],[\"的数量乘以左边连续\",{\"1\":{\"498\":1}}],[\"的数量乘以后面\",{\"1\":{\"328\":1}}],[\"的数量即可\",{\"1\":{\"329\":1,\"884\":1}}],[\"的数量和后缀\",{\"1\":{\"329\":1}}],[\"的数量就好\",{\"1\":{\"329\":1}}],[\"的数量根据乘法原理就是它前面\",{\"1\":{\"328\":1}}],[\"的数量排序\",{\"1\":{\"182\":1}}],[\"的数量\",{\"1\":{\"131\":1,\"132\":1,\"162\":2,\"182\":1,\"228\":1,\"328\":1,\"440\":1,\"498\":1}}],[\"的费用时\",{\"1\":{\"127\":1}}],[\"的费用小于\",{\"1\":{\"127\":1}}],[\"的价值不需要重量能达到\",{\"1\":{\"362\":1}}],[\"的价值\",{\"1\":{\"361\":1}}],[\"的价值并且\",{\"1\":{\"127\":1}}],[\"的价值大于\",{\"1\":{\"127\":1}}],[\"的长度\",{\"1\":{\"126\":2}}],[\"的前缀和\",{\"1\":{\"169\":1}}],[\"的前\",{\"1\":{\"126\":1}}],[\"的前一个状态\",{\"1\":{\"125\":1}}],[\"的上一个元素下标\",{\"1\":{\"115\":1,\"116\":1}}],[\"的砖块密铺它\",{\"1\":{\"108\":1}}],[\"的队列\",{\"1\":{\"106\":1}}],[\"的栈\",{\"1\":{\"105\":1}}],[\"的引用\",{\"1\":{\"104\":2,\"105\":1,\"106\":2}}],[\"的双端队列\",{\"1\":{\"104\":1}}],[\"的元素\",{\"1\":{\"103\":1,\"104\":1}}],[\"的动态数组\",{\"1\":{\"103\":1}}],[\"的情况显而易见\",{\"1\":{\"909\":1}}],[\"的情况下\",{\"1\":{\"307\":1}}],[\"的情况\",{\"1\":{\"100\":1,\"435\":1,\"452\":1,\"661\":1,\"740\":1}}],[\"的解\",{\"0\":{\"41\":1},\"1\":{\"621\":1}}],[\"的问题答案\",{\"1\":{\"14\":1}}],[\"的最大子段和\",{\"1\":{\"493\":2}}],[\"的最大值\",{\"1\":{\"216\":1}}],[\"的最大路径和\",{\"1\":{\"177\":1}}],[\"的最小值\",{\"1\":{\"497\":1,\"525\":1}}],[\"的最小值的最小值\",{\"1\":{\"13\":1}}],[\"的最小结尾\",{\"1\":{\"113\":1,\"117\":1,\"122\":1,\"123\":1,\"233\":2}}],[\"的最近公共祖先\",{\"1\":{\"12\":1}}],[\"的深度\",{\"1\":{\"12\":1,\"13\":1}}],[\"的\",{\"0\":{\"546\":1,\"584\":1},\"1\":{\"11\":1,\"12\":3,\"113\":1,\"116\":1,\"117\":1,\"122\":1,\"123\":1,\"126\":1,\"182\":4,\"233\":2,\"236\":1,\"237\":1,\"239\":1,\"284\":1,\"306\":4,\"320\":4,\"326\":2,\"335\":2,\"402\":2,\"414\":1,\"475\":1,\"508\":2,\"759\":1,\"769\":1,\"825\":1,\"866\":1,\"887\":1,\"891\":1,\"904\":1}}],[\"的内容都会逐渐迁移到这里\",{\"1\":{\"0\":1}}],[\"59\",{\"0\":{\"699\":1}}],[\"5972\",{\"1\":{\"484\":1}}],[\"5861\",{\"1\":{\"484\":1}}],[\"580\",{\"1\":{\"484\":1}}],[\"5639\",{\"1\":{\"484\":1}}],[\"5615\",{\"1\":{\"484\":1}}],[\"5626ms\",{\"1\":{\"109\":1}}],[\"5474\",{\"1\":{\"484\":1}}],[\"5447\",{\"1\":{\"484\":1}}],[\"5415\",{\"1\":{\"484\":1}}],[\"542\",{\"1\":{\"484\":1}}],[\"5388\",{\"1\":{\"484\":1}}],[\"5356\",{\"1\":{\"484\":1}}],[\"5327\",{\"1\":{\"484\":1}}],[\"5+i\",{\"1\":{\"338\":1}}],[\"5123456\",{\"1\":{\"760\":1}}],[\"512\",{\"1\":{\"451\":1}}],[\"51\",{\"1\":{\"232\":1}}],[\"5292\",{\"1\":{\"484\":1}}],[\"5258\",{\"1\":{\"484\":1}}],[\"5228\",{\"1\":{\"484\":1}}],[\"5203\",{\"1\":{\"484\":1}}],[\"52\",{\"1\":{\"193\":4}}],[\"5>\",{\"1\":{\"158\":3,\"162\":1,\"444\":1}}],[\"5591\",{\"1\":{\"484\":1}}],[\"550000\",{\"1\":{\"156\":1,\"157\":1}}],[\"55\",{\"0\":{\"156\":1},\"1\":{\"177\":6,\"193\":1,\"224\":1,\"232\":8,\"505\":2,\"665\":1}}],[\"5750\",{\"1\":{\"484\":1}}],[\"57\",{\"1\":{\"93\":1}}],[\"5094\",{\"1\":{\"484\":1}}],[\"5069\",{\"1\":{\"484\":1}}],[\"5039\",{\"1\":{\"484\":1}}],[\"508\",{\"1\":{\"484\":1}}],[\"501\",{\"1\":{\"295\":4}}],[\"505\",{\"1\":{\"219\":2,\"295\":4,\"299\":4,\"426\":2,\"438\":4}}],[\"50\",{\"0\":{\"150\":1,\"184\":1,\"253\":1},\"1\":{\"79\":1,\"80\":1,\"232\":1,\"377\":2,\"907\":1}}],[\"50010\",{\"1\":{\"816\":1}}],[\"5005\",{\"1\":{\"118\":2,\"119\":3,\"128\":2,\"174\":2,\"275\":1,\"340\":2,\"419\":2,\"430\":3,\"432\":1,\"433\":2,\"436\":2,\"484\":1,\"499\":3,\"560\":1,\"832\":1}}],[\"500010\",{\"1\":{\"269\":1}}],[\"50000\",{\"1\":{\"235\":1,\"236\":1,\"237\":1,\"239\":1}}],[\"500000\",{\"1\":{\"11\":1,\"15\":1,\"17\":1,\"250\":2,\"258\":3,\"441\":1}}],[\"5000\",{\"1\":{\"112\":1,\"115\":1,\"126\":1,\"164\":1,\"221\":3,\"222\":5,\"432\":1,\"433\":2,\"495\":1}}],[\"500\",{\"1\":{\"12\":1,\"13\":1,\"126\":1,\"241\":1,\"242\":1,\"443\":1}}],[\"5\",{\"0\":{\"217\":1,\"820\":1},\"1\":{\"11\":4,\"12\":3,\"13\":4,\"14\":5,\"15\":1,\"17\":2,\"19\":3,\"20\":3,\"21\":4,\"23\":4,\"40\":6,\"41\":684,\"59\":4,\"63\":2,\"64\":1,\"109\":1,\"110\":1,\"112\":2,\"113\":3,\"115\":3,\"116\":4,\"117\":3,\"122\":5,\"123\":5,\"126\":4,\"129\":2,\"139\":1,\"140\":1,\"141\":2,\"142\":3,\"144\":5,\"146\":1,\"147\":6,\"148\":3,\"150\":4,\"151\":5,\"153\":2,\"158\":5,\"162\":3,\"164\":5,\"165\":3,\"166\":4,\"168\":1,\"169\":2,\"175\":4,\"176\":4,\"181\":1,\"182\":11,\"190\":1,\"191\":3,\"192\":4,\"193\":1,\"195\":5,\"196\":17,\"197\":6,\"198\":12,\"199\":11,\"204\":1,\"208\":2,\"209\":1,\"210\":1,\"213\":3,\"214\":2,\"215\":5,\"216\":3,\"218\":1,\"221\":2,\"222\":2,\"225\":3,\"226\":4,\"227\":13,\"228\":2,\"232\":1,\"233\":10,\"235\":1,\"236\":2,\"237\":3,\"239\":3,\"241\":6,\"242\":6,\"243\":2,\"244\":6,\"246\":1,\"248\":9,\"249\":9,\"250\":2,\"251\":2,\"258\":3,\"259\":6,\"262\":1,\"266\":5,\"267\":64,\"268\":1,\"278\":2,\"279\":2,\"282\":2,\"283\":3,\"284\":2,\"285\":2,\"291\":3,\"292\":3,\"295\":2,\"298\":2,\"302\":1,\"303\":2,\"305\":2,\"306\":2,\"307\":4,\"312\":6,\"313\":14,\"314\":8,\"317\":2,\"325\":2,\"329\":7,\"334\":1,\"336\":5,\"338\":5,\"340\":2,\"342\":2,\"347\":1,\"348\":2,\"349\":2,\"350\":1,\"351\":3,\"352\":2,\"354\":3,\"355\":2,\"356\":6,\"358\":3,\"362\":3,\"363\":2,\"365\":2,\"366\":4,\"369\":1,\"370\":1,\"372\":2,\"374\":1,\"375\":2,\"376\":4,\"378\":2,\"381\":2,\"383\":3,\"384\":5,\"391\":2,\"392\":2,\"393\":3,\"394\":2,\"395\":1,\"400\":1,\"402\":2,\"405\":2,\"410\":6,\"415\":5,\"418\":1,\"422\":2,\"423\":2,\"427\":4,\"428\":5,\"433\":1,\"437\":1,\"441\":1,\"443\":4,\"444\":12,\"453\":2,\"456\":1,\"457\":2,\"458\":2,\"462\":1,\"473\":2,\"475\":4,\"479\":1,\"485\":1,\"489\":1,\"490\":6,\"492\":3,\"493\":2,\"494\":3,\"495\":5,\"513\":2,\"516\":1,\"575\":2,\"627\":1,\"640\":1,\"656\":1,\"662\":2,\"675\":4,\"708\":1,\"718\":1,\"727\":1,\"732\":4,\"737\":1,\"770\":3,\"786\":2,\"799\":1,\"851\":1,\"872\":1,\"885\":1,\"906\":1,\"907\":1}}],[\"ul\",{\"1\":{\"911\":1}}],[\"ull\",{\"1\":{\"575\":1,\"576\":1}}],[\"ur\",{\"1\":{\"911\":1}}],[\"uh\",{\"1\":{\"519\":1}}],[\"up\",{\"1\":{\"260\":7,\"270\":2,\"301\":3,\"312\":3,\"313\":6,\"314\":3,\"378\":2,\"498\":7,\"605\":3}}],[\"upper\",{\"1\":{\"225\":1,\"298\":2,\"462\":1}}],[\"update\",{\"1\":{\"17\":4,\"19\":4,\"20\":4,\"21\":8,\"23\":4,\"216\":6,\"236\":3,\"237\":5,\"239\":5,\"258\":2,\"266\":3,\"291\":4,\"292\":4,\"312\":4,\"313\":8,\"314\":4,\"376\":2}}],[\"ui\",{\"1\":{\"164\":3}}],[\"usaco09oct\",{\"0\":{\"276\":1}}],[\"usaco07mar\",{\"0\":{\"275\":1}}],[\"usaco3\",{\"0\":{\"259\":1}}],[\"usaco18open\",{\"0\":{\"293\":1}}],[\"usaco12mar\",{\"0\":{\"277\":1}}],[\"usaco1\",{\"0\":{\"217\":1}}],[\"username为\",{\"1\":{\"70\":1}}],[\"username\",{\"1\":{\"70\":2,\"74\":3}}],[\"used\",{\"1\":{\"40\":7}}],[\"using\",{\"1\":{\"11\":1,\"12\":1,\"13\":1,\"14\":1,\"15\":1,\"17\":1,\"19\":1,\"20\":1,\"21\":1,\"23\":1,\"27\":1,\"29\":1,\"30\":1,\"31\":1,\"32\":1,\"40\":1,\"46\":1,\"47\":1,\"48\":1,\"49\":1,\"50\":1,\"52\":1,\"53\":1,\"54\":1,\"57\":1,\"59\":1,\"60\":1,\"61\":1,\"63\":3,\"64\":1,\"66\":1,\"70\":1,\"74\":1,\"109\":1,\"110\":1,\"111\":1,\"112\":1,\"113\":1,\"115\":1,\"116\":1,\"117\":1,\"118\":1,\"119\":1,\"120\":1,\"122\":1,\"123\":1,\"124\":1,\"125\":1,\"126\":1,\"127\":1,\"128\":1,\"129\":1,\"131\":1,\"132\":1,\"134\":1,\"135\":1,\"136\":1,\"137\":1,\"139\":1,\"140\":1,\"141\":1,\"142\":1,\"144\":1,\"146\":1,\"147\":1,\"148\":1,\"150\":1,\"151\":1,\"153\":1,\"154\":1,\"156\":1,\"157\":1,\"158\":1,\"160\":1,\"161\":1,\"162\":1,\"163\":1,\"164\":1,\"165\":1,\"166\":1,\"167\":1,\"168\":1,\"169\":1,\"170\":1,\"172\":1,\"173\":1,\"174\":1,\"175\":1,\"176\":1,\"177\":1,\"178\":1,\"179\":1,\"180\":1,\"181\":2,\"182\":2,\"184\":1,\"185\":1,\"186\":1,\"187\":1,\"188\":1,\"190\":1,\"191\":1,\"192\":1,\"193\":4,\"194\":1,\"195\":2,\"196\":5,\"197\":4,\"198\":3,\"199\":4,\"200\":1,\"202\":1,\"203\":1,\"204\":1,\"205\":2,\"208\":2,\"209\":1,\"210\":1,\"211\":1,\"213\":1,\"214\":1,\"215\":1,\"216\":2,\"217\":1,\"218\":1,\"219\":2,\"221\":1,\"222\":1,\"224\":1,\"225\":1,\"226\":1,\"227\":1,\"228\":1,\"230\":1,\"231\":1,\"232\":1,\"233\":2,\"235\":1,\"236\":1,\"237\":1,\"239\":1,\"241\":1,\"242\":1,\"243\":1,\"244\":2,\"245\":1,\"246\":1,\"248\":1,\"249\":1,\"250\":2,\"251\":1,\"253\":1,\"255\":1,\"256\":1,\"257\":1,\"258\":1,\"259\":1,\"260\":1,\"262\":1,\"263\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":2,\"268\":1,\"269\":1,\"270\":1,\"272\":1,\"273\":1,\"274\":1,\"275\":2,\"276\":2,\"278\":1,\"279\":1,\"280\":1,\"282\":1,\"283\":1,\"284\":1,\"285\":1,\"286\":2,\"287\":1,\"288\":1,\"289\":2,\"291\":1,\"292\":1,\"293\":1,\"295\":1,\"298\":2,\"299\":1,\"301\":1,\"302\":1,\"303\":1,\"305\":1,\"306\":1,\"307\":2,\"309\":1,\"310\":1,\"312\":1,\"313\":2,\"314\":1,\"317\":1,\"318\":1,\"319\":1,\"320\":3,\"321\":1,\"323\":1,\"324\":1,\"325\":1,\"326\":1,\"329\":1,\"331\":1,\"333\":1,\"334\":1,\"335\":1,\"336\":1,\"338\":1,\"340\":1,\"342\":1,\"343\":1,\"345\":1,\"347\":1,\"348\":1,\"349\":1,\"350\":1,\"351\":1,\"352\":1,\"354\":1,\"355\":1,\"356\":1,\"358\":1,\"359\":1,\"361\":1,\"362\":1,\"363\":1,\"365\":1,\"366\":1,\"367\":1,\"368\":1,\"369\":1,\"370\":1,\"371\":1,\"372\":1,\"373\":1,\"374\":1,\"375\":1,\"376\":1,\"377\":1,\"378\":1,\"379\":1,\"380\":1,\"381\":1,\"383\":1,\"384\":1,\"386\":1,\"388\":1,\"389\":1,\"391\":1,\"392\":1,\"393\":1,\"394\":1,\"395\":1,\"397\":1,\"399\":1,\"400\":1,\"402\":2,\"405\":1,\"410\":1,\"412\":1,\"413\":2,\"414\":1,\"415\":4,\"417\":1,\"418\":1,\"419\":1,\"421\":1,\"422\":1,\"423\":1,\"425\":1,\"426\":1,\"427\":1,\"428\":1,\"430\":1,\"431\":1,\"432\":1,\"433\":1,\"435\":1,\"436\":2,\"437\":1,\"438\":1,\"440\":1,\"441\":1,\"443\":1,\"444\":1,\"446\":1,\"447\":1,\"448\":1,\"450\":1,\"451\":1,\"452\":1,\"453\":1,\"455\":1,\"456\":1,\"457\":1,\"458\":1,\"460\":1,\"461\":1,\"462\":1,\"464\":1,\"465\":1,\"466\":1,\"467\":1,\"469\":1,\"470\":1,\"471\":1,\"473\":1,\"475\":1,\"477\":1,\"478\":1,\"479\":1,\"480\":1,\"482\":1,\"483\":1,\"484\":2,\"485\":1,\"487\":1,\"488\":1,\"489\":1,\"490\":1,\"492\":1,\"493\":1,\"494\":1,\"495\":1,\"497\":1,\"498\":1,\"499\":1,\"500\":1,\"502\":1,\"503\":1,\"504\":1,\"505\":1,\"507\":1,\"508\":1,\"509\":2,\"513\":1,\"516\":1,\"519\":1,\"522\":1,\"524\":1,\"525\":1,\"526\":1,\"531\":1,\"534\":1,\"535\":1,\"538\":1,\"539\":1,\"542\":1,\"544\":1,\"545\":1,\"546\":1,\"547\":1,\"551\":1,\"554\":1,\"557\":1,\"560\":1,\"562\":1,\"563\":1,\"564\":1,\"565\":1,\"569\":1,\"572\":1,\"575\":2,\"576\":2,\"579\":1,\"583\":1,\"586\":1,\"589\":1,\"592\":1,\"596\":1,\"599\":1,\"602\":1,\"605\":1,\"609\":1,\"612\":1,\"615\":1,\"618\":1,\"620\":1,\"621\":1,\"622\":1,\"623\":1,\"627\":1,\"630\":1,\"633\":1,\"636\":1,\"640\":1,\"643\":1,\"646\":1,\"649\":1,\"653\":1,\"656\":1,\"659\":1,\"662\":1,\"666\":1,\"669\":1,\"672\":1,\"675\":1,\"679\":1,\"682\":1,\"685\":1,\"688\":1,\"692\":1,\"695\":1,\"698\":1,\"701\":1,\"705\":1,\"708\":1,\"711\":1,\"714\":1,\"718\":1,\"721\":1,\"724\":1,\"727\":1,\"729\":1,\"730\":1,\"731\":1,\"732\":1,\"734\":1,\"735\":1,\"736\":1,\"737\":1,\"739\":1,\"740\":1,\"741\":1,\"742\":1,\"744\":1,\"745\":1,\"746\":1,\"747\":1,\"751\":1,\"754\":1,\"757\":1,\"760\":1,\"764\":1,\"767\":1,\"770\":1,\"773\":1,\"777\":1,\"780\":1,\"783\":1,\"786\":1,\"790\":1,\"793\":1,\"796\":1,\"799\":1,\"801\":1,\"803\":1,\"804\":1,\"805\":1,\"806\":1,\"810\":1,\"813\":1,\"816\":1,\"819\":1,\"823\":1,\"826\":1,\"829\":1,\"832\":1,\"836\":1,\"839\":1,\"843\":1,\"844\":1,\"847\":1,\"851\":1,\"854\":1,\"857\":1,\"860\":1,\"864\":1,\"868\":1,\"869\":1,\"872\":1,\"875\":1,\"879\":1,\"882\":1,\"885\":1,\"888\":1,\"892\":1,\"895\":1,\"898\":1,\"902\":1,\"906\":1,\"907\":1}}],[\"u++\",{\"1\":{\"11\":1,\"215\":1,\"444\":1,\"494\":1}}],[\"u\",{\"0\":{\"381\":1},\"1\":{\"11\":35,\"12\":28,\"13\":24,\"14\":20,\"15\":38,\"83\":2,\"163\":3,\"215\":21,\"228\":4,\"243\":3,\"268\":6,\"269\":13,\"295\":6,\"319\":21,\"331\":1,\"352\":11,\"365\":9,\"366\":10,\"375\":13,\"383\":18,\"384\":37,\"427\":7,\"428\":4,\"433\":11,\"436\":2,\"444\":35,\"494\":9}}],[\"unrank\",{\"0\":{\"814\":1}}],[\"unhappy=0\",{\"1\":{\"545\":1}}],[\"unhappy==1\",{\"1\":{\"545\":1}}],[\"unhappy==0\",{\"1\":{\"545\":1}}],[\"unhappy=1\",{\"1\":{\"545\":2}}],[\"unhappy\",{\"1\":{\"545\":1}}],[\"unique\",{\"1\":{\"258\":1,\"349\":2}}],[\"unsigned\",{\"1\":{\"3\":3,\"83\":2,\"414\":1,\"451\":6,\"457\":5,\"575\":1,\"576\":1}}],[\"unzip\",{\"1\":{\"3\":2}}],[\"祖先\",{\"0\":{\"11\":1}}],[\"预处理所有\",{\"1\":{\"658\":1}}],[\"预处理所有单行的合法状态\",{\"1\":{\"257\":1}}],[\"预处理出冲突数组\",{\"1\":{\"490\":1}}],[\"预处理深度\",{\"1\":{\"12\":1}}],[\"预处理\",{\"0\":{\"11\":1},\"1\":{\"109\":1,\"110\":1,\"196\":1,\"288\":1,\"320\":2,\"351\":1,\"475\":2}}],[\"个中取两个\",{\"1\":{\"742\":1}}],[\"个质数是\",{\"1\":{\"735\":1}}],[\"个质数\",{\"0\":{\"735\":1}}],[\"个朋友\",{\"1\":{\"726\":1}}],[\"个小时的课应该在\",{\"1\":{\"665\":1}}],[\"个小于等于\",{\"1\":{\"298\":2}}],[\"个了\",{\"1\":{\"500\":1}}],[\"个记一下当前的\",{\"1\":{\"484\":1}}],[\"个单人群就搞定了后两个规则\",{\"1\":{\"480\":1}}],[\"个群才能和其他人建立联系\",{\"1\":{\"480\":1}}],[\"个群\",{\"1\":{\"480\":2}}],[\"个敌人的战斗力之和\",{\"1\":{\"475\":1}}],[\"个是谁\",{\"1\":{\"475\":1}}],[\"个分界点然后二分\",{\"1\":{\"458\":1}}],[\"个方向的下标变化\",{\"1\":{\"505\":1}}],[\"个方向可以延伸\",{\"1\":{\"505\":1}}],[\"个方向可以延伸出去\",{\"1\":{\"505\":1}}],[\"个方案能\",{\"1\":{\"404\":1}}],[\"个方格的消失时间\",{\"1\":{\"342\":1}}],[\"个女生\",{\"1\":{\"374\":1}}],[\"个男生和谁组合\",{\"1\":{\"374\":1}}],[\"个的次数\",{\"1\":{\"742\":1}}],[\"个的概率\",{\"1\":{\"368\":1}}],[\"个的维生素量\",{\"1\":{\"340\":1}}],[\"个硬币\",{\"1\":{\"368\":1}}],[\"个数除以\",{\"1\":{\"904\":1}}],[\"个数是一样的\",{\"1\":{\"838\":1}}],[\"个数\",{\"1\":{\"301\":2,\"485\":1,\"735\":2,\"806\":1}}],[\"个数选不选\",{\"1\":{\"298\":1}}],[\"个数的最大值\",{\"1\":{\"216\":2}}],[\"个相同的需要改一个位置\",{\"1\":{\"286\":4}}],[\"个骑士和王去接王点\",{\"1\":{\"259\":1}}],[\"个骑士的贡献\",{\"1\":{\"259\":1}}],[\"个九宫格有没有数字\",{\"1\":{\"249\":1}}],[\"个包裹接收时间段\",{\"1\":{\"244\":2}}],[\"个点\",{\"1\":{\"427\":1}}],[\"个点被摧毁时的状态\",{\"1\":{\"215\":1}}],[\"个点之后\",{\"1\":{\"215\":1}}],[\"个点的树\",{\"1\":{\"10\":1}}],[\"个星球都被摧毁之后的状态\",{\"1\":{\"215\":1}}],[\"个垃圾\",{\"1\":{\"202\":1,\"203\":1,\"204\":1}}],[\"个任务\",{\"1\":{\"196\":4}}],[\"个人比自己实力低\",{\"1\":{\"779\":3}}],[\"个人还是很推荐第二种方法\",{\"1\":{\"574\":1}}],[\"个人即可\",{\"1\":{\"559\":1}}],[\"个人会影响到\",{\"1\":{\"499\":1}}],[\"个人选\",{\"1\":{\"499\":1}}],[\"个人和\",{\"1\":{\"374\":1}}],[\"个人的攻击力为\",{\"1\":{\"197\":1}}],[\"个人的词库\",{\"1\":{\"196\":4}}],[\"个人可以从\",{\"1\":{\"196\":1}}],[\"个人接到\",{\"1\":{\"196\":1}}],[\"个人\",{\"1\":{\"196\":4,\"251\":2,\"499\":1}}],[\"个火柴棒\",{\"1\":{\"195\":1}}],[\"个字母了\",{\"1\":{\"187\":1}}],[\"个字符串有没有和第二行的那个字符串一样的即可\",{\"1\":{\"815\":1}}],[\"个字符输入配合条件判断即可\",{\"1\":{\"568\":1}}],[\"个字符到\",{\"1\":{\"509\":2}}],[\"个字符\",{\"1\":{\"126\":1,\"187\":2,\"509\":2}}],[\"个能否达到\",{\"1\":{\"181\":2}}],[\"个规则\",{\"1\":{\"179\":1}}],[\"个互补串\",{\"1\":{\"160\":3}}],[\"个当前串\",{\"1\":{\"160\":1}}],[\"个都按完了\",{\"1\":{\"154\":1}}],[\"个\",{\"1\":{\"139\":2,\"140\":2,\"160\":3,\"197\":1,\"257\":1,\"340\":1,\"397\":4,\"427\":1,\"437\":3,\"453\":2,\"457\":1,\"484\":1,\"499\":1,\"560\":1,\"661\":1,\"705\":1,\"812\":1}}],[\"个元素的\",{\"1\":{\"120\":1,\"124\":1,\"125\":1}}],[\"个元素与\",{\"1\":{\"120\":1,\"124\":1,\"125\":1}}],[\"个元素中的最小值下标\",{\"1\":{\"13\":1}}],[\"个动态数组\",{\"1\":{\"103\":1}}],[\"个位又是\",{\"1\":{\"661\":1}}],[\"个位是\",{\"1\":{\"648\":1,\"661\":1,\"662\":2}}],[\"个位置就可以由一只猫咪监控到\",{\"1\":{\"497\":1}}],[\"个位置区间和是否大于\",{\"1\":{\"196\":1}}],[\"个位置是否匹配规则\",{\"1\":{\"179\":1}}],[\"个位置需要是\",{\"1\":{\"173\":1}}],[\"个位置\",{\"1\":{\"109\":1,\"110\":1,\"154\":1,\"497\":1}}],[\"个位\",{\"1\":{\"97\":1,\"507\":1}}],[\"个询问\",{\"1\":{\"10\":1}}],[\"例如\",{\"1\":{\"740\":1}}],[\"例5\",{\"0\":{\"308\":1}}],[\"例题\",{\"0\":{\"10\":1}}],[\"例子\",{\"0\":{\"4\":1}}],[\"一直在提醒大家要注意算数据范围\",{\"1\":{\"894\":1}}],[\"一道非常简单的排序题\",{\"0\":{\"758\":1}}],[\"一正一负\",{\"1\":{\"622\":1}}],[\"一负一正\",{\"1\":{\"622\":1}}],[\"一维分形图\",{\"0\":{\"616\":1}}],[\"一维数组\",{\"0\":{\"222\":1}}],[\"一一判断\",{\"1\":{\"578\":1}}],[\"一一比对可能是哪些即可\",{\"1\":{\"578\":1}}],[\"一旦出现了输入的某一位是\",{\"1\":{\"578\":1}}],[\"一旦碰到墙就停止\",{\"1\":{\"509\":1}}],[\"一天天模拟\",{\"1\":{\"572\":1}}],[\"一致\",{\"1\":{\"556\":1}}],[\"一样就好\",{\"1\":{\"556\":1}}],[\"一位数位和\",{\"1\":{\"533\":1}}],[\"一定是大于等于\",{\"1\":{\"620\":1}}],[\"一定是\",{\"1\":{\"502\":1}}],[\"一定要注意\",{\"1\":{\"478\":1}}],[\"一个比较关键的数据规模是\",{\"1\":{\"900\":1}}],[\"一个比较经典的二分套路\",{\"1\":{\"500\":1}}],[\"一个一个人看过去\",{\"1\":{\"559\":1}}],[\"一个凑数的子任务\",{\"1\":{\"556\":1}}],[\"一个是要用\",{\"1\":{\"478\":1}}],[\"一个简单的树上搜索\",{\"1\":{\"433\":1}}],[\"一半的空间byte\",{\"1\":{\"451\":1}}],[\"一种是修改上面的代码套一层\",{\"1\":{\"413\":1}}],[\"一种写法\",{\"0\":{\"7\":1}}],[\"一次两步过去\",{\"1\":{\"405\":1}}],[\"一场都不看的特判\",{\"1\":{\"298\":2}}],[\"一开始认为所有位置都有树\",{\"1\":{\"832\":1}}],[\"一开始认为全都是\",{\"1\":{\"285\":1}}],[\"一开始就要看完四道题目再来决定时间分配\",{\"1\":{\"438\":1}}],[\"一开始就不超速\",{\"1\":{\"198\":1}}],[\"一开始就超速\",{\"1\":{\"198\":1}}],[\"一共上了\",{\"1\":{\"884\":1}}],[\"一共\",{\"1\":{\"668\":1}}],[\"一共十个点\",{\"1\":{\"585\":1}}],[\"一共这么多\",{\"1\":{\"560\":1}}],[\"一共有\",{\"1\":{\"257\":1,\"404\":1}}],[\"一共变了\",{\"1\":{\"160\":2}}],[\"一些单词\",{\"0\":{\"47\":1}}],[\"一般会直接读进来一个\",{\"1\":{\"478\":1}}],[\"一般常见的思路是看结尾或者看中间的位置\",{\"1\":{\"328\":1}}],[\"一般不常用\",{\"0\":{\"283\":1}}],[\"一般情况\",{\"1\":{\"83\":1}}],[\"一般来说会标记永久化\",{\"1\":{\"22\":1}}],[\"一般用来输出\",{\"1\":{\"3\":1}}],[\"n=1\",{\"1\":{\"907\":2}}],[\"n=a\",{\"1\":{\"843\":1}}],[\"n=n\",{\"1\":{\"509\":1}}],[\"n3\",{\"1\":{\"618\":6}}],[\"npos\",{\"1\":{\"546\":1,\"575\":1,\"576\":2}}],[\"n^2\",{\"1\":{\"320\":1,\"413\":1}}],[\"n^timint\",{\"1\":{\"287\":1}}],[\"nfnfnfnf\",{\"1\":{\"286\":2}}],[\"nineteen\",{\"1\":{\"246\":1}}],[\"nine\",{\"1\":{\"246\":1}}],[\"nb\",{\"1\":{\"227\":4}}],[\"nam\",{\"1\":{\"456\":7}}],[\"name+space\",{\"1\":{\"47\":1}}],[\"namespace\",{\"1\":{\"11\":1,\"12\":1,\"13\":1,\"14\":1,\"15\":1,\"17\":1,\"19\":1,\"20\":1,\"21\":1,\"23\":1,\"27\":1,\"29\":1,\"30\":1,\"31\":1,\"32\":1,\"40\":1,\"46\":1,\"47\":1,\"48\":1,\"49\":1,\"50\":1,\"52\":1,\"53\":1,\"54\":1,\"57\":1,\"59\":1,\"60\":1,\"61\":1,\"63\":3,\"64\":1,\"66\":1,\"70\":1,\"74\":1,\"109\":1,\"110\":1,\"111\":1,\"112\":1,\"113\":1,\"115\":1,\"116\":1,\"117\":1,\"118\":1,\"119\":1,\"120\":1,\"122\":1,\"123\":1,\"124\":1,\"125\":1,\"126\":1,\"127\":1,\"128\":1,\"129\":1,\"131\":1,\"132\":1,\"134\":1,\"135\":1,\"136\":1,\"137\":1,\"139\":1,\"140\":1,\"141\":1,\"142\":1,\"144\":1,\"146\":1,\"147\":1,\"148\":1,\"150\":1,\"151\":1,\"153\":1,\"154\":1,\"156\":1,\"157\":1,\"158\":1,\"160\":1,\"161\":1,\"162\":1,\"163\":1,\"164\":1,\"165\":1,\"166\":1,\"167\":1,\"168\":1,\"169\":1,\"170\":1,\"172\":1,\"173\":1,\"174\":1,\"175\":1,\"176\":1,\"177\":1,\"178\":1,\"179\":1,\"180\":1,\"181\":2,\"182\":2,\"184\":1,\"185\":1,\"186\":1,\"187\":1,\"188\":1,\"190\":1,\"191\":1,\"192\":1,\"193\":4,\"194\":1,\"195\":2,\"196\":5,\"197\":4,\"198\":3,\"199\":4,\"200\":1,\"202\":1,\"203\":1,\"204\":1,\"205\":2,\"208\":2,\"209\":1,\"210\":1,\"211\":1,\"213\":1,\"214\":1,\"215\":1,\"216\":3,\"217\":1,\"218\":1,\"219\":2,\"221\":1,\"222\":1,\"224\":1,\"225\":1,\"226\":1,\"227\":1,\"228\":1,\"230\":1,\"231\":1,\"232\":1,\"233\":2,\"235\":1,\"236\":1,\"237\":1,\"239\":1,\"241\":1,\"242\":1,\"243\":1,\"244\":2,\"245\":1,\"246\":1,\"248\":1,\"249\":1,\"250\":2,\"251\":1,\"253\":1,\"255\":1,\"256\":1,\"257\":1,\"258\":1,\"259\":1,\"260\":1,\"262\":1,\"263\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":2,\"268\":1,\"269\":1,\"270\":1,\"272\":1,\"273\":1,\"274\":1,\"275\":2,\"276\":2,\"278\":1,\"279\":1,\"280\":1,\"282\":1,\"283\":1,\"284\":1,\"285\":1,\"286\":2,\"287\":1,\"288\":1,\"289\":2,\"291\":1,\"292\":1,\"293\":1,\"295\":1,\"298\":2,\"299\":1,\"301\":1,\"302\":1,\"303\":1,\"305\":1,\"306\":1,\"307\":2,\"309\":1,\"310\":1,\"312\":1,\"313\":2,\"314\":1,\"317\":1,\"318\":1,\"319\":1,\"320\":3,\"321\":1,\"323\":1,\"324\":1,\"325\":1,\"326\":1,\"329\":1,\"331\":1,\"333\":1,\"334\":1,\"335\":1,\"336\":1,\"338\":1,\"340\":1,\"342\":1,\"343\":1,\"345\":1,\"347\":1,\"348\":1,\"349\":1,\"350\":1,\"351\":1,\"352\":1,\"354\":1,\"355\":1,\"356\":1,\"358\":1,\"359\":1,\"361\":1,\"362\":1,\"363\":1,\"365\":1,\"366\":1,\"367\":1,\"368\":1,\"369\":1,\"370\":1,\"371\":1,\"372\":1,\"373\":1,\"374\":1,\"375\":1,\"376\":1,\"377\":1,\"378\":1,\"379\":1,\"380\":1,\"381\":1,\"383\":1,\"384\":1,\"386\":1,\"388\":1,\"389\":1,\"391\":1,\"392\":1,\"393\":1,\"394\":1,\"395\":1,\"397\":1,\"399\":1,\"400\":1,\"402\":2,\"405\":1,\"410\":1,\"412\":1,\"413\":2,\"414\":1,\"415\":4,\"417\":1,\"418\":1,\"419\":1,\"421\":1,\"422\":1,\"423\":1,\"425\":1,\"426\":1,\"427\":1,\"428\":1,\"430\":1,\"431\":1,\"432\":1,\"433\":1,\"435\":1,\"436\":2,\"437\":1,\"438\":1,\"440\":1,\"441\":1,\"443\":1,\"444\":1,\"446\":1,\"447\":1,\"448\":1,\"450\":1,\"451\":1,\"452\":1,\"453\":1,\"455\":1,\"456\":1,\"457\":1,\"458\":1,\"460\":1,\"461\":1,\"462\":1,\"464\":1,\"465\":1,\"466\":1,\"467\":1,\"469\":1,\"470\":1,\"471\":1,\"473\":1,\"475\":1,\"477\":1,\"478\":1,\"479\":1,\"480\":1,\"482\":1,\"483\":1,\"484\":2,\"485\":1,\"487\":1,\"488\":1,\"489\":1,\"490\":1,\"492\":1,\"493\":1,\"494\":1,\"495\":1,\"497\":1,\"498\":1,\"499\":1,\"500\":1,\"502\":1,\"503\":1,\"504\":1,\"505\":1,\"507\":1,\"508\":1,\"509\":2,\"513\":1,\"516\":1,\"519\":1,\"522\":1,\"524\":1,\"525\":1,\"526\":1,\"531\":1,\"534\":1,\"535\":1,\"538\":1,\"539\":1,\"542\":1,\"544\":1,\"545\":1,\"546\":1,\"547\":1,\"551\":1,\"554\":1,\"557\":1,\"560\":1,\"562\":1,\"563\":1,\"564\":1,\"565\":1,\"569\":1,\"572\":1,\"575\":2,\"576\":2,\"579\":1,\"583\":1,\"586\":1,\"589\":1,\"592\":1,\"596\":1,\"599\":1,\"602\":1,\"605\":1,\"609\":1,\"612\":1,\"615\":1,\"618\":1,\"620\":1,\"621\":1,\"622\":1,\"623\":1,\"627\":1,\"630\":1,\"633\":1,\"636\":1,\"640\":1,\"643\":1,\"646\":1,\"649\":1,\"653\":1,\"656\":1,\"659\":1,\"662\":1,\"666\":1,\"669\":1,\"672\":1,\"675\":1,\"679\":1,\"682\":1,\"685\":1,\"688\":1,\"692\":1,\"695\":1,\"698\":1,\"701\":1,\"705\":1,\"708\":1,\"711\":1,\"714\":1,\"718\":1,\"721\":1,\"724\":1,\"727\":1,\"729\":1,\"730\":1,\"731\":1,\"732\":1,\"734\":1,\"735\":1,\"736\":1,\"737\":1,\"739\":1,\"740\":1,\"741\":1,\"742\":1,\"744\":1,\"745\":1,\"746\":1,\"747\":1,\"751\":1,\"754\":1,\"757\":1,\"760\":1,\"764\":1,\"767\":1,\"770\":1,\"773\":1,\"777\":1,\"780\":1,\"783\":1,\"786\":1,\"790\":1,\"793\":1,\"796\":1,\"799\":1,\"801\":1,\"803\":1,\"804\":1,\"805\":1,\"806\":1,\"810\":1,\"813\":1,\"816\":1,\"819\":1,\"823\":1,\"826\":1,\"829\":1,\"832\":1,\"836\":1,\"839\":1,\"843\":1,\"844\":1,\"847\":1,\"851\":1,\"854\":1,\"857\":1,\"860\":1,\"864\":1,\"868\":1,\"869\":1,\"872\":1,\"875\":1,\"879\":1,\"882\":1,\"885\":1,\"888\":1,\"892\":1,\"895\":1,\"898\":1,\"902\":1,\"906\":1,\"907\":1}}],[\"na\",{\"1\":{\"227\":4}}],[\"neg\",{\"1\":{\"685\":4}}],[\"next\",{\"1\":{\"184\":1,\"417\":1}}],[\"new\",{\"0\":{\"333\":1},\"1\":{\"455\":5}}],[\"newvalue\",{\"1\":{\"40\":4}}],[\"newexpr\",{\"1\":{\"40\":4}}],[\"newsign\",{\"1\":{\"3\":3}}],[\"n++\",{\"1\":{\"179\":1,\"232\":1,\"575\":2,\"907\":1}}],[\"n+m\",{\"1\":{\"124\":1,\"164\":1}}],[\"nyynnyy\",{\"1\":{\"579\":1}}],[\"nyynnnn\",{\"1\":{\"579\":1}}],[\"ny\",{\"1\":{\"167\":10,\"200\":7,\"241\":13,\"259\":6,\"267\":6,\"336\":7,\"421\":7,\"422\":7,\"423\":9,\"438\":6}}],[\"nx\",{\"1\":{\"167\":10,\"200\":7,\"241\":13,\"259\":6,\"267\":6,\"336\":7,\"421\":7,\"422\":7,\"423\":9,\"438\":6}}],[\"nxt4\",{\"1\":{\"329\":7}}],[\"nxt0\",{\"1\":{\"329\":5}}],[\"nxtt\",{\"1\":{\"283\":7,\"321\":8}}],[\"nxtp\",{\"1\":{\"283\":8}}],[\"nxty\",{\"1\":{\"248\":6,\"249\":6,\"276\":5}}],[\"nxtx++\",{\"1\":{\"248\":1,\"249\":1}}],[\"nxtx\",{\"1\":{\"248\":4,\"249\":4,\"276\":5}}],[\"nxtf\",{\"1\":{\"127\":1}}],[\"nxt\",{\"1\":{\"109\":7,\"110\":10,\"127\":12,\"158\":13,\"170\":6,\"196\":2,\"228\":2,\"230\":4,\"231\":24,\"242\":3,\"282\":10,\"283\":2,\"284\":10,\"321\":6,\"329\":6,\"391\":8,\"402\":7,\"435\":10,\"499\":6}}],[\"n1\",{\"1\":{\"165\":2,\"410\":1}}],[\"num++\",{\"1\":{\"646\":1}}],[\"numbers\",{\"0\":{\"335\":1}}],[\"number\",{\"1\":{\"274\":9,\"718\":2}}],[\"num2\",{\"1\":{\"160\":11}}],[\"num1\",{\"1\":{\"160\":7}}],[\"num\",{\"1\":{\"146\":5,\"147\":4,\"161\":5,\"184\":8,\"185\":9,\"186\":12,\"187\":19,\"195\":2,\"196\":10,\"228\":6,\"270\":7,\"272\":8,\"288\":3,\"307\":13,\"335\":12,\"392\":6,\"453\":8,\"464\":3,\"465\":3,\"466\":3,\"467\":3,\"478\":2,\"479\":3,\"488\":4,\"534\":3,\"560\":5,\"646\":2,\"675\":22,\"682\":5,\"688\":9,\"714\":5,\"770\":3,\"805\":5,\"875\":3}}],[\"numss\",{\"1\":{\"160\":2}}],[\"nums\",{\"1\":{\"40\":9,\"160\":2}}],[\"normal\",{\"1\":{\"850\":1,\"851\":1}}],[\"no2==1\",{\"1\":{\"545\":3}}],[\"no2==0\",{\"1\":{\"545\":1}}],[\"no2=1\",{\"1\":{\"545\":1}}],[\"no2\",{\"1\":{\"545\":1}}],[\"no++\",{\"1\":{\"492\":1}}],[\"november\",{\"1\":{\"455\":1}}],[\"noi\",{\"1\":{\"415\":1}}],[\"noip\",{\"0\":{\"176\":1}}],[\"noip2007\",{\"0\":{\"188\":1}}],[\"noip2004\",{\"0\":{\"183\":1}}],[\"noip2009\",{\"0\":{\"182\":1}}],[\"noip2002\",{\"0\":{\"179\":1,\"180\":1}}],[\"noip2000\",{\"0\":{\"178\":1}}],[\"noip2008\",{\"0\":{\"177\":1}}],[\"noip2018\",{\"0\":{\"307\":1}}],[\"noip2017\",{\"0\":{\"287\":1,\"288\":1}}],[\"noip2015\",{\"0\":{\"274\":1}}],[\"noip2010\",{\"0\":{\"240\":1}}],[\"noip2014\",{\"0\":{\"227\":1,\"260\":1}}],[\"noip2011\",{\"0\":{\"175\":1,\"223\":1}}],[\"noip2016\",{\"0\":{\"163\":1}}],[\"noip2024模拟赛t2\",{\"0\":{\"171\":1}}],[\"noip2024模拟赛t1\",{\"0\":{\"170\":1}}],[\"noi2014\",{\"0\":{\"164\":1,\"165\":1}}],[\"no\",{\"1\":{\"76\":1,\"129\":1,\"131\":1,\"132\":1,\"168\":3,\"179\":1,\"285\":1,\"287\":1,\"289\":2,\"295\":1,\"307\":11,\"323\":1,\"326\":1,\"342\":1,\"345\":1,\"409\":1,\"410\":2,\"451\":1,\"471\":1,\"488\":1,\"492\":3,\"525\":1,\"526\":2,\"546\":1,\"557\":2,\"562\":3,\"565\":2,\"569\":1,\"575\":4,\"576\":3,\"589\":1,\"675\":6,\"734\":1,\"773\":1,\"801\":1}}],[\"notp\",{\"1\":{\"415\":6}}],[\"not\",{\"0\":{\"192\":1,\"350\":1},\"1\":{\"73\":1,\"81\":1,\"912\":1}}],[\"now=i\",{\"1\":{\"804\":1}}],[\"nowlen\",{\"1\":{\"410\":4}}],[\"nowb++\",{\"1\":{\"324\":1}}],[\"nowb\",{\"1\":{\"324\":5}}],[\"nowp\",{\"1\":{\"268\":25}}],[\"nowidx\",{\"1\":{\"248\":3}}],[\"nowa++\",{\"1\":{\"324\":1}}],[\"nowa\",{\"1\":{\"324\":5,\"413\":3,\"754\":2}}],[\"nowadd\",{\"1\":{\"187\":3}}],[\"nowans++\",{\"1\":{\"215\":1}}],[\"nowans\",{\"1\":{\"161\":6,\"215\":6}}],[\"nowcode\",{\"1\":{\"410\":4}}],[\"nowcol\",{\"1\":{\"162\":11}}],[\"nowc\",{\"1\":{\"318\":4}}],[\"nowcnt++\",{\"1\":{\"579\":1}}],[\"nowcnt\",{\"1\":{\"161\":7,\"579\":2}}],[\"nowd\",{\"1\":{\"156\":5,\"157\":5,\"754\":2}}],[\"now++\",{\"1\":{\"151\":1,\"165\":3,\"200\":1,\"270\":1,\"273\":1,\"275\":1,\"378\":1,\"412\":1,\"440\":1,\"504\":1,\"736\":1,\"804\":1,\"832\":1}}],[\"nowy++\",{\"1\":{\"318\":1}}],[\"nowy\",{\"1\":{\"140\":2,\"164\":5,\"248\":5,\"249\":12,\"318\":10}}],[\"nowx++\",{\"1\":{\"318\":3}}],[\"nowx\",{\"1\":{\"140\":2,\"164\":5,\"248\":6,\"249\":13,\"318\":10}}],[\"now|a\",{\"1\":{\"139\":1,\"140\":1}}],[\"noww\",{\"1\":{\"127\":2}}],[\"nowt\",{\"1\":{\"127\":3,\"268\":19}}],[\"nowf\",{\"1\":{\"127\":1}}],[\"now\",{\"1\":{\"5\":4,\"17\":18,\"18\":4,\"19\":37,\"20\":21,\"21\":74,\"23\":17,\"24\":5,\"127\":12,\"139\":10,\"140\":8,\"142\":12,\"144\":3,\"146\":2,\"147\":4,\"148\":4,\"150\":3,\"151\":3,\"153\":4,\"156\":4,\"157\":6,\"158\":20,\"160\":16,\"161\":4,\"162\":12,\"163\":4,\"164\":2,\"165\":36,\"166\":3,\"167\":4,\"169\":4,\"170\":9,\"173\":7,\"178\":6,\"179\":8,\"182\":22,\"184\":3,\"185\":7,\"186\":4,\"187\":11,\"195\":5,\"196\":13,\"197\":6,\"199\":20,\"200\":3,\"202\":10,\"203\":10,\"211\":3,\"216\":36,\"219\":22,\"221\":4,\"222\":8,\"227\":3,\"228\":7,\"230\":5,\"231\":14,\"237\":40,\"239\":45,\"241\":5,\"242\":3,\"259\":11,\"267\":5,\"270\":14,\"273\":9,\"275\":7,\"276\":5,\"291\":28,\"292\":20,\"298\":19,\"301\":10,\"302\":8,\"306\":8,\"312\":21,\"313\":39,\"314\":18,\"320\":6,\"335\":2,\"340\":3,\"342\":6,\"343\":5,\"345\":4,\"378\":5,\"392\":2,\"393\":5,\"395\":4,\"402\":3,\"410\":3,\"412\":2,\"421\":5,\"422\":5,\"423\":7,\"432\":3,\"440\":11,\"443\":3,\"444\":3,\"451\":4,\"457\":3,\"479\":3,\"485\":11,\"487\":2,\"489\":3,\"490\":4,\"500\":2,\"504\":4,\"527\":6,\"534\":9,\"538\":3,\"560\":3,\"586\":3,\"599\":15,\"659\":6,\"736\":3,\"741\":10,\"747\":6,\"754\":3,\"812\":4,\"832\":4}}],[\"nworld\",{\"1\":{\"54\":1}}],[\"nhello\",{\"1\":{\"54\":1}}],[\"nn++\",{\"1\":{\"347\":1}}],[\"nn\",{\"1\":{\"11\":5,\"298\":15,\"347\":2,\"348\":3,\"349\":3,\"359\":13,\"499\":6,\"793\":2}}],[\"n\",{\"0\":{\"373\":1,\"735\":1},\"1\":{\"5\":3,\"11\":6,\"12\":6,\"13\":4,\"14\":5,\"15\":4,\"17\":7,\"19\":7,\"20\":7,\"21\":8,\"23\":5,\"24\":1,\"27\":6,\"29\":6,\"30\":5,\"31\":4,\"32\":5,\"52\":2,\"53\":2,\"57\":4,\"59\":1,\"60\":1,\"61\":1,\"63\":3,\"64\":1,\"66\":2,\"78\":3,\"109\":6,\"110\":6,\"111\":9,\"112\":4,\"113\":6,\"115\":5,\"116\":7,\"117\":6,\"118\":4,\"119\":5,\"120\":5,\"122\":11,\"123\":10,\"124\":5,\"125\":12,\"126\":9,\"127\":5,\"128\":7,\"131\":2,\"132\":2,\"137\":27,\"139\":6,\"140\":6,\"141\":6,\"142\":1,\"144\":5,\"146\":5,\"147\":5,\"148\":6,\"150\":8,\"151\":8,\"153\":7,\"154\":7,\"156\":5,\"157\":5,\"158\":9,\"160\":9,\"161\":7,\"162\":27,\"163\":8,\"164\":12,\"165\":10,\"166\":7,\"167\":9,\"168\":10,\"169\":3,\"170\":5,\"172\":3,\"173\":6,\"174\":9,\"175\":4,\"176\":3,\"177\":8,\"178\":7,\"179\":6,\"180\":4,\"181\":20,\"184\":10,\"185\":11,\"186\":11,\"187\":18,\"190\":4,\"191\":5,\"192\":7,\"193\":15,\"194\":6,\"195\":25,\"196\":33,\"197\":18,\"198\":16,\"199\":25,\"200\":6,\"203\":1,\"208\":10,\"209\":6,\"210\":5,\"211\":6,\"213\":12,\"214\":11,\"215\":7,\"216\":2,\"217\":6,\"218\":4,\"219\":4,\"221\":12,\"222\":4,\"224\":5,\"225\":5,\"226\":5,\"227\":3,\"228\":3,\"230\":4,\"232\":10,\"233\":21,\"235\":6,\"236\":9,\"237\":13,\"239\":13,\"241\":14,\"242\":10,\"243\":6,\"244\":8,\"245\":5,\"248\":1,\"249\":1,\"250\":8,\"251\":11,\"253\":5,\"255\":4,\"256\":7,\"257\":7,\"258\":11,\"260\":11,\"262\":5,\"263\":5,\"264\":5,\"265\":8,\"266\":6,\"267\":1,\"268\":7,\"269\":9,\"270\":1,\"272\":12,\"273\":3,\"274\":5,\"275\":13,\"276\":14,\"278\":5,\"279\":5,\"280\":8,\"282\":3,\"283\":1,\"284\":1,\"285\":10,\"286\":10,\"287\":3,\"288\":5,\"289\":12,\"291\":7,\"292\":7,\"293\":5,\"295\":8,\"298\":8,\"299\":8,\"301\":5,\"302\":6,\"303\":5,\"305\":6,\"306\":1,\"307\":14,\"309\":6,\"310\":7,\"312\":6,\"313\":10,\"314\":4,\"317\":4,\"319\":8,\"320\":18,\"321\":3,\"323\":6,\"324\":7,\"325\":6,\"326\":5,\"329\":11,\"331\":3,\"334\":4,\"335\":1,\"340\":3,\"342\":5,\"343\":4,\"345\":3,\"347\":7,\"348\":4,\"349\":6,\"350\":4,\"351\":7,\"352\":5,\"354\":5,\"355\":5,\"356\":7,\"358\":4,\"359\":5,\"361\":5,\"362\":4,\"365\":4,\"366\":4,\"367\":5,\"368\":6,\"369\":16,\"370\":4,\"371\":6,\"372\":5,\"373\":7,\"374\":9,\"375\":3,\"376\":7,\"377\":8,\"379\":5,\"380\":5,\"381\":8,\"383\":5,\"384\":5,\"386\":8,\"388\":1,\"389\":1,\"391\":4,\"392\":5,\"393\":4,\"394\":3,\"395\":4,\"397\":3,\"402\":9,\"403\":2,\"405\":5,\"410\":19,\"412\":4,\"413\":14,\"414\":4,\"415\":8,\"417\":3,\"418\":7,\"419\":6,\"421\":6,\"422\":6,\"423\":6,\"425\":5,\"426\":18,\"427\":7,\"428\":6,\"430\":7,\"431\":2,\"432\":4,\"433\":3,\"436\":12,\"437\":7,\"438\":8,\"441\":5,\"443\":17,\"444\":26,\"446\":5,\"447\":5,\"448\":5,\"451\":5,\"452\":6,\"453\":5,\"456\":7,\"457\":3,\"458\":5,\"461\":13,\"462\":8,\"464\":4,\"465\":4,\"466\":4,\"467\":4,\"469\":4,\"470\":6,\"471\":9,\"473\":6,\"475\":5,\"479\":5,\"480\":25,\"484\":10,\"485\":4,\"488\":10,\"490\":7,\"493\":5,\"494\":8,\"495\":6,\"497\":10,\"498\":6,\"499\":5,\"500\":8,\"502\":10,\"503\":4,\"504\":1,\"505\":5,\"509\":2,\"516\":2,\"522\":5,\"524\":5,\"525\":5,\"526\":2,\"527\":3,\"534\":4,\"535\":4,\"538\":6,\"539\":1,\"542\":1,\"544\":2,\"545\":2,\"547\":2,\"551\":1,\"554\":3,\"557\":1,\"560\":6,\"562\":2,\"563\":6,\"564\":2,\"565\":7,\"572\":6,\"575\":9,\"576\":1,\"579\":4,\"586\":3,\"589\":2,\"595\":2,\"596\":6,\"599\":2,\"602\":3,\"605\":8,\"609\":5,\"618\":5,\"620\":1,\"621\":1,\"623\":1,\"627\":4,\"630\":2,\"633\":2,\"636\":1,\"640\":2,\"643\":3,\"646\":1,\"649\":3,\"656\":9,\"659\":4,\"662\":4,\"665\":4,\"666\":6,\"668\":2,\"669\":3,\"675\":7,\"679\":3,\"682\":5,\"688\":13,\"692\":5,\"698\":2,\"701\":4,\"705\":10,\"708\":4,\"711\":4,\"721\":3,\"724\":7,\"727\":4,\"731\":4,\"732\":2,\"734\":2,\"735\":6,\"736\":2,\"737\":7,\"739\":2,\"740\":5,\"742\":1,\"747\":3,\"751\":2,\"754\":4,\"757\":3,\"760\":5,\"767\":4,\"770\":3,\"772\":1,\"773\":7,\"783\":3,\"786\":4,\"790\":1,\"793\":8,\"799\":7,\"801\":3,\"802\":1,\"803\":7,\"804\":1,\"806\":4,\"809\":5,\"810\":7,\"812\":1,\"813\":4,\"816\":1,\"819\":5,\"823\":1,\"826\":4,\"829\":1,\"832\":1,\"839\":1,\"843\":1,\"847\":1,\"851\":4,\"854\":5,\"860\":5,\"866\":1,\"868\":3,\"869\":3,\"872\":6,\"875\":7,\"879\":4,\"882\":3,\"885\":3,\"888\":5,\"895\":5,\"898\":5,\"902\":1,\"911\":4}}],[\"阶乘和\",{\"0\":{\"5\":1}}],[\"wyh\",{\"0\":{\"690\":1}}],[\"w++\",{\"1\":{\"575\":2}}],[\"weekpri\",{\"1\":{\"516\":2}}],[\"wei\",{\"1\":{\"488\":2}}],[\"wotojo\",{\"0\":{\"504\":1,\"567\":1},\"1\":{\"504\":3,\"698\":4}}],[\"work\",{\"1\":{\"198\":2,\"260\":1,\"329\":1,\"351\":2}}],[\"world\",{\"1\":{\"46\":1,\"47\":1,\"48\":2,\"50\":3,\"52\":3,\"53\":3,\"54\":2}}],[\"wu\",{\"1\":{\"494\":2}}],[\"ww++\",{\"1\":{\"572\":1}}],[\"wwronganswer\",{\"1\":{\"546\":1}}],[\"www\",{\"1\":{\"437\":1,\"489\":1,\"494\":1,\"726\":1}}],[\"ww\",{\"1\":{\"359\":8,\"572\":5}}],[\"ww0\",{\"1\":{\"205\":8}}],[\"wawa\",{\"1\":{\"576\":3}}],[\"wa\",{\"1\":{\"551\":1,\"575\":9,\"576\":3}}],[\"wa=\",{\"1\":{\"546\":1}}],[\"walk\",{\"0\":{\"336\":1,\"377\":1}}],[\"way\",{\"0\":{\"275\":1}}],[\"w0\",{\"1\":{\"205\":6}}],[\"w\",{\"1\":{\"128\":5,\"198\":1,\"205\":6,\"250\":14,\"278\":3,\"279\":3,\"280\":3,\"293\":11,\"295\":4,\"321\":1,\"336\":4,\"342\":4,\"352\":7,\"358\":8,\"359\":8,\"361\":7,\"362\":8,\"397\":1,\"399\":1,\"400\":1,\"402\":2,\"405\":1,\"410\":1,\"412\":1,\"413\":2,\"415\":4,\"421\":1,\"422\":1,\"423\":1,\"425\":1,\"426\":1,\"427\":1,\"428\":1,\"430\":1,\"431\":1,\"432\":1,\"433\":7,\"435\":1,\"436\":2,\"437\":1,\"438\":1,\"444\":6,\"450\":1,\"452\":1,\"453\":1,\"455\":1,\"456\":1,\"457\":1,\"458\":1,\"480\":1,\"482\":1,\"483\":1,\"484\":2,\"487\":1,\"488\":1,\"489\":1,\"490\":1,\"492\":1,\"493\":1,\"494\":1,\"495\":1,\"497\":1,\"498\":1,\"499\":1,\"500\":1,\"504\":4,\"575\":9,\"576\":1,\"691\":1,\"698\":1,\"705\":1,\"708\":1,\"711\":1,\"714\":1,\"718\":1,\"721\":1,\"724\":1,\"727\":1}}],[\"wronganswer\",{\"0\":{\"546\":1},\"1\":{\"546\":6,\"575\":3,\"576\":5}}],[\"wrong\",{\"1\":{\"69\":1,\"269\":1}}],[\"windy\",{\"0\":{\"273\":1}}],[\"wi\",{\"1\":{\"127\":3}}],[\"with\",{\"1\":{\"11\":1,\"12\":1,\"13\":1,\"14\":1,\"15\":1,\"17\":1,\"19\":1,\"20\":1,\"21\":1,\"23\":1,\"109\":1,\"110\":1,\"111\":1,\"112\":1,\"113\":1,\"115\":1,\"116\":1,\"117\":1,\"120\":1,\"122\":1,\"123\":1,\"124\":1,\"125\":1,\"126\":1,\"127\":1,\"128\":1,\"137\":1,\"141\":1,\"142\":1,\"144\":1,\"146\":1,\"147\":1,\"148\":1,\"154\":1,\"158\":1,\"163\":1,\"164\":1,\"165\":1,\"166\":1,\"167\":1,\"168\":1,\"169\":1,\"170\":1,\"175\":1,\"176\":1,\"177\":1,\"178\":1,\"179\":1,\"180\":1,\"181\":2,\"182\":2,\"184\":1,\"185\":1,\"186\":1,\"187\":1,\"190\":1,\"192\":1,\"193\":4,\"195\":2,\"196\":5,\"197\":4,\"198\":3,\"199\":4,\"202\":1,\"203\":1,\"204\":1,\"205\":2,\"208\":2,\"209\":1,\"210\":1,\"211\":1,\"213\":1,\"214\":1,\"215\":1,\"216\":2,\"217\":1,\"218\":1,\"219\":2,\"221\":1,\"222\":1,\"224\":1,\"225\":1,\"226\":1,\"227\":1,\"228\":1,\"230\":1,\"231\":1,\"232\":1,\"233\":2,\"235\":1,\"236\":1,\"237\":1,\"239\":1,\"242\":1,\"244\":2,\"245\":1,\"246\":1,\"248\":1,\"249\":1,\"250\":2,\"253\":1,\"255\":1,\"256\":1,\"257\":1,\"258\":1,\"259\":1,\"260\":1,\"265\":1,\"266\":1,\"267\":2,\"268\":1,\"270\":1,\"272\":1,\"273\":1,\"274\":1,\"275\":2,\"276\":2,\"278\":1,\"279\":1,\"280\":1,\"282\":1,\"283\":1,\"284\":1,\"285\":1,\"286\":2,\"287\":1,\"288\":1,\"291\":1,\"292\":1,\"293\":1,\"295\":1,\"298\":2,\"299\":1,\"301\":1,\"302\":1,\"303\":1,\"306\":1,\"307\":1,\"309\":1,\"310\":1,\"312\":1,\"313\":2,\"314\":1,\"317\":1,\"318\":1,\"319\":1,\"320\":3,\"321\":1,\"331\":1,\"333\":1,\"334\":1,\"335\":1,\"336\":1,\"338\":1,\"340\":1,\"345\":1,\"347\":1,\"348\":1,\"349\":1,\"350\":1,\"351\":1,\"352\":1,\"354\":1,\"355\":1,\"356\":1,\"358\":1,\"359\":1,\"361\":1,\"362\":1,\"363\":1,\"365\":1,\"366\":1,\"367\":1,\"368\":1,\"369\":1,\"370\":1,\"371\":1,\"372\":1,\"373\":1,\"374\":1,\"375\":1,\"376\":1,\"377\":1,\"381\":1,\"383\":1,\"384\":1,\"386\":1,\"388\":1,\"389\":1,\"391\":1,\"392\":1,\"393\":1,\"394\":1,\"395\":1,\"399\":1,\"400\":1,\"402\":2,\"405\":1,\"410\":1,\"412\":1,\"413\":2,\"414\":1,\"417\":1,\"418\":1,\"419\":1,\"421\":1,\"422\":1,\"423\":1,\"425\":1,\"426\":1,\"427\":1,\"428\":1,\"443\":1,\"444\":1,\"445\":2,\"446\":1,\"447\":1,\"458\":1,\"460\":1,\"461\":1,\"475\":1,\"542\":1,\"560\":1,\"596\":1,\"599\":1,\"602\":1,\"605\":1,\"729\":1,\"730\":1,\"731\":1,\"732\":1,\"734\":1,\"735\":1,\"736\":1,\"737\":1,\"741\":1,\"790\":1,\"793\":1,\"796\":1,\"799\":1,\"819\":1,\"906\":1}}],[\"wiki\",{\"1\":{\"0\":1}}],[\"while\",{\"0\":{\"131\":1},\"1\":{\"3\":1,\"11\":5,\"12\":1,\"13\":1,\"15\":2,\"19\":1,\"20\":1,\"21\":1,\"23\":1,\"32\":1,\"115\":1,\"116\":2,\"117\":1,\"123\":1,\"125\":1,\"127\":4,\"131\":1,\"137\":1,\"142\":1,\"144\":2,\"146\":1,\"147\":1,\"148\":2,\"150\":1,\"151\":1,\"153\":1,\"156\":1,\"157\":1,\"164\":1,\"167\":1,\"169\":1,\"170\":2,\"172\":3,\"173\":3,\"174\":1,\"176\":1,\"179\":2,\"181\":4,\"184\":1,\"192\":2,\"194\":1,\"195\":2,\"196\":9,\"197\":1,\"198\":4,\"199\":4,\"203\":1,\"205\":1,\"209\":1,\"210\":2,\"213\":1,\"218\":1,\"219\":1,\"226\":1,\"230\":1,\"231\":1,\"233\":1,\"235\":1,\"236\":2,\"237\":2,\"239\":1,\"241\":2,\"242\":1,\"243\":1,\"244\":1,\"245\":1,\"259\":2,\"264\":1,\"265\":1,\"267\":2,\"268\":1,\"269\":1,\"273\":1,\"276\":1,\"282\":1,\"283\":2,\"284\":2,\"286\":1,\"287\":1,\"288\":1,\"289\":2,\"291\":1,\"292\":1,\"293\":1,\"295\":1,\"299\":1,\"307\":2,\"309\":1,\"310\":1,\"317\":2,\"318\":2,\"319\":2,\"321\":1,\"324\":1,\"325\":1,\"326\":1,\"329\":1,\"331\":2,\"335\":1,\"336\":1,\"338\":1,\"340\":2,\"342\":1,\"343\":1,\"351\":1,\"363\":1,\"366\":1,\"377\":1,\"388\":1,\"389\":1,\"399\":1,\"410\":1,\"414\":2,\"417\":1,\"421\":1,\"422\":1,\"423\":1,\"428\":1,\"435\":1,\"436\":1,\"437\":1,\"438\":1,\"443\":1,\"444\":2,\"446\":1,\"447\":1,\"448\":2,\"450\":2,\"453\":1,\"456\":1,\"461\":1,\"464\":1,\"465\":1,\"466\":1,\"467\":1,\"473\":1,\"475\":1,\"484\":5,\"485\":1,\"489\":1,\"500\":1,\"503\":1,\"516\":1,\"534\":2,\"563\":1,\"572\":1,\"592\":1,\"615\":1,\"621\":1,\"623\":1,\"633\":2,\"636\":1,\"649\":1,\"659\":1,\"662\":1,\"672\":2,\"685\":2,\"732\":2,\"735\":1,\"737\":1,\"741\":1,\"745\":1,\"747\":1,\"793\":1,\"803\":1,\"804\":1,\"854\":1,\"875\":1,\"902\":1,\"907\":3}}],[\"mp\",{\"1\":{\"576\":6}}],[\"music\",{\"1\":{\"458\":2}}],[\"multiset<int>\",{\"1\":{\"211\":1}}],[\"multiset\",{\"1\":{\"211\":1}}],[\"mul\",{\"1\":{\"3\":4,\"21\":11,\"384\":8}}],[\"mx\",{\"1\":{\"276\":8}}],[\"my\",{\"1\":{\"236\":3,\"237\":3,\"276\":8}}],[\"myscore\",{\"1\":{\"62\":1}}],[\"meow\",{\"1\":{\"453\":1}}],[\"mei\",{\"1\":{\"437\":2}}],[\"merge\",{\"1\":{\"289\":4}}],[\"mergesort\",{\"1\":{\"173\":4}}],[\"memory\",{\"1\":{\"69\":1}}],[\"memset\",{\"1\":{\"14\":1,\"128\":1,\"200\":2,\"204\":1,\"221\":1,\"222\":1,\"232\":1,\"260\":1,\"270\":1,\"273\":1,\"280\":1,\"306\":1,\"318\":1,\"377\":1,\"378\":1,\"633\":1}}],[\"mt19937\",{\"1\":{\"170\":1}}],[\"m++\",{\"1\":{\"162\":3,\"732\":1}}],[\"m+1\",{\"1\":{\"158\":1,\"241\":1}}],[\"mm++\",{\"1\":{\"572\":1}}],[\"mm\",{\"1\":{\"131\":4,\"132\":4,\"527\":4,\"572\":11,\"666\":4}}],[\"mo++\",{\"1\":{\"527\":1}}],[\"mo\",{\"1\":{\"527\":8}}],[\"moni\",{\"1\":{\"633\":3}}],[\"month\",{\"1\":{\"455\":13}}],[\"money\",{\"1\":{\"134\":9,\"135\":10,\"136\":10}}],[\"most\",{\"1\":{\"351\":1}}],[\"mod2=998244353\",{\"1\":{\"575\":1,\"576\":1}}],[\"mod1=1e9+7\",{\"1\":{\"575\":1,\"576\":1}}],[\"modd\",{\"1\":{\"378\":6}}],[\"modnum\",{\"1\":{\"274\":16}}],[\"mod\",{\"1\":{\"109\":2,\"110\":3,\"119\":3,\"190\":4,\"302\":3,\"303\":3,\"305\":2,\"306\":3,\"329\":14,\"367\":2,\"372\":4,\"374\":2,\"375\":4,\"377\":3,\"378\":2,\"379\":4,\"380\":5,\"395\":2,\"402\":4,\"405\":7,\"415\":10,\"464\":2,\"465\":3,\"466\":3,\"467\":3,\"579\":2,\"633\":1,\"636\":1}}],[\"mov\",{\"1\":{\"37\":3}}],[\"mb\",{\"0\":{\"677\":1},\"1\":{\"83\":2}}],[\"miao\",{\"1\":{\"453\":2}}],[\"milkweed\",{\"0\":{\"276\":1}}],[\"mib\",{\"0\":{\"677\":1},\"1\":{\"83\":1,\"457\":2}}],[\"minai\",{\"1\":{\"888\":4}}],[\"minans\",{\"1\":{\"371\":5}}],[\"minn\",{\"1\":{\"525\":5}}],[\"minimum\",{\"0\":{\"352\":1}}],[\"minsum\",{\"1\":{\"493\":4}}],[\"minse\",{\"1\":{\"343\":8}}],[\"minsiz\",{\"1\":{\"147\":7}}],[\"min\",{\"1\":{\"20\":1,\"141\":1,\"146\":1,\"160\":8,\"161\":2,\"164\":1,\"166\":1,\"169\":1,\"182\":3,\"195\":1,\"196\":2,\"198\":1,\"202\":1,\"203\":1,\"204\":2,\"221\":2,\"222\":3,\"228\":1,\"241\":1,\"242\":1,\"257\":1,\"259\":4,\"260\":4,\"278\":1,\"279\":1,\"280\":2,\"286\":2,\"293\":1,\"320\":1,\"325\":2,\"335\":1,\"343\":3,\"350\":1,\"351\":2,\"354\":2,\"355\":1,\"361\":1,\"362\":1,\"371\":1,\"373\":1,\"431\":4,\"433\":1,\"443\":1,\"444\":6,\"469\":1,\"488\":1,\"493\":1,\"495\":1,\"497\":2,\"504\":1,\"525\":1,\"633\":1,\"704\":1,\"747\":1,\"780\":1,\"799\":1,\"810\":2,\"888\":1}}],[\"mid++\",{\"1\":{\"320\":2,\"373\":1}}],[\"mid+1\",{\"1\":{\"19\":3,\"20\":2,\"21\":4}}],[\"mid\",{\"1\":{\"17\":13,\"18\":3,\"19\":19,\"20\":15,\"21\":25,\"23\":15,\"24\":3,\"116\":5,\"117\":5,\"123\":5,\"146\":11,\"147\":7,\"169\":14,\"173\":6,\"181\":21,\"205\":4,\"213\":5,\"216\":13,\"219\":5,\"233\":5,\"236\":5,\"237\":25,\"239\":23,\"244\":4,\"245\":4,\"286\":5,\"291\":13,\"292\":13,\"293\":7,\"312\":5,\"313\":10,\"314\":5,\"320\":14,\"340\":10,\"373\":4,\"399\":6,\"400\":4,\"437\":19,\"446\":6,\"447\":12,\"484\":6,\"485\":5,\"500\":11,\"803\":6}}],[\"man\",{\"1\":{\"487\":2}}],[\"map\",{\"1\":{\"456\":1,\"509\":6,\"874\":1}}],[\"map<int\",{\"1\":{\"230\":1,\"231\":1,\"331\":1,\"897\":1}}],[\"map<string\",{\"1\":{\"160\":1,\"161\":1,\"179\":2,\"464\":1,\"465\":2,\"466\":1,\"467\":2}}],[\"map<pair<int\",{\"1\":{\"141\":1}}],[\"may\",{\"1\":{\"455\":1}}],[\"march\",{\"1\":{\"455\":1}}],[\"mat\",{\"1\":{\"377\":10}}],[\"matching\",{\"0\":{\"374\":1}}],[\"majority\",{\"0\":{\"343\":1}}],[\"mask\",{\"1\":{\"153\":3,\"352\":4}}],[\"make\",{\"0\":{\"141\":1},\"1\":{\"14\":2,\"125\":3,\"127\":2,\"141\":1,\"144\":2,\"167\":4,\"182\":2,\"190\":1,\"198\":4,\"241\":4,\"242\":1,\"259\":2,\"266\":1,\"267\":2,\"276\":2,\"295\":8,\"340\":1,\"342\":1,\"343\":1,\"410\":2,\"421\":2,\"422\":2,\"423\":2,\"433\":2,\"438\":3,\"443\":5}}],[\"main\",{\"1\":{\"5\":1,\"7\":1,\"8\":1,\"11\":1,\"12\":1,\"13\":1,\"14\":1,\"15\":1,\"17\":1,\"19\":1,\"20\":1,\"21\":1,\"23\":1,\"27\":1,\"29\":1,\"30\":1,\"31\":1,\"32\":1,\"40\":1,\"46\":1,\"47\":1,\"48\":1,\"49\":1,\"50\":1,\"52\":1,\"53\":1,\"54\":1,\"57\":1,\"59\":1,\"60\":1,\"61\":1,\"62\":1,\"63\":3,\"64\":1,\"66\":1,\"70\":1,\"74\":1,\"109\":1,\"110\":1,\"111\":1,\"112\":1,\"113\":1,\"115\":1,\"116\":1,\"117\":1,\"118\":1,\"119\":1,\"120\":1,\"122\":1,\"123\":1,\"124\":1,\"125\":1,\"126\":1,\"127\":1,\"128\":1,\"129\":1,\"131\":1,\"132\":1,\"134\":1,\"135\":1,\"136\":1,\"137\":1,\"139\":1,\"140\":1,\"141\":1,\"142\":1,\"144\":1,\"146\":1,\"147\":1,\"148\":1,\"150\":1,\"151\":1,\"153\":1,\"154\":1,\"156\":1,\"157\":1,\"158\":1,\"160\":1,\"161\":1,\"162\":1,\"163\":1,\"164\":1,\"165\":1,\"166\":1,\"167\":1,\"168\":1,\"169\":1,\"170\":1,\"172\":1,\"173\":1,\"174\":1,\"175\":1,\"176\":1,\"177\":1,\"178\":1,\"179\":1,\"180\":1,\"181\":2,\"182\":2,\"184\":1,\"185\":1,\"186\":1,\"187\":1,\"188\":1,\"190\":1,\"191\":1,\"192\":1,\"193\":4,\"194\":1,\"195\":2,\"196\":5,\"197\":4,\"198\":3,\"199\":4,\"200\":1,\"202\":1,\"203\":1,\"204\":1,\"205\":2,\"208\":2,\"209\":1,\"210\":1,\"211\":1,\"213\":1,\"214\":1,\"215\":1,\"216\":2,\"217\":1,\"218\":1,\"219\":2,\"221\":1,\"222\":1,\"224\":1,\"225\":1,\"226\":1,\"227\":1,\"228\":1,\"230\":1,\"231\":1,\"232\":1,\"233\":2,\"235\":1,\"236\":1,\"237\":1,\"239\":1,\"241\":1,\"242\":1,\"243\":1,\"244\":2,\"245\":1,\"246\":1,\"248\":1,\"249\":1,\"250\":2,\"251\":1,\"253\":1,\"255\":1,\"256\":1,\"257\":1,\"258\":1,\"259\":1,\"260\":1,\"262\":1,\"263\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":2,\"268\":1,\"269\":1,\"270\":1,\"272\":1,\"273\":1,\"274\":1,\"275\":2,\"276\":2,\"278\":1,\"279\":1,\"280\":1,\"282\":1,\"283\":1,\"284\":1,\"285\":1,\"286\":2,\"287\":1,\"288\":1,\"289\":2,\"291\":1,\"292\":1,\"293\":1,\"295\":1,\"298\":2,\"299\":1,\"301\":1,\"302\":1,\"303\":1,\"305\":1,\"306\":1,\"307\":2,\"309\":1,\"310\":1,\"312\":1,\"313\":2,\"314\":1,\"317\":1,\"318\":1,\"319\":1,\"320\":3,\"321\":1,\"323\":1,\"324\":1,\"325\":1,\"326\":1,\"329\":1,\"331\":1,\"333\":1,\"334\":1,\"335\":1,\"336\":1,\"338\":1,\"340\":1,\"342\":1,\"343\":1,\"345\":1,\"347\":1,\"348\":1,\"349\":1,\"350\":1,\"351\":1,\"352\":1,\"354\":1,\"355\":1,\"356\":1,\"358\":1,\"359\":1,\"361\":1,\"362\":1,\"363\":1,\"365\":1,\"366\":1,\"367\":1,\"368\":1,\"369\":1,\"370\":1,\"371\":1,\"372\":1,\"373\":1,\"374\":1,\"375\":1,\"376\":1,\"377\":1,\"378\":1,\"379\":1,\"380\":1,\"381\":1,\"383\":1,\"384\":1,\"386\":1,\"388\":1,\"389\":1,\"391\":1,\"392\":1,\"393\":1,\"394\":1,\"395\":1,\"397\":1,\"399\":1,\"400\":1,\"402\":2,\"405\":1,\"410\":1,\"412\":1,\"413\":2,\"414\":1,\"415\":4,\"417\":1,\"418\":1,\"419\":1,\"421\":1,\"422\":1,\"423\":1,\"425\":1,\"426\":1,\"427\":1,\"428\":1,\"430\":1,\"431\":1,\"432\":1,\"433\":1,\"435\":1,\"436\":2,\"437\":1,\"438\":1,\"440\":1,\"441\":1,\"443\":1,\"444\":1,\"446\":1,\"447\":1,\"448\":1,\"450\":1,\"451\":1,\"452\":1,\"453\":1,\"455\":1,\"456\":1,\"457\":1,\"458\":1,\"460\":1,\"461\":1,\"462\":1,\"464\":1,\"465\":1,\"466\":1,\"467\":1,\"469\":1,\"470\":1,\"471\":1,\"473\":1,\"475\":1,\"477\":1,\"478\":1,\"479\":1,\"480\":1,\"482\":1,\"483\":1,\"484\":3,\"485\":1,\"487\":1,\"488\":1,\"489\":1,\"490\":1,\"492\":1,\"493\":1,\"494\":1,\"495\":1,\"497\":1,\"498\":1,\"499\":1,\"500\":1,\"502\":1,\"503\":1,\"504\":1,\"505\":1,\"507\":1,\"508\":1,\"509\":2,\"513\":1,\"516\":1,\"519\":1,\"522\":1,\"524\":1,\"525\":1,\"526\":1,\"527\":1,\"531\":1,\"534\":1,\"535\":1,\"538\":1,\"539\":1,\"542\":1,\"544\":1,\"545\":1,\"546\":1,\"547\":1,\"551\":2,\"554\":1,\"557\":1,\"560\":1,\"562\":1,\"563\":1,\"564\":1,\"565\":1,\"569\":1,\"572\":1,\"575\":1,\"576\":1,\"579\":1,\"583\":1,\"586\":1,\"589\":1,\"592\":1,\"596\":1,\"599\":1,\"602\":1,\"605\":1,\"609\":1,\"612\":1,\"615\":1,\"618\":1,\"620\":1,\"621\":1,\"622\":1,\"623\":1,\"627\":1,\"630\":1,\"633\":1,\"636\":1,\"640\":1,\"643\":1,\"646\":1,\"649\":1,\"653\":1,\"656\":1,\"659\":1,\"662\":1,\"666\":1,\"669\":1,\"672\":1,\"675\":1,\"679\":1,\"682\":1,\"685\":1,\"688\":1,\"692\":1,\"695\":1,\"698\":1,\"701\":1,\"705\":1,\"708\":1,\"711\":1,\"714\":1,\"718\":1,\"721\":1,\"724\":1,\"727\":1,\"729\":1,\"730\":1,\"731\":1,\"732\":1,\"734\":1,\"735\":1,\"736\":1,\"737\":1,\"739\":1,\"740\":1,\"741\":1,\"742\":1,\"744\":1,\"745\":1,\"746\":1,\"747\":1,\"751\":1,\"754\":1,\"757\":1,\"760\":1,\"764\":1,\"767\":1,\"770\":1,\"773\":1,\"777\":1,\"780\":1,\"783\":1,\"786\":1,\"790\":1,\"793\":1,\"796\":1,\"799\":1,\"801\":1,\"803\":1,\"804\":1,\"805\":1,\"806\":1,\"810\":1,\"813\":1,\"816\":1,\"819\":1,\"823\":1,\"826\":1,\"829\":1,\"832\":1,\"836\":1,\"839\":1,\"843\":1,\"844\":1,\"847\":1,\"851\":1,\"854\":1,\"857\":1,\"860\":1,\"864\":1,\"868\":1,\"869\":1,\"872\":1,\"875\":1,\"879\":1,\"882\":1,\"885\":1,\"888\":1,\"892\":1,\"895\":1,\"898\":1,\"902\":1,\"906\":1,\"907\":1,\"911\":1}}],[\"max2\",{\"1\":{\"485\":2}}],[\"max1\",{\"1\":{\"485\":2}}],[\"maxx\",{\"1\":{\"399\":4}}],[\"maxxy\",{\"1\":{\"313\":2,\"314\":2}}],[\"maxans\",{\"1\":{\"371\":6}}],[\"maxai\",{\"1\":{\"23\":4,\"24\":1,\"113\":2,\"116\":2,\"117\":1,\"266\":2,\"307\":9,\"348\":4,\"349\":2,\"819\":4,\"860\":4}}],[\"maxlen\",{\"1\":{\"363\":3,\"378\":3}}],[\"maxli\",{\"1\":{\"196\":4}}],[\"maxse\",{\"1\":{\"343\":6}}],[\"maxsij\",{\"1\":{\"196\":4}}],[\"maxcnt\",{\"1\":{\"400\":5}}],[\"maxc\",{\"1\":{\"317\":2,\"377\":2}}],[\"maxci\",{\"1\":{\"196\":15}}],[\"maxday\",{\"1\":{\"572\":6}}],[\"maxd\",{\"1\":{\"273\":2,\"378\":2}}],[\"maxv\",{\"1\":{\"244\":10,\"362\":5}}],[\"maxq=maxn\",{\"1\":{\"196\":1}}],[\"maxri\",{\"1\":{\"197\":7}}],[\"maxr\",{\"1\":{\"196\":12,\"317\":2,\"377\":2}}],[\"maxk\",{\"1\":{\"196\":4,\"225\":2,\"226\":3,\"260\":1}}],[\"maxi\",{\"1\":{\"163\":12}}],[\"maxw\",{\"1\":{\"127\":12,\"342\":2,\"358\":2}}],[\"maxtot\",{\"1\":{\"23\":4,\"313\":5,\"314\":5,\"444\":11}}],[\"maxm\",{\"1\":{\"14\":2,\"109\":3,\"110\":3,\"126\":2,\"153\":1,\"198\":3,\"215\":1,\"260\":2,\"266\":2,\"305\":2,\"365\":1,\"366\":1,\"391\":1,\"392\":2,\"393\":4,\"394\":2,\"415\":7,\"428\":1}}],[\"maxn=1e6\",{\"1\":{\"575\":1,\"576\":1}}],[\"maxnm\",{\"1\":{\"164\":9}}],[\"maxnow\",{\"1\":{\"148\":4}}],[\"maxn+5\",{\"1\":{\"140\":1}}],[\"maxn\",{\"1\":{\"11\":5,\"12\":4,\"13\":5,\"14\":5,\"15\":9,\"17\":3,\"19\":4,\"20\":4,\"21\":5,\"23\":3,\"109\":2,\"110\":2,\"112\":3,\"113\":4,\"115\":4,\"116\":5,\"117\":4,\"120\":1,\"122\":6,\"123\":6,\"124\":1,\"125\":1,\"126\":4,\"139\":2,\"140\":2,\"141\":3,\"142\":2,\"144\":4,\"147\":4,\"148\":4,\"150\":5,\"151\":6,\"153\":3,\"158\":6,\"162\":4,\"165\":3,\"166\":5,\"168\":2,\"169\":3,\"176\":5,\"192\":5,\"196\":12,\"197\":10,\"198\":15,\"199\":15,\"213\":4,\"214\":3,\"215\":6,\"216\":5,\"225\":3,\"226\":3,\"233\":12,\"235\":2,\"236\":3,\"237\":4,\"239\":4,\"241\":7,\"242\":7,\"243\":3,\"251\":3,\"260\":7,\"266\":4,\"268\":4,\"285\":3,\"291\":4,\"292\":4,\"305\":2,\"307\":2,\"312\":8,\"313\":14,\"314\":6,\"321\":8,\"325\":3,\"329\":8,\"336\":5,\"342\":2,\"347\":2,\"348\":2,\"349\":2,\"350\":2,\"351\":4,\"352\":3,\"354\":3,\"355\":3,\"356\":7,\"358\":3,\"362\":3,\"365\":3,\"366\":5,\"375\":3,\"383\":4,\"384\":6,\"391\":3,\"392\":2,\"393\":4,\"394\":2,\"395\":2,\"402\":4,\"405\":3,\"422\":3,\"423\":3,\"427\":5,\"428\":8,\"443\":5,\"444\":5,\"475\":5,\"493\":3,\"495\":6,\"633\":1,\"636\":1,\"737\":2,\"786\":3}}],[\"max\",{\"1\":{\"3\":2,\"20\":1,\"112\":2,\"113\":1,\"117\":1,\"118\":2,\"119\":2,\"120\":1,\"122\":1,\"123\":1,\"124\":1,\"128\":1,\"142\":1,\"144\":2,\"146\":1,\"147\":2,\"148\":1,\"160\":2,\"161\":1,\"164\":1,\"176\":1,\"177\":4,\"178\":1,\"182\":2,\"197\":1,\"199\":11,\"202\":1,\"203\":1,\"204\":2,\"216\":6,\"232\":3,\"233\":2,\"241\":2,\"242\":2,\"259\":2,\"260\":1,\"276\":1,\"293\":1,\"307\":1,\"320\":4,\"324\":4,\"340\":1,\"342\":1,\"343\":2,\"355\":1,\"356\":5,\"358\":1,\"359\":2,\"363\":1,\"365\":2,\"366\":3,\"371\":1,\"372\":1,\"376\":3,\"381\":1,\"399\":1,\"400\":1,\"412\":1,\"413\":2,\"414\":1,\"432\":1,\"436\":1,\"440\":1,\"443\":1,\"444\":5,\"485\":4,\"488\":2,\"493\":1,\"495\":1,\"499\":1,\"500\":1,\"503\":1,\"596\":1,\"633\":1,\"662\":1,\"704\":1,\"819\":1,\"826\":1,\"860\":1}}],[\"m\",{\"0\":{\"372\":1},\"1\":{\"3\":3,\"11\":3,\"12\":3,\"13\":3,\"14\":4,\"15\":3,\"17\":3,\"19\":3,\"20\":3,\"21\":3,\"23\":1,\"109\":6,\"110\":6,\"120\":5,\"124\":5,\"125\":9,\"126\":5,\"131\":6,\"132\":5,\"150\":4,\"151\":4,\"153\":5,\"154\":9,\"156\":4,\"157\":4,\"158\":19,\"160\":4,\"161\":4,\"162\":7,\"163\":4,\"164\":13,\"165\":3,\"166\":7,\"176\":10,\"177\":8,\"191\":5,\"194\":5,\"198\":19,\"200\":3,\"205\":6,\"215\":3,\"216\":13,\"219\":12,\"228\":3,\"232\":4,\"235\":3,\"236\":3,\"237\":3,\"239\":3,\"241\":9,\"242\":10,\"243\":4,\"251\":5,\"260\":12,\"266\":4,\"269\":3,\"273\":3,\"274\":3,\"276\":23,\"291\":3,\"292\":3,\"295\":9,\"298\":10,\"299\":3,\"305\":6,\"318\":3,\"325\":5,\"326\":6,\"331\":3,\"350\":4,\"352\":3,\"365\":3,\"366\":3,\"367\":5,\"377\":10,\"383\":3,\"384\":7,\"391\":3,\"392\":3,\"393\":8,\"394\":4,\"397\":4,\"412\":3,\"414\":5,\"415\":16,\"421\":4,\"422\":4,\"423\":4,\"426\":6,\"428\":3,\"430\":4,\"436\":9,\"448\":8,\"451\":5,\"456\":3,\"457\":8,\"464\":3,\"465\":3,\"466\":3,\"467\":3,\"469\":3,\"471\":6,\"473\":4,\"475\":5,\"480\":5,\"485\":5,\"488\":8,\"490\":3,\"498\":6,\"505\":4,\"509\":1,\"522\":1,\"560\":6,\"605\":4,\"630\":2,\"643\":5,\"659\":3,\"679\":1,\"701\":4,\"711\":3,\"727\":5,\"732\":7,\"742\":1,\"747\":4,\"754\":3,\"767\":3,\"816\":1,\"823\":3,\"832\":3,\"847\":3,\"875\":6,\"906\":2,\"907\":9}}],[\"p83\",{\"1\":{\"735\":2}}],[\"pi\",{\"1\":{\"575\":1,\"576\":1}}],[\"pib\",{\"1\":{\"83\":1}}],[\"puts\",{\"1\":{\"544\":1,\"546\":2,\"575\":7,\"576\":5}}],[\"push\",{\"1\":{\"3\":2,\"11\":2,\"12\":2,\"13\":4,\"14\":4,\"15\":2,\"103\":1,\"104\":2,\"105\":1,\"106\":1,\"109\":1,\"110\":1,\"115\":1,\"116\":1,\"125\":1,\"126\":1,\"127\":8,\"144\":2,\"148\":1,\"150\":1,\"151\":1,\"156\":3,\"157\":3,\"163\":3,\"164\":1,\"167\":2,\"170\":3,\"179\":2,\"182\":2,\"190\":1,\"192\":3,\"196\":5,\"198\":4,\"200\":3,\"208\":1,\"210\":7,\"214\":1,\"215\":2,\"219\":4,\"225\":1,\"226\":1,\"228\":2,\"230\":2,\"231\":5,\"235\":1,\"236\":1,\"237\":1,\"239\":1,\"241\":4,\"242\":1,\"257\":2,\"259\":2,\"266\":1,\"267\":2,\"268\":10,\"274\":2,\"276\":2,\"295\":11,\"298\":3,\"312\":4,\"313\":6,\"314\":2,\"319\":3,\"336\":6,\"340\":1,\"342\":1,\"343\":2,\"352\":2,\"365\":1,\"366\":4,\"375\":2,\"383\":2,\"384\":6,\"395\":1,\"410\":2,\"421\":2,\"422\":6,\"423\":6,\"433\":2,\"436\":3,\"438\":3,\"443\":5,\"444\":11,\"453\":1,\"462\":1,\"464\":1,\"465\":1,\"466\":1,\"467\":1,\"475\":1,\"479\":1,\"480\":4,\"494\":1,\"636\":1}}],[\"pen\",{\"1\":{\"519\":1}}],[\"perfect\",{\"1\":{\"192\":1}}],[\"permutation\",{\"0\":{\"379\":1},\"1\":{\"184\":1,\"417\":1}}],[\"p7167\",{\"1\":{\"472\":1}}],[\"p5490\",{\"1\":{\"313\":1}}],[\"p4\",{\"1\":{\"295\":5}}],[\"p+1+n\",{\"1\":{\"623\":1}}],[\"p+1\",{\"1\":{\"623\":1}}],[\"p+n\",{\"1\":{\"251\":1}}],[\"p++\",{\"1\":{\"178\":1}}],[\"p3958\",{\"1\":{\"289\":1}}],[\"p3\",{\"1\":{\"188\":3,\"295\":5}}],[\"pt++\",{\"1\":{\"173\":4}}],[\"pt\",{\"1\":{\"173\":1}}],[\"plus\",{\"0\":{\"670\":1}}],[\"pl++\",{\"1\":{\"172\":2,\"173\":2}}],[\"pl\",{\"1\":{\"172\":13,\"173\":4}}],[\"plan\",{\"1\":{\"115\":4,\"116\":4,\"125\":4,\"219\":18}}],[\"plan3\",{\"1\":{\"111\":5,\"502\":4}}],[\"plan2\",{\"1\":{\"111\":5,\"502\":4}}],[\"plan1\",{\"1\":{\"111\":5,\"502\":4}}],[\"ppt\",{\"1\":{\"401\":1}}],[\"pp++\",{\"1\":{\"157\":1}}],[\"pp\",{\"1\":{\"157\":7}}],[\"p2\",{\"1\":{\"157\":5,\"188\":3,\"295\":5,\"462\":1}}],[\"p10\",{\"1\":{\"270\":7}}],[\"p1\",{\"1\":{\"157\":5,\"188\":4,\"295\":5,\"462\":4,\"735\":2}}],[\"pnxt++\",{\"1\":{\"127\":4}}],[\"pnxt\",{\"1\":{\"127\":7}}],[\"pnow++\",{\"1\":{\"127\":4}}],[\"pnow\",{\"1\":{\"127\":7}}],[\"pro\",{\"0\":{\"683\":1}}],[\"problem\",{\"1\":{\"419\":1,\"437\":1,\"445\":1,\"489\":1,\"494\":1}}],[\"problemset\",{\"1\":{\"419\":1,\"445\":1}}],[\"pr++\",{\"1\":{\"173\":2}}],[\"pr\",{\"1\":{\"172\":13,\"173\":4}}],[\"prime\",{\"1\":{\"539\":3}}],[\"prim\",{\"1\":{\"428\":1}}],[\"priority\",{\"1\":{\"144\":1,\"147\":1,\"148\":1,\"167\":1,\"210\":1,\"342\":1,\"410\":1}}],[\"printf\",{\"1\":{\"83\":1,\"89\":1,\"445\":1,\"527\":3}}],[\"pre4\",{\"1\":{\"329\":7}}],[\"pret\",{\"1\":{\"321\":7}}],[\"pre0\",{\"1\":{\"165\":2,\"329\":5}}],[\"prenm\",{\"1\":{\"125\":3}}],[\"pre\",{\"1\":{\"109\":3,\"115\":4,\"116\":4,\"125\":5,\"158\":7,\"257\":5,\"273\":6,\"306\":6,\"321\":6,\"329\":6,\"391\":8,\"497\":1}}],[\"power>=m\",{\"1\":{\"630\":1}}],[\"power+=600\",{\"1\":{\"630\":7}}],[\"power+=1600\",{\"1\":{\"630\":7}}],[\"power+=300\",{\"1\":{\"630\":7}}],[\"power\",{\"1\":{\"428\":5,\"473\":4,\"630\":1}}],[\"pow\",{\"1\":{\"377\":2,\"902\":1}}],[\"points\",{\"1\":{\"241\":8}}],[\"pop\",{\"1\":{\"104\":2,\"105\":1,\"106\":1,\"144\":2,\"148\":1,\"156\":1,\"157\":1,\"163\":2,\"167\":1,\"179\":1,\"210\":2,\"230\":1,\"231\":1,\"235\":1,\"236\":1,\"237\":1,\"239\":1,\"241\":1,\"259\":1,\"267\":1,\"268\":2,\"276\":1,\"295\":1,\"319\":4,\"336\":3,\"342\":1,\"343\":3,\"366\":1,\"410\":2,\"421\":1,\"422\":1,\"423\":1,\"436\":1,\"438\":1,\"443\":1,\"444\":3,\"453\":4,\"475\":1,\"636\":4}}],[\"posc++\",{\"1\":{\"192\":2}}],[\"posc\",{\"1\":{\"192\":6}}],[\"posp++\",{\"1\":{\"192\":2}}],[\"posp\",{\"1\":{\"192\":8}}],[\"posa++\",{\"1\":{\"192\":2}}],[\"posa\",{\"1\":{\"192\":7}}],[\"posy\",{\"1\":{\"173\":2}}],[\"posx\",{\"1\":{\"173\":2}}],[\"pos+1\",{\"1\":{\"414\":1}}],[\"pos+x+y\",{\"1\":{\"140\":1}}],[\"pos+x+i\",{\"1\":{\"139\":1}}],[\"pos+x\",{\"1\":{\"140\":2}}],[\"pos+i\",{\"1\":{\"139\":1}}],[\"pos++\",{\"1\":{\"32\":1,\"198\":2,\"473\":2}}],[\"pos\",{\"1\":{\"3\":18,\"13\":12,\"32\":8,\"103\":2,\"104\":2,\"109\":10,\"110\":10,\"126\":9,\"137\":6,\"139\":2,\"140\":3,\"144\":2,\"147\":6,\"154\":9,\"164\":3,\"170\":6,\"173\":7,\"180\":5,\"198\":7,\"199\":8,\"203\":10,\"204\":5,\"209\":9,\"214\":7,\"225\":6,\"226\":6,\"230\":10,\"246\":4,\"266\":6,\"270\":20,\"273\":11,\"278\":8,\"279\":8,\"298\":10,\"378\":9,\"384\":5,\"393\":4,\"414\":7,\"438\":3,\"447\":5,\"448\":3,\"457\":4,\"462\":3,\"473\":9,\"475\":7,\"497\":8,\"557\":5,\"602\":4,\"618\":4,\"688\":1,\"806\":3}}],[\"pb\",{\"1\":{\"83\":1}}],[\"park\",{\"1\":{\"708\":2}}],[\"partb中的完整周快速计算总价格\",{\"1\":{\"516\":1}}],[\"partb\",{\"1\":{\"516\":3,\"839\":4}}],[\"parta为中间剩余的天数\",{\"1\":{\"516\":1}}],[\"parta\",{\"1\":{\"516\":4,\"839\":2}}],[\"pa\",{\"1\":{\"551\":3}}],[\"path\",{\"0\":{\"352\":1,\"364\":1},\"1\":{\"318\":7}}],[\"password为\",{\"1\":{\"70\":1}}],[\"password\",{\"1\":{\"70\":2,\"74\":3}}],[\"pair<int\",{\"1\":{\"125\":2,\"167\":1,\"182\":2,\"198\":2,\"241\":4,\"242\":3,\"259\":1,\"267\":1,\"276\":1,\"342\":1,\"343\":6,\"392\":1,\"410\":2,\"418\":1,\"421\":1,\"422\":1,\"423\":1,\"438\":5,\"443\":1,\"575\":1,\"576\":1,\"727\":1}}],[\"pair\",{\"1\":{\"14\":2,\"125\":3,\"127\":2,\"141\":1,\"144\":2,\"167\":4,\"182\":2,\"190\":1,\"198\":4,\"241\":4,\"242\":1,\"259\":2,\"266\":1,\"267\":2,\"276\":2,\"295\":8,\"340\":1,\"342\":1,\"343\":1,\"410\":2,\"421\":2,\"422\":2,\"423\":2,\"433\":2,\"438\":3,\"443\":5}}],[\"p\",{\"0\":{\"375\":1,\"729\":1},\"1\":{\"21\":21,\"100\":8,\"101\":1,\"158\":25,\"178\":4,\"192\":10,\"198\":21,\"205\":8,\"224\":3,\"225\":3,\"226\":3,\"251\":7,\"268\":15,\"283\":11,\"331\":10,\"368\":4,\"415\":7,\"417\":2,\"458\":2,\"462\":12,\"484\":5,\"623\":1,\"729\":7,\"732\":2,\"760\":4}}],[\"f=i\",{\"1\":{\"636\":1}}],[\"f==3\",{\"1\":{\"630\":1}}],[\"f==2\",{\"1\":{\"630\":1}}],[\"f==1\",{\"1\":{\"630\":1}}],[\"f=0\",{\"1\":{\"630\":1}}],[\"f++\",{\"1\":{\"630\":1}}],[\"f<=3\",{\"1\":{\"630\":1}}],[\"february\",{\"1\":{\"455\":1}}],[\"fc\",{\"1\":{\"356\":5}}],[\"fb\",{\"1\":{\"356\":5}}],[\"fnfnfnfn\",{\"1\":{\"286\":2}}],[\"found\",{\"1\":{\"551\":1,\"912\":1}}],[\"fountain\",{\"1\":{\"472\":1}}],[\"fourteen\",{\"1\":{\"246\":1}}],[\"four\",{\"1\":{\"246\":1}}],[\"ford\",{\"1\":{\"772\":1}}],[\"for\",{\"0\":{\"132\":1},\"1\":{\"3\":11,\"5\":1,\"11\":4,\"12\":6,\"13\":5,\"14\":6,\"15\":3,\"17\":2,\"19\":1,\"20\":1,\"21\":1,\"23\":2,\"27\":4,\"29\":4,\"30\":4,\"31\":4,\"32\":2,\"40\":3,\"55\":1,\"109\":4,\"110\":4,\"112\":3,\"113\":3,\"115\":4,\"116\":4,\"117\":3,\"118\":3,\"119\":5,\"120\":4,\"122\":6,\"123\":5,\"124\":4,\"125\":5,\"126\":8,\"127\":2,\"128\":3,\"132\":1,\"134\":1,\"135\":1,\"136\":1,\"137\":2,\"139\":4,\"140\":4,\"141\":6,\"144\":4,\"146\":5,\"147\":6,\"148\":4,\"150\":6,\"151\":6,\"153\":5,\"154\":9,\"156\":8,\"157\":8,\"158\":16,\"160\":6,\"161\":6,\"162\":11,\"163\":6,\"164\":10,\"165\":11,\"166\":12,\"167\":3,\"168\":8,\"169\":3,\"170\":3,\"173\":4,\"174\":3,\"175\":2,\"176\":4,\"177\":6,\"178\":7,\"179\":5,\"180\":2,\"181\":8,\"182\":14,\"184\":4,\"185\":5,\"186\":4,\"187\":8,\"188\":4,\"190\":4,\"191\":3,\"192\":6,\"193\":11,\"194\":4,\"195\":2,\"196\":41,\"197\":12,\"198\":11,\"199\":18,\"200\":5,\"202\":1,\"203\":3,\"204\":8,\"205\":3,\"208\":5,\"209\":2,\"210\":2,\"211\":2,\"213\":6,\"214\":6,\"215\":8,\"216\":5,\"217\":3,\"218\":4,\"219\":9,\"221\":4,\"222\":5,\"224\":3,\"225\":2,\"226\":2,\"227\":5,\"228\":3,\"230\":3,\"231\":10,\"232\":7,\"233\":11,\"235\":2,\"236\":2,\"241\":12,\"242\":8,\"243\":3,\"244\":5,\"245\":2,\"246\":5,\"248\":12,\"249\":5,\"250\":6,\"251\":3,\"253\":3,\"256\":2,\"257\":7,\"258\":6,\"259\":11,\"260\":8,\"262\":2,\"263\":3,\"264\":2,\"266\":7,\"267\":5,\"268\":5,\"269\":3,\"270\":5,\"272\":2,\"273\":1,\"274\":5,\"275\":10,\"276\":14,\"278\":2,\"279\":2,\"280\":5,\"282\":5,\"283\":4,\"284\":3,\"285\":12,\"286\":5,\"287\":3,\"288\":3,\"289\":10,\"291\":1,\"292\":1,\"293\":5,\"295\":8,\"298\":6,\"299\":8,\"301\":2,\"302\":4,\"303\":3,\"305\":3,\"306\":8,\"307\":9,\"309\":1,\"312\":3,\"313\":6,\"314\":3,\"317\":4,\"318\":6,\"319\":2,\"320\":11,\"321\":6,\"324\":2,\"325\":3,\"326\":1,\"329\":5,\"331\":2,\"334\":2,\"335\":7,\"336\":5,\"338\":1,\"340\":5,\"342\":4,\"343\":2,\"345\":1,\"347\":3,\"348\":3,\"349\":2,\"350\":3,\"351\":2,\"352\":3,\"354\":2,\"355\":3,\"356\":2,\"358\":3,\"359\":3,\"361\":5,\"362\":5,\"363\":2,\"365\":4,\"366\":5,\"367\":4,\"368\":4,\"369\":4,\"370\":3,\"371\":3,\"372\":5,\"373\":5,\"374\":5,\"375\":2,\"376\":6,\"377\":8,\"378\":2,\"379\":5,\"380\":4,\"381\":6,\"383\":4,\"384\":7,\"386\":5,\"391\":3,\"392\":3,\"393\":3,\"394\":3,\"395\":3,\"397\":1,\"399\":2,\"400\":1,\"402\":2,\"405\":1,\"410\":8,\"412\":3,\"413\":4,\"414\":3,\"415\":9,\"417\":2,\"418\":3,\"419\":4,\"421\":4,\"422\":4,\"423\":4,\"425\":3,\"426\":5,\"427\":3,\"428\":4,\"430\":6,\"431\":1,\"432\":4,\"433\":2,\"436\":7,\"437\":1,\"438\":7,\"440\":1,\"441\":2,\"443\":5,\"444\":24,\"451\":2,\"453\":3,\"455\":2,\"456\":3,\"457\":3,\"458\":4,\"462\":4,\"464\":3,\"465\":4,\"466\":5,\"467\":5,\"469\":1,\"470\":1,\"473\":2,\"475\":6,\"478\":1,\"479\":6,\"480\":9,\"483\":1,\"484\":5,\"485\":2,\"487\":1,\"488\":5,\"490\":8,\"492\":4,\"493\":3,\"494\":4,\"495\":3,\"497\":1,\"498\":8,\"499\":6,\"500\":4,\"503\":1,\"504\":2,\"505\":6,\"508\":2,\"509\":10,\"519\":3,\"522\":3,\"525\":1,\"526\":2,\"534\":1,\"538\":3,\"539\":2,\"542\":1,\"545\":1,\"546\":1,\"554\":1,\"557\":4,\"560\":3,\"565\":2,\"575\":3,\"576\":3,\"579\":3,\"586\":2,\"589\":1,\"592\":1,\"599\":3,\"602\":1,\"605\":7,\"612\":3,\"618\":2,\"623\":1,\"630\":7,\"633\":1,\"636\":7,\"643\":1,\"646\":2,\"649\":1,\"659\":1,\"669\":1,\"672\":1,\"675\":6,\"682\":1,\"685\":1,\"688\":8,\"695\":2,\"701\":6,\"708\":2,\"711\":3,\"714\":2,\"721\":1,\"724\":2,\"727\":4,\"730\":1,\"732\":7,\"735\":2,\"736\":2,\"737\":3,\"742\":3,\"746\":4,\"747\":2,\"754\":2,\"757\":1,\"760\":2,\"767\":1,\"770\":3,\"772\":1,\"773\":3,\"780\":1,\"783\":1,\"786\":3,\"793\":1,\"796\":1,\"799\":3,\"803\":1,\"804\":1,\"805\":4,\"806\":2,\"812\":3,\"813\":1,\"816\":4,\"819\":2,\"826\":1,\"829\":1,\"832\":4,\"839\":1,\"843\":1,\"847\":1,\"857\":1,\"860\":3,\"868\":1,\"869\":1,\"872\":2,\"875\":12,\"882\":1,\"885\":1,\"888\":3,\"895\":1,\"898\":2,\"902\":5,\"906\":3,\"907\":2}}],[\"fflush\",{\"1\":{\"445\":1}}],[\"ff\",{\"1\":{\"188\":3}}],[\"fx++\",{\"1\":{\"167\":1}}],[\"fx\",{\"1\":{\"167\":4,\"875\":6}}],[\"friend\",{\"1\":{\"727\":2}}],[\"frac\",{\"1\":{\"550\":1,\"802\":1}}],[\"fruit\",{\"1\":{\"321\":2}}],[\"freopen\",{\"1\":{\"198\":2,\"321\":2,\"397\":2,\"399\":2,\"400\":2,\"402\":4,\"405\":2,\"410\":2,\"412\":2,\"413\":4,\"415\":8,\"421\":2,\"422\":2,\"423\":2,\"425\":2,\"426\":2,\"427\":2,\"428\":2,\"430\":2,\"431\":2,\"432\":2,\"433\":2,\"435\":2,\"436\":4,\"437\":2,\"438\":2,\"450\":2,\"452\":2,\"453\":2,\"455\":2,\"456\":2,\"457\":2,\"458\":2,\"480\":2,\"482\":2,\"483\":2,\"484\":3,\"487\":2,\"488\":2,\"489\":2,\"490\":2,\"492\":2,\"493\":2,\"494\":2,\"495\":2,\"497\":2,\"498\":2,\"499\":2,\"500\":2,\"698\":2,\"705\":2,\"708\":2,\"711\":2,\"714\":2,\"718\":2,\"721\":2,\"724\":2,\"727\":2}}],[\"freshans\",{\"1\":{\"440\":3}}],[\"freshg\",{\"1\":{\"158\":2}}],[\"freshnow\",{\"1\":{\"158\":2}}],[\"frog\",{\"0\":{\"354\":1,\"355\":1}}],[\"front\",{\"1\":{\"104\":3,\"106\":1,\"156\":1,\"157\":1,\"163\":6,\"179\":1,\"230\":1,\"231\":1,\"241\":1,\"259\":1,\"267\":1,\"268\":2,\"276\":1,\"295\":3,\"336\":3,\"343\":4,\"366\":1,\"421\":1,\"422\":1,\"423\":1,\"436\":1,\"438\":1,\"443\":1,\"444\":1}}],[\"from\",{\"1\":{\"14\":2}}],[\"flush\",{\"1\":{\"445\":1,\"446\":2,\"447\":2,\"656\":9}}],[\"floor\",{\"1\":{\"450\":1}}],[\"flowers\",{\"0\":{\"376\":1}}],[\"float\",{\"1\":{\"61\":1,\"83\":1}}],[\"flip\",{\"0\":{\"351\":1}}],[\"flag++\",{\"1\":{\"352\":1}}],[\"flag3\",{\"1\":{\"249\":5}}],[\"flag2\",{\"1\":{\"196\":3,\"249\":5,\"777\":5}}],[\"flag1\",{\"1\":{\"196\":3,\"249\":5,\"777\":5}}],[\"flag\",{\"1\":{\"136\":3,\"154\":3,\"178\":3,\"179\":3,\"184\":3,\"185\":3,\"187\":6,\"192\":6,\"196\":10,\"200\":4,\"215\":6,\"217\":3,\"259\":3,\"260\":3,\"262\":11,\"263\":3,\"276\":6,\"285\":3,\"289\":8,\"301\":6,\"319\":5,\"342\":2,\"352\":4,\"394\":4,\"410\":4,\"428\":4,\"432\":8,\"471\":6,\"505\":5,\"575\":3,\"576\":2,\"605\":5,\"701\":3,\"732\":6,\"735\":3,\"737\":4,\"786\":3,\"857\":4,\"872\":9}}],[\"firt=nxtt\",{\"1\":{\"321\":1}}],[\"firt=1\",{\"1\":{\"321\":1}}],[\"firt\",{\"1\":{\"321\":2}}],[\"first+y\",{\"1\":{\"438\":1}}],[\"first+x\",{\"1\":{\"438\":1}}],[\"first++\",{\"1\":{\"153\":1,\"438\":2}}],[\"first<=l\",{\"1\":{\"241\":1}}],[\"first<<\",{\"1\":{\"241\":2}}],[\"first\",{\"1\":{\"13\":5,\"14\":2,\"125\":1,\"127\":7,\"144\":2,\"153\":7,\"160\":2,\"161\":1,\"167\":3,\"182\":4,\"190\":2,\"198\":3,\"241\":12,\"242\":3,\"246\":1,\"259\":2,\"266\":1,\"267\":2,\"276\":2,\"295\":1,\"340\":1,\"342\":1,\"343\":7,\"352\":1,\"370\":1,\"392\":1,\"410\":2,\"418\":7,\"421\":2,\"422\":2,\"423\":3,\"433\":1,\"438\":10,\"443\":1,\"508\":1,\"622\":4,\"672\":2,\"685\":2,\"727\":4}}],[\"final\",{\"0\":{\"320\":1}}],[\"find\",{\"1\":{\"137\":4,\"230\":2,\"309\":1,\"310\":1,\"465\":1,\"466\":1,\"467\":2,\"546\":2,\"575\":1,\"576\":2}}],[\"findexpressions\",{\"1\":{\"40\":3}}],[\"findfa\",{\"1\":{\"14\":3,\"191\":4,\"215\":6,\"243\":4,\"251\":8,\"289\":12}}],[\"fifteen\",{\"1\":{\"246\":1}}],[\"five\",{\"1\":{\"246\":1}}],[\"fixed\",{\"1\":{\"90\":1,\"129\":2,\"181\":1,\"205\":2,\"244\":2,\"285\":1,\"368\":1,\"369\":1,\"450\":1,\"640\":1}}],[\"f\",{\"0\":{\"363\":1,\"908\":1},\"1\":{\"12\":13,\"83\":3,\"109\":7,\"110\":8,\"112\":7,\"113\":4,\"115\":10,\"116\":6,\"117\":4,\"118\":6,\"119\":10,\"120\":8,\"122\":4,\"123\":4,\"124\":8,\"125\":12,\"126\":15,\"128\":13,\"141\":4,\"156\":5,\"157\":10,\"177\":17,\"188\":2,\"196\":25,\"199\":26,\"202\":10,\"203\":23,\"204\":19,\"209\":3,\"233\":8,\"251\":1,\"262\":2,\"263\":2,\"264\":2,\"265\":3,\"272\":7,\"275\":3,\"276\":23,\"280\":13,\"286\":2,\"293\":8,\"307\":3,\"335\":7,\"336\":8,\"340\":8,\"343\":2,\"351\":6,\"354\":11,\"355\":8,\"358\":5,\"359\":4,\"361\":10,\"362\":7,\"363\":8,\"365\":3,\"366\":11,\"367\":7,\"368\":7,\"369\":16,\"370\":4,\"372\":12,\"373\":10,\"375\":12,\"376\":4,\"379\":10,\"380\":7,\"383\":8,\"384\":9,\"399\":3,\"400\":3,\"402\":9,\"405\":9,\"415\":3,\"420\":1,\"436\":5,\"461\":1,\"462\":5,\"473\":2,\"475\":9,\"479\":6,\"489\":3,\"495\":8,\"499\":16,\"500\":5,\"527\":3,\"569\":3,\"618\":4,\"636\":1,\"649\":2,\"662\":3,\"760\":2,\"816\":3,\"844\":4}}],[\"fan\",{\"1\":{\"436\":4}}],[\"fann\",{\"1\":{\"11\":10}}],[\"faw\",{\"1\":{\"384\":5}}],[\"fabs\",{\"1\":{\"285\":3}}],[\"face\",{\"0\":{\"275\":1}}],[\"fa2\",{\"1\":{\"251\":12}}],[\"fa1\",{\"1\":{\"251\":12}}],[\"fav\",{\"1\":{\"243\":3}}],[\"fau\",{\"1\":{\"243\":3}}],[\"fay\",{\"1\":{\"191\":6,\"289\":8}}],[\"fax\",{\"1\":{\"191\":7,\"289\":8}}],[\"fat\",{\"1\":{\"15\":2}}],[\"father\",{\"1\":{\"11\":3}}],[\"fa\",{\"1\":{\"11\":7,\"12\":3,\"13\":2,\"14\":6,\"15\":7,\"191\":6,\"215\":7,\"243\":7,\"251\":10,\"289\":12,\"356\":5,\"375\":2,\"383\":6,\"384\":5,\"433\":2,\"494\":2}}],[\"false\",{\"1\":{\"3\":1,\"11\":1,\"12\":1,\"13\":1,\"14\":2,\"15\":1,\"17\":1,\"19\":1,\"20\":1,\"21\":1,\"23\":1,\"40\":2,\"80\":1,\"109\":1,\"110\":1,\"111\":1,\"112\":1,\"113\":1,\"115\":1,\"116\":1,\"117\":1,\"120\":1,\"122\":1,\"123\":1,\"124\":1,\"125\":1,\"126\":1,\"127\":1,\"128\":1,\"136\":2,\"137\":1,\"141\":1,\"142\":1,\"144\":1,\"146\":2,\"147\":1,\"148\":1,\"150\":1,\"154\":2,\"158\":1,\"162\":4,\"163\":1,\"164\":1,\"165\":1,\"166\":3,\"167\":1,\"168\":3,\"169\":1,\"170\":1,\"172\":1,\"173\":1,\"175\":1,\"176\":1,\"177\":1,\"178\":2,\"179\":3,\"180\":3,\"181\":2,\"182\":8,\"184\":2,\"185\":4,\"186\":4,\"187\":5,\"190\":1,\"192\":2,\"193\":4,\"194\":1,\"195\":2,\"196\":11,\"197\":4,\"198\":4,\"199\":4,\"202\":1,\"203\":1,\"204\":1,\"205\":2,\"208\":2,\"209\":1,\"210\":1,\"211\":1,\"213\":1,\"214\":1,\"215\":2,\"216\":2,\"217\":2,\"218\":1,\"219\":4,\"221\":1,\"222\":1,\"224\":1,\"225\":1,\"226\":1,\"227\":1,\"228\":1,\"230\":1,\"231\":1,\"232\":1,\"233\":2,\"235\":1,\"236\":1,\"237\":1,\"239\":1,\"242\":4,\"244\":4,\"245\":1,\"246\":1,\"248\":1,\"249\":4,\"250\":3,\"253\":2,\"255\":2,\"256\":1,\"257\":1,\"258\":1,\"259\":2,\"260\":2,\"262\":1,\"263\":1,\"265\":1,\"266\":1,\"267\":2,\"268\":1,\"270\":1,\"272\":1,\"273\":1,\"274\":1,\"275\":2,\"276\":4,\"278\":1,\"279\":1,\"280\":1,\"282\":1,\"283\":1,\"284\":1,\"285\":2,\"286\":2,\"287\":1,\"288\":1,\"289\":2,\"291\":3,\"292\":1,\"293\":1,\"295\":1,\"298\":2,\"299\":1,\"301\":5,\"302\":1,\"303\":1,\"305\":1,\"306\":3,\"307\":4,\"309\":1,\"310\":1,\"312\":1,\"313\":2,\"314\":1,\"317\":1,\"318\":1,\"319\":1,\"320\":3,\"321\":1,\"331\":1,\"333\":1,\"334\":1,\"335\":1,\"336\":1,\"338\":1,\"340\":2,\"345\":1,\"347\":1,\"348\":1,\"349\":1,\"350\":1,\"351\":1,\"352\":2,\"354\":1,\"355\":1,\"356\":1,\"358\":1,\"359\":1,\"361\":1,\"362\":1,\"363\":1,\"365\":1,\"366\":1,\"367\":1,\"368\":1,\"369\":1,\"370\":2,\"371\":1,\"372\":1,\"373\":1,\"374\":1,\"375\":1,\"376\":1,\"377\":1,\"381\":1,\"383\":1,\"384\":1,\"386\":1,\"388\":1,\"389\":1,\"391\":1,\"392\":1,\"393\":2,\"394\":1,\"395\":1,\"399\":1,\"400\":1,\"402\":4,\"405\":1,\"410\":4,\"412\":1,\"413\":2,\"414\":1,\"417\":3,\"418\":1,\"419\":1,\"421\":1,\"422\":1,\"423\":1,\"425\":1,\"426\":1,\"427\":1,\"428\":2,\"432\":1,\"438\":1,\"443\":1,\"444\":3,\"445\":2,\"446\":1,\"447\":1,\"458\":1,\"460\":1,\"461\":1,\"471\":1,\"475\":1,\"483\":1,\"484\":6,\"485\":1,\"487\":1,\"505\":1,\"538\":2,\"539\":2,\"542\":1,\"560\":1,\"579\":1,\"596\":1,\"599\":1,\"602\":1,\"605\":4,\"675\":1,\"685\":1,\"701\":1,\"729\":1,\"730\":1,\"731\":1,\"732\":6,\"734\":1,\"735\":2,\"736\":1,\"737\":2,\"741\":1,\"777\":2,\"786\":1,\"790\":1,\"793\":1,\"796\":1,\"799\":1,\"819\":1,\"832\":1,\"857\":2,\"872\":4,\"906\":1}}],[\"r=0\",{\"1\":{\"902\":1}}],[\"r==1\",{\"1\":{\"196\":1}}],[\"r+=helper\",{\"1\":{\"902\":1}}],[\"r+=\",{\"1\":{\"816\":1}}],[\"r++\",{\"1\":{\"146\":1,\"156\":1,\"157\":1,\"166\":1,\"266\":1,\"575\":2,\"621\":1}}],[\"rap\",{\"0\":{\"742\":1}}],[\"random\",{\"1\":{\"457\":2}}],[\"rrrrrr\",{\"1\":{\"705\":1}}],[\"rrbr\",{\"1\":{\"601\":1}}],[\"r<=n\",{\"1\":{\"621\":1}}],[\"r<=5\",{\"1\":{\"196\":1}}],[\"r13\",{\"1\":{\"565\":1}}],[\"r12d\",{\"0\":{\"395\":1}}],[\"r12c\",{\"0\":{\"390\":1}}],[\"r12b\",{\"0\":{\"387\":1}}],[\"r12a\",{\"0\":{\"386\":1}}],[\"ri\",{\"1\":{\"451\":3}}],[\"rightpos\",{\"1\":{\"447\":2}}],[\"right\",{\"0\":{\"275\":1},\"1\":{\"320\":19}}],[\"round\",{\"0\":{\"501\":1,\"506\":1,\"510\":1,\"523\":1,\"528\":1,\"543\":1,\"548\":1,\"561\":1,\"566\":1,\"580\":1,\"593\":1,\"606\":1,\"619\":1,\"624\":1,\"637\":1,\"650\":1,\"663\":1,\"676\":1,\"689\":1,\"702\":1,\"715\":1,\"728\":1,\"733\":1,\"738\":1,\"743\":1,\"748\":1,\"761\":1,\"774\":1,\"787\":1,\"800\":1,\"807\":1,\"820\":1,\"833\":1,\"848\":1,\"861\":1,\"876\":1},\"1\":{\"887\":1}}],[\"root\",{\"1\":{\"427\":8}}],[\"rootv\",{\"1\":{\"215\":6}}],[\"rootu\",{\"1\":{\"215\":6}}],[\"row++\",{\"1\":{\"164\":2,\"711\":1}}],[\"row\",{\"1\":{\"164\":8,\"182\":10,\"185\":6,\"186\":5,\"187\":6,\"285\":5,\"711\":3}}],[\"rnd\",{\"1\":{\"170\":3,\"457\":2}}],[\"rnk\",{\"1\":{\"15\":2,\"122\":4,\"123\":7,\"151\":5,\"174\":1,\"233\":11,\"427\":4,\"467\":6,\"522\":4,\"799\":9}}],[\"run\",{\"1\":{\"318\":3}}],[\"runtime\",{\"1\":{\"40\":1,\"69\":1}}],[\"rubbish\",{\"0\":{\"142\":1}}],[\"rson\",{\"1\":{\"23\":7,\"24\":1,\"313\":5,\"314\":5}}],[\"r\",{\"0\":{\"377\":1},\"1\":{\"13\":6,\"17\":12,\"18\":5,\"19\":23,\"20\":18,\"21\":29,\"23\":12,\"24\":4,\"116\":4,\"117\":4,\"123\":4,\"146\":16,\"147\":4,\"156\":4,\"157\":4,\"163\":5,\"166\":8,\"169\":8,\"172\":5,\"173\":7,\"176\":6,\"181\":8,\"196\":24,\"197\":23,\"198\":1,\"205\":4,\"213\":4,\"216\":16,\"219\":8,\"233\":4,\"235\":5,\"236\":9,\"237\":34,\"239\":34,\"241\":5,\"242\":6,\"244\":4,\"245\":4,\"259\":7,\"260\":4,\"266\":14,\"270\":3,\"286\":4,\"289\":12,\"291\":14,\"292\":13,\"293\":4,\"299\":15,\"312\":9,\"313\":18,\"314\":9,\"317\":5,\"318\":4,\"321\":1,\"331\":5,\"335\":3,\"338\":7,\"340\":8,\"350\":3,\"371\":11,\"372\":3,\"373\":10,\"377\":10,\"384\":3,\"397\":1,\"399\":11,\"400\":10,\"402\":2,\"405\":1,\"410\":4,\"412\":1,\"413\":2,\"414\":6,\"415\":4,\"421\":1,\"422\":1,\"423\":1,\"425\":1,\"426\":1,\"427\":6,\"428\":1,\"430\":4,\"431\":1,\"432\":1,\"433\":1,\"435\":1,\"436\":2,\"437\":5,\"438\":1,\"446\":7,\"447\":16,\"448\":12,\"450\":1,\"452\":1,\"453\":1,\"455\":1,\"456\":1,\"457\":1,\"458\":3,\"470\":4,\"478\":10,\"480\":1,\"482\":1,\"483\":1,\"484\":5,\"485\":4,\"487\":1,\"488\":1,\"489\":1,\"490\":1,\"492\":1,\"493\":1,\"494\":1,\"495\":17,\"497\":1,\"498\":1,\"499\":1,\"500\":5,\"516\":5,\"542\":1,\"575\":9,\"576\":1,\"592\":3,\"615\":6,\"621\":3,\"627\":4,\"659\":3,\"662\":3,\"698\":1,\"704\":1,\"705\":9,\"708\":1,\"711\":1,\"714\":1,\"718\":1,\"721\":1,\"724\":1,\"727\":1,\"729\":4,\"803\":4,\"816\":5,\"832\":3,\"844\":4,\"872\":6}}],[\"rbegin\",{\"1\":{\"3\":2}}],[\"re\",{\"1\":{\"902\":1}}],[\"red\",{\"1\":{\"835\":1,\"836\":1}}],[\"ret\",{\"1\":{\"636\":1}}],[\"ret+=\",{\"1\":{\"636\":1}}],[\"ret=x\",{\"1\":{\"636\":1}}],[\"return\",{\"1\":{\"3\":24,\"5\":1,\"7\":1,\"8\":1,\"11\":2,\"12\":3,\"13\":3,\"14\":3,\"15\":2,\"17\":5,\"18\":3,\"19\":5,\"20\":5,\"21\":6,\"23\":4,\"24\":3,\"27\":1,\"29\":1,\"30\":1,\"31\":1,\"32\":1,\"40\":8,\"46\":1,\"47\":1,\"48\":1,\"49\":1,\"50\":1,\"52\":1,\"53\":1,\"54\":1,\"57\":1,\"59\":1,\"60\":1,\"61\":1,\"63\":3,\"64\":1,\"66\":2,\"70\":1,\"74\":1,\"109\":3,\"110\":3,\"111\":1,\"112\":1,\"113\":1,\"115\":1,\"116\":1,\"117\":1,\"118\":1,\"119\":1,\"120\":1,\"122\":1,\"123\":1,\"124\":1,\"125\":1,\"126\":2,\"127\":1,\"128\":3,\"129\":1,\"131\":1,\"132\":1,\"134\":1,\"135\":2,\"136\":1,\"137\":4,\"139\":2,\"140\":2,\"141\":1,\"142\":4,\"144\":2,\"146\":4,\"147\":3,\"148\":1,\"150\":2,\"151\":3,\"153\":2,\"154\":3,\"156\":1,\"157\":1,\"158\":1,\"160\":1,\"161\":1,\"162\":3,\"163\":2,\"164\":2,\"165\":1,\"166\":4,\"167\":1,\"168\":4,\"169\":3,\"170\":2,\"172\":3,\"173\":3,\"174\":1,\"175\":1,\"176\":1,\"177\":1,\"178\":1,\"179\":1,\"180\":6,\"181\":4,\"182\":8,\"184\":2,\"185\":2,\"186\":3,\"187\":10,\"188\":3,\"190\":4,\"191\":5,\"192\":1,\"193\":4,\"194\":2,\"195\":6,\"196\":9,\"197\":4,\"198\":6,\"199\":9,\"202\":5,\"203\":6,\"204\":3,\"205\":4,\"208\":2,\"209\":1,\"210\":1,\"211\":1,\"213\":4,\"214\":3,\"215\":3,\"216\":8,\"217\":2,\"218\":1,\"219\":6,\"221\":4,\"222\":4,\"224\":1,\"225\":1,\"226\":1,\"227\":1,\"228\":2,\"230\":1,\"231\":1,\"232\":1,\"233\":2,\"235\":1,\"236\":4,\"237\":7,\"239\":9,\"241\":3,\"242\":4,\"243\":3,\"244\":7,\"245\":2,\"246\":3,\"248\":5,\"249\":2,\"250\":5,\"251\":3,\"253\":4,\"255\":3,\"256\":3,\"257\":1,\"258\":3,\"259\":1,\"260\":1,\"262\":10,\"263\":2,\"264\":3,\"265\":1,\"266\":3,\"267\":2,\"268\":1,\"269\":1,\"270\":6,\"272\":2,\"273\":5,\"274\":1,\"275\":6,\"276\":4,\"278\":2,\"279\":3,\"280\":1,\"282\":1,\"283\":1,\"284\":1,\"285\":2,\"286\":6,\"287\":1,\"288\":1,\"289\":8,\"291\":5,\"292\":6,\"293\":2,\"295\":1,\"298\":5,\"299\":1,\"301\":2,\"302\":3,\"303\":1,\"305\":3,\"306\":6,\"307\":6,\"309\":1,\"310\":1,\"312\":4,\"313\":8,\"314\":4,\"317\":1,\"318\":1,\"319\":5,\"320\":3,\"321\":1,\"323\":1,\"324\":1,\"325\":2,\"326\":1,\"329\":1,\"331\":1,\"333\":1,\"334\":1,\"335\":3,\"336\":1,\"338\":1,\"340\":3,\"342\":1,\"343\":2,\"345\":2,\"347\":1,\"348\":1,\"349\":1,\"350\":1,\"351\":1,\"352\":4,\"354\":1,\"355\":1,\"356\":1,\"358\":1,\"359\":4,\"361\":1,\"362\":1,\"363\":1,\"365\":3,\"366\":1,\"367\":1,\"368\":1,\"369\":1,\"370\":1,\"371\":1,\"372\":1,\"373\":1,\"374\":4,\"375\":1,\"376\":3,\"377\":3,\"378\":4,\"379\":1,\"380\":1,\"381\":6,\"383\":1,\"384\":2,\"386\":1,\"388\":1,\"389\":1,\"391\":1,\"392\":1,\"393\":1,\"394\":1,\"395\":3,\"397\":1,\"399\":2,\"400\":2,\"402\":3,\"405\":1,\"410\":3,\"412\":1,\"413\":4,\"414\":3,\"415\":6,\"417\":6,\"418\":1,\"419\":1,\"421\":1,\"422\":1,\"423\":1,\"425\":1,\"426\":1,\"427\":2,\"428\":1,\"430\":1,\"431\":1,\"432\":1,\"433\":1,\"435\":1,\"436\":3,\"437\":5,\"438\":4,\"440\":1,\"441\":1,\"443\":2,\"444\":2,\"446\":3,\"447\":3,\"448\":3,\"450\":1,\"451\":1,\"452\":1,\"453\":1,\"455\":1,\"456\":1,\"457\":2,\"458\":1,\"460\":1,\"461\":1,\"462\":1,\"464\":2,\"465\":2,\"466\":3,\"467\":4,\"469\":2,\"470\":2,\"471\":1,\"473\":3,\"475\":2,\"477\":1,\"478\":1,\"479\":1,\"480\":4,\"482\":1,\"483\":1,\"484\":15,\"485\":3,\"487\":1,\"488\":1,\"489\":2,\"490\":3,\"492\":1,\"493\":1,\"494\":3,\"495\":1,\"497\":1,\"498\":1,\"499\":1,\"500\":2,\"502\":1,\"503\":1,\"504\":1,\"505\":1,\"507\":1,\"509\":1,\"513\":1,\"516\":1,\"519\":3,\"522\":2,\"524\":1,\"525\":1,\"526\":2,\"527\":4,\"531\":1,\"534\":1,\"535\":1,\"538\":4,\"539\":3,\"542\":1,\"544\":1,\"545\":1,\"546\":1,\"547\":1,\"551\":1,\"554\":1,\"557\":3,\"560\":1,\"562\":1,\"563\":1,\"564\":1,\"565\":3,\"569\":1,\"572\":1,\"575\":8,\"576\":4,\"579\":3,\"583\":1,\"586\":1,\"589\":2,\"592\":2,\"596\":1,\"599\":1,\"602\":3,\"605\":1,\"609\":1,\"612\":2,\"615\":1,\"618\":2,\"620\":1,\"621\":1,\"622\":1,\"623\":3,\"627\":1,\"630\":1,\"633\":2,\"636\":3,\"640\":1,\"643\":1,\"646\":1,\"649\":5,\"653\":1,\"656\":10,\"659\":1,\"662\":2,\"666\":1,\"669\":1,\"672\":5,\"675\":9,\"679\":1,\"682\":1,\"685\":3,\"688\":1,\"692\":1,\"695\":1,\"698\":1,\"701\":1,\"705\":1,\"708\":1,\"711\":1,\"714\":2,\"718\":1,\"721\":1,\"724\":1,\"727\":1,\"729\":1,\"730\":1,\"731\":1,\"732\":9,\"734\":1,\"735\":1,\"736\":1,\"737\":1,\"739\":1,\"740\":1,\"741\":1,\"744\":1,\"745\":1,\"746\":1,\"747\":2,\"751\":1,\"754\":1,\"757\":1,\"760\":3,\"764\":1,\"767\":1,\"770\":1,\"773\":1,\"777\":1,\"780\":2,\"783\":1,\"786\":1,\"790\":1,\"793\":1,\"796\":1,\"799\":2,\"801\":1,\"803\":1,\"805\":1,\"806\":1,\"810\":1,\"813\":1,\"816\":1,\"819\":1,\"823\":1,\"826\":1,\"829\":1,\"832\":1,\"836\":1,\"839\":1,\"843\":1,\"844\":2,\"847\":1,\"851\":1,\"854\":1,\"857\":1,\"860\":1,\"864\":1,\"868\":1,\"869\":1,\"872\":5,\"875\":7,\"879\":1,\"882\":1,\"885\":1,\"888\":1,\"892\":1,\"895\":1,\"898\":1,\"902\":4,\"906\":2,\"907\":1,\"911\":1}}],[\"readint\",{\"1\":{\"551\":2}}],[\"registertestlibcmd\",{\"1\":{\"551\":1}}],[\"repeat\",{\"1\":{\"269\":1}}],[\"res=\",{\"1\":{\"906\":1}}],[\"res2\",{\"1\":{\"413\":3}}],[\"res1\",{\"1\":{\"413\":3}}],[\"res>a\",{\"1\":{\"413\":1}}],[\"res++\",{\"1\":{\"264\":1,\"335\":1,\"414\":2,\"443\":4}}],[\"result\",{\"1\":{\"40\":3}}],[\"res\",{\"1\":{\"17\":4,\"18\":4,\"19\":4,\"20\":4,\"21\":4,\"23\":4,\"153\":3,\"170\":6,\"172\":3,\"173\":3,\"213\":3,\"216\":10,\"236\":3,\"237\":4,\"239\":4,\"258\":3,\"264\":3,\"266\":3,\"291\":4,\"292\":4,\"302\":4,\"335\":5,\"343\":5,\"359\":6,\"365\":4,\"374\":4,\"376\":4,\"377\":14,\"378\":5,\"381\":7,\"413\":2,\"414\":2,\"417\":4,\"438\":6,\"443\":2,\"446\":3,\"447\":3,\"466\":7,\"467\":7,\"498\":3,\"586\":3,\"875\":3,\"906\":6}}],[\"resize\",{\"1\":{\"3\":4,\"103\":1,\"618\":1}}],[\"rev\",{\"1\":{\"3\":2}}],[\"easy\",{\"1\":{\"851\":1}}],[\"e==3\",{\"1\":{\"630\":1}}],[\"e==2\",{\"1\":{\"630\":1}}],[\"e==1\",{\"1\":{\"630\":1}}],[\"e=0\",{\"1\":{\"630\":1}}],[\"e<=3\",{\"1\":{\"630\":1}}],[\"e++\",{\"1\":{\"575\":2,\"630\":1}}],[\"ejoi2020\",{\"1\":{\"472\":1}}],[\"ee\",{\"1\":{\"366\":3,\"444\":5,\"480\":8}}],[\"ey\",{\"1\":{\"336\":5}}],[\"even\",{\"1\":{\"274\":5,\"564\":2}}],[\"evaluateexpression\",{\"1\":{\"40\":2}}],[\"eleven\",{\"1\":{\"246\":1}}],[\"else\",{\"1\":{\"3\":2,\"13\":2,\"14\":2,\"15\":1,\"19\":1,\"20\":1,\"21\":2,\"23\":1,\"32\":1,\"40\":1,\"71\":1,\"74\":1,\"75\":3,\"76\":1,\"77\":1,\"78\":2,\"79\":1,\"80\":1,\"100\":1,\"111\":2,\"116\":1,\"117\":1,\"119\":1,\"120\":1,\"123\":1,\"124\":1,\"125\":2,\"127\":5,\"129\":2,\"131\":1,\"132\":1,\"135\":1,\"136\":1,\"139\":1,\"140\":2,\"146\":2,\"147\":1,\"156\":1,\"157\":3,\"160\":1,\"162\":3,\"165\":6,\"168\":5,\"169\":1,\"173\":1,\"174\":1,\"179\":1,\"181\":2,\"185\":1,\"186\":2,\"187\":1,\"188\":6,\"192\":4,\"194\":1,\"195\":7,\"196\":8,\"197\":1,\"198\":3,\"199\":3,\"202\":1,\"203\":1,\"204\":1,\"205\":2,\"210\":3,\"211\":1,\"213\":1,\"214\":1,\"219\":5,\"221\":1,\"222\":3,\"224\":1,\"225\":1,\"230\":2,\"232\":2,\"233\":1,\"235\":1,\"236\":3,\"237\":3,\"239\":2,\"244\":1,\"245\":1,\"246\":1,\"260\":1,\"262\":11,\"263\":3,\"264\":3,\"265\":1,\"268\":2,\"269\":2,\"270\":4,\"272\":4,\"273\":1,\"274\":1,\"275\":1,\"276\":1,\"280\":1,\"283\":1,\"286\":3,\"287\":2,\"289\":2,\"291\":2,\"292\":1,\"293\":1,\"295\":3,\"299\":1,\"301\":1,\"305\":1,\"309\":2,\"310\":3,\"312\":2,\"313\":4,\"314\":2,\"317\":4,\"318\":3,\"319\":5,\"320\":2,\"321\":2,\"323\":1,\"324\":4,\"326\":1,\"328\":1,\"331\":2,\"340\":3,\"342\":1,\"343\":1,\"361\":1,\"363\":3,\"367\":1,\"370\":1,\"372\":1,\"379\":1,\"380\":1,\"384\":1,\"388\":1,\"389\":1,\"397\":2,\"410\":2,\"413\":1,\"421\":1,\"422\":1,\"423\":1,\"431\":3,\"432\":1,\"435\":1,\"437\":4,\"438\":2,\"440\":2,\"441\":1,\"444\":1,\"446\":1,\"447\":6,\"448\":3,\"451\":1,\"460\":4,\"461\":3,\"465\":1,\"471\":3,\"475\":1,\"477\":2,\"480\":1,\"482\":2,\"484\":1,\"485\":2,\"488\":1,\"500\":1,\"502\":2,\"507\":1,\"508\":3,\"509\":4,\"513\":10,\"516\":1,\"522\":1,\"525\":1,\"527\":2,\"531\":2,\"542\":1,\"544\":2,\"545\":2,\"546\":1,\"560\":1,\"562\":1,\"563\":3,\"564\":1,\"565\":3,\"569\":1,\"572\":3,\"575\":4,\"576\":4,\"583\":1,\"599\":8,\"622\":6,\"627\":1,\"633\":4,\"646\":1,\"653\":6,\"679\":3,\"685\":4,\"714\":1,\"721\":2,\"724\":1,\"732\":2,\"734\":1,\"735\":2,\"736\":1,\"739\":1,\"741\":2,\"747\":2,\"751\":1,\"763\":1,\"764\":17,\"767\":1,\"773\":1,\"777\":5,\"796\":3,\"799\":3,\"801\":1,\"803\":1,\"819\":1,\"832\":1,\"836\":3,\"843\":1,\"844\":1,\"851\":2,\"854\":2,\"857\":2,\"868\":1,\"872\":2,\"879\":1,\"892\":2,\"898\":1,\"907\":1,\"911\":4}}],[\"eighteen\",{\"1\":{\"246\":1}}],[\"eight\",{\"1\":{\"246\":1}}],[\"educational\",{\"0\":{\"353\":1}}],[\"ed\",{\"1\":{\"231\":3,\"527\":5}}],[\"end\",{\"1\":{\"103\":1,\"126\":1,\"137\":4,\"151\":1,\"182\":1,\"198\":1,\"208\":1,\"214\":2,\"225\":1,\"230\":2,\"241\":2,\"285\":1,\"298\":2,\"309\":2,\"310\":2,\"312\":4,\"313\":5,\"314\":1,\"331\":2,\"417\":2,\"438\":1,\"462\":1,\"465\":1,\"466\":1,\"467\":2,\"589\":1}}],[\"endl\",{\"1\":{\"40\":2,\"128\":2,\"170\":2,\"172\":3,\"173\":3,\"178\":3,\"200\":1,\"217\":1,\"222\":1,\"273\":1,\"280\":1,\"318\":1,\"448\":3,\"461\":1,\"902\":1}}],[\"expected\",{\"1\":{\"551\":1}}],[\"expr\",{\"1\":{\"40\":3}}],[\"ex\",{\"1\":{\"336\":5}}],[\"exist\",{\"1\":{\"309\":1,\"310\":1}}],[\"exit\",{\"1\":{\"135\":1,\"170\":1,\"185\":1,\"186\":1,\"228\":1,\"248\":1,\"249\":1,\"447\":1,\"633\":1}}],[\"exceeded\",{\"1\":{\"69\":2}}],[\"error\",{\"1\":{\"40\":1,\"69\":2}}],[\"erase\",{\"1\":{\"3\":1,\"309\":1,\"310\":1,\"331\":4}}],[\"eps\",{\"1\":{\"40\":2,\"575\":1,\"576\":1}}],[\"e\",{\"0\":{\"340\":1,\"343\":1,\"352\":1,\"360\":1,\"903\":1},\"1\":{\"11\":4,\"12\":5,\"13\":5,\"14\":5,\"15\":7,\"147\":2,\"215\":8,\"228\":5,\"251\":1,\"287\":1,\"295\":12,\"352\":6,\"365\":3,\"366\":3,\"375\":4,\"383\":7,\"384\":9,\"428\":4,\"433\":6,\"436\":3,\"444\":7,\"453\":13,\"464\":2,\"465\":6,\"466\":5,\"467\":5,\"479\":4,\"480\":12,\"494\":3,\"516\":3,\"527\":3,\"569\":5,\"575\":7,\"727\":9,\"773\":3,\"786\":3}}],[\"empty\",{\"1\":{\"3\":1,\"103\":1,\"104\":1,\"105\":1,\"106\":1,\"144\":1,\"156\":1,\"157\":1,\"163\":2,\"167\":1,\"179\":1,\"230\":1,\"231\":1,\"241\":1,\"259\":1,\"267\":1,\"268\":1,\"276\":1,\"295\":1,\"309\":2,\"310\":2,\"336\":1,\"342\":1,\"343\":1,\"366\":1,\"421\":1,\"422\":1,\"423\":1,\"436\":1,\"438\":1,\"443\":1,\"444\":1,\"475\":2}}],[\">32\",{\"1\":{\"494\":1}}],[\">j+v\",{\"1\":{\"293\":1}}],[\">>\",{\"1\":{\"5\":1,\"7\":2,\"8\":2,\"11\":7,\"12\":7,\"13\":7,\"14\":7,\"15\":7,\"17\":8,\"19\":9,\"20\":9,\"21\":13,\"23\":2,\"27\":2,\"29\":2,\"30\":2,\"31\":2,\"32\":2,\"40\":1,\"66\":6,\"70\":2,\"74\":2,\"109\":2,\"110\":2,\"111\":7,\"112\":2,\"113\":2,\"115\":2,\"116\":2,\"117\":2,\"118\":2,\"119\":2,\"120\":4,\"122\":3,\"123\":3,\"124\":4,\"125\":4,\"126\":4,\"127\":4,\"128\":3,\"129\":3,\"131\":2,\"132\":2,\"134\":1,\"135\":1,\"136\":1,\"137\":3,\"139\":3,\"140\":3,\"141\":3,\"142\":5,\"144\":5,\"146\":5,\"147\":5,\"148\":4,\"150\":7,\"151\":7,\"153\":5,\"154\":3,\"156\":3,\"157\":3,\"158\":3,\"160\":3,\"161\":3,\"162\":3,\"163\":7,\"164\":10,\"165\":7,\"166\":3,\"167\":2,\"168\":2,\"169\":2,\"170\":2,\"172\":2,\"173\":2,\"174\":7,\"175\":7,\"176\":3,\"177\":3,\"178\":3,\"179\":4,\"180\":3,\"181\":8,\"182\":2,\"184\":4,\"185\":4,\"186\":4,\"187\":4,\"188\":4,\"190\":3,\"191\":5,\"192\":2,\"193\":8,\"194\":8,\"195\":4,\"196\":40,\"197\":8,\"198\":27,\"199\":14,\"200\":5,\"202\":5,\"203\":5,\"204\":5,\"205\":6,\"208\":4,\"209\":2,\"210\":2,\"211\":2,\"213\":2,\"214\":2,\"215\":6,\"216\":8,\"217\":1,\"218\":7,\"219\":6,\"221\":3,\"222\":3,\"224\":5,\"225\":5,\"226\":5,\"227\":5,\"228\":4,\"230\":1,\"231\":1,\"232\":3,\"233\":6,\"235\":5,\"236\":5,\"237\":5,\"239\":5,\"241\":3,\"242\":3,\"243\":4,\"244\":8,\"245\":3,\"246\":1,\"248\":1,\"249\":1,\"250\":8,\"251\":5,\"253\":2,\"255\":2,\"256\":2,\"257\":4,\"258\":2,\"259\":6,\"260\":8,\"262\":5,\"263\":5,\"264\":5,\"265\":6,\"266\":5,\"267\":4,\"268\":3,\"269\":4,\"270\":2,\"272\":1,\"273\":2,\"274\":4,\"275\":4,\"276\":10,\"278\":3,\"279\":3,\"280\":3,\"282\":2,\"283\":2,\"284\":2,\"285\":2,\"286\":6,\"287\":8,\"288\":5,\"289\":14,\"291\":8,\"292\":8,\"293\":4,\"295\":3,\"298\":8,\"299\":6,\"301\":2,\"302\":2,\"303\":2,\"305\":2,\"306\":2,\"307\":6,\"309\":3,\"310\":3,\"312\":5,\"313\":10,\"314\":5,\"317\":5,\"318\":5,\"319\":4,\"320\":6,\"323\":1,\"324\":4,\"325\":6,\"326\":4,\"329\":3,\"331\":8,\"333\":2,\"334\":1,\"335\":2,\"336\":3,\"338\":1,\"340\":5,\"342\":7,\"343\":2,\"345\":3,\"347\":2,\"348\":2,\"349\":2,\"350\":4,\"351\":3,\"352\":5,\"354\":2,\"355\":3,\"356\":4,\"358\":4,\"359\":4,\"361\":4,\"362\":4,\"363\":2,\"365\":4,\"366\":4,\"367\":3,\"368\":2,\"369\":2,\"370\":3,\"371\":2,\"372\":3,\"373\":2,\"374\":2,\"375\":3,\"376\":3,\"377\":3,\"378\":2,\"379\":2,\"380\":2,\"381\":2,\"383\":4,\"384\":4,\"386\":1,\"388\":2,\"389\":2,\"391\":3,\"392\":3,\"393\":3,\"394\":3,\"395\":1,\"397\":2,\"399\":2,\"400\":2,\"402\":6,\"405\":3,\"410\":4,\"412\":3,\"413\":2,\"414\":3,\"415\":8,\"417\":1,\"418\":3,\"419\":3,\"421\":8,\"422\":8,\"423\":8,\"425\":1,\"426\":4,\"427\":4,\"428\":5,\"430\":4,\"431\":6,\"432\":2,\"433\":4,\"435\":4,\"436\":8,\"437\":3,\"438\":2,\"440\":1,\"441\":2,\"443\":2,\"444\":2,\"446\":2,\"447\":2,\"448\":2,\"450\":2,\"451\":4,\"452\":1,\"453\":1,\"455\":1,\"456\":7,\"457\":4,\"458\":5,\"460\":4,\"461\":2,\"462\":1,\"464\":6,\"465\":6,\"466\":6,\"467\":6,\"469\":2,\"470\":3,\"471\":12,\"473\":6,\"475\":6,\"477\":16,\"478\":2,\"479\":3,\"480\":3,\"482\":1,\"483\":2,\"484\":2,\"485\":3,\"487\":1,\"488\":5,\"489\":3,\"490\":3,\"492\":1,\"493\":2,\"494\":2,\"495\":2,\"497\":2,\"498\":3,\"499\":4,\"500\":3,\"502\":7,\"503\":3,\"504\":1,\"505\":3,\"513\":6,\"516\":6,\"522\":3,\"524\":3,\"525\":6,\"526\":1,\"530\":3,\"531\":3,\"534\":1,\"535\":1,\"538\":1,\"542\":2,\"547\":1,\"551\":1,\"554\":2,\"557\":2,\"560\":5,\"562\":4,\"563\":5,\"564\":1,\"565\":3,\"569\":6,\"572\":1,\"575\":2,\"576\":2,\"579\":2,\"583\":2,\"586\":1,\"589\":1,\"592\":2,\"596\":3,\"599\":12,\"602\":2,\"605\":3,\"609\":1,\"612\":4,\"615\":1,\"618\":1,\"622\":2,\"627\":1,\"630\":2,\"640\":2,\"643\":3,\"646\":1,\"649\":2,\"653\":2,\"656\":9,\"659\":5,\"662\":4,\"666\":1,\"669\":3,\"672\":2,\"675\":1,\"679\":3,\"682\":1,\"685\":2,\"688\":6,\"692\":1,\"695\":1,\"698\":1,\"701\":3,\"705\":5,\"708\":6,\"711\":2,\"714\":1,\"718\":8,\"721\":2,\"724\":1,\"727\":4,\"729\":2,\"730\":1,\"731\":5,\"732\":4,\"734\":4,\"735\":1,\"736\":2,\"737\":2,\"741\":1,\"744\":5,\"745\":3,\"746\":1,\"747\":4,\"751\":4,\"754\":5,\"757\":2,\"760\":3,\"764\":4,\"767\":6,\"770\":1,\"773\":5,\"777\":6,\"780\":2,\"783\":2,\"786\":4,\"790\":2,\"793\":1,\"799\":2,\"801\":1,\"803\":1,\"805\":1,\"806\":3,\"810\":7,\"813\":1,\"819\":2,\"823\":3,\"826\":3,\"829\":1,\"832\":5,\"836\":4,\"839\":1,\"844\":1,\"847\":8,\"851\":1,\"854\":1,\"857\":1,\"860\":2,\"864\":9,\"868\":2,\"869\":2,\"872\":6,\"875\":9,\"879\":3,\"882\":2,\"885\":2,\"888\":2,\"892\":3,\"895\":2,\"898\":2,\"907\":1}}],[\">>=\",{\"1\":{\"3\":1}}],[\">\",{\"1\":{\"3\":2,\"13\":1,\"14\":1,\"15\":3,\"17\":1,\"19\":2,\"20\":2,\"21\":3,\"23\":1,\"29\":1,\"72\":1,\"76\":1,\"77\":2,\"80\":1,\"81\":1,\"91\":6,\"99\":3,\"111\":3,\"115\":2,\"116\":1,\"125\":1,\"127\":4,\"128\":3,\"129\":2,\"131\":1,\"132\":1,\"139\":1,\"140\":2,\"141\":1,\"142\":1,\"144\":1,\"146\":1,\"147\":1,\"148\":2,\"150\":1,\"151\":1,\"153\":1,\"158\":3,\"163\":3,\"167\":3,\"168\":2,\"172\":1,\"176\":1,\"178\":1,\"181\":1,\"195\":2,\"196\":6,\"198\":6,\"199\":1,\"202\":2,\"203\":2,\"205\":1,\"209\":1,\"210\":2,\"211\":1,\"214\":1,\"217\":1,\"219\":6,\"222\":1,\"232\":1,\"236\":1,\"242\":1,\"244\":2,\"245\":1,\"248\":2,\"249\":2,\"250\":1,\"251\":1,\"257\":1,\"260\":1,\"264\":1,\"272\":1,\"273\":1,\"285\":1,\"286\":4,\"291\":2,\"292\":2,\"295\":1,\"298\":3,\"301\":3,\"307\":1,\"312\":2,\"313\":4,\"314\":2,\"324\":2,\"325\":1,\"335\":1,\"336\":2,\"338\":2,\"345\":1,\"348\":2,\"363\":1,\"377\":1,\"379\":1,\"380\":1,\"381\":1,\"388\":1,\"389\":1,\"397\":1,\"399\":1,\"400\":1,\"402\":1,\"405\":1,\"410\":2,\"421\":2,\"422\":2,\"423\":2,\"435\":1,\"444\":1,\"448\":2,\"450\":1,\"453\":1,\"456\":1,\"462\":1,\"470\":1,\"477\":1,\"478\":3,\"483\":1,\"484\":7,\"485\":1,\"487\":1,\"488\":2,\"494\":3,\"495\":1,\"502\":3,\"513\":7,\"519\":2,\"526\":2,\"527\":2,\"534\":2,\"560\":2,\"562\":3,\"563\":2,\"572\":3,\"575\":1,\"576\":1,\"592\":1,\"599\":1,\"602\":1,\"605\":2,\"609\":3,\"646\":1,\"672\":4,\"682\":1,\"685\":2,\"705\":2,\"735\":1,\"737\":1,\"760\":1,\"764\":1,\"777\":2,\"799\":1,\"839\":1,\"844\":1,\"854\":2,\"872\":6,\"875\":4,\"879\":1,\"892\":2,\"895\":1}}],[\">=3\",{\"1\":{\"636\":1}}],[\">=2\",{\"1\":{\"633\":1,\"742\":1}}],[\">=11\",{\"1\":{\"633\":2}}],[\">=siz+1\",{\"1\":{\"146\":1}}],[\">=mid+1\",{\"1\":{\"146\":1}}],[\">=\",{\"1\":{\"3\":5,\"11\":1,\"12\":3,\"17\":1,\"23\":2,\"24\":1,\"30\":1,\"72\":1,\"81\":1,\"115\":1,\"116\":2,\"117\":3,\"123\":1,\"125\":3,\"126\":2,\"128\":1,\"135\":1,\"136\":1,\"144\":1,\"147\":1,\"156\":1,\"157\":1,\"160\":2,\"165\":6,\"170\":1,\"172\":1,\"173\":2,\"181\":6,\"184\":1,\"185\":1,\"187\":2,\"188\":1,\"193\":1,\"196\":3,\"199\":2,\"202\":1,\"203\":4,\"204\":1,\"213\":2,\"214\":2,\"215\":1,\"216\":1,\"219\":4,\"222\":1,\"232\":2,\"233\":1,\"235\":1,\"236\":1,\"237\":3,\"239\":3,\"244\":1,\"245\":1,\"256\":1,\"258\":1,\"260\":1,\"266\":1,\"267\":2,\"276\":2,\"279\":1,\"285\":2,\"291\":2,\"292\":2,\"293\":2,\"303\":1,\"320\":3,\"329\":1,\"335\":2,\"340\":1,\"343\":1,\"352\":1,\"354\":2,\"355\":1,\"358\":1,\"362\":2,\"370\":1,\"376\":1,\"384\":1,\"394\":1,\"410\":1,\"428\":1,\"432\":1,\"436\":1,\"437\":1,\"440\":2,\"441\":2,\"444\":2,\"447\":2,\"448\":1,\"453\":1,\"458\":1,\"475\":2,\"479\":2,\"485\":2,\"487\":1,\"494\":2,\"497\":3,\"499\":2,\"500\":2,\"516\":1,\"527\":2,\"546\":1,\"575\":4,\"576\":3,\"599\":12,\"662\":4,\"714\":1,\"721\":3,\"734\":3,\"751\":1,\"759\":1,\"780\":1,\"803\":1,\"810\":3,\"832\":2,\"882\":1}}],[\"3+\",{\"1\":{\"742\":1}}],[\"360+1\",{\"1\":{\"740\":1}}],[\"360+1<<\",{\"1\":{\"740\":1}}],[\"3600\",{\"1\":{\"527\":3}}],[\"3985\",{\"1\":{\"484\":1}}],[\"3958\",{\"1\":{\"484\":1}}],[\"3923\",{\"1\":{\"484\":1}}],[\"390\",{\"1\":{\"484\":1}}],[\"3883\",{\"1\":{\"484\":1}}],[\"3848\",{\"1\":{\"484\":1}}],[\"3825\",{\"1\":{\"484\":1}}],[\"3802\",{\"1\":{\"484\":1}}],[\"3863ms\",{\"1\":{\"109\":1}}],[\"3771\",{\"1\":{\"484\":1}}],[\"3738\",{\"1\":{\"484\":1}}],[\"3701\",{\"1\":{\"484\":1}}],[\"34\",{\"0\":{\"787\":1}}],[\"3469\",{\"1\":{\"484\":1}}],[\"3439\",{\"1\":{\"484\":1}}],[\"3411\",{\"1\":{\"484\":1}}],[\"344\",{\"1\":{\"484\":1}}],[\"3a+4b\",{\"1\":{\"413\":1}}],[\"3597\",{\"1\":{\"484\":1}}],[\"3570\",{\"1\":{\"484\":1}}],[\"3540\",{\"1\":{\"484\":1}}],[\"3501\",{\"1\":{\"484\":1}}],[\"35\",{\"0\":{\"800\":1},\"1\":{\"318\":3}}],[\"32\",{\"0\":{\"278\":1,\"761\":1},\"1\":{\"83\":2,\"85\":2,\"101\":2,\"575\":4}}],[\"3095\",{\"1\":{\"484\":1}}],[\"3063\",{\"1\":{\"484\":1}}],[\"3036\",{\"1\":{\"484\":1}}],[\"30ull\",{\"1\":{\"457\":1}}],[\"305\",{\"1\":{\"167\":4,\"369\":3,\"875\":2}}],[\"3005\",{\"1\":{\"371\":5,\"379\":2,\"380\":4}}],[\"3000\",{\"1\":{\"363\":1,\"368\":7,\"575\":1,\"576\":1}}],[\"30005\",{\"1\":{\"318\":2}}],[\"30000\",{\"1\":{\"317\":1}}],[\"300000\",{\"1\":{\"280\":1,\"391\":2,\"392\":2,\"393\":2,\"394\":2}}],[\"3000000\",{\"1\":{\"192\":1}}],[\"300\",{\"1\":{\"134\":2,\"135\":2,\"136\":2,\"519\":1}}],[\"30\",{\"0\":{\"185\":1,\"409\":1,\"465\":1,\"473\":1,\"743\":1},\"1\":{\"23\":1,\"79\":1,\"80\":1,\"126\":1,\"165\":1,\"184\":1,\"185\":2,\"186\":3,\"187\":4,\"267\":2,\"317\":1,\"352\":1,\"457\":1,\"465\":1,\"502\":1,\"504\":1,\"507\":1,\"509\":1,\"512\":2,\"515\":2,\"518\":2,\"521\":2,\"524\":2,\"525\":2,\"526\":2,\"527\":10,\"530\":2,\"533\":2,\"537\":2,\"541\":2,\"544\":2,\"545\":2,\"546\":2,\"550\":2,\"553\":2,\"556\":2,\"559\":2,\"562\":2,\"563\":2,\"564\":2,\"565\":2,\"568\":2,\"571\":2,\"572\":1,\"578\":2,\"582\":2,\"588\":2,\"591\":2,\"595\":2,\"598\":2,\"599\":4,\"601\":2,\"604\":2,\"608\":2,\"611\":2,\"614\":2,\"622\":1,\"626\":2,\"629\":2,\"639\":2,\"642\":2,\"645\":2,\"648\":2,\"652\":2,\"655\":2,\"658\":2,\"661\":2,\"665\":2,\"668\":2,\"671\":2,\"678\":2,\"681\":2,\"684\":2,\"687\":2,\"691\":2,\"700\":2,\"704\":2,\"707\":2,\"720\":2,\"726\":2,\"783\":1,\"809\":2,\"812\":2,\"815\":2,\"816\":4,\"818\":2,\"822\":2,\"825\":2,\"828\":2,\"831\":2,\"835\":2,\"838\":2,\"839\":2,\"841\":2,\"846\":2,\"850\":2,\"853\":2,\"856\":2,\"859\":2,\"863\":2,\"866\":2,\"871\":2,\"872\":2,\"874\":2,\"875\":4,\"878\":2,\"881\":2,\"884\":2,\"887\":2,\"891\":2,\"894\":2,\"897\":2}}],[\"312\",{\"1\":{\"494\":1}}],[\"3194\",{\"1\":{\"484\":1}}],[\"3163\",{\"1\":{\"484\":1}}],[\"3130\",{\"1\":{\"484\":1}}],[\"31\",{\"0\":{\"748\":1},\"1\":{\"3\":1,\"414\":1,\"509\":4,\"527\":14,\"572\":1,\"839\":1}}],[\"3\",{\"0\":{\"78\":1,\"259\":1,\"264\":1,\"409\":1,\"447\":1,\"738\":1},\"1\":{\"3\":2,\"21\":1,\"37\":2,\"38\":2,\"41\":684,\"57\":4,\"60\":1,\"61\":1,\"63\":2,\"64\":1,\"131\":2,\"132\":2,\"156\":2,\"157\":2,\"158\":2,\"163\":1,\"170\":1,\"172\":1,\"173\":1,\"174\":1,\"182\":12,\"184\":1,\"185\":2,\"186\":1,\"187\":2,\"188\":1,\"192\":1,\"193\":1,\"195\":2,\"196\":1,\"205\":1,\"213\":1,\"214\":1,\"217\":1,\"218\":3,\"228\":1,\"230\":5,\"231\":2,\"241\":2,\"242\":1,\"246\":2,\"248\":9,\"249\":9,\"262\":1,\"267\":40,\"268\":1,\"282\":3,\"283\":3,\"284\":3,\"319\":1,\"340\":2,\"343\":1,\"354\":1,\"369\":1,\"395\":1,\"397\":3,\"402\":6,\"413\":5,\"414\":1,\"437\":5,\"441\":1,\"452\":1,\"453\":5,\"456\":3,\"461\":4,\"464\":1,\"465\":1,\"480\":3,\"492\":9,\"493\":1,\"494\":1,\"495\":1,\"512\":1,\"513\":4,\"515\":1,\"518\":1,\"521\":1,\"524\":1,\"525\":2,\"526\":1,\"527\":1,\"530\":1,\"533\":1,\"537\":1,\"538\":1,\"541\":1,\"544\":1,\"545\":1,\"546\":1,\"550\":3,\"553\":1,\"556\":1,\"559\":1,\"562\":1,\"563\":1,\"564\":1,\"565\":1,\"568\":1,\"571\":1,\"574\":1,\"578\":1,\"582\":1,\"588\":1,\"591\":1,\"595\":1,\"598\":1,\"601\":1,\"604\":1,\"608\":1,\"611\":1,\"614\":1,\"618\":1,\"622\":1,\"626\":1,\"629\":1,\"636\":4,\"639\":1,\"642\":1,\"645\":1,\"648\":1,\"652\":1,\"655\":1,\"656\":1,\"658\":1,\"661\":1,\"665\":1,\"668\":1,\"671\":1,\"675\":12,\"678\":1,\"681\":1,\"684\":1,\"687\":1,\"691\":2,\"700\":1,\"704\":1,\"707\":1,\"711\":1,\"718\":9,\"720\":1,\"726\":1,\"732\":3,\"734\":1,\"735\":1,\"736\":1,\"744\":1,\"747\":1,\"757\":2,\"764\":2,\"767\":1,\"770\":1,\"801\":1,\"809\":1,\"812\":1,\"815\":1,\"816\":2,\"818\":1,\"822\":1,\"825\":1,\"828\":1,\"831\":1,\"835\":1,\"838\":1,\"839\":2,\"841\":1,\"846\":1,\"847\":1,\"850\":1,\"853\":1,\"854\":1,\"856\":1,\"857\":2,\"859\":1,\"863\":1,\"866\":1,\"871\":1,\"874\":1,\"875\":13,\"878\":1,\"881\":1,\"884\":1,\"887\":1,\"891\":1,\"894\":1,\"897\":1,\"902\":3}}],[\"332\",{\"1\":{\"735\":1}}],[\"333\",{\"1\":{\"735\":1}}],[\"33333333\",{\"1\":{\"735\":1}}],[\"333333\",{\"1\":{\"190\":1}}],[\"3375\",{\"1\":{\"484\":1}}],[\"3343\",{\"1\":{\"484\":1}}],[\"3306\",{\"1\":{\"484\":1}}],[\"33dai\",{\"0\":{\"549\":1,\"716\":1,\"744\":1,\"762\":1,\"765\":1,\"768\":1,\"771\":1,\"775\":1,\"778\":1,\"781\":1,\"784\":1},\"1\":{\"432\":1,\"477\":1,\"493\":1,\"495\":1,\"563\":2,\"668\":3,\"764\":1,\"894\":1}}],[\"33\",{\"0\":{\"774\":1},\"1\":{\"0\":1,\"3\":1,\"471\":1,\"735\":1,\"756\":1,\"839\":2}}],[\"2==0\",{\"1\":{\"907\":1}}],[\"2a\",{\"1\":{\"790\":1}}],[\"2+t\",{\"1\":{\"742\":1}}],[\"2+1\",{\"1\":{\"19\":3,\"20\":2,\"21\":4,\"497\":1}}],[\"2y\",{\"1\":{\"734\":1}}],[\"2<<endl\",{\"1\":{\"620\":1,\"911\":3}}],[\"23978\",{\"1\":{\"484\":1}}],[\"23945\",{\"1\":{\"484\":1}}],[\"23858\",{\"1\":{\"484\":1}}],[\"23826\",{\"1\":{\"484\":1}}],[\"23800\",{\"1\":{\"484\":1}}],[\"23768\",{\"1\":{\"484\":1}}],[\"23734\",{\"1\":{\"484\":1}}],[\"23704\",{\"1\":{\"484\":1}}],[\"2379\",{\"1\":{\"484\":1}}],[\"23681\",{\"1\":{\"484\":1}}],[\"23660\",{\"1\":{\"484\":1}}],[\"23632\",{\"1\":{\"484\":1}}],[\"23604\",{\"1\":{\"484\":1}}],[\"23498\",{\"1\":{\"484\":1}}],[\"23478\",{\"1\":{\"484\":1}}],[\"23444\",{\"1\":{\"484\":1}}],[\"23421\",{\"1\":{\"484\":1}}],[\"233\",{\"1\":{\"839\":1}}],[\"23392\",{\"1\":{\"484\":1}}],[\"23368\",{\"1\":{\"484\":1}}],[\"23338\",{\"1\":{\"484\":1}}],[\"23324\",{\"1\":{\"484\":1}}],[\"23298\",{\"1\":{\"484\":1}}],[\"23272\",{\"1\":{\"484\":1}}],[\"23154\",{\"1\":{\"484\":1}}],[\"23124\",{\"1\":{\"484\":1}}],[\"23099\",{\"1\":{\"484\":1}}],[\"23071\",{\"1\":{\"484\":1}}],[\"23037\",{\"1\":{\"484\":1}}],[\"23009\",{\"1\":{\"484\":1}}],[\"23\",{\"0\":{\"663\":1},\"1\":{\"482\":1}}],[\"2995\",{\"1\":{\"484\":1}}],[\"2955\",{\"1\":{\"484\":1}}],[\"2920\",{\"1\":{\"484\":1}}],[\"293\",{\"1\":{\"484\":2}}],[\"29\",{\"0\":{\"733\":1},\"1\":{\"352\":1,\"527\":1,\"572\":1}}],[\"24935\",{\"1\":{\"484\":1}}],[\"24819\",{\"1\":{\"484\":1}}],[\"24709\",{\"1\":{\"484\":1}}],[\"24688\",{\"1\":{\"484\":1}}],[\"24665\",{\"1\":{\"484\":1}}],[\"24570\",{\"1\":{\"484\":1}}],[\"24545\",{\"1\":{\"484\":1}}],[\"24516\",{\"1\":{\"484\":1}}],[\"24487\",{\"1\":{\"484\":1}}],[\"24467\",{\"1\":{\"484\":1}}],[\"24438\",{\"1\":{\"484\":1}}],[\"24408\",{\"1\":{\"484\":1}}],[\"24379\",{\"1\":{\"484\":1}}],[\"24355\",{\"1\":{\"484\":1}}],[\"24322\",{\"1\":{\"484\":1}}],[\"24213\",{\"1\":{\"484\":1}}],[\"24185\",{\"1\":{\"484\":1}}],[\"24150\",{\"1\":{\"484\":1}}],[\"24124\",{\"1\":{\"484\":1}}],[\"24094\",{\"1\":{\"484\":1}}],[\"24058\",{\"1\":{\"484\":1}}],[\"24030\",{\"1\":{\"484\":1}}],[\"24006\",{\"1\":{\"484\":1}}],[\"24\",{\"0\":{\"322\":1,\"676\":1},\"1\":{\"482\":1,\"516\":1,\"530\":1,\"531\":2,\"640\":1}}],[\"26409\",{\"1\":{\"484\":1}}],[\"26383\",{\"1\":{\"484\":1}}],[\"26285\",{\"1\":{\"484\":1}}],[\"26254\",{\"1\":{\"484\":1}}],[\"26222\",{\"1\":{\"484\":1}}],[\"26196\",{\"1\":{\"484\":1}}],[\"26169\",{\"1\":{\"484\":1}}],[\"26142\",{\"1\":{\"484\":1}}],[\"26106\",{\"1\":{\"484\":1}}],[\"2618\",{\"1\":{\"484\":1}}],[\"26075\",{\"1\":{\"484\":1}}],[\"26048\",{\"1\":{\"484\":1}}],[\"26024\",{\"1\":{\"484\":1}}],[\"2684\",{\"1\":{\"484\":1}}],[\"2650\",{\"1\":{\"484\":1}}],[\"26\",{\"0\":{\"699\":1,\"702\":1},\"1\":{\"246\":1,\"259\":4,\"269\":1,\"744\":1}}],[\"2883\",{\"1\":{\"484\":1}}],[\"288\",{\"1\":{\"195\":1}}],[\"28\",{\"0\":{\"202\":1,\"728\":1},\"1\":{\"195\":1,\"527\":1,\"572\":1}}],[\"22983\",{\"1\":{\"484\":1}}],[\"22957\",{\"1\":{\"484\":1}}],[\"22930\",{\"1\":{\"484\":1}}],[\"22893\",{\"1\":{\"484\":1}}],[\"22797\",{\"1\":{\"484\":1}}],[\"22767\",{\"1\":{\"484\":1}}],[\"22734\",{\"1\":{\"484\":1}}],[\"22711\",{\"1\":{\"484\":1}}],[\"22682\",{\"1\":{\"484\":1}}],[\"22654\",{\"1\":{\"484\":1}}],[\"22624\",{\"1\":{\"484\":1}}],[\"2264\",{\"1\":{\"484\":1}}],[\"22594\",{\"1\":{\"484\":1}}],[\"22561\",{\"1\":{\"484\":1}}],[\"22535\",{\"1\":{\"484\":1}}],[\"22436\",{\"1\":{\"484\":1}}],[\"22402\",{\"1\":{\"484\":1}}],[\"22375\",{\"1\":{\"484\":1}}],[\"22339\",{\"1\":{\"484\":1}}],[\"22313\",{\"1\":{\"484\":1}}],[\"222\",{\"1\":{\"652\":1}}],[\"22292\",{\"1\":{\"484\":1}}],[\"22255\",{\"1\":{\"484\":1}}],[\"22225\",{\"1\":{\"484\":101}}],[\"22116\",{\"1\":{\"484\":1}}],[\"22025\",{\"1\":{\"484\":1}}],[\"22\",{\"0\":{\"650\":1},\"1\":{\"195\":1}}],[\"2~n\",{\"1\":{\"154\":2}}],[\"2756\",{\"1\":{\"484\":1}}],[\"2719\",{\"1\":{\"484\":1}}],[\"27\",{\"0\":{\"715\":1},\"1\":{\"142\":9}}],[\"2k\",{\"1\":{\"137\":13}}],[\"2^k\",{\"1\":{\"475\":1}}],[\"2^0\",{\"1\":{\"475\":1}}],[\"2^b\",{\"1\":{\"458\":1}}],[\"2^m\",{\"1\":{\"414\":1}}],[\"2^i\",{\"1\":{\"414\":1}}],[\"2^\",{\"1\":{\"12\":2,\"475\":1}}],[\"2^j\",{\"1\":{\"12\":2,\"13\":4,\"140\":1,\"475\":2}}],[\"20964\",{\"1\":{\"484\":1}}],[\"20764\",{\"1\":{\"484\":1}}],[\"20656\",{\"1\":{\"484\":1}}],[\"20446\",{\"1\":{\"484\":1}}],[\"2045\",{\"1\":{\"484\":1}}],[\"20336\",{\"1\":{\"484\":1}}],[\"2019\",{\"1\":{\"717\":1}}],[\"20120\",{\"1\":{\"484\":1}}],[\"2011\",{\"0\":{\"294\":1}}],[\"20553\",{\"1\":{\"484\":1}}],[\"205\",{\"1\":{\"227\":2}}],[\"20870\",{\"1\":{\"484\":1}}],[\"208\",{\"1\":{\"195\":1}}],[\"20225\",{\"1\":{\"484\":1}}],[\"2025\",{\"0\":{\"333\":1}}],[\"2021\",{\"0\":{\"320\":1,\"321\":1}}],[\"2024\",{\"0\":{\"193\":1,\"194\":1,\"195\":1,\"196\":1,\"197\":1,\"198\":1,\"199\":1},\"1\":{\"572\":1,\"761\":1,\"769\":1}}],[\"2024五一模拟赛\",{\"0\":{\"137\":1}}],[\"2023暑假专题测试1\",{\"0\":{\"169\":1}}],[\"20023\",{\"1\":{\"484\":1}}],[\"2007\",{\"0\":{\"176\":1,\"316\":1}}],[\"200\",{\"1\":{\"113\":1,\"116\":1,\"117\":1,\"195\":2,\"799\":1}}],[\"20000\",{\"1\":{\"302\":5,\"303\":2,\"458\":1}}],[\"200005\",{\"1\":{\"224\":3,\"320\":5}}],[\"200000+5\",{\"1\":{\"321\":1}}],[\"2000000\",{\"1\":{\"225\":1,\"226\":1,\"282\":1,\"283\":2}}],[\"200000\",{\"1\":{\"139\":1,\"140\":1,\"141\":1,\"169\":1,\"190\":1,\"196\":5,\"215\":1,\"216\":2,\"244\":6,\"342\":2,\"351\":1,\"352\":1,\"376\":4,\"872\":1}}],[\"2000\",{\"1\":{\"31\":1,\"199\":2}}],[\"2005\",{\"1\":{\"31\":1,\"498\":6}}],[\"20\",{\"0\":{\"408\":1,\"624\":1},\"1\":{\"12\":2,\"13\":1,\"195\":4,\"202\":1,\"203\":1,\"246\":1,\"267\":6,\"273\":2,\"280\":2,\"298\":2,\"335\":2,\"381\":2,\"415\":2,\"475\":2,\"900\":1}}],[\"25916\",{\"1\":{\"484\":1}}],[\"25862\",{\"1\":{\"484\":1}}],[\"25837\",{\"1\":{\"484\":1}}],[\"25813\",{\"1\":{\"484\":1}}],[\"25895\",{\"1\":{\"484\":1}}],[\"2589\",{\"1\":{\"484\":1}}],[\"25785\",{\"1\":{\"484\":1}}],[\"25751\",{\"1\":{\"484\":1}}],[\"25727\",{\"1\":{\"484\":1}}],[\"25458\",{\"1\":{\"484\":1}}],[\"2549\",{\"1\":{\"484\":1}}],[\"25353\",{\"1\":{\"484\":1}}],[\"25254\",{\"1\":{\"484\":1}}],[\"25144\",{\"1\":{\"484\":1}}],[\"25032\",{\"1\":{\"484\":1}}],[\"2508\",{\"1\":{\"484\":11}}],[\"25000\",{\"1\":{\"307\":3}}],[\"2505\",{\"1\":{\"128\":1,\"499\":1}}],[\"25559\",{\"1\":{\"484\":1}}],[\"255\",{\"1\":{\"293\":3}}],[\"25650\",{\"1\":{\"484\":1}}],[\"256\",{\"1\":{\"193\":3,\"268\":1,\"519\":2,\"805\":2}}],[\"25\",{\"0\":{\"689\":1},\"1\":{\"12\":1,\"59\":1,\"178\":4,\"180\":1,\"298\":2,\"374\":3,\"412\":1,\"475\":2}}],[\"2\",{\"0\":{\"77\":1,\"90\":1,\"147\":1,\"231\":1,\"256\":1,\"263\":1,\"290\":1,\"331\":1,\"355\":1,\"360\":1,\"408\":1,\"421\":1,\"446\":1,\"539\":1,\"573\":1,\"619\":1,\"680\":1,\"869\":1},\"1\":{\"3\":4,\"13\":1,\"17\":14,\"18\":3,\"19\":21,\"20\":13,\"21\":44,\"23\":5,\"24\":2,\"30\":2,\"37\":1,\"59\":1,\"64\":1,\"76\":1,\"77\":2,\"80\":2,\"85\":1,\"109\":2,\"110\":1,\"111\":1,\"116\":1,\"117\":1,\"118\":2,\"123\":1,\"128\":4,\"129\":2,\"137\":43,\"139\":2,\"140\":2,\"142\":1,\"144\":2,\"146\":4,\"147\":4,\"148\":1,\"153\":1,\"154\":3,\"156\":1,\"157\":2,\"158\":2,\"160\":2,\"161\":1,\"163\":3,\"165\":1,\"168\":1,\"169\":3,\"170\":4,\"172\":1,\"173\":2,\"174\":1,\"176\":1,\"178\":1,\"180\":2,\"181\":2,\"182\":9,\"184\":3,\"185\":3,\"186\":7,\"187\":7,\"188\":1,\"193\":1,\"195\":5,\"196\":1,\"197\":2,\"198\":6,\"199\":5,\"205\":1,\"208\":4,\"209\":3,\"210\":1,\"211\":2,\"213\":3,\"214\":2,\"216\":17,\"218\":4,\"219\":1,\"227\":7,\"228\":1,\"230\":2,\"231\":24,\"232\":1,\"233\":1,\"236\":1,\"237\":23,\"239\":27,\"241\":1,\"242\":1,\"244\":3,\"245\":1,\"246\":3,\"248\":9,\"249\":9,\"251\":3,\"259\":13,\"260\":1,\"262\":2,\"263\":1,\"264\":1,\"267\":29,\"268\":1,\"269\":2,\"272\":1,\"273\":1,\"274\":1,\"275\":4,\"282\":4,\"283\":5,\"284\":5,\"285\":1,\"286\":5,\"287\":2,\"289\":4,\"291\":15,\"292\":13,\"293\":1,\"298\":2,\"301\":2,\"305\":12,\"306\":4,\"312\":10,\"313\":11,\"314\":1,\"319\":4,\"320\":4,\"329\":3,\"335\":2,\"336\":2,\"340\":3,\"343\":2,\"347\":2,\"351\":1,\"354\":4,\"355\":1,\"369\":1,\"373\":1,\"375\":1,\"377\":2,\"379\":2,\"380\":2,\"386\":1,\"397\":2,\"399\":2,\"400\":1,\"402\":10,\"404\":8,\"405\":5,\"410\":6,\"413\":4,\"414\":4,\"415\":4,\"417\":2,\"418\":1,\"421\":1,\"426\":8,\"427\":1,\"428\":1,\"430\":1,\"432\":2,\"437\":12,\"440\":1,\"441\":2,\"446\":1,\"447\":4,\"448\":3,\"452\":1,\"453\":23,\"456\":5,\"460\":4,\"461\":1,\"462\":1,\"464\":1,\"465\":1,\"470\":1,\"480\":9,\"482\":1,\"484\":5,\"485\":6,\"492\":9,\"493\":2,\"494\":1,\"495\":4,\"497\":4,\"499\":4,\"500\":1,\"502\":2,\"504\":1,\"505\":8,\"512\":1,\"513\":5,\"515\":1,\"516\":1,\"518\":2,\"521\":1,\"524\":1,\"525\":1,\"526\":1,\"527\":2,\"530\":1,\"533\":1,\"535\":1,\"537\":1,\"538\":3,\"539\":2,\"541\":1,\"542\":2,\"544\":1,\"545\":1,\"546\":1,\"550\":1,\"551\":1,\"553\":3,\"556\":1,\"559\":2,\"562\":1,\"563\":1,\"564\":2,\"565\":2,\"568\":1,\"571\":1,\"572\":1,\"574\":1,\"575\":8,\"576\":3,\"578\":3,\"582\":1,\"588\":1,\"591\":1,\"592\":1,\"595\":1,\"598\":1,\"601\":1,\"604\":1,\"605\":3,\"608\":1,\"611\":1,\"614\":1,\"618\":1,\"622\":1,\"626\":7,\"627\":2,\"629\":1,\"636\":1,\"639\":1,\"642\":1,\"645\":1,\"648\":1,\"652\":2,\"653\":3,\"655\":2,\"656\":28,\"658\":1,\"661\":1,\"662\":2,\"665\":6,\"666\":1,\"668\":2,\"671\":1,\"674\":1,\"675\":12,\"678\":1,\"681\":1,\"684\":1,\"685\":3,\"687\":1,\"688\":1,\"691\":1,\"695\":2,\"700\":1,\"704\":1,\"705\":2,\"707\":1,\"714\":2,\"718\":1,\"720\":1,\"724\":2,\"726\":1,\"727\":1,\"732\":4,\"734\":3,\"735\":4,\"736\":1,\"742\":3,\"744\":2,\"746\":3,\"764\":2,\"767\":1,\"770\":2,\"777\":1,\"780\":1,\"790\":1,\"793\":1,\"796\":4,\"799\":1,\"803\":3,\"805\":1,\"809\":1,\"812\":4,\"813\":1,\"815\":1,\"816\":2,\"818\":1,\"819\":1,\"822\":2,\"825\":2,\"828\":1,\"831\":1,\"835\":1,\"838\":2,\"839\":4,\"841\":1,\"844\":1,\"846\":3,\"847\":4,\"850\":1,\"851\":1,\"853\":1,\"856\":2,\"859\":1,\"863\":1,\"866\":1,\"871\":1,\"874\":1,\"875\":14,\"878\":1,\"881\":1,\"884\":1,\"885\":2,\"887\":1,\"891\":1,\"894\":1,\"897\":1,\"898\":1,\"907\":1}}],[\"2147483647\",{\"1\":{\"583\":1}}],[\"2147483648\",{\"1\":{\"452\":1,\"583\":1}}],[\"21908\",{\"1\":{\"484\":1}}],[\"21820\",{\"1\":{\"484\":1}}],[\"21728\",{\"1\":{\"484\":1}}],[\"21613\",{\"1\":{\"484\":1}}],[\"21510\",{\"1\":{\"484\":1}}],[\"2154\",{\"1\":{\"484\":1}}],[\"21389\",{\"1\":{\"484\":1}}],[\"21259\",{\"1\":{\"484\":1}}],[\"21156\",{\"1\":{\"484\":1}}],[\"21057\",{\"1\":{\"484\":1}}],[\"21\",{\"0\":{\"637\":1},\"1\":{\"3\":1,\"195\":1,\"374\":1,\"516\":1}}],[\"4y\",{\"1\":{\"790\":1}}],[\"4a\",{\"1\":{\"734\":1}}],[\"4x\",{\"1\":{\"734\":1}}],[\"4983\",{\"1\":{\"484\":1}}],[\"4956\",{\"1\":{\"484\":1}}],[\"4925\",{\"1\":{\"484\":1}}],[\"4905\",{\"1\":{\"484\":1}}],[\"4751\",{\"1\":{\"484\":1}}],[\"4728\",{\"1\":{\"484\":1}}],[\"4499\",{\"1\":{\"484\":1}}],[\"4470\",{\"1\":{\"484\":1}}],[\"4363\",{\"1\":{\"484\":1}}],[\"4336\",{\"1\":{\"484\":1}}],[\"4308\",{\"1\":{\"484\":1}}],[\"412\",{\"1\":{\"494\":1}}],[\"4194\",{\"1\":{\"484\":1}}],[\"4155\",{\"1\":{\"484\":1}}],[\"4119\",{\"1\":{\"484\":1}}],[\"4282\",{\"1\":{\"484\":1}}],[\"4250\",{\"1\":{\"484\":1}}],[\"4219\",{\"1\":{\"484\":1}}],[\"4213\",{\"1\":{\"453\":1}}],[\"427\",{\"1\":{\"484\":1}}],[\"42216523\",{\"1\":{\"453\":1}}],[\"42426523\",{\"1\":{\"453\":1}}],[\"4095\",{\"1\":{\"484\":1}}],[\"405\",{\"1\":{\"373\":4}}],[\"404\",{\"0\":{\"327\":1},\"1\":{\"329\":1,\"912\":1}}],[\"40\",{\"0\":{\"208\":1,\"410\":1},\"1\":{\"259\":4,\"267\":6,\"272\":2,\"329\":1,\"423\":1,\"512\":1,\"515\":1,\"518\":1,\"521\":1,\"524\":1,\"525\":1,\"526\":1,\"527\":1,\"530\":1,\"533\":1,\"537\":1,\"541\":1,\"544\":1,\"545\":1,\"546\":1,\"550\":1,\"553\":1,\"556\":1,\"559\":1,\"562\":1,\"563\":1,\"564\":1,\"565\":1,\"568\":1,\"571\":1,\"578\":1,\"582\":1,\"588\":1,\"591\":1,\"595\":1,\"598\":1,\"601\":1,\"604\":1,\"608\":1,\"611\":1,\"614\":1,\"626\":1,\"629\":1,\"639\":1,\"642\":1,\"645\":1,\"648\":1,\"652\":1,\"655\":1,\"658\":1,\"661\":1,\"665\":1,\"668\":1,\"671\":1,\"678\":1,\"681\":1,\"684\":1,\"687\":1,\"691\":1,\"700\":1,\"704\":1,\"707\":1,\"720\":1,\"726\":1,\"809\":1,\"812\":1,\"815\":1,\"818\":1,\"822\":1,\"825\":1,\"828\":1,\"831\":1,\"835\":1,\"838\":1,\"841\":1,\"846\":1,\"850\":1,\"853\":1,\"856\":1,\"859\":1,\"863\":1,\"866\":1,\"871\":1,\"874\":1,\"878\":1,\"881\":1,\"884\":1,\"887\":1,\"891\":1,\"894\":1,\"897\":1,\"909\":1}}],[\"40000\",{\"1\":{\"302\":1}}],[\"400000\",{\"1\":{\"215\":1}}],[\"400\",{\"1\":{\"98\":2,\"527\":1,\"572\":1,\"799\":1}}],[\"4694\",{\"1\":{\"484\":1}}],[\"4626\",{\"1\":{\"484\":1}}],[\"4663\",{\"1\":{\"484\":1}}],[\"466\",{\"1\":{\"484\":1}}],[\"46\",{\"0\":{\"203\":1}}],[\"4879\",{\"1\":{\"484\":1}}],[\"4845\",{\"1\":{\"484\":1}}],[\"48\",{\"1\":{\"93\":1}}],[\"4594\",{\"1\":{\"484\":1}}],[\"4559\",{\"1\":{\"484\":1}}],[\"4528\",{\"1\":{\"484\":1}}],[\"45\",{\"1\":{\"85\":1,\"484\":1,\"535\":1}}],[\"456\",{\"1\":{\"63\":1,\"656\":1}}],[\"4\",{\"0\":{\"79\":1,\"265\":1,\"320\":1,\"410\":1,\"807\":1},\"1\":{\"3\":8,\"17\":1,\"19\":2,\"20\":2,\"21\":3,\"60\":1,\"83\":3,\"85\":2,\"98\":2,\"111\":1,\"129\":4,\"161\":1,\"165\":4,\"167\":1,\"182\":9,\"193\":2,\"194\":3,\"195\":3,\"200\":1,\"216\":2,\"227\":2,\"230\":2,\"237\":2,\"239\":2,\"242\":2,\"245\":1,\"246\":1,\"248\":9,\"249\":9,\"256\":2,\"262\":1,\"267\":52,\"268\":2,\"282\":1,\"283\":1,\"284\":1,\"287\":1,\"291\":2,\"292\":2,\"312\":2,\"313\":2,\"328\":1,\"329\":5,\"336\":3,\"338\":1,\"402\":1,\"413\":10,\"421\":1,\"422\":1,\"423\":1,\"451\":1,\"452\":1,\"453\":4,\"456\":3,\"469\":1,\"480\":2,\"482\":1,\"490\":4,\"492\":11,\"502\":2,\"505\":1,\"513\":2,\"527\":1,\"538\":1,\"550\":1,\"572\":9,\"574\":1,\"575\":2,\"589\":1,\"595\":2,\"596\":3,\"622\":1,\"627\":2,\"656\":1,\"675\":18,\"711\":1,\"718\":1,\"732\":2,\"734\":3,\"744\":1,\"764\":2,\"767\":1,\"770\":1,\"790\":1,\"875\":8,\"902\":2}}],[\"09\",{\"1\":{\"665\":1}}],[\"02d\",{\"1\":{\"527\":15}}],[\"0或1\",{\"1\":{\"343\":1}}],[\"04\",{\"1\":{\"329\":1}}],[\"0~\",{\"1\":{\"662\":1}}],[\"0~num\",{\"1\":{\"335\":1}}],[\"0~now\",{\"1\":{\"335\":1}}],[\"0~i\",{\"1\":{\"335\":1}}],[\"0~2n\",{\"1\":{\"312\":1,\"313\":1}}],[\"0~x\",{\"1\":{\"270\":1}}],[\"0~m\",{\"1\":{\"109\":2,\"110\":2}}],[\"00\",{\"1\":{\"608\":1}}],[\"001\",{\"1\":{\"244\":2}}],[\"00010101\",{\"1\":{\"351\":1}}],[\"00011011000\",{\"1\":{\"351\":1}}],[\"0001\",{\"1\":{\"181\":1,\"205\":3,\"244\":1}}],[\"000ll\",{\"1\":{\"169\":1,\"839\":1}}],[\"000000011\",{\"1\":{\"36\":1}}],[\"000\",{\"1\":{\"12\":1,\"13\":1,\"23\":3,\"113\":4,\"116\":4,\"117\":4,\"119\":3,\"126\":1,\"146\":3,\"147\":3,\"169\":5,\"195\":12,\"293\":6,\"305\":3,\"306\":3,\"329\":3,\"340\":3,\"367\":3,\"372\":3,\"378\":3,\"379\":3,\"380\":3,\"381\":6,\"395\":2,\"400\":2,\"402\":10,\"405\":5,\"415\":16,\"422\":2,\"423\":2,\"437\":6,\"464\":3,\"465\":3,\"466\":3,\"467\":3,\"483\":6,\"484\":4,\"500\":3,\"721\":3,\"839\":3}}],[\"0x3f\",{\"1\":{\"260\":1,\"280\":1}}],[\"0x3f3f3f3f\",{\"1\":{\"164\":1,\"260\":4,\"280\":2}}],[\"0xc0\",{\"1\":{\"128\":1}}],[\"0ll\",{\"1\":{\"144\":1,\"485\":2,\"488\":2}}],[\"010101\",{\"1\":{\"604\":1}}],[\"010000000\",{\"1\":{\"36\":1}}],[\"0123\",{\"1\":{\"541\":1}}],[\"01迷宫\",{\"0\":{\"200\":1}}],[\"01\",{\"1\":{\"160\":1,\"841\":1}}],[\"011011111\",{\"1\":{\"36\":1}}],[\"011000010\",{\"1\":{\"36\":1}}],[\"011000001\",{\"1\":{\"36\":1}}],[\"0\",{\"0\":{\"248\":1,\"264\":1,\"501\":1,\"565\":1,\"573\":1},\"1\":{\"3\":34,\"5\":2,\"7\":1,\"8\":1,\"11\":4,\"12\":10,\"13\":8,\"14\":6,\"15\":10,\"17\":3,\"18\":2,\"19\":4,\"20\":4,\"21\":5,\"23\":4,\"24\":1,\"27\":1,\"29\":1,\"30\":1,\"31\":1,\"32\":1,\"37\":2,\"40\":9,\"46\":1,\"47\":2,\"48\":2,\"49\":1,\"50\":1,\"52\":1,\"53\":1,\"54\":1,\"57\":1,\"59\":1,\"60\":1,\"61\":1,\"63\":3,\"64\":1,\"66\":2,\"70\":1,\"74\":1,\"80\":1,\"85\":2,\"93\":3,\"98\":6,\"100\":2,\"101\":1,\"103\":1,\"109\":8,\"110\":8,\"111\":2,\"112\":3,\"113\":3,\"115\":3,\"116\":5,\"117\":4,\"118\":2,\"119\":4,\"120\":2,\"122\":2,\"123\":4,\"124\":2,\"125\":3,\"126\":10,\"127\":6,\"128\":7,\"129\":3,\"131\":4,\"132\":4,\"134\":3,\"135\":5,\"136\":3,\"137\":13,\"139\":2,\"140\":5,\"141\":7,\"142\":7,\"144\":4,\"146\":11,\"147\":8,\"148\":5,\"150\":5,\"151\":4,\"153\":12,\"154\":8,\"156\":11,\"157\":14,\"158\":4,\"160\":8,\"161\":24,\"162\":12,\"163\":8,\"164\":4,\"165\":37,\"166\":3,\"167\":8,\"168\":18,\"169\":10,\"170\":6,\"172\":1,\"173\":1,\"174\":2,\"175\":2,\"176\":5,\"177\":3,\"178\":6,\"179\":5,\"180\":6,\"181\":18,\"182\":56,\"184\":11,\"185\":14,\"186\":15,\"187\":21,\"188\":6,\"190\":6,\"191\":2,\"192\":6,\"193\":14,\"194\":7,\"195\":9,\"196\":41,\"197\":20,\"198\":19,\"199\":39,\"200\":8,\"202\":6,\"203\":10,\"204\":10,\"205\":10,\"208\":4,\"209\":2,\"210\":2,\"211\":2,\"213\":3,\"214\":5,\"215\":7,\"216\":8,\"217\":2,\"218\":7,\"219\":16,\"221\":10,\"222\":10,\"224\":5,\"225\":5,\"226\":4,\"227\":15,\"228\":10,\"230\":10,\"231\":36,\"232\":5,\"233\":6,\"235\":7,\"236\":11,\"237\":12,\"239\":12,\"241\":14,\"242\":18,\"243\":3,\"244\":11,\"245\":4,\"246\":7,\"248\":17,\"249\":15,\"250\":10,\"251\":4,\"253\":9,\"255\":8,\"256\":9,\"257\":11,\"258\":4,\"259\":6,\"260\":9,\"262\":10,\"263\":9,\"264\":12,\"265\":5,\"266\":5,\"267\":9,\"268\":12,\"269\":3,\"270\":21,\"272\":3,\"273\":10,\"274\":5,\"275\":13,\"276\":17,\"278\":4,\"279\":4,\"280\":7,\"282\":13,\"283\":16,\"284\":12,\"285\":15,\"286\":14,\"287\":7,\"288\":3,\"289\":4,\"291\":4,\"292\":5,\"293\":7,\"295\":9,\"298\":16,\"299\":3,\"301\":5,\"302\":3,\"303\":3,\"305\":3,\"306\":20,\"307\":10,\"309\":2,\"310\":2,\"312\":8,\"313\":19,\"314\":11,\"317\":2,\"318\":2,\"319\":15,\"320\":12,\"321\":2,\"323\":1,\"324\":5,\"325\":2,\"326\":1,\"329\":15,\"331\":4,\"333\":2,\"334\":3,\"335\":6,\"336\":11,\"338\":10,\"340\":6,\"342\":3,\"343\":4,\"345\":4,\"347\":2,\"348\":5,\"349\":2,\"350\":2,\"351\":10,\"352\":4,\"354\":3,\"355\":3,\"356\":2,\"358\":2,\"359\":7,\"361\":10,\"362\":6,\"363\":4,\"365\":4,\"366\":7,\"367\":3,\"368\":5,\"369\":12,\"370\":3,\"371\":2,\"372\":18,\"373\":3,\"374\":8,\"375\":9,\"376\":3,\"377\":5,\"378\":9,\"379\":3,\"380\":3,\"381\":8,\"383\":6,\"384\":10,\"386\":2,\"388\":3,\"389\":5,\"391\":6,\"392\":2,\"393\":2,\"394\":2,\"395\":6,\"397\":4,\"399\":5,\"400\":4,\"402\":12,\"405\":5,\"406\":1,\"407\":1,\"410\":9,\"412\":5,\"413\":4,\"414\":6,\"415\":11,\"417\":7,\"418\":3,\"419\":3,\"421\":7,\"422\":9,\"423\":9,\"425\":7,\"426\":2,\"427\":8,\"428\":4,\"430\":3,\"431\":3,\"432\":3,\"433\":5,\"435\":1,\"436\":7,\"437\":2,\"438\":9,\"440\":10,\"441\":3,\"443\":4,\"444\":9,\"446\":3,\"447\":3,\"448\":5,\"450\":1,\"451\":2,\"452\":1,\"453\":6,\"455\":1,\"456\":1,\"457\":2,\"458\":3,\"460\":6,\"461\":3,\"462\":5,\"464\":3,\"465\":3,\"466\":4,\"467\":4,\"469\":2,\"470\":2,\"471\":14,\"473\":4,\"475\":7,\"477\":1,\"478\":3,\"479\":7,\"480\":6,\"482\":2,\"483\":3,\"484\":14,\"485\":2,\"487\":2,\"488\":3,\"489\":3,\"490\":2,\"492\":14,\"493\":2,\"494\":5,\"495\":1,\"497\":2,\"498\":2,\"499\":7,\"500\":2,\"502\":1,\"503\":1,\"504\":2,\"505\":8,\"507\":1,\"509\":1,\"513\":1,\"516\":3,\"519\":5,\"522\":3,\"524\":1,\"525\":1,\"526\":3,\"527\":5,\"530\":2,\"531\":5,\"534\":4,\"535\":1,\"538\":11,\"539\":1,\"541\":1,\"542\":25,\"544\":1,\"545\":1,\"546\":1,\"547\":1,\"550\":1,\"551\":1,\"554\":2,\"557\":5,\"560\":5,\"562\":1,\"563\":1,\"564\":3,\"565\":6,\"569\":1,\"572\":4,\"575\":26,\"576\":9,\"579\":4,\"583\":1,\"586\":2,\"589\":2,\"592\":5,\"596\":2,\"599\":7,\"602\":6,\"605\":5,\"608\":1,\"609\":1,\"611\":3,\"612\":8,\"615\":2,\"618\":5,\"620\":1,\"621\":1,\"622\":15,\"623\":1,\"627\":1,\"630\":4,\"633\":5,\"636\":2,\"640\":1,\"643\":3,\"645\":1,\"646\":4,\"649\":2,\"652\":1,\"653\":4,\"656\":20,\"659\":3,\"662\":6,\"666\":3,\"669\":5,\"671\":1,\"672\":9,\"675\":7,\"679\":1,\"682\":1,\"685\":14,\"688\":1,\"692\":1,\"695\":2,\"698\":1,\"701\":2,\"705\":3,\"708\":2,\"711\":2,\"714\":9,\"718\":2,\"721\":1,\"724\":1,\"727\":1,\"729\":2,\"730\":4,\"731\":2,\"732\":4,\"734\":2,\"735\":3,\"736\":5,\"737\":2,\"739\":1,\"740\":1,\"741\":2,\"744\":2,\"745\":1,\"746\":7,\"747\":5,\"751\":1,\"754\":2,\"757\":3,\"760\":2,\"764\":3,\"767\":2,\"770\":1,\"773\":1,\"777\":4,\"780\":4,\"783\":2,\"786\":3,\"790\":2,\"793\":3,\"796\":5,\"799\":3,\"801\":1,\"803\":3,\"805\":7,\"806\":1,\"810\":1,\"812\":2,\"813\":2,\"816\":3,\"819\":3,\"823\":1,\"826\":2,\"829\":3,\"832\":6,\"836\":1,\"839\":1,\"842\":1,\"843\":2,\"844\":2,\"847\":3,\"851\":1,\"854\":4,\"857\":5,\"860\":2,\"864\":2,\"868\":1,\"869\":1,\"872\":6,\"875\":18,\"879\":1,\"882\":2,\"885\":4,\"888\":2,\"892\":1,\"895\":3,\"898\":1,\"902\":3,\"906\":5,\"907\":3,\"911\":1}}],[\"i>=0\",{\"1\":{\"843\":1,\"902\":3}}],[\"io\",{\"0\":{\"696\":1}}],[\"ios\",{\"1\":{\"11\":1,\"12\":1,\"13\":1,\"14\":1,\"15\":1,\"17\":1,\"19\":1,\"20\":1,\"21\":1,\"23\":1,\"109\":1,\"110\":1,\"111\":1,\"112\":1,\"113\":1,\"115\":1,\"116\":1,\"117\":1,\"120\":1,\"122\":1,\"123\":1,\"124\":1,\"125\":1,\"126\":1,\"127\":1,\"128\":1,\"137\":1,\"141\":1,\"142\":1,\"144\":1,\"146\":1,\"147\":1,\"148\":1,\"154\":1,\"158\":1,\"163\":1,\"164\":1,\"165\":1,\"166\":1,\"167\":1,\"168\":1,\"169\":1,\"170\":1,\"175\":1,\"176\":1,\"177\":1,\"178\":1,\"179\":1,\"180\":1,\"181\":2,\"182\":2,\"184\":1,\"185\":1,\"186\":1,\"187\":1,\"190\":1,\"192\":1,\"193\":4,\"195\":2,\"196\":5,\"197\":4,\"198\":3,\"199\":4,\"202\":1,\"203\":1,\"204\":1,\"205\":2,\"208\":2,\"209\":1,\"210\":1,\"211\":1,\"213\":1,\"214\":1,\"215\":1,\"216\":2,\"217\":1,\"218\":1,\"219\":2,\"221\":1,\"222\":1,\"224\":1,\"225\":1,\"226\":1,\"227\":1,\"228\":1,\"230\":1,\"231\":1,\"232\":1,\"233\":2,\"235\":1,\"236\":1,\"237\":1,\"239\":1,\"242\":1,\"244\":2,\"245\":1,\"246\":1,\"248\":1,\"249\":1,\"250\":2,\"253\":1,\"255\":1,\"256\":1,\"257\":1,\"258\":1,\"259\":1,\"260\":1,\"265\":1,\"266\":1,\"267\":2,\"268\":1,\"270\":1,\"272\":1,\"273\":1,\"274\":1,\"275\":2,\"276\":2,\"278\":1,\"279\":1,\"280\":1,\"282\":1,\"283\":1,\"284\":1,\"285\":1,\"286\":2,\"287\":1,\"288\":1,\"291\":1,\"292\":1,\"293\":1,\"295\":1,\"298\":2,\"299\":1,\"301\":1,\"302\":1,\"303\":1,\"306\":1,\"307\":1,\"309\":1,\"310\":1,\"312\":1,\"313\":2,\"314\":1,\"317\":1,\"318\":1,\"319\":1,\"320\":3,\"321\":1,\"331\":1,\"333\":1,\"334\":1,\"335\":1,\"336\":1,\"338\":1,\"340\":1,\"345\":1,\"347\":1,\"348\":1,\"349\":1,\"350\":1,\"351\":1,\"352\":1,\"354\":1,\"355\":1,\"356\":1,\"358\":1,\"359\":1,\"361\":1,\"362\":1,\"363\":1,\"365\":1,\"366\":1,\"367\":1,\"368\":1,\"369\":1,\"370\":1,\"371\":1,\"372\":1,\"373\":1,\"374\":1,\"375\":1,\"376\":1,\"377\":1,\"381\":1,\"383\":1,\"384\":1,\"386\":1,\"388\":1,\"389\":1,\"391\":1,\"392\":1,\"393\":1,\"394\":1,\"395\":1,\"399\":1,\"400\":1,\"402\":2,\"405\":1,\"410\":1,\"412\":1,\"413\":2,\"414\":1,\"417\":1,\"418\":1,\"419\":1,\"421\":1,\"422\":1,\"423\":1,\"425\":1,\"426\":1,\"427\":1,\"428\":1,\"443\":1,\"444\":1,\"445\":2,\"446\":1,\"447\":1,\"458\":1,\"460\":1,\"461\":1,\"475\":1,\"542\":1,\"560\":1,\"596\":1,\"599\":1,\"602\":1,\"605\":1,\"729\":1,\"730\":1,\"731\":1,\"732\":1,\"734\":1,\"735\":1,\"736\":1,\"737\":1,\"741\":1,\"790\":1,\"793\":1,\"796\":1,\"799\":1,\"819\":1,\"906\":1}}],[\"ic++\",{\"1\":{\"599\":1}}],[\"ic\",{\"1\":{\"599\":7}}],[\"icpc2024\",{\"0\":{\"141\":1,\"142\":1}}],[\"ib++\",{\"1\":{\"599\":1}}],[\"ib\",{\"1\":{\"599\":8}}],[\"ia++\",{\"1\":{\"599\":1}}],[\"ia\",{\"1\":{\"599\":9}}],[\"i~pos\",{\"1\":{\"557\":1}}],[\"i~k\",{\"1\":{\"215\":1}}],[\"ix+n\",{\"1\":{\"471\":2}}],[\"i^\",{\"1\":{\"335\":1}}],[\"i这个种类最新出现的位置\",{\"1\":{\"266\":1}}],[\"impossible\",{\"1\":{\"228\":1}}],[\"ith\",{\"1\":{\"318\":4}}],[\"iterator\",{\"1\":{\"309\":1,\"310\":1}}],[\"it++\",{\"1\":{\"211\":1,\"309\":1}}],[\"it\",{\"1\":{\"211\":4,\"309\":4,\"310\":4}}],[\"i=l\",{\"1\":{\"902\":1}}],[\"i=3\",{\"1\":{\"902\":3}}],[\"i=n\",{\"1\":{\"509\":1,\"843\":1}}],[\"i=nxtt\",{\"1\":{\"321\":5}}],[\"i==firt\",{\"1\":{\"321\":1}}],[\"i=firt\",{\"1\":{\"321\":3}}],[\"i=2\",{\"1\":{\"321\":1}}],[\"i=10\",{\"1\":{\"539\":1}}],[\"i=1\",{\"1\":{\"192\":3,\"321\":1,\"508\":2,\"509\":3,\"545\":1,\"623\":1,\"636\":2,\"742\":3,\"816\":2,\"902\":1,\"906\":1,\"907\":1}}],[\"i=0\",{\"1\":{\"139\":2,\"140\":1,\"241\":2,\"546\":1,\"623\":1,\"633\":1,\"636\":4,\"804\":1}}],[\"is\",{\"1\":{\"551\":1,\"741\":2}}],[\"isprime\",{\"1\":{\"538\":2}}],[\"isp\",{\"1\":{\"180\":2}}],[\"iszero\",{\"1\":{\"40\":3,\"273\":7}}],[\"ii++\",{\"1\":{\"177\":1}}],[\"ii\",{\"1\":{\"177\":20,\"253\":2,\"287\":2,\"475\":3,\"605\":3}}],[\"i+2<=n\",{\"1\":{\"539\":1}}],[\"i+2\",{\"1\":{\"539\":1}}],[\"i+n\",{\"1\":{\"251\":1}}],[\"i+1\",{\"1\":{\"139\":1,\"140\":1,\"204\":1,\"526\":1,\"539\":4,\"682\":1}}],[\"i++\",{\"1\":{\"3\":5,\"5\":1,\"11\":2,\"12\":3,\"13\":4,\"14\":6,\"15\":3,\"17\":2,\"19\":1,\"20\":1,\"21\":1,\"23\":2,\"27\":3,\"29\":3,\"30\":3,\"31\":3,\"32\":2,\"109\":1,\"110\":1,\"112\":2,\"113\":3,\"115\":2,\"116\":3,\"117\":3,\"118\":2,\"119\":3,\"120\":3,\"122\":6,\"123\":5,\"124\":3,\"125\":3,\"126\":5,\"127\":1,\"128\":2,\"134\":1,\"135\":1,\"136\":1,\"137\":2,\"139\":4,\"140\":3,\"141\":4,\"144\":4,\"146\":4,\"147\":6,\"148\":4,\"150\":6,\"151\":6,\"153\":3,\"154\":4,\"156\":4,\"157\":4,\"158\":9,\"160\":4,\"161\":3,\"162\":5,\"163\":6,\"164\":5,\"165\":2,\"166\":4,\"167\":1,\"168\":3,\"169\":2,\"170\":1,\"173\":4,\"174\":3,\"175\":2,\"176\":2,\"177\":2,\"178\":4,\"179\":1,\"180\":2,\"181\":8,\"182\":8,\"184\":3,\"185\":4,\"186\":4,\"187\":6,\"188\":2,\"190\":4,\"191\":3,\"192\":6,\"193\":9,\"194\":2,\"195\":2,\"196\":17,\"197\":11,\"198\":10,\"199\":9,\"200\":4,\"202\":1,\"203\":2,\"204\":5,\"205\":2,\"208\":2,\"209\":1,\"210\":1,\"211\":1,\"213\":3,\"214\":3,\"215\":6,\"216\":3,\"217\":2,\"218\":4,\"219\":5,\"221\":3,\"222\":3,\"224\":2,\"225\":2,\"226\":2,\"227\":4,\"228\":3,\"230\":3,\"231\":5,\"232\":2,\"233\":11,\"235\":1,\"241\":6,\"242\":4,\"243\":3,\"244\":4,\"245\":2,\"246\":5,\"248\":7,\"249\":3,\"250\":4,\"251\":3,\"253\":1,\"256\":2,\"257\":2,\"258\":4,\"259\":4,\"260\":4,\"262\":1,\"263\":1,\"264\":1,\"266\":4,\"267\":3,\"268\":5,\"270\":3,\"272\":1,\"274\":3,\"275\":7,\"276\":5,\"278\":2,\"279\":2,\"280\":3,\"282\":5,\"283\":4,\"284\":3,\"285\":3,\"286\":5,\"287\":3,\"288\":3,\"289\":6,\"291\":1,\"292\":1,\"293\":4,\"295\":5,\"298\":6,\"299\":4,\"301\":2,\"302\":3,\"303\":2,\"305\":1,\"306\":3,\"307\":7,\"312\":2,\"313\":5,\"314\":3,\"317\":2,\"318\":4,\"319\":3,\"320\":8,\"321\":2,\"324\":2,\"325\":3,\"326\":1,\"329\":4,\"331\":2,\"334\":1,\"335\":3,\"336\":4,\"338\":1,\"340\":2,\"342\":3,\"343\":2,\"345\":1,\"347\":3,\"348\":3,\"349\":2,\"350\":3,\"351\":2,\"352\":2,\"354\":2,\"355\":2,\"356\":2,\"358\":2,\"359\":2,\"361\":3,\"362\":3,\"363\":1,\"365\":3,\"366\":3,\"367\":2,\"368\":3,\"369\":2,\"370\":2,\"371\":1,\"372\":3,\"373\":2,\"374\":3,\"375\":1,\"376\":4,\"377\":4,\"378\":1,\"379\":2,\"380\":2,\"381\":3,\"383\":4,\"384\":6,\"386\":2,\"391\":2,\"392\":3,\"393\":3,\"394\":2,\"395\":2,\"397\":1,\"399\":2,\"400\":1,\"402\":2,\"405\":1,\"410\":6,\"412\":2,\"413\":2,\"414\":3,\"415\":6,\"417\":2,\"418\":3,\"419\":3,\"421\":2,\"422\":2,\"423\":2,\"426\":5,\"427\":3,\"428\":3,\"430\":5,\"431\":1,\"432\":2,\"433\":2,\"436\":4,\"437\":1,\"438\":4,\"440\":1,\"441\":1,\"443\":3,\"444\":8,\"451\":1,\"453\":1,\"455\":2,\"456\":3,\"457\":3,\"458\":3,\"462\":3,\"464\":3,\"465\":3,\"466\":3,\"467\":3,\"470\":1,\"473\":2,\"475\":3,\"478\":1,\"479\":3,\"480\":5,\"484\":5,\"485\":2,\"488\":4,\"490\":4,\"492\":2,\"493\":3,\"494\":1,\"495\":1,\"497\":1,\"498\":4,\"499\":4,\"500\":2,\"503\":1,\"504\":1,\"505\":2,\"508\":2,\"509\":4,\"519\":3,\"522\":3,\"525\":1,\"526\":1,\"534\":1,\"538\":3,\"539\":2,\"542\":1,\"545\":1,\"546\":1,\"554\":1,\"557\":1,\"560\":2,\"565\":2,\"575\":2,\"576\":3,\"579\":3,\"586\":1,\"589\":1,\"592\":1,\"602\":1,\"605\":3,\"612\":1,\"618\":2,\"623\":2,\"633\":1,\"636\":6,\"643\":1,\"646\":2,\"649\":1,\"659\":1,\"669\":1,\"672\":1,\"675\":3,\"682\":1,\"685\":1,\"688\":5,\"695\":2,\"701\":2,\"708\":2,\"711\":1,\"714\":1,\"721\":1,\"724\":1,\"727\":4,\"730\":1,\"732\":6,\"735\":1,\"736\":2,\"737\":3,\"742\":3,\"746\":2,\"747\":2,\"754\":1,\"757\":1,\"760\":2,\"767\":1,\"770\":3,\"773\":2,\"783\":1,\"786\":2,\"793\":1,\"796\":1,\"799\":3,\"803\":1,\"804\":1,\"805\":4,\"806\":2,\"812\":1,\"813\":1,\"819\":2,\"826\":1,\"829\":1,\"832\":3,\"839\":1,\"847\":1,\"857\":1,\"860\":3,\"868\":1,\"869\":1,\"872\":2,\"875\":5,\"882\":1,\"885\":1,\"888\":3,\"895\":1,\"898\":1,\"902\":2,\"906\":1,\"907\":1}}],[\"i<k\",{\"1\":{\"633\":1}}],[\"i<len\",{\"1\":{\"546\":1}}],[\"i<=r\",{\"1\":{\"902\":1}}],[\"i<=100\",{\"1\":{\"742\":1}}],[\"i<=m\",{\"1\":{\"742\":1,\"816\":1}}],[\"i<=f\",{\"1\":{\"636\":1}}],[\"i<=2\",{\"1\":{\"636\":4}}],[\"i<=cur\",{\"1\":{\"509\":1}}],[\"i<=cntc\",{\"1\":{\"192\":1}}],[\"i<=cntp\",{\"1\":{\"192\":1}}],[\"i<=cnta\",{\"1\":{\"192\":1}}],[\"i<=a\",{\"1\":{\"508\":1}}],[\"i<=b\",{\"1\":{\"508\":1}}],[\"i<=n+m\",{\"1\":{\"509\":1}}],[\"i<=n\",{\"1\":{\"321\":2,\"509\":2,\"539\":1,\"545\":1,\"623\":1,\"636\":1,\"742\":1,\"804\":1,\"816\":1,\"902\":1,\"907\":1}}],[\"i<points\",{\"1\":{\"241\":2}}],[\"i<60\",{\"1\":{\"140\":1}}],[\"i<y\",{\"1\":{\"139\":1}}],[\"i<x\",{\"1\":{\"139\":1}}],[\"id++\",{\"1\":{\"259\":2}}],[\"idx++\",{\"1\":{\"443\":1}}],[\"idx\",{\"1\":{\"126\":5,\"248\":2,\"249\":5,\"295\":8,\"443\":12,\"444\":1}}],[\"id\",{\"1\":{\"14\":6,\"150\":6,\"151\":10,\"164\":7,\"259\":16,\"266\":2,\"444\":17,\"599\":5,\"731\":6,\"760\":3}}],[\"ins\",{\"1\":{\"444\":5}}],[\"insert\",{\"1\":{\"3\":2,\"137\":4,\"193\":1,\"211\":4,\"268\":2,\"309\":1,\"310\":1,\"331\":2,\"480\":5}}],[\"independent\",{\"0\":{\"375\":1}}],[\"index\",{\"1\":{\"40\":4}}],[\"init\",{\"1\":{\"329\":1,\"415\":4,\"475\":2}}],[\"initst\",{\"1\":{\"13\":2}}],[\"invasion\",{\"0\":{\"276\":1}}],[\"inf=1e18l\",{\"1\":{\"575\":1,\"576\":1}}],[\"info\",{\"1\":{\"458\":8}}],[\"information\",{\"1\":{\"55\":1}}],[\"inf\",{\"1\":{\"128\":1,\"164\":1,\"169\":2,\"195\":4,\"354\":2,\"355\":2,\"381\":4,\"410\":4,\"433\":2,\"437\":2,\"575\":1,\"576\":1}}],[\"in\",{\"0\":{\"277\":1,\"338\":1},\"1\":{\"66\":1,\"198\":1,\"321\":1,\"397\":1,\"399\":1,\"400\":1,\"402\":2,\"405\":1,\"410\":1,\"412\":1,\"413\":2,\"415\":4,\"421\":1,\"422\":1,\"423\":1,\"425\":1,\"426\":1,\"427\":1,\"428\":1,\"430\":1,\"431\":1,\"432\":1,\"433\":1,\"435\":1,\"436\":2,\"437\":1,\"438\":1,\"450\":1,\"452\":1,\"453\":1,\"455\":4,\"456\":1,\"457\":1,\"458\":1,\"480\":1,\"482\":1,\"483\":1,\"484\":1,\"487\":1,\"488\":1,\"489\":1,\"490\":1,\"492\":1,\"493\":1,\"494\":1,\"495\":1,\"497\":1,\"498\":1,\"499\":1,\"500\":1,\"698\":1,\"705\":1,\"708\":1,\"711\":1,\"714\":1,\"718\":1,\"721\":1,\"724\":1,\"727\":1}}],[\"include<bits\",{\"1\":{\"139\":1,\"140\":1,\"241\":1,\"321\":1,\"507\":1,\"508\":1,\"524\":1,\"525\":1,\"526\":1,\"527\":1,\"539\":1,\"544\":1,\"545\":1,\"546\":1,\"547\":1,\"562\":1,\"563\":1,\"564\":1,\"565\":1,\"575\":1,\"576\":1,\"620\":1,\"621\":1,\"623\":1,\"804\":1,\"902\":1,\"906\":1,\"911\":1}}],[\"include<iomanip>\",{\"1\":{\"90\":1}}],[\"include<iostream>\",{\"1\":{\"90\":1,\"843\":1}}],[\"include\",{\"1\":{\"11\":1,\"12\":1,\"13\":1,\"14\":1,\"15\":1,\"17\":1,\"19\":1,\"20\":1,\"21\":1,\"23\":1,\"27\":1,\"29\":1,\"30\":1,\"31\":1,\"32\":1,\"40\":1,\"46\":1,\"47\":1,\"48\":1,\"49\":1,\"50\":1,\"52\":1,\"53\":1,\"54\":1,\"57\":1,\"59\":1,\"60\":1,\"61\":1,\"63\":3,\"64\":1,\"66\":1,\"70\":1,\"74\":1,\"89\":1,\"109\":1,\"110\":1,\"111\":1,\"112\":1,\"113\":1,\"115\":1,\"116\":1,\"117\":1,\"118\":1,\"119\":1,\"120\":1,\"122\":1,\"123\":1,\"124\":1,\"125\":1,\"126\":1,\"127\":1,\"128\":1,\"129\":1,\"131\":1,\"132\":1,\"134\":1,\"135\":1,\"136\":1,\"137\":1,\"141\":1,\"142\":1,\"144\":1,\"146\":1,\"147\":1,\"148\":1,\"150\":1,\"151\":1,\"153\":1,\"154\":1,\"156\":1,\"157\":1,\"158\":1,\"160\":1,\"161\":1,\"162\":1,\"163\":1,\"164\":1,\"165\":1,\"166\":1,\"167\":1,\"168\":1,\"169\":1,\"170\":1,\"172\":1,\"173\":1,\"174\":1,\"175\":1,\"176\":1,\"177\":1,\"178\":1,\"179\":1,\"180\":1,\"181\":2,\"182\":2,\"184\":1,\"185\":1,\"186\":1,\"187\":1,\"188\":1,\"190\":1,\"191\":1,\"192\":1,\"193\":4,\"194\":1,\"195\":2,\"196\":5,\"197\":4,\"198\":3,\"199\":4,\"200\":1,\"202\":1,\"203\":1,\"204\":1,\"205\":2,\"208\":2,\"209\":1,\"210\":1,\"211\":1,\"213\":1,\"214\":1,\"215\":1,\"216\":2,\"217\":1,\"218\":1,\"219\":2,\"221\":1,\"222\":1,\"224\":1,\"225\":1,\"226\":1,\"227\":1,\"228\":1,\"230\":1,\"231\":1,\"232\":1,\"233\":2,\"235\":1,\"236\":1,\"237\":1,\"239\":1,\"242\":1,\"243\":1,\"244\":2,\"245\":1,\"246\":1,\"248\":1,\"249\":1,\"250\":2,\"251\":1,\"253\":1,\"255\":1,\"256\":1,\"257\":1,\"258\":1,\"259\":1,\"260\":1,\"262\":1,\"263\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":2,\"268\":1,\"269\":1,\"270\":1,\"272\":1,\"273\":1,\"274\":1,\"275\":2,\"276\":2,\"278\":1,\"279\":1,\"280\":1,\"282\":1,\"283\":1,\"284\":1,\"285\":1,\"286\":2,\"287\":1,\"288\":1,\"289\":2,\"291\":1,\"292\":1,\"293\":1,\"295\":1,\"298\":2,\"299\":1,\"301\":1,\"302\":1,\"303\":1,\"305\":1,\"306\":1,\"307\":2,\"309\":1,\"310\":1,\"312\":1,\"313\":2,\"314\":1,\"317\":1,\"318\":1,\"319\":1,\"320\":3,\"323\":1,\"324\":1,\"325\":1,\"326\":1,\"329\":1,\"331\":1,\"333\":1,\"334\":1,\"335\":1,\"336\":1,\"338\":1,\"340\":1,\"342\":1,\"343\":1,\"345\":1,\"347\":1,\"348\":1,\"349\":1,\"350\":1,\"351\":1,\"352\":1,\"354\":1,\"355\":1,\"356\":1,\"358\":1,\"359\":1,\"361\":1,\"362\":1,\"363\":1,\"365\":1,\"366\":1,\"367\":1,\"368\":1,\"369\":1,\"370\":1,\"371\":1,\"372\":1,\"373\":1,\"374\":1,\"375\":1,\"376\":1,\"377\":1,\"378\":1,\"379\":1,\"380\":1,\"381\":1,\"383\":1,\"384\":1,\"386\":1,\"388\":1,\"389\":1,\"391\":1,\"392\":1,\"393\":1,\"394\":1,\"395\":1,\"397\":1,\"399\":1,\"400\":1,\"402\":2,\"405\":1,\"410\":1,\"412\":1,\"413\":2,\"414\":1,\"415\":4,\"417\":1,\"418\":1,\"419\":1,\"421\":1,\"422\":1,\"423\":1,\"425\":1,\"426\":1,\"427\":1,\"428\":1,\"430\":1,\"431\":1,\"432\":1,\"433\":1,\"435\":1,\"436\":2,\"437\":1,\"438\":1,\"440\":1,\"441\":1,\"443\":1,\"444\":1,\"446\":1,\"447\":1,\"448\":1,\"450\":1,\"451\":1,\"452\":1,\"453\":1,\"455\":1,\"456\":1,\"457\":1,\"458\":1,\"460\":1,\"461\":1,\"462\":1,\"464\":1,\"465\":1,\"466\":1,\"467\":1,\"469\":1,\"470\":1,\"471\":1,\"473\":1,\"475\":1,\"477\":1,\"478\":1,\"479\":1,\"480\":1,\"482\":1,\"483\":1,\"484\":2,\"485\":1,\"487\":1,\"488\":1,\"489\":1,\"490\":1,\"492\":1,\"493\":1,\"494\":1,\"495\":1,\"497\":1,\"498\":1,\"499\":1,\"500\":1,\"502\":1,\"503\":1,\"504\":1,\"505\":1,\"509\":2,\"513\":1,\"516\":1,\"519\":1,\"522\":1,\"531\":1,\"534\":1,\"535\":1,\"538\":1,\"542\":1,\"551\":3,\"554\":1,\"557\":1,\"560\":1,\"569\":1,\"572\":1,\"579\":1,\"583\":1,\"586\":1,\"589\":1,\"592\":1,\"596\":1,\"599\":1,\"602\":1,\"605\":1,\"609\":1,\"612\":1,\"615\":1,\"618\":1,\"622\":1,\"627\":1,\"630\":1,\"633\":1,\"636\":1,\"640\":1,\"643\":1,\"646\":1,\"649\":1,\"653\":1,\"656\":1,\"659\":1,\"662\":1,\"666\":1,\"669\":1,\"672\":1,\"675\":1,\"679\":1,\"682\":1,\"685\":1,\"688\":1,\"692\":1,\"695\":1,\"698\":1,\"701\":1,\"705\":1,\"708\":1,\"711\":1,\"714\":1,\"718\":1,\"721\":1,\"724\":1,\"727\":1,\"729\":1,\"730\":1,\"731\":1,\"732\":1,\"734\":1,\"735\":1,\"736\":1,\"737\":1,\"739\":1,\"740\":1,\"741\":1,\"742\":1,\"744\":1,\"745\":1,\"746\":1,\"747\":1,\"751\":1,\"754\":1,\"757\":1,\"760\":1,\"764\":1,\"767\":1,\"770\":1,\"773\":1,\"777\":1,\"780\":1,\"783\":1,\"786\":1,\"790\":1,\"793\":1,\"796\":1,\"799\":1,\"801\":1,\"803\":1,\"805\":1,\"806\":1,\"810\":1,\"813\":1,\"816\":1,\"819\":1,\"823\":1,\"826\":1,\"829\":1,\"832\":1,\"836\":1,\"839\":1,\"844\":1,\"847\":1,\"851\":1,\"854\":1,\"857\":1,\"860\":1,\"864\":1,\"868\":1,\"869\":1,\"872\":1,\"875\":1,\"879\":1,\"882\":1,\"885\":1,\"888\":1,\"892\":1,\"895\":1,\"898\":1,\"907\":1}}],[\"int128\",{\"1\":{\"176\":4,\"478\":8}}],[\"interval\",{\"1\":{\"351\":1}}],[\"interchange\",{\"1\":{\"55\":1}}],[\"integer\",{\"1\":{\"47\":1}}],[\"int>p\",{\"1\":{\"575\":1,\"576\":1}}],[\"int>\",{\"1\":{\"14\":1,\"125\":2,\"141\":1,\"160\":1,\"161\":1,\"179\":1,\"182\":2,\"198\":2,\"230\":1,\"231\":1,\"241\":4,\"242\":3,\"259\":1,\"267\":1,\"276\":1,\"342\":1,\"343\":6,\"392\":1,\"410\":2,\"418\":1,\"421\":1,\"422\":1,\"423\":1,\"438\":5,\"443\":1,\"467\":1,\"727\":1,\"897\":1}}],[\"int>>>\",{\"1\":{\"167\":1}}],[\"int>>\",{\"1\":{\"13\":1,\"127\":1,\"144\":1,\"147\":1,\"182\":2,\"190\":1,\"198\":1,\"241\":3,\"242\":1,\"259\":1,\"266\":1,\"267\":1,\"276\":1,\"295\":1,\"340\":1,\"342\":1,\"343\":1,\"352\":1,\"410\":1,\"421\":1,\"422\":1,\"423\":1,\"433\":1,\"438\":2,\"443\":1}}],[\"int\",{\"1\":{\"3\":35,\"5\":3,\"7\":1,\"8\":1,\"11\":17,\"12\":19,\"13\":27,\"14\":19,\"15\":19,\"17\":26,\"18\":8,\"19\":30,\"20\":27,\"21\":40,\"23\":30,\"24\":7,\"27\":7,\"29\":7,\"30\":7,\"31\":8,\"32\":6,\"38\":1,\"40\":4,\"46\":1,\"47\":1,\"48\":1,\"49\":1,\"50\":1,\"52\":1,\"53\":1,\"54\":1,\"57\":1,\"59\":1,\"60\":2,\"61\":3,\"62\":1,\"63\":5,\"64\":2,\"66\":3,\"70\":1,\"74\":1,\"78\":1,\"79\":1,\"80\":1,\"83\":2,\"92\":1,\"93\":1,\"94\":2,\"100\":1,\"101\":1,\"103\":1,\"109\":13,\"110\":13,\"111\":6,\"112\":9,\"113\":12,\"115\":12,\"116\":18,\"117\":15,\"118\":8,\"119\":13,\"120\":9,\"122\":16,\"123\":18,\"124\":9,\"125\":11,\"126\":15,\"127\":10,\"128\":7,\"129\":1,\"131\":4,\"132\":4,\"134\":4,\"135\":4,\"136\":4,\"137\":14,\"139\":16,\"140\":21,\"141\":9,\"142\":12,\"144\":13,\"146\":28,\"147\":28,\"148\":10,\"150\":14,\"151\":18,\"153\":18,\"154\":20,\"156\":14,\"157\":16,\"158\":25,\"160\":16,\"161\":10,\"162\":18,\"163\":17,\"164\":27,\"165\":23,\"166\":22,\"167\":14,\"168\":12,\"169\":21,\"170\":14,\"172\":11,\"173\":21,\"174\":8,\"175\":9,\"176\":10,\"177\":10,\"178\":14,\"179\":7,\"180\":10,\"181\":21,\"182\":44,\"184\":9,\"185\":13,\"186\":14,\"187\":25,\"188\":4,\"190\":13,\"191\":12,\"192\":12,\"193\":26,\"194\":17,\"195\":14,\"196\":111,\"197\":38,\"198\":43,\"199\":58,\"200\":13,\"202\":9,\"203\":13,\"204\":14,\"205\":4,\"208\":11,\"209\":6,\"210\":5,\"211\":5,\"213\":24,\"214\":17,\"215\":27,\"216\":45,\"217\":7,\"218\":10,\"219\":34,\"221\":12,\"222\":13,\"224\":10,\"225\":11,\"226\":11,\"227\":15,\"228\":13,\"230\":10,\"231\":20,\"232\":14,\"233\":34,\"235\":9,\"236\":24,\"237\":39,\"239\":39,\"241\":27,\"242\":27,\"243\":14,\"244\":10,\"245\":5,\"246\":10,\"248\":21,\"249\":11,\"250\":16,\"251\":17,\"253\":13,\"255\":8,\"256\":15,\"257\":13,\"258\":19,\"259\":30,\"260\":20,\"262\":10,\"263\":11,\"264\":11,\"265\":5,\"266\":26,\"267\":15,\"268\":14,\"269\":10,\"270\":19,\"272\":8,\"273\":6,\"274\":14,\"275\":26,\"276\":24,\"278\":9,\"279\":9,\"280\":9,\"282\":8,\"283\":9,\"284\":7,\"285\":17,\"286\":24,\"287\":9,\"288\":9,\"289\":40,\"291\":24,\"292\":26,\"293\":16,\"295\":18,\"298\":24,\"299\":16,\"301\":10,\"302\":14,\"303\":11,\"305\":16,\"306\":19,\"307\":24,\"309\":3,\"310\":3,\"312\":21,\"313\":47,\"314\":26,\"317\":9,\"318\":15,\"319\":20,\"320\":18,\"321\":20,\"323\":2,\"324\":6,\"325\":12,\"326\":4,\"329\":14,\"331\":13,\"333\":2,\"334\":5,\"335\":15,\"336\":17,\"338\":5,\"340\":21,\"342\":12,\"343\":9,\"345\":4,\"347\":8,\"348\":10,\"349\":9,\"350\":9,\"351\":9,\"352\":14,\"354\":8,\"355\":9,\"356\":7,\"358\":9,\"359\":11,\"361\":10,\"362\":11,\"363\":11,\"365\":14,\"366\":14,\"367\":8,\"368\":6,\"369\":9,\"370\":6,\"371\":8,\"372\":13,\"373\":11,\"374\":14,\"375\":10,\"376\":14,\"377\":18,\"378\":14,\"379\":10,\"380\":10,\"381\":18,\"383\":16,\"384\":28,\"386\":7,\"388\":2,\"389\":2,\"391\":11,\"392\":9,\"393\":11,\"394\":8,\"395\":15,\"397\":3,\"399\":12,\"400\":10,\"402\":15,\"405\":9,\"410\":18,\"412\":8,\"413\":16,\"414\":12,\"415\":33,\"417\":7,\"418\":6,\"419\":6,\"421\":12,\"422\":12,\"423\":12,\"425\":6,\"426\":9,\"427\":14,\"428\":11,\"430\":11,\"431\":5,\"432\":6,\"433\":12,\"435\":5,\"436\":13,\"437\":18,\"438\":17,\"440\":6,\"441\":6,\"443\":16,\"444\":46,\"446\":10,\"447\":14,\"448\":11,\"450\":1,\"451\":5,\"452\":4,\"453\":6,\"455\":3,\"456\":7,\"457\":7,\"458\":12,\"460\":3,\"461\":2,\"462\":8,\"464\":13,\"465\":13,\"466\":12,\"467\":12,\"469\":3,\"470\":4,\"471\":6,\"473\":10,\"475\":17,\"477\":9,\"478\":5,\"479\":11,\"480\":12,\"482\":2,\"483\":6,\"484\":29,\"485\":14,\"487\":4,\"488\":10,\"489\":3,\"490\":14,\"492\":7,\"493\":10,\"494\":12,\"495\":10,\"497\":5,\"498\":12,\"499\":14,\"500\":13,\"502\":6,\"503\":4,\"504\":5,\"505\":19,\"507\":6,\"508\":5,\"509\":16,\"513\":3,\"519\":7,\"522\":11,\"524\":2,\"525\":3,\"526\":5,\"527\":9,\"530\":1,\"531\":3,\"534\":1,\"535\":1,\"538\":8,\"539\":7,\"542\":4,\"544\":2,\"545\":3,\"546\":4,\"547\":2,\"551\":8,\"554\":3,\"557\":7,\"560\":10,\"562\":2,\"563\":2,\"564\":3,\"565\":4,\"569\":1,\"572\":5,\"575\":11,\"576\":9,\"579\":8,\"582\":4,\"583\":2,\"586\":4,\"589\":2,\"592\":6,\"596\":4,\"599\":11,\"602\":5,\"605\":13,\"609\":5,\"612\":7,\"615\":4,\"618\":7,\"620\":2,\"621\":1,\"622\":3,\"623\":4,\"627\":4,\"630\":11,\"633\":2,\"636\":15,\"640\":1,\"643\":4,\"646\":4,\"649\":4,\"653\":8,\"656\":5,\"659\":4,\"662\":8,\"666\":3,\"669\":4,\"672\":8,\"675\":9,\"679\":1,\"682\":1,\"685\":10,\"688\":12,\"692\":5,\"695\":3,\"698\":1,\"701\":9,\"705\":5,\"708\":8,\"711\":5,\"714\":7,\"718\":2,\"721\":4,\"724\":4,\"727\":7,\"729\":1,\"730\":1,\"731\":1,\"732\":15,\"734\":2,\"735\":6,\"736\":5,\"737\":7,\"739\":2,\"740\":2,\"741\":1,\"742\":8,\"744\":2,\"745\":1,\"746\":8,\"747\":7,\"751\":2,\"754\":8,\"757\":4,\"760\":12,\"764\":2,\"767\":5,\"770\":8,\"772\":1,\"773\":6,\"777\":2,\"780\":5,\"783\":4,\"786\":8,\"790\":3,\"793\":4,\"796\":2,\"799\":10,\"801\":2,\"803\":7,\"804\":6,\"805\":7,\"806\":3,\"810\":3,\"813\":1,\"816\":8,\"819\":7,\"823\":3,\"825\":1,\"826\":3,\"829\":3,\"832\":9,\"836\":3,\"839\":4,\"842\":1,\"843\":3,\"844\":4,\"847\":5,\"851\":2,\"854\":4,\"856\":1,\"857\":3,\"860\":8,\"864\":2,\"868\":3,\"869\":3,\"872\":7,\"875\":31,\"879\":2,\"882\":3,\"885\":5,\"888\":8,\"891\":2,\"892\":2,\"894\":1,\"895\":3,\"898\":5,\"902\":11,\"906\":5,\"907\":2,\"911\":2}}],[\"i\",{\"0\":{\"141\":1,\"142\":1,\"368\":1,\"584\":2},\"1\":{\"3\":56,\"5\":3,\"11\":4,\"12\":15,\"13\":22,\"14\":23,\"15\":8,\"17\":5,\"19\":3,\"20\":3,\"21\":3,\"23\":8,\"24\":1,\"27\":11,\"29\":8,\"30\":9,\"31\":10,\"32\":6,\"40\":12,\"109\":5,\"110\":6,\"112\":13,\"113\":14,\"115\":21,\"116\":22,\"117\":14,\"118\":13,\"119\":25,\"120\":16,\"122\":28,\"123\":25,\"124\":16,\"125\":30,\"126\":45,\"127\":7,\"128\":24,\"134\":2,\"135\":4,\"136\":4,\"137\":22,\"139\":9,\"140\":19,\"141\":18,\"144\":16,\"146\":32,\"147\":29,\"148\":18,\"150\":23,\"151\":27,\"153\":20,\"154\":13,\"156\":17,\"157\":17,\"158\":39,\"160\":13,\"161\":9,\"162\":26,\"163\":22,\"164\":43,\"165\":44,\"166\":17,\"167\":8,\"168\":40,\"169\":9,\"170\":3,\"173\":30,\"174\":9,\"175\":13,\"176\":7,\"177\":24,\"178\":31,\"179\":8,\"180\":7,\"181\":28,\"182\":53,\"184\":18,\"185\":24,\"186\":18,\"187\":38,\"188\":10,\"190\":15,\"191\":15,\"192\":21,\"193\":27,\"194\":7,\"195\":7,\"196\":112,\"197\":41,\"198\":67,\"199\":92,\"200\":15,\"202\":5,\"203\":12,\"204\":31,\"205\":4,\"208\":16,\"209\":14,\"210\":16,\"211\":14,\"213\":29,\"214\":28,\"215\":26,\"216\":20,\"217\":10,\"218\":14,\"219\":47,\"221\":32,\"222\":22,\"224\":15,\"225\":16,\"226\":22,\"227\":15,\"228\":9,\"230\":14,\"231\":16,\"232\":47,\"233\":53,\"235\":9,\"236\":12,\"237\":2,\"241\":22,\"242\":16,\"243\":10,\"244\":24,\"245\":6,\"246\":25,\"248\":25,\"249\":29,\"250\":20,\"251\":16,\"253\":4,\"256\":8,\"257\":13,\"258\":31,\"259\":20,\"260\":41,\"262\":2,\"263\":5,\"264\":2,\"266\":26,\"267\":10,\"268\":27,\"269\":2,\"270\":21,\"272\":3,\"274\":28,\"275\":26,\"276\":36,\"278\":8,\"279\":8,\"280\":18,\"282\":19,\"283\":19,\"284\":14,\"285\":30,\"286\":24,\"287\":9,\"288\":12,\"289\":50,\"291\":3,\"292\":3,\"293\":19,\"295\":21,\"298\":22,\"299\":15,\"301\":9,\"302\":11,\"303\":10,\"305\":8,\"306\":21,\"307\":29,\"312\":20,\"313\":41,\"314\":21,\"317\":6,\"318\":20,\"319\":13,\"320\":64,\"321\":38,\"324\":4,\"325\":10,\"326\":5,\"328\":12,\"329\":49,\"331\":4,\"334\":4,\"335\":25,\"336\":24,\"338\":4,\"340\":14,\"342\":16,\"343\":5,\"345\":2,\"347\":12,\"348\":11,\"349\":6,\"350\":10,\"351\":20,\"352\":12,\"354\":20,\"355\":13,\"356\":19,\"358\":9,\"359\":7,\"361\":20,\"362\":17,\"363\":16,\"365\":8,\"366\":11,\"367\":11,\"368\":17,\"369\":23,\"370\":8,\"371\":3,\"372\":25,\"373\":8,\"374\":12,\"375\":2,\"376\":27,\"377\":15,\"378\":5,\"379\":15,\"380\":18,\"381\":12,\"383\":15,\"384\":30,\"386\":6,\"391\":13,\"392\":12,\"393\":13,\"394\":13,\"395\":7,\"397\":4,\"399\":6,\"400\":3,\"402\":9,\"405\":18,\"410\":27,\"412\":6,\"413\":11,\"414\":10,\"415\":32,\"417\":7,\"418\":16,\"419\":12,\"421\":7,\"422\":10,\"423\":10,\"426\":24,\"427\":16,\"428\":14,\"430\":19,\"431\":6,\"432\":11,\"433\":6,\"436\":16,\"437\":3,\"438\":15,\"440\":6,\"441\":15,\"443\":18,\"444\":56,\"451\":2,\"453\":8,\"455\":8,\"456\":18,\"457\":13,\"458\":12,\"462\":18,\"464\":8,\"465\":10,\"466\":8,\"467\":8,\"470\":7,\"471\":6,\"473\":6,\"475\":27,\"478\":7,\"479\":13,\"480\":24,\"483\":5,\"484\":15,\"485\":6,\"487\":5,\"488\":21,\"490\":16,\"492\":7,\"493\":12,\"494\":10,\"495\":3,\"497\":2,\"498\":22,\"499\":27,\"500\":9,\"503\":2,\"504\":7,\"505\":10,\"509\":6,\"518\":1,\"519\":15,\"522\":14,\"525\":2,\"526\":4,\"534\":5,\"538\":15,\"539\":7,\"542\":5,\"546\":3,\"554\":3,\"557\":10,\"560\":8,\"565\":13,\"575\":28,\"576\":14,\"579\":9,\"586\":4,\"589\":4,\"592\":3,\"602\":5,\"605\":8,\"612\":8,\"618\":7,\"623\":4,\"633\":1,\"636\":12,\"643\":2,\"646\":7,\"649\":2,\"653\":4,\"659\":3,\"669\":4,\"672\":4,\"675\":11,\"679\":1,\"682\":12,\"685\":4,\"688\":19,\"695\":5,\"701\":8,\"708\":8,\"711\":2,\"714\":10,\"721\":2,\"724\":3,\"727\":20,\"730\":6,\"732\":29,\"735\":2,\"736\":6,\"737\":16,\"741\":1,\"742\":14,\"746\":6,\"747\":8,\"754\":4,\"757\":6,\"760\":8,\"767\":2,\"770\":11,\"772\":2,\"773\":6,\"780\":3,\"783\":5,\"786\":8,\"793\":5,\"796\":8,\"799\":18,\"802\":1,\"803\":7,\"805\":12,\"806\":6,\"812\":16,\"813\":5,\"816\":7,\"819\":8,\"826\":2,\"829\":3,\"832\":8,\"839\":3,\"843\":5,\"846\":1,\"847\":6,\"857\":4,\"860\":9,\"868\":3,\"869\":2,\"872\":16,\"875\":18,\"882\":3,\"885\":4,\"888\":9,\"895\":2,\"898\":9,\"902\":10,\"907\":1}}],[\"if\",{\"0\":{\"262\":1,\"263\":1},\"1\":{\"3\":8,\"11\":2,\"12\":5,\"13\":4,\"14\":4,\"15\":5,\"17\":9,\"18\":2,\"19\":8,\"20\":8,\"21\":13,\"23\":10,\"24\":2,\"27\":1,\"29\":1,\"30\":1,\"32\":2,\"40\":5,\"71\":1,\"74\":1,\"75\":3,\"76\":1,\"77\":2,\"78\":2,\"79\":1,\"80\":1,\"100\":1,\"109\":4,\"110\":4,\"111\":2,\"112\":1,\"115\":2,\"116\":2,\"117\":1,\"118\":1,\"119\":4,\"120\":1,\"123\":1,\"124\":1,\"125\":3,\"126\":4,\"127\":10,\"128\":2,\"129\":3,\"131\":2,\"132\":2,\"135\":1,\"136\":2,\"137\":16,\"139\":1,\"140\":4,\"141\":2,\"142\":9,\"144\":1,\"146\":8,\"147\":5,\"150\":1,\"151\":1,\"153\":1,\"154\":6,\"156\":5,\"157\":7,\"158\":9,\"160\":6,\"161\":3,\"162\":15,\"163\":5,\"164\":1,\"165\":12,\"166\":5,\"167\":3,\"168\":18,\"169\":2,\"170\":4,\"172\":3,\"173\":3,\"174\":4,\"175\":1,\"176\":2,\"177\":1,\"178\":4,\"179\":5,\"180\":5,\"181\":4,\"182\":7,\"184\":2,\"185\":6,\"186\":7,\"187\":13,\"188\":9,\"190\":2,\"191\":4,\"192\":8,\"193\":3,\"194\":2,\"195\":13,\"196\":33,\"197\":4,\"198\":16,\"199\":7,\"200\":4,\"202\":5,\"203\":10,\"204\":5,\"205\":2,\"209\":1,\"210\":3,\"211\":3,\"213\":1,\"214\":1,\"215\":6,\"216\":12,\"217\":4,\"218\":5,\"219\":10,\"221\":5,\"222\":8,\"224\":2,\"225\":3,\"226\":1,\"227\":3,\"228\":4,\"230\":9,\"231\":9,\"232\":6,\"233\":1,\"235\":6,\"236\":7,\"237\":15,\"239\":16,\"241\":7,\"242\":8,\"243\":4,\"244\":6,\"245\":1,\"246\":4,\"248\":6,\"249\":5,\"250\":7,\"251\":7,\"253\":4,\"255\":4,\"256\":5,\"257\":4,\"259\":5,\"260\":4,\"262\":14,\"263\":6,\"264\":6,\"265\":4,\"266\":1,\"267\":3,\"268\":9,\"269\":4,\"270\":8,\"272\":5,\"273\":5,\"274\":1,\"275\":7,\"276\":6,\"278\":2,\"279\":3,\"280\":4,\"282\":2,\"283\":4,\"284\":3,\"285\":4,\"286\":14,\"287\":4,\"288\":2,\"289\":12,\"291\":12,\"292\":11,\"293\":1,\"295\":4,\"298\":3,\"299\":1,\"301\":5,\"302\":2,\"305\":7,\"306\":14,\"307\":6,\"309\":4,\"310\":6,\"312\":5,\"313\":12,\"314\":7,\"317\":5,\"318\":5,\"319\":12,\"320\":9,\"321\":4,\"323\":1,\"324\":4,\"326\":2,\"328\":1,\"329\":7,\"331\":6,\"335\":3,\"336\":5,\"340\":4,\"342\":3,\"343\":4,\"345\":1,\"347\":2,\"348\":1,\"352\":5,\"354\":2,\"359\":3,\"361\":2,\"362\":1,\"363\":3,\"365\":1,\"366\":2,\"367\":2,\"369\":4,\"370\":2,\"371\":1,\"372\":1,\"373\":1,\"374\":4,\"375\":1,\"377\":1,\"378\":3,\"379\":1,\"380\":1,\"381\":4,\"383\":3,\"384\":5,\"388\":1,\"389\":3,\"391\":1,\"393\":1,\"394\":2,\"395\":2,\"397\":3,\"399\":4,\"400\":2,\"402\":2,\"405\":2,\"410\":8,\"412\":1,\"413\":3,\"415\":5,\"417\":3,\"418\":3,\"419\":3,\"421\":3,\"422\":3,\"423\":5,\"425\":1,\"426\":4,\"427\":3,\"428\":2,\"430\":1,\"431\":4,\"432\":4,\"433\":2,\"435\":3,\"436\":3,\"437\":6,\"438\":5,\"440\":4,\"441\":2,\"443\":4,\"444\":14,\"446\":2,\"447\":9,\"448\":4,\"451\":1,\"452\":4,\"453\":3,\"455\":1,\"456\":4,\"457\":4,\"458\":1,\"460\":9,\"461\":4,\"462\":3,\"465\":1,\"466\":1,\"467\":2,\"469\":1,\"470\":2,\"471\":14,\"473\":2,\"475\":2,\"477\":2,\"478\":5,\"479\":2,\"480\":5,\"482\":2,\"483\":4,\"484\":17,\"485\":4,\"487\":1,\"488\":3,\"489\":1,\"490\":3,\"492\":6,\"494\":2,\"495\":2,\"497\":1,\"498\":4,\"499\":4,\"500\":1,\"502\":2,\"504\":3,\"505\":5,\"507\":1,\"508\":4,\"509\":6,\"512\":1,\"513\":16,\"516\":5,\"519\":2,\"522\":1,\"525\":1,\"526\":3,\"527\":6,\"531\":4,\"538\":4,\"539\":4,\"542\":3,\"544\":2,\"545\":5,\"546\":2,\"551\":2,\"557\":5,\"560\":1,\"562\":2,\"563\":5,\"564\":1,\"565\":4,\"568\":1,\"569\":1,\"572\":7,\"575\":38,\"576\":7,\"579\":2,\"583\":1,\"589\":1,\"599\":13,\"602\":3,\"605\":4,\"609\":3,\"612\":1,\"615\":2,\"618\":1,\"622\":6,\"623\":1,\"627\":1,\"630\":22,\"633\":9,\"636\":2,\"643\":1,\"646\":3,\"649\":3,\"653\":6,\"656\":18,\"662\":5,\"666\":2,\"669\":1,\"672\":4,\"675\":7,\"679\":4,\"682\":1,\"685\":9,\"688\":2,\"691\":2,\"701\":2,\"705\":5,\"708\":2,\"714\":2,\"718\":8,\"721\":3,\"724\":1,\"729\":2,\"730\":1,\"732\":10,\"734\":1,\"735\":3,\"736\":2,\"737\":1,\"739\":1,\"741\":3,\"742\":1,\"744\":5,\"745\":2,\"747\":2,\"751\":1,\"757\":1,\"763\":1,\"764\":19,\"767\":5,\"770\":1,\"772\":1,\"773\":2,\"777\":5,\"780\":1,\"786\":1,\"793\":1,\"796\":5,\"799\":3,\"801\":1,\"803\":2,\"804\":2,\"810\":3,\"812\":1,\"816\":1,\"819\":1,\"822\":1,\"829\":1,\"832\":3,\"836\":3,\"839\":2,\"843\":1,\"844\":2,\"847\":2,\"851\":2,\"854\":2,\"857\":3,\"864\":10,\"868\":1,\"872\":5,\"875\":6,\"879\":1,\"881\":1,\"882\":1,\"885\":3,\"892\":3,\"898\":1,\"902\":2,\"906\":1,\"907\":1,\"911\":4}}],[\"dmy\",{\"0\":{\"915\":1}}],[\"dl\",{\"1\":{\"911\":1}}],[\"dlen\",{\"1\":{\"270\":5}}],[\"d<=3\",{\"1\":{\"630\":1}}],[\"d3\",{\"1\":{\"599\":3}}],[\"dd++\",{\"1\":{\"527\":1,\"572\":1}}],[\"dd\",{\"1\":{\"527\":7,\"572\":6,\"754\":3}}],[\"d==\",{\"1\":{\"911\":2}}],[\"d==3\",{\"1\":{\"630\":1}}],[\"d==2\",{\"1\":{\"630\":1}}],[\"d==1\",{\"1\":{\"630\":1}}],[\"d=0\",{\"1\":{\"630\":1}}],[\"d=d\",{\"1\":{\"508\":1}}],[\"d=1\",{\"1\":{\"508\":1}}],[\"da=a\",{\"1\":{\"633\":1}}],[\"dag\",{\"1\":{\"442\":1,\"444\":1}}],[\"da\",{\"1\":{\"412\":2}}],[\"day2\",{\"0\":{\"298\":1}}],[\"day1\",{\"0\":{\"294\":1},\"1\":{\"472\":1}}],[\"day++\",{\"1\":{\"276\":1,\"516\":1}}],[\"day\",{\"1\":{\"276\":17,\"516\":6}}],[\"dr\",{\"1\":{\"911\":1}}],[\"draw\",{\"1\":{\"324\":1}}],[\"dropping\",{\"0\":{\"181\":1}}],[\"dchs\",{\"1\":{\"193\":2,\"763\":1}}],[\"d2\",{\"1\":{\"187\":4,\"599\":3,\"764\":16}}],[\"d1\",{\"1\":{\"187\":4,\"599\":3,\"764\":12}}],[\"d0\",{\"1\":{\"187\":4}}],[\"dp\",{\"0\":{\"204\":1,\"257\":1,\"280\":1,\"303\":1,\"353\":1},\"1\":{\"176\":6,\"196\":11,\"221\":21,\"222\":26,\"232\":22,\"257\":6,\"260\":17,\"270\":7,\"273\":6,\"303\":5,\"306\":11,\"307\":8,\"335\":1,\"362\":1,\"405\":1,\"436\":7,\"444\":1,\"495\":3,\"499\":1}}],[\"dy\",{\"1\":{\"167\":2,\"194\":2,\"200\":2,\"241\":3,\"242\":3,\"253\":2,\"255\":1,\"256\":3,\"259\":2,\"267\":2,\"276\":2,\"305\":3,\"336\":2,\"421\":2,\"422\":2,\"423\":2,\"438\":2,\"505\":5,\"527\":2,\"875\":2}}],[\"dx\",{\"1\":{\"167\":2,\"194\":2,\"200\":2,\"241\":3,\"242\":3,\"253\":2,\"255\":1,\"256\":3,\"259\":2,\"267\":2,\"276\":2,\"305\":5,\"336\":2,\"402\":2,\"421\":2,\"422\":2,\"423\":2,\"438\":2,\"505\":5,\"875\":2}}],[\"d++\",{\"1\":{\"141\":1,\"302\":1,\"431\":1,\"630\":1}}],[\"do\",{\"1\":{\"184\":1,\"417\":1}}],[\"doswap\",{\"1\":{\"172\":3,\"173\":2}}],[\"down\",{\"1\":{\"19\":3,\"21\":4,\"216\":3,\"237\":3,\"239\":3,\"260\":4}}],[\"double\",{\"1\":{\"3\":1,\"40\":7,\"61\":1,\"64\":1,\"83\":1,\"91\":2,\"101\":1,\"129\":4,\"181\":6,\"205\":11,\"244\":8,\"245\":5,\"285\":3,\"368\":3,\"369\":5,\"450\":2,\"458\":4,\"478\":1,\"575\":1,\"576\":1,\"640\":1,\"746\":1,\"884\":1}}],[\"deltab\",{\"1\":{\"633\":1}}],[\"deltaa\",{\"1\":{\"633\":1}}],[\"delta\",{\"1\":{\"575\":1,\"576\":1}}],[\"december\",{\"1\":{\"455\":1}}],[\"detect\",{\"1\":{\"198\":2}}],[\"deque<int>\",{\"1\":{\"104\":1,\"295\":1}}],[\"deque\",{\"0\":{\"104\":1,\"371\":1}}],[\"debug\",{\"0\":{\"45\":1}}],[\"dev\",{\"0\":{\"42\":1}}],[\"default\",{\"1\":{\"40\":1}}],[\"define\",{\"1\":{\"19\":1,\"20\":1,\"21\":1,\"109\":1,\"110\":1,\"119\":1,\"127\":1,\"128\":1,\"139\":1,\"140\":1,\"144\":1,\"146\":1,\"147\":1,\"148\":1,\"151\":1,\"163\":1,\"164\":1,\"167\":1,\"169\":1,\"176\":1,\"181\":2,\"195\":2,\"224\":1,\"225\":1,\"226\":1,\"241\":1,\"245\":1,\"257\":1,\"266\":1,\"270\":1,\"291\":1,\"292\":1,\"293\":1,\"298\":2,\"303\":1,\"305\":1,\"313\":1,\"314\":1,\"329\":1,\"331\":1,\"335\":1,\"338\":1,\"358\":1,\"359\":1,\"362\":1,\"371\":1,\"373\":1,\"375\":1,\"377\":1,\"381\":1,\"383\":1,\"384\":1,\"395\":1,\"402\":1,\"405\":1,\"410\":1,\"413\":2,\"414\":1,\"415\":4,\"418\":1,\"428\":1,\"435\":1,\"437\":1,\"470\":1,\"471\":1,\"475\":1,\"478\":1,\"483\":1,\"484\":2,\"485\":1,\"488\":1,\"493\":1,\"495\":1,\"524\":1,\"525\":1,\"526\":1,\"527\":1,\"575\":8,\"576\":8,\"579\":1,\"633\":3,\"636\":3,\"705\":1,\"708\":1,\"803\":1,\"804\":1}}],[\"dep\",{\"1\":{\"11\":11,\"15\":8}}],[\"difficult\",{\"1\":{\"851\":1}}],[\"didi\",{\"0\":{\"555\":1}}],[\"digit\",{\"0\":{\"378\":1}}],[\"dig++\",{\"1\":{\"168\":1}}],[\"dig\",{\"1\":{\"165\":33,\"168\":17,\"270\":16}}],[\"div2\",{\"1\":{\"285\":2}}],[\"div1\",{\"1\":{\"285\":2}}],[\"division\",{\"1\":{\"40\":1}}],[\"div\",{\"1\":{\"15\":4}}],[\"dis\",{\"1\":{\"12\":10,\"13\":7,\"230\":9,\"231\":16,\"259\":13,\"276\":5,\"295\":11,\"421\":8,\"422\":10,\"423\":13,\"433\":7}}],[\"dfn\",{\"1\":{\"15\":2,\"444\":6}}],[\"dfsy\",{\"1\":{\"298\":4}}],[\"dfsx\",{\"1\":{\"298\":4}}],[\"dfsdfs\",{\"1\":{\"242\":3,\"383\":3,\"384\":3}}],[\"dfs路径上所有点可以走到的点的数量设置为now\",{\"1\":{\"200\":1}}],[\"dfs2\",{\"1\":{\"142\":4,\"319\":4}}],[\"dfs1\",{\"1\":{\"142\":4}}],[\"dfs序对应的节点编号\",{\"1\":{\"15\":1}}],[\"dfs\",{\"0\":{\"154\":1,\"185\":1},\"1\":{\"11\":3,\"12\":3,\"13\":3,\"14\":3,\"15\":8,\"24\":4,\"109\":6,\"110\":6,\"154\":4,\"178\":3,\"180\":5,\"182\":6,\"185\":4,\"186\":6,\"187\":6,\"194\":4,\"195\":3,\"196\":6,\"199\":4,\"200\":3,\"202\":4,\"203\":4,\"217\":3,\"228\":3,\"242\":3,\"248\":4,\"249\":4,\"253\":4,\"255\":4,\"256\":4,\"270\":7,\"273\":4,\"278\":4,\"279\":4,\"298\":5,\"301\":4,\"302\":3,\"305\":4,\"319\":4,\"374\":3,\"375\":3,\"378\":3,\"381\":3,\"383\":3,\"384\":3,\"400\":4,\"402\":5,\"406\":1,\"410\":4,\"427\":5,\"433\":3,\"444\":3,\"490\":3,\"772\":1}}],[\"db=b\",{\"1\":{\"633\":1}}],[\"db\",{\"1\":{\"3\":2}}],[\"d\",{\"0\":{\"331\":1,\"336\":1,\"338\":1,\"342\":1,\"351\":1,\"357\":1,\"406\":1,\"520\":1,\"540\":1,\"558\":1,\"577\":1,\"590\":1,\"603\":1,\"616\":1,\"634\":1,\"647\":1,\"660\":1,\"673\":1,\"686\":1,\"699\":1,\"712\":1,\"725\":1,\"737\":1,\"747\":1,\"817\":1,\"830\":1,\"845\":1,\"858\":1,\"873\":1,\"886\":1,\"899\":1},\"1\":{\"3\":10,\"83\":2,\"141\":6,\"164\":5,\"187\":6,\"194\":10,\"198\":19,\"202\":4,\"203\":5,\"204\":4,\"216\":12,\"218\":3,\"231\":40,\"235\":1,\"236\":1,\"237\":1,\"239\":1,\"270\":12,\"273\":5,\"275\":5,\"301\":3,\"302\":10,\"303\":5,\"331\":1,\"350\":7,\"366\":5,\"378\":5,\"395\":8,\"419\":1,\"431\":7,\"437\":1,\"444\":5,\"460\":9,\"464\":2,\"465\":2,\"527\":18,\"541\":1,\"542\":1,\"551\":5,\"562\":3,\"563\":4,\"565\":3,\"569\":4,\"612\":5,\"705\":11,\"731\":4,\"754\":4,\"764\":2,\"767\":8,\"887\":1,\"911\":1}}],[\"c+d\",{\"0\":{\"745\":1}}],[\"c++\",{\"0\":{\"42\":1,\"349\":1},\"1\":{\"58\":1,\"62\":1,\"102\":1,\"166\":1,\"346\":1,\"431\":1,\"630\":1,\"662\":2,\"904\":1}}],[\"cpp\",{\"1\":{\"731\":4}}],[\"cc\",{\"1\":{\"692\":2}}],[\"c<=3\",{\"1\":{\"630\":1}}],[\"c<d\",{\"1\":{\"508\":1}}],[\"c3\",{\"1\":{\"599\":3}}],[\"c1\",{\"1\":{\"599\":3}}],[\"cur\",{\"1\":{\"509\":1}}],[\"cur=0\",{\"1\":{\"509\":1}}],[\"c>d\",{\"1\":{\"508\":1}}],[\"c=4\",{\"1\":{\"816\":2}}],[\"c==3\",{\"1\":{\"630\":1}}],[\"c==2\",{\"1\":{\"630\":1}}],[\"c==1\",{\"1\":{\"630\":1}}],[\"c=0\",{\"1\":{\"630\":1}}],[\"c=c\",{\"1\":{\"508\":1}}],[\"c=1\",{\"1\":{\"508\":1}}],[\"cf902b\",{\"1\":{\"494\":1}}],[\"cf900b\",{\"1\":{\"489\":1}}],[\"cf490e加强\",{\"0\":{\"168\":1}}],[\"c2\",{\"1\":{\"445\":1,\"599\":3}}],[\"c2i\",{\"1\":{\"193\":5,\"268\":12}}],[\"cn\",{\"1\":{\"437\":1,\"489\":1,\"494\":1}}],[\"cnte++\",{\"1\":{\"854\":1}}],[\"cnte\",{\"1\":{\"854\":2}}],[\"cnt+1\",{\"1\":{\"705\":3}}],[\"cnt++\",{\"1\":{\"154\":1,\"193\":1,\"217\":1,\"219\":4,\"241\":1,\"242\":1,\"275\":2,\"286\":4,\"301\":1,\"399\":1,\"418\":1,\"428\":1,\"484\":3,\"489\":1,\"490\":1,\"509\":1,\"538\":1,\"576\":2,\"592\":1,\"718\":8,\"732\":1,\"747\":1,\"803\":1,\"816\":1}}],[\"cntx++\",{\"1\":{\"602\":1}}],[\"cntx\",{\"1\":{\"602\":3}}],[\"cnt=0\",{\"1\":{\"509\":1,\"816\":1}}],[\"cntstar\",{\"1\":{\"329\":9}}],[\"cntstarall++\",{\"1\":{\"329\":1}}],[\"cntstarall\",{\"1\":{\"329\":4}}],[\"cnt404\",{\"1\":{\"328\":3}}],[\"cnt40\",{\"1\":{\"328\":4}}],[\"cnt4\",{\"1\":{\"328\":4}}],[\"cntn++\",{\"1\":{\"287\":1}}],[\"cntn\",{\"1\":{\"287\":2}}],[\"cntc\",{\"1\":{\"192\":3}}],[\"cntp\",{\"1\":{\"192\":3}}],[\"cntall++\",{\"1\":{\"228\":1}}],[\"cntall\",{\"1\":{\"228\":3}}],[\"cnta++\",{\"1\":{\"192\":1}}],[\"cnta\",{\"1\":{\"192\":4}}],[\"cnt0\",{\"1\":{\"160\":18,\"182\":4,\"351\":4}}],[\"cnt2++\",{\"1\":{\"146\":2}}],[\"cnt2\",{\"1\":{\"146\":3,\"286\":4}}],[\"cnt1++\",{\"1\":{\"160\":1,\"228\":1}}],[\"cnt1\",{\"1\":{\"140\":9,\"146\":5,\"160\":6,\"228\":4,\"257\":4,\"351\":8}}],[\"cnt3++\",{\"1\":{\"131\":1,\"132\":1,\"854\":1}}],[\"cnt3\",{\"1\":{\"131\":2,\"132\":2,\"854\":2}}],[\"cnt\",{\"1\":{\"31\":3,\"142\":6,\"146\":4,\"147\":3,\"153\":3,\"154\":3,\"162\":11,\"169\":4,\"178\":7,\"180\":4,\"187\":7,\"191\":7,\"193\":8,\"195\":5,\"197\":13,\"214\":3,\"217\":3,\"219\":4,\"232\":8,\"236\":5,\"237\":5,\"239\":5,\"241\":3,\"242\":3,\"243\":1,\"245\":3,\"251\":10,\"253\":4,\"255\":4,\"256\":5,\"257\":3,\"258\":2,\"260\":5,\"268\":5,\"275\":12,\"278\":7,\"279\":8,\"286\":14,\"301\":4,\"334\":3,\"343\":3,\"348\":4,\"349\":1,\"351\":1,\"369\":5,\"395\":5,\"399\":2,\"400\":5,\"418\":2,\"426\":5,\"427\":6,\"428\":1,\"437\":13,\"484\":9,\"489\":2,\"490\":3,\"518\":1,\"519\":10,\"538\":2,\"560\":3,\"576\":2,\"592\":2,\"701\":3,\"705\":17,\"708\":2,\"718\":2,\"727\":8,\"732\":6,\"747\":3,\"780\":3,\"803\":3,\"875\":3}}],[\"ci\",{\"1\":{\"340\":3}}],[\"circle\",{\"0\":{\"338\":1},\"1\":{\"724\":2}}],[\"cin>>m\",{\"1\":{\"906\":1}}],[\"cin>>map\",{\"1\":{\"509\":1}}],[\"cin>>r\",{\"1\":{\"816\":1}}],[\"cin>>t\",{\"1\":{\"742\":1}}],[\"cin>>p\",{\"1\":{\"623\":1}}],[\"cin>>x\",{\"1\":{\"545\":1,\"636\":1}}],[\"cin>>x>>y>>a>>b\",{\"1\":{\"544\":1}}],[\"cin>>x>>y\",{\"1\":{\"507\":1}}],[\"cin>>s1>>s2\",{\"1\":{\"902\":1}}],[\"cin>>s\",{\"1\":{\"509\":1,\"546\":1,\"633\":1,\"902\":1}}],[\"cin>>a>>b\",{\"1\":{\"508\":1}}],[\"cin>>a\",{\"1\":{\"321\":1,\"742\":1,\"816\":1,\"843\":1}}],[\"cin>>n>>q\",{\"1\":{\"902\":1}}],[\"cin>>n>>x>>y>>d\",{\"1\":{\"911\":1}}],[\"cin>>n>>x>>y\",{\"1\":{\"739\":1}}],[\"cin>>n>>k\",{\"1\":{\"633\":1}}],[\"cin>>n>>m\",{\"1\":{\"509\":1,\"742\":1,\"816\":1}}],[\"cin>>n\",{\"1\":{\"321\":1,\"509\":1,\"539\":1,\"545\":1,\"620\":1,\"621\":1,\"623\":1,\"636\":1,\"740\":1,\"804\":1}}],[\"cin\",{\"1\":{\"5\":1,\"7\":2,\"8\":1,\"11\":4,\"12\":4,\"13\":4,\"14\":4,\"15\":4,\"17\":6,\"19\":6,\"20\":6,\"21\":7,\"23\":3,\"27\":2,\"29\":2,\"30\":2,\"31\":2,\"32\":2,\"40\":1,\"66\":3,\"70\":2,\"74\":2,\"109\":2,\"110\":2,\"111\":3,\"112\":3,\"113\":3,\"115\":3,\"116\":3,\"117\":3,\"118\":2,\"119\":2,\"120\":4,\"122\":4,\"123\":4,\"124\":4,\"125\":4,\"126\":4,\"127\":3,\"128\":3,\"129\":1,\"131\":1,\"132\":1,\"134\":1,\"135\":1,\"136\":1,\"137\":3,\"139\":2,\"140\":2,\"141\":4,\"142\":5,\"144\":4,\"146\":4,\"147\":4,\"148\":4,\"150\":6,\"151\":6,\"153\":2,\"154\":3,\"156\":2,\"157\":2,\"158\":3,\"160\":2,\"161\":2,\"162\":2,\"163\":3,\"164\":4,\"165\":3,\"166\":3,\"167\":3,\"168\":3,\"169\":2,\"170\":3,\"172\":2,\"173\":2,\"174\":5,\"175\":4,\"176\":3,\"177\":3,\"178\":4,\"179\":3,\"180\":3,\"181\":8,\"182\":4,\"184\":5,\"185\":5,\"186\":5,\"187\":5,\"188\":2,\"190\":3,\"191\":2,\"192\":3,\"193\":12,\"194\":4,\"195\":6,\"196\":30,\"197\":12,\"198\":15,\"199\":16,\"200\":3,\"202\":3,\"203\":3,\"204\":3,\"205\":4,\"208\":6,\"209\":3,\"210\":3,\"211\":3,\"213\":3,\"214\":3,\"215\":5,\"216\":6,\"217\":2,\"218\":5,\"219\":6,\"221\":3,\"222\":3,\"224\":3,\"225\":3,\"226\":3,\"227\":4,\"228\":3,\"230\":2,\"231\":2,\"232\":3,\"233\":8,\"235\":5,\"236\":5,\"237\":5,\"239\":5,\"241\":2,\"242\":3,\"243\":3,\"244\":6,\"245\":3,\"246\":2,\"248\":2,\"249\":2,\"250\":6,\"251\":3,\"253\":2,\"255\":2,\"256\":2,\"257\":2,\"258\":3,\"259\":4,\"260\":4,\"262\":5,\"263\":5,\"264\":5,\"265\":4,\"266\":5,\"267\":3,\"268\":4,\"269\":4,\"270\":2,\"272\":2,\"273\":2,\"274\":4,\"275\":6,\"276\":6,\"278\":3,\"279\":3,\"280\":3,\"282\":2,\"283\":2,\"284\":2,\"285\":3,\"286\":6,\"287\":5,\"288\":4,\"289\":6,\"291\":7,\"292\":7,\"293\":3,\"295\":3,\"298\":8,\"299\":3,\"301\":3,\"302\":3,\"303\":3,\"305\":1,\"306\":2,\"307\":7,\"309\":3,\"310\":3,\"312\":3,\"313\":6,\"314\":3,\"317\":5,\"318\":5,\"319\":6,\"320\":9,\"321\":1,\"323\":1,\"324\":4,\"325\":4,\"326\":3,\"329\":3,\"331\":4,\"333\":2,\"334\":2,\"335\":2,\"336\":3,\"338\":2,\"340\":3,\"342\":4,\"343\":2,\"345\":3,\"347\":3,\"348\":3,\"349\":3,\"350\":3,\"351\":3,\"352\":3,\"354\":3,\"355\":3,\"356\":3,\"358\":3,\"359\":3,\"361\":3,\"362\":3,\"363\":2,\"365\":3,\"366\":3,\"367\":3,\"368\":3,\"369\":3,\"370\":3,\"371\":3,\"372\":3,\"373\":3,\"374\":3,\"375\":3,\"376\":4,\"377\":3,\"378\":1,\"379\":2,\"380\":2,\"381\":3,\"383\":3,\"384\":3,\"386\":2,\"388\":2,\"389\":2,\"391\":3,\"392\":3,\"393\":3,\"394\":3,\"395\":2,\"397\":1,\"399\":2,\"400\":2,\"402\":4,\"405\":2,\"410\":4,\"412\":3,\"413\":4,\"414\":3,\"415\":4,\"417\":2,\"418\":3,\"419\":4,\"421\":4,\"422\":4,\"423\":4,\"425\":2,\"426\":3,\"427\":4,\"428\":4,\"430\":2,\"431\":3,\"432\":1,\"433\":2,\"435\":1,\"436\":4,\"437\":2,\"438\":2,\"440\":1,\"441\":2,\"443\":3,\"444\":3,\"446\":3,\"447\":3,\"448\":2,\"450\":1,\"451\":3,\"452\":1,\"453\":1,\"455\":1,\"456\":4,\"457\":2,\"458\":3,\"460\":5,\"461\":3,\"462\":1,\"464\":5,\"465\":5,\"466\":5,\"467\":5,\"469\":1,\"470\":1,\"471\":2,\"473\":3,\"475\":5,\"477\":4,\"478\":2,\"479\":3,\"480\":1,\"482\":1,\"483\":1,\"484\":2,\"485\":2,\"487\":1,\"488\":3,\"489\":1,\"490\":2,\"492\":1,\"493\":2,\"494\":2,\"495\":2,\"497\":1,\"498\":2,\"499\":3,\"500\":2,\"502\":2,\"503\":2,\"504\":1,\"505\":2,\"513\":2,\"516\":1,\"519\":1,\"522\":3,\"524\":1,\"525\":3,\"526\":1,\"530\":1,\"531\":1,\"534\":1,\"535\":1,\"538\":1,\"542\":3,\"547\":1,\"551\":1,\"554\":2,\"557\":1,\"560\":3,\"562\":1,\"563\":2,\"564\":1,\"565\":2,\"569\":1,\"572\":1,\"575\":1,\"576\":1,\"579\":2,\"583\":1,\"586\":1,\"589\":1,\"592\":1,\"596\":2,\"599\":5,\"602\":3,\"605\":3,\"609\":1,\"612\":1,\"615\":1,\"618\":1,\"622\":1,\"627\":1,\"630\":1,\"640\":1,\"643\":2,\"646\":1,\"649\":2,\"653\":1,\"656\":3,\"659\":3,\"662\":2,\"666\":1,\"669\":1,\"672\":1,\"675\":1,\"679\":1,\"682\":1,\"685\":1,\"688\":4,\"692\":1,\"695\":1,\"698\":1,\"701\":2,\"705\":1,\"708\":4,\"711\":1,\"714\":1,\"718\":8,\"721\":2,\"724\":1,\"727\":2,\"729\":2,\"730\":2,\"731\":2,\"732\":3,\"734\":2,\"735\":2,\"736\":3,\"737\":3,\"741\":2,\"744\":5,\"745\":2,\"746\":1,\"747\":2,\"751\":1,\"754\":1,\"757\":2,\"760\":1,\"764\":1,\"767\":2,\"770\":1,\"773\":2,\"777\":1,\"780\":1,\"783\":2,\"786\":2,\"790\":2,\"793\":2,\"796\":2,\"799\":3,\"801\":1,\"803\":1,\"805\":1,\"806\":1,\"810\":4,\"813\":1,\"819\":3,\"823\":1,\"826\":2,\"829\":1,\"832\":2,\"836\":1,\"839\":1,\"844\":1,\"847\":5,\"851\":1,\"854\":1,\"857\":1,\"860\":2,\"864\":9,\"868\":2,\"869\":2,\"872\":3,\"875\":6,\"879\":1,\"882\":2,\"885\":2,\"888\":2,\"892\":1,\"895\":2,\"898\":2,\"906\":1,\"907\":1}}],[\"clock\",{\"1\":{\"551\":1}}],[\"claus\",{\"0\":{\"331\":1}}],[\"clear\",{\"1\":{\"3\":1,\"103\":1,\"104\":1,\"127\":4,\"137\":1,\"150\":1,\"151\":1,\"170\":1,\"192\":3,\"196\":5,\"198\":1,\"200\":3,\"208\":1}}],[\"ceoi2015\",{\"0\":{\"298\":1}}],[\"c~d\",{\"1\":{\"218\":1}}],[\"csp\",{\"0\":{\"193\":1,\"194\":1,\"195\":1,\"196\":1,\"197\":1,\"198\":1,\"199\":1,\"315\":1,\"319\":1,\"321\":1,\"396\":1,\"411\":1,\"416\":1,\"424\":1,\"429\":1,\"434\":1,\"439\":1,\"449\":1,\"454\":1,\"459\":1,\"468\":1,\"476\":1,\"481\":1,\"486\":1,\"491\":1,\"496\":1},\"1\":{\"717\":1,\"761\":1,\"769\":1}}],[\"chen\",{\"1\":{\"492\":2}}],[\"check3\",{\"1\":{\"732\":9}}],[\"checky\",{\"1\":{\"331\":3}}],[\"checkx\",{\"1\":{\"331\":3}}],[\"check2\",{\"1\":{\"306\":2,\"414\":2}}],[\"check1\",{\"1\":{\"306\":3}}],[\"checker\",{\"0\":{\"217\":1}}],[\"check\",{\"1\":{\"137\":5,\"146\":2,\"166\":2,\"169\":2,\"181\":4,\"198\":2,\"205\":4,\"219\":4,\"244\":4,\"245\":2,\"250\":4,\"275\":4,\"286\":4,\"293\":2,\"340\":2,\"437\":2,\"485\":2,\"500\":5,\"579\":2,\"592\":2,\"675\":7}}],[\"choose\",{\"1\":{\"381\":6}}],[\"ch\",{\"1\":{\"269\":5}}],[\"change\",{\"1\":{\"875\":3}}],[\"chatgpt\",{\"0\":{\"824\":1}}],[\"challenge\",{\"0\":{\"217\":1}}],[\"character\",{\"1\":{\"66\":2}}],[\"character+out\",{\"1\":{\"47\":1}}],[\"char\",{\"1\":{\"3\":2,\"40\":2,\"61\":1,\"66\":2,\"83\":1,\"92\":1,\"93\":1,\"95\":2,\"101\":2,\"160\":1,\"161\":2,\"178\":1,\"188\":5,\"193\":1,\"194\":1,\"200\":1,\"216\":2,\"235\":1,\"236\":1,\"237\":1,\"239\":1,\"251\":1,\"259\":1,\"262\":2,\"263\":2,\"264\":2,\"265\":2,\"275\":2,\"276\":2,\"287\":1,\"295\":1,\"317\":1,\"318\":1,\"331\":1,\"336\":1,\"367\":1,\"421\":1,\"422\":1,\"423\":1,\"438\":1,\"460\":1,\"466\":1,\"467\":1,\"471\":2,\"498\":1,\"505\":1,\"507\":1,\"509\":1,\"519\":3,\"530\":1,\"531\":1,\"538\":2,\"542\":1,\"551\":1,\"569\":1,\"656\":1,\"679\":1,\"692\":2,\"701\":1,\"718\":1,\"744\":3,\"745\":1,\"764\":1,\"816\":2,\"875\":2,\"902\":1}}],[\"cmpp\",{\"1\":{\"151\":2}}],[\"cmp\",{\"1\":{\"128\":2,\"150\":2,\"151\":2,\"163\":2,\"182\":2,\"191\":2,\"198\":2,\"202\":2,\"203\":2,\"204\":2,\"241\":2,\"312\":2,\"313\":4,\"314\":2,\"325\":3,\"438\":2,\"519\":2,\"522\":3,\"623\":3,\"737\":1,\"760\":2,\"799\":2,\"872\":2}}],[\"can\",{\"1\":{\"428\":4,\"444\":5}}],[\"candies\",{\"0\":{\"372\":1}}],[\"canr\",{\"1\":{\"164\":6}}],[\"canl\",{\"1\":{\"164\":6}}],[\"caltime\",{\"1\":{\"147\":2}}],[\"cal\",{\"1\":{\"137\":2,\"139\":3,\"140\":3,\"144\":2,\"146\":2,\"147\":2,\"154\":3,\"160\":2,\"169\":3,\"262\":4,\"263\":4,\"264\":4,\"270\":3,\"273\":3,\"335\":3,\"381\":2,\"384\":2,\"414\":2,\"464\":2,\"465\":3,\"466\":3,\"467\":3,\"475\":2,\"875\":16}}],[\"cai\",{\"1\":{\"128\":4}}],[\"case\",{\"1\":{\"40\":4}}],[\"carry\",{\"1\":{\"3\":10}}],[\"copy\",{\"1\":{\"711\":2}}],[\"com\",{\"1\":{\"419\":1,\"437\":1,\"445\":1,\"489\":1,\"494\":1,\"726\":1}}],[\"compression\",{\"0\":{\"346\":1}}],[\"compile\",{\"1\":{\"69\":1}}],[\"cow\",{\"1\":{\"402\":4,\"405\":2}}],[\"cows\",{\"0\":{\"277\":1}}],[\"coins\",{\"0\":{\"368\":1}}],[\"covered\",{\"0\":{\"350\":1}}],[\"coci2006\",{\"0\":{\"316\":1}}],[\"count\",{\"1\":{\"162\":4,\"480\":1}}],[\"cout<<2\",{\"1\":{\"911\":3}}],[\"cout<<10\",{\"1\":{\"843\":1}}],[\"cout<<1<<\",{\"1\":{\"620\":1}}],[\"cout<<n<<endl\",{\"1\":{\"911\":2}}],[\"cout<<n\",{\"1\":{\"739\":2}}],[\"cout<<best<<endl\",{\"1\":{\"636\":1}}],[\"cout<<r\",{\"1\":{\"621\":1}}],[\"cout<<sum\",{\"1\":{\"742\":1}}],[\"cout<<s\",{\"1\":{\"509\":1,\"539\":1}}],[\"cout<<i<<\",{\"1\":{\"321\":1}}],[\"cout<<head\",{\"1\":{\"321\":1}}],[\"cout<<j<<\",{\"1\":{\"241\":1}}],[\"cout<<cnt\",{\"1\":{\"509\":1,\"816\":1}}],[\"cout<<char\",{\"1\":{\"507\":2}}],[\"cout<<c\",{\"1\":{\"192\":1}}],[\"cout<<points\",{\"1\":{\"241\":1}}],[\"cout<<p\",{\"1\":{\"192\":1}}],[\"cout<<\",{\"1\":{\"192\":3,\"321\":2,\"508\":3,\"544\":2,\"740\":3,\"902\":2,\"906\":2}}],[\"cout<<a<<\",{\"1\":{\"633\":2}}],[\"cout<<ans\",{\"1\":{\"623\":1,\"804\":1}}],[\"cout<<ans<<\",{\"1\":{\"545\":1}}],[\"cout<<a\",{\"1\":{\"192\":1,\"636\":2,\"843\":1}}],[\"cout<<endl\",{\"1\":{\"168\":1,\"636\":1}}],[\"cout\",{\"1\":{\"5\":1,\"7\":1,\"8\":1,\"11\":1,\"12\":1,\"13\":1,\"14\":1,\"15\":1,\"17\":1,\"19\":2,\"20\":2,\"21\":2,\"23\":1,\"24\":1,\"27\":1,\"29\":1,\"30\":1,\"31\":1,\"32\":1,\"38\":1,\"40\":2,\"46\":1,\"47\":1,\"48\":1,\"50\":3,\"52\":3,\"53\":2,\"54\":1,\"57\":4,\"59\":1,\"60\":1,\"61\":1,\"63\":3,\"64\":1,\"66\":3,\"70\":4,\"74\":4,\"76\":2,\"77\":3,\"78\":3,\"79\":2,\"80\":2,\"90\":1,\"109\":1,\"110\":1,\"111\":4,\"112\":1,\"113\":1,\"115\":2,\"116\":2,\"117\":1,\"118\":1,\"119\":1,\"120\":1,\"122\":1,\"123\":1,\"124\":1,\"125\":3,\"126\":1,\"127\":1,\"128\":2,\"129\":3,\"131\":2,\"132\":2,\"134\":1,\"135\":2,\"136\":2,\"137\":1,\"139\":3,\"140\":3,\"141\":1,\"142\":1,\"144\":1,\"146\":1,\"147\":1,\"148\":1,\"150\":1,\"151\":1,\"153\":1,\"154\":1,\"156\":1,\"157\":1,\"158\":5,\"160\":1,\"161\":1,\"162\":10,\"163\":4,\"164\":4,\"165\":12,\"166\":1,\"167\":1,\"168\":5,\"169\":1,\"170\":2,\"172\":3,\"173\":3,\"174\":6,\"175\":1,\"176\":1,\"177\":1,\"178\":3,\"179\":2,\"180\":1,\"181\":2,\"182\":2,\"184\":2,\"185\":2,\"186\":2,\"187\":1,\"188\":5,\"190\":1,\"191\":2,\"192\":5,\"193\":4,\"194\":1,\"195\":11,\"196\":7,\"197\":4,\"198\":4,\"199\":4,\"200\":1,\"202\":2,\"203\":4,\"204\":2,\"205\":2,\"208\":2,\"209\":2,\"210\":1,\"211\":2,\"213\":2,\"214\":2,\"215\":1,\"216\":2,\"217\":3,\"218\":1,\"219\":4,\"221\":3,\"222\":3,\"224\":1,\"225\":1,\"226\":1,\"227\":1,\"228\":2,\"230\":1,\"231\":1,\"232\":1,\"233\":2,\"235\":2,\"236\":2,\"237\":2,\"239\":2,\"241\":4,\"242\":4,\"243\":1,\"244\":2,\"245\":1,\"246\":3,\"248\":2,\"249\":2,\"250\":2,\"251\":1,\"253\":1,\"255\":1,\"256\":1,\"257\":1,\"258\":1,\"259\":1,\"260\":2,\"262\":2,\"263\":2,\"264\":2,\"265\":2,\"266\":1,\"267\":3,\"268\":3,\"269\":3,\"270\":2,\"272\":2,\"273\":1,\"274\":1,\"275\":2,\"276\":6,\"278\":1,\"279\":1,\"280\":1,\"282\":6,\"283\":2,\"284\":2,\"285\":2,\"286\":2,\"287\":2,\"288\":1,\"289\":4,\"291\":1,\"292\":1,\"293\":1,\"295\":2,\"298\":2,\"299\":2,\"301\":1,\"302\":1,\"303\":1,\"305\":1,\"306\":1,\"307\":2,\"309\":3,\"310\":4,\"312\":1,\"313\":2,\"314\":1,\"317\":2,\"318\":2,\"319\":2,\"320\":3,\"323\":2,\"324\":3,\"325\":1,\"326\":2,\"329\":1,\"331\":1,\"333\":1,\"334\":1,\"335\":1,\"336\":1,\"338\":1,\"340\":1,\"342\":2,\"343\":1,\"345\":2,\"347\":3,\"348\":2,\"349\":2,\"350\":1,\"351\":1,\"352\":1,\"354\":1,\"355\":1,\"356\":1,\"358\":1,\"359\":1,\"361\":1,\"362\":1,\"363\":1,\"365\":1,\"366\":1,\"367\":1,\"368\":1,\"369\":1,\"370\":2,\"371\":1,\"372\":1,\"373\":1,\"374\":1,\"375\":1,\"376\":1,\"377\":1,\"378\":1,\"379\":1,\"380\":1,\"381\":1,\"383\":1,\"384\":1,\"386\":5,\"388\":1,\"389\":1,\"391\":1,\"392\":1,\"393\":1,\"394\":2,\"395\":1,\"397\":3,\"399\":1,\"400\":1,\"402\":2,\"405\":1,\"410\":7,\"412\":1,\"413\":2,\"414\":1,\"415\":4,\"417\":2,\"418\":1,\"419\":1,\"421\":2,\"422\":2,\"423\":2,\"425\":1,\"426\":9,\"427\":1,\"428\":1,\"430\":3,\"431\":1,\"432\":2,\"433\":1,\"435\":1,\"436\":2,\"437\":1,\"438\":1,\"440\":1,\"441\":1,\"443\":1,\"444\":9,\"445\":4,\"446\":4,\"447\":4,\"448\":3,\"450\":1,\"451\":2,\"452\":4,\"453\":2,\"455\":1,\"456\":1,\"457\":1,\"458\":1,\"460\":1,\"461\":4,\"462\":1,\"464\":1,\"465\":1,\"466\":1,\"467\":1,\"469\":1,\"470\":2,\"471\":10,\"473\":3,\"475\":1,\"477\":3,\"478\":2,\"479\":1,\"480\":15,\"482\":3,\"483\":2,\"484\":3,\"485\":1,\"487\":1,\"488\":3,\"489\":2,\"490\":3,\"492\":1,\"493\":1,\"494\":1,\"495\":1,\"497\":1,\"498\":1,\"499\":1,\"500\":1,\"502\":3,\"503\":1,\"504\":1,\"505\":1,\"513\":5,\"516\":3,\"519\":3,\"522\":4,\"524\":1,\"525\":2,\"526\":2,\"531\":5,\"534\":2,\"535\":1,\"538\":3,\"542\":1,\"547\":2,\"551\":1,\"554\":1,\"557\":3,\"560\":1,\"562\":2,\"563\":3,\"564\":2,\"565\":3,\"569\":2,\"572\":1,\"579\":1,\"583\":2,\"586\":1,\"589\":2,\"592\":1,\"596\":1,\"599\":2,\"602\":3,\"605\":1,\"609\":1,\"612\":2,\"615\":1,\"618\":1,\"622\":7,\"627\":2,\"630\":1,\"640\":3,\"643\":1,\"646\":4,\"649\":1,\"653\":9,\"656\":18,\"659\":1,\"662\":1,\"666\":5,\"669\":1,\"672\":5,\"675\":7,\"679\":3,\"682\":1,\"685\":5,\"688\":1,\"692\":1,\"695\":1,\"698\":2,\"701\":1,\"705\":1,\"708\":1,\"711\":2,\"714\":2,\"718\":1,\"721\":1,\"724\":3,\"727\":1,\"729\":1,\"730\":1,\"731\":4,\"732\":1,\"734\":2,\"735\":1,\"736\":1,\"737\":3,\"741\":1,\"744\":1,\"745\":1,\"746\":2,\"747\":2,\"751\":2,\"754\":3,\"757\":1,\"760\":1,\"764\":2,\"767\":1,\"770\":1,\"773\":2,\"777\":4,\"780\":1,\"783\":1,\"786\":1,\"790\":1,\"793\":3,\"796\":5,\"799\":1,\"801\":2,\"803\":1,\"805\":1,\"806\":2,\"810\":1,\"813\":1,\"819\":1,\"823\":1,\"826\":1,\"829\":1,\"832\":1,\"836\":4,\"839\":1,\"844\":2,\"847\":1,\"851\":3,\"854\":2,\"857\":2,\"860\":1,\"864\":1,\"868\":1,\"869\":1,\"872\":2,\"875\":1,\"879\":2,\"882\":1,\"885\":2,\"888\":1,\"892\":3,\"895\":1,\"898\":1,\"906\":1,\"907\":3}}],[\"color\",{\"1\":{\"199\":6,\"274\":8}}],[\"col++\",{\"1\":{\"162\":1}}],[\"col\",{\"1\":{\"162\":24,\"182\":10,\"185\":7,\"186\":20,\"187\":18,\"225\":6,\"226\":5}}],[\"codeforces\",{\"1\":{\"419\":1,\"445\":1}}],[\"code\",{\"1\":{\"55\":1,\"410\":3,\"714\":2}}],[\"contests\",{\"1\":{\"420\":1}}],[\"contest\",{\"0\":{\"353\":1}}],[\"continue\",{\"1\":{\"11\":1,\"12\":1,\"13\":1,\"14\":1,\"15\":2,\"23\":1,\"110\":1,\"141\":1,\"144\":1,\"146\":2,\"147\":2,\"150\":1,\"158\":1,\"161\":1,\"162\":4,\"166\":2,\"167\":1,\"168\":1,\"170\":1,\"176\":1,\"177\":1,\"179\":2,\"187\":1,\"195\":1,\"196\":9,\"197\":1,\"198\":3,\"200\":1,\"203\":1,\"204\":1,\"209\":1,\"215\":3,\"221\":1,\"222\":1,\"225\":1,\"236\":1,\"237\":1,\"239\":1,\"249\":1,\"250\":2,\"257\":2,\"259\":3,\"268\":1,\"273\":1,\"276\":1,\"280\":1,\"305\":3,\"306\":10,\"307\":2,\"309\":1,\"310\":1,\"317\":1,\"329\":3,\"336\":2,\"352\":2,\"367\":1,\"369\":1,\"371\":1,\"373\":1,\"374\":2,\"375\":1,\"383\":2,\"384\":2,\"391\":1,\"402\":1,\"410\":1,\"415\":1,\"418\":1,\"419\":1,\"421\":1,\"422\":1,\"423\":1,\"432\":1,\"433\":1,\"440\":1,\"444\":1,\"457\":1,\"473\":1,\"478\":1,\"480\":1,\"484\":6,\"495\":1,\"504\":1,\"505\":2,\"538\":1,\"545\":1,\"557\":1,\"701\":1,\"708\":2,\"732\":1,\"881\":1}}],[\"const\",{\"1\":{\"3\":31,\"11\":1,\"12\":1,\"13\":1,\"14\":2,\"15\":1,\"17\":1,\"19\":1,\"20\":1,\"21\":1,\"23\":3,\"40\":1,\"109\":3,\"110\":3,\"112\":1,\"113\":2,\"115\":1,\"116\":2,\"117\":2,\"119\":1,\"120\":1,\"122\":1,\"123\":1,\"124\":1,\"125\":1,\"126\":2,\"139\":1,\"140\":1,\"141\":1,\"142\":1,\"144\":1,\"147\":1,\"148\":1,\"150\":1,\"151\":1,\"153\":2,\"158\":1,\"162\":1,\"164\":2,\"165\":2,\"166\":1,\"168\":1,\"169\":2,\"176\":1,\"190\":1,\"192\":1,\"195\":2,\"196\":15,\"197\":6,\"198\":3,\"199\":4,\"213\":1,\"214\":1,\"215\":2,\"216\":2,\"221\":1,\"222\":1,\"225\":2,\"226\":2,\"231\":1,\"233\":2,\"235\":1,\"236\":1,\"237\":1,\"239\":1,\"241\":1,\"242\":1,\"243\":1,\"251\":1,\"260\":3,\"266\":3,\"268\":1,\"269\":1,\"274\":1,\"282\":1,\"283\":2,\"284\":1,\"285\":1,\"291\":1,\"292\":1,\"302\":1,\"303\":2,\"305\":3,\"306\":1,\"307\":2,\"312\":1,\"313\":4,\"314\":3,\"317\":2,\"321\":1,\"325\":1,\"329\":2,\"336\":1,\"342\":2,\"347\":1,\"348\":2,\"349\":2,\"350\":1,\"351\":1,\"352\":1,\"354\":2,\"355\":2,\"356\":1,\"358\":2,\"362\":2,\"363\":1,\"365\":2,\"366\":2,\"367\":1,\"372\":1,\"374\":1,\"375\":2,\"377\":5,\"378\":3,\"379\":1,\"380\":1,\"381\":1,\"383\":1,\"384\":1,\"391\":2,\"392\":2,\"393\":2,\"394\":2,\"395\":2,\"402\":4,\"405\":2,\"415\":6,\"422\":1,\"423\":1,\"427\":1,\"428\":2,\"433\":1,\"437\":1,\"443\":1,\"444\":2,\"458\":2,\"464\":1,\"465\":1,\"466\":1,\"467\":1,\"475\":1,\"493\":1,\"494\":1,\"495\":1,\"575\":4,\"576\":4,\"579\":1,\"735\":2,\"737\":1,\"786\":1,\"839\":1}}],[\"c\",{\"0\":{\"192\":1,\"335\":1,\"350\":1,\"356\":1,\"401\":1,\"517\":1,\"536\":1,\"555\":1,\"573\":1,\"587\":1,\"600\":1,\"613\":1,\"631\":1,\"644\":1,\"657\":1,\"670\":1,\"683\":1,\"696\":1,\"709\":1,\"722\":1,\"736\":1,\"746\":1,\"814\":1,\"827\":1,\"840\":1,\"855\":1,\"870\":1,\"883\":1,\"896\":1},\"1\":{\"3\":23,\"66\":4,\"77\":1,\"78\":1,\"83\":2,\"92\":1,\"93\":1,\"94\":2,\"95\":2,\"99\":3,\"101\":1,\"128\":7,\"129\":6,\"160\":3,\"161\":5,\"164\":5,\"166\":8,\"178\":3,\"186\":9,\"190\":3,\"192\":8,\"196\":24,\"199\":5,\"218\":3,\"259\":7,\"262\":7,\"263\":7,\"264\":7,\"265\":9,\"268\":3,\"269\":6,\"282\":1,\"283\":1,\"284\":1,\"317\":5,\"318\":6,\"319\":10,\"340\":3,\"343\":9,\"356\":3,\"377\":9,\"425\":3,\"431\":7,\"460\":17,\"464\":2,\"465\":2,\"471\":6,\"489\":3,\"513\":12,\"519\":9,\"525\":3,\"527\":5,\"530\":2,\"531\":2,\"542\":1,\"562\":4,\"563\":4,\"569\":5,\"583\":4,\"609\":6,\"612\":3,\"656\":7,\"662\":2,\"692\":2,\"721\":7,\"731\":4,\"751\":4,\"764\":2,\"777\":3,\"875\":3,\"892\":5}}],[\"t+x\",{\"1\":{\"907\":1}}],[\"t+=helper\",{\"1\":{\"902\":1}}],[\"t++\",{\"1\":{\"688\":2}}],[\"t=0\",{\"1\":{\"902\":1}}],[\"t3\",{\"1\":{\"769\":1}}],[\"turtle\",{\"1\":{\"732\":7}}],[\"t4\",{\"1\":{\"509\":1,\"565\":1}}],[\"txt\",{\"1\":{\"484\":1}}],[\"twenty\",{\"1\":{\"246\":1}}],[\"twelve\",{\"1\":{\"246\":1}}],[\"two\",{\"1\":{\"176\":7,\"246\":1,\"329\":8}}],[\"tasks\",{\"1\":{\"420\":1}}],[\"tail\",{\"1\":{\"321\":5}}],[\"talent\",{\"0\":{\"293\":1}}],[\"tag\",{\"1\":{\"216\":13,\"228\":5,\"269\":5}}],[\"tarjan\",{\"0\":{\"14\":1},\"1\":{\"14\":1,\"444\":1}}],[\"trie\",{\"1\":{\"268\":1}}],[\"tr\",{\"1\":{\"268\":43}}],[\"treen\",{\"1\":{\"266\":3}}],[\"trash\",{\"1\":{\"202\":4,\"203\":4,\"204\":4}}],[\"true\",{\"1\":{\"14\":1,\"40\":1,\"80\":1,\"136\":1,\"150\":1,\"154\":1,\"156\":2,\"157\":2,\"162\":4,\"166\":1,\"167\":2,\"168\":1,\"172\":1,\"173\":1,\"178\":1,\"179\":3,\"180\":1,\"182\":12,\"184\":1,\"185\":2,\"186\":2,\"187\":5,\"192\":3,\"194\":1,\"196\":6,\"215\":4,\"217\":1,\"241\":2,\"242\":2,\"244\":2,\"245\":1,\"249\":6,\"250\":1,\"253\":1,\"255\":1,\"259\":1,\"260\":1,\"262\":1,\"263\":1,\"268\":4,\"270\":2,\"273\":2,\"276\":2,\"285\":1,\"289\":2,\"291\":1,\"301\":2,\"305\":1,\"306\":3,\"307\":5,\"342\":1,\"352\":2,\"370\":1,\"378\":2,\"393\":2,\"394\":1,\"402\":2,\"410\":2,\"415\":2,\"417\":1,\"428\":6,\"432\":3,\"436\":2,\"438\":2,\"444\":1,\"457\":1,\"462\":2,\"471\":4,\"479\":1,\"483\":1,\"484\":4,\"487\":1,\"489\":1,\"505\":2,\"538\":1,\"539\":1,\"579\":1,\"605\":1,\"633\":2,\"649\":2,\"675\":1,\"685\":1,\"701\":1,\"732\":7,\"735\":1,\"737\":2,\"772\":1,\"773\":2,\"777\":2,\"786\":1,\"804\":1,\"832\":2,\"857\":1}}],[\"t2\",{\"1\":{\"193\":4,\"805\":3}}],[\"t1\",{\"0\":{\"625\":1},\"1\":{\"193\":4,\"805\":3}}],[\"team\",{\"1\":{\"872\":8}}],[\"ten\",{\"1\":{\"230\":8,\"246\":1,\"288\":5}}],[\"testlib\",{\"1\":{\"551\":1}}],[\"test7\",{\"1\":{\"484\":5}}],[\"test\",{\"0\":{\"181\":1},\"1\":{\"428\":1}}],[\"tempc\",{\"1\":{\"259\":5}}],[\"temp++\",{\"1\":{\"257\":1}}],[\"tempb\",{\"1\":{\"162\":5}}],[\"tempy\",{\"1\":{\"140\":3}}],[\"tempx\",{\"1\":{\"140\":3}}],[\"temp\",{\"1\":{\"127\":11,\"129\":2,\"150\":4,\"151\":6,\"156\":5,\"157\":5,\"162\":3,\"168\":3,\"179\":8,\"181\":10,\"196\":12,\"213\":10,\"214\":10,\"257\":2,\"258\":10,\"259\":5,\"262\":7,\"263\":7,\"264\":7,\"312\":13,\"313\":13,\"377\":2,\"422\":3,\"423\":3,\"460\":9,\"542\":4,\"579\":3,\"695\":7,\"732\":6}}],[\"tdig\",{\"1\":{\"165\":9}}],[\"tt>best\",{\"1\":{\"636\":1}}],[\"tt=get\",{\"1\":{\"636\":1}}],[\"ttt\",{\"1\":{\"147\":3}}],[\"tt\",{\"1\":{\"144\":3,\"147\":6}}],[\"typb\",{\"1\":{\"513\":9}}],[\"typa\",{\"1\":{\"513\":9}}],[\"typ++\",{\"1\":{\"340\":2}}],[\"typ\",{\"1\":{\"142\":7,\"312\":4,\"313\":7,\"314\":3,\"340\":20,\"430\":9}}],[\"typedef\",{\"1\":{\"318\":1,\"575\":1,\"576\":1,\"907\":1}}],[\"type\",{\"1\":{\"101\":2}}],[\"tb\",{\"1\":{\"83\":2}}],[\"title\",{\"1\":{\"289\":1,\"313\":1}}],[\"tim+=quan\",{\"1\":{\"633\":1}}],[\"tim++\",{\"1\":{\"633\":1}}],[\"tim==n\",{\"1\":{\"633\":2}}],[\"tim=0\",{\"1\":{\"633\":1}}],[\"timint\",{\"1\":{\"287\":6}}],[\"tim\",{\"1\":{\"219\":2,\"244\":10,\"287\":7,\"633\":1,\"872\":5}}],[\"times\",{\"1\":{\"645\":1}}],[\"timeout\",{\"0\":{\"345\":1}}],[\"time\",{\"1\":{\"69\":1,\"170\":1}}],[\"ti\",{\"1\":{\"127\":4,\"342\":3}}],[\"tib\",{\"1\":{\"83\":1}}],[\"tie\",{\"1\":{\"11\":1,\"12\":1,\"13\":1,\"14\":1,\"15\":1,\"17\":1,\"19\":1,\"20\":1,\"21\":1,\"23\":1,\"109\":1,\"110\":1,\"111\":1,\"112\":1,\"113\":1,\"115\":1,\"116\":1,\"117\":1,\"120\":1,\"122\":1,\"123\":1,\"124\":1,\"125\":1,\"126\":1,\"127\":1,\"128\":1,\"137\":1,\"141\":1,\"142\":1,\"144\":1,\"146\":1,\"147\":1,\"148\":1,\"154\":1,\"158\":1,\"163\":1,\"164\":1,\"165\":1,\"166\":1,\"167\":1,\"168\":1,\"169\":1,\"170\":1,\"175\":1,\"176\":1,\"177\":1,\"178\":1,\"179\":1,\"180\":1,\"181\":2,\"182\":2,\"184\":1,\"185\":1,\"186\":1,\"187\":1,\"190\":1,\"192\":1,\"193\":4,\"195\":2,\"196\":5,\"197\":4,\"198\":3,\"199\":4,\"202\":1,\"203\":1,\"204\":1,\"205\":2,\"208\":2,\"209\":1,\"210\":1,\"211\":1,\"213\":1,\"214\":1,\"215\":1,\"216\":2,\"217\":1,\"218\":1,\"219\":2,\"221\":1,\"222\":1,\"224\":1,\"225\":1,\"226\":1,\"227\":1,\"228\":1,\"230\":1,\"231\":1,\"232\":1,\"233\":2,\"235\":1,\"236\":1,\"237\":1,\"239\":1,\"242\":1,\"244\":2,\"245\":1,\"246\":1,\"248\":1,\"249\":1,\"250\":2,\"253\":1,\"255\":1,\"256\":1,\"257\":1,\"258\":1,\"259\":1,\"260\":1,\"265\":1,\"266\":1,\"267\":2,\"268\":1,\"270\":1,\"272\":1,\"273\":1,\"274\":1,\"275\":2,\"276\":2,\"278\":1,\"279\":1,\"280\":1,\"282\":1,\"283\":1,\"284\":1,\"285\":1,\"286\":2,\"287\":1,\"288\":1,\"291\":1,\"292\":1,\"293\":1,\"295\":1,\"298\":2,\"299\":1,\"301\":1,\"302\":1,\"303\":1,\"306\":1,\"307\":1,\"309\":1,\"310\":1,\"312\":1,\"313\":2,\"314\":1,\"317\":1,\"318\":1,\"319\":1,\"320\":3,\"321\":1,\"331\":1,\"333\":1,\"334\":1,\"335\":1,\"336\":1,\"338\":1,\"340\":1,\"345\":1,\"347\":1,\"348\":1,\"349\":1,\"350\":1,\"351\":1,\"352\":1,\"354\":1,\"355\":1,\"356\":1,\"358\":1,\"359\":1,\"361\":1,\"362\":1,\"363\":1,\"365\":1,\"366\":1,\"367\":1,\"368\":1,\"369\":1,\"370\":1,\"371\":1,\"372\":1,\"373\":1,\"374\":1,\"375\":1,\"376\":1,\"377\":1,\"381\":1,\"383\":1,\"384\":1,\"386\":1,\"388\":1,\"389\":1,\"391\":1,\"392\":1,\"393\":1,\"394\":1,\"395\":1,\"399\":1,\"400\":1,\"402\":2,\"405\":1,\"410\":1,\"412\":1,\"413\":2,\"414\":1,\"417\":1,\"418\":1,\"419\":1,\"421\":1,\"422\":1,\"423\":1,\"425\":1,\"426\":1,\"427\":1,\"428\":1,\"443\":1,\"444\":1,\"446\":1,\"447\":1,\"458\":1,\"460\":1,\"461\":1,\"475\":1,\"542\":1,\"560\":1,\"563\":1,\"596\":1,\"599\":1,\"602\":1,\"605\":1,\"729\":1,\"730\":1,\"731\":1,\"732\":1,\"734\":1,\"735\":1,\"736\":1,\"737\":1,\"741\":1,\"790\":1,\"793\":1,\"796\":1,\"799\":1,\"819\":1,\"906\":2}}],[\"the\",{\"0\":{\"275\":1,\"276\":1,\"294\":1}}],[\"them\",{\"0\":{\"141\":1}}],[\"third\",{\"1\":{\"246\":1}}],[\"thirteen\",{\"1\":{\"246\":1}}],[\"this\",{\"1\":{\"3\":20}}],[\"thrid\",{\"1\":{\"721\":2}}],[\"three\",{\"1\":{\"246\":1,\"397\":2}}],[\"throw\",{\"1\":{\"40\":1}}],[\"th\",{\"1\":{\"156\":6,\"157\":6}}],[\"t\",{\"0\":{\"379\":1},\"1\":{\"7\":5,\"17\":10,\"18\":1,\"19\":12,\"20\":7,\"21\":27,\"23\":6,\"24\":2,\"137\":3,\"144\":4,\"146\":14,\"147\":4,\"148\":3,\"163\":4,\"164\":17,\"165\":6,\"170\":7,\"173\":6,\"174\":1,\"191\":5,\"192\":3,\"194\":3,\"195\":6,\"196\":15,\"198\":9,\"199\":12,\"202\":10,\"203\":14,\"204\":10,\"208\":8,\"209\":1,\"213\":3,\"214\":4,\"216\":26,\"230\":12,\"236\":3,\"237\":12,\"239\":14,\"258\":3,\"260\":3,\"266\":3,\"268\":3,\"275\":18,\"282\":13,\"283\":6,\"284\":6,\"287\":3,\"289\":6,\"291\":12,\"292\":12,\"293\":4,\"307\":6,\"312\":8,\"313\":15,\"314\":7,\"324\":3,\"325\":3,\"326\":3,\"329\":3,\"336\":3,\"351\":3,\"363\":6,\"376\":5,\"458\":3,\"461\":3,\"464\":3,\"465\":3,\"466\":3,\"467\":3,\"471\":9,\"473\":3,\"475\":3,\"487\":2,\"503\":3,\"504\":3,\"524\":1,\"527\":2,\"531\":6,\"557\":7,\"575\":1,\"576\":1,\"615\":5,\"627\":1,\"633\":7,\"688\":4,\"708\":5,\"742\":13,\"764\":2,\"796\":18,\"836\":2,\"839\":2,\"872\":3,\"875\":14,\"902\":1,\"907\":4}}],[\"toosimple\",{\"1\":{\"544\":1}}],[\"tooy0ung的贪吃蛇\",{\"0\":{\"908\":1}}],[\"tooy0ung的数学简单题\",{\"0\":{\"903\":1}}],[\"tooy0ung的16位内存系统\",{\"0\":{\"899\":1}}],[\"tooy0ung的wronganswer\",{\"0\":{\"573\":1}}],[\"tooy0ung的等差数列2\",{\"0\":{\"565\":1}}],[\"tooy0ung\",{\"0\":{\"544\":1,\"545\":1,\"546\":1,\"547\":1,\"552\":1,\"902\":1,\"906\":1,\"911\":1},\"1\":{\"525\":1,\"544\":1,\"563\":1,\"565\":2}}],[\"tou\",{\"1\":{\"430\":2}}],[\"toy\",{\"1\":{\"318\":4}}],[\"tox\",{\"1\":{\"318\":8}}],[\"top\",{\"1\":{\"15\":11,\"105\":1,\"144\":1,\"148\":1,\"167\":1,\"210\":5,\"235\":1,\"236\":2,\"237\":3,\"239\":3,\"260\":5,\"319\":5,\"342\":2,\"410\":2,\"444\":7,\"456\":2,\"475\":2}}],[\"tot>0\",{\"1\":{\"321\":1}}],[\"tot=n\",{\"1\":{\"321\":1}}],[\"tott++\",{\"1\":{\"321\":1}}],[\"tott+1\",{\"1\":{\"321\":1}}],[\"tott=1\",{\"1\":{\"321\":1}}],[\"tott\",{\"1\":{\"321\":6}}],[\"tot++\",{\"1\":{\"259\":1,\"410\":1,\"480\":2,\"519\":1}}],[\"tot\",{\"1\":{\"15\":3,\"23\":1,\"258\":2,\"259\":5,\"268\":2,\"269\":1,\"295\":3,\"313\":2,\"314\":2,\"319\":11,\"321\":2,\"410\":6,\"415\":3,\"444\":8,\"480\":11,\"519\":4}}],[\"to\",{\"0\":{\"351\":1},\"1\":{\"3\":2,\"5\":1,\"7\":1,\"8\":1,\"40\":2,\"193\":1}}],[\"1<<\",{\"1\":{\"621\":1,\"902\":2}}],[\"1<<m\",{\"1\":{\"109\":1,\"110\":1}}],[\"1+1\",{\"1\":{\"742\":2}}],[\"1+t\",{\"1\":{\"742\":1}}],[\"1+\",{\"1\":{\"369\":1}}],[\"1行\",{\"1\":{\"306\":1}}],[\"1行摆放方案为\",{\"1\":{\"306\":1}}],[\"1号节点\",{\"1\":{\"269\":1}}],[\"17948\",{\"1\":{\"484\":1}}],[\"17844\",{\"1\":{\"484\":1}}],[\"1781\",{\"1\":{\"484\":1}}],[\"17745\",{\"1\":{\"484\":1}}],[\"17640\",{\"1\":{\"484\":1}}],[\"17545\",{\"1\":{\"484\":1}}],[\"17442\",{\"1\":{\"484\":1}}],[\"17335\",{\"1\":{\"484\":1}}],[\"17230\",{\"1\":{\"484\":1}}],[\"17124\",{\"1\":{\"484\":1}}],[\"17010\",{\"1\":{\"484\":1}}],[\"17\",{\"0\":{\"580\":1},\"1\":{\"195\":1,\"246\":1,\"516\":1,\"633\":6}}],[\"184\",{\"1\":{\"839\":2}}],[\"18466\",{\"1\":{\"484\":1}}],[\"18987\",{\"1\":{\"484\":1}}],[\"18775\",{\"1\":{\"484\":1}}],[\"18675\",{\"1\":{\"484\":1}}],[\"18574\",{\"1\":{\"484\":1}}],[\"18360\",{\"1\":{\"484\":1}}],[\"18250\",{\"1\":{\"484\":1}}],[\"18142\",{\"1\":{\"484\":1}}],[\"18030\",{\"1\":{\"484\":1}}],[\"18892\",{\"1\":{\"484\":1}}],[\"188\",{\"1\":{\"195\":1}}],[\"18\",{\"0\":{\"593\":1},\"1\":{\"195\":1,\"246\":1,\"278\":2,\"279\":2,\"640\":1}}],[\"1~x\",{\"1\":{\"335\":1,\"662\":2}}],[\"1~tot\",{\"1\":{\"295\":1,\"313\":1,\"314\":1}}],[\"1~13数字\",{\"1\":{\"193\":1}}],[\"1~4\",{\"1\":{\"193\":1}}],[\"1~9\",{\"1\":{\"182\":4,\"248\":1,\"249\":1}}],[\"1~m+1\",{\"1\":{\"158\":1,\"295\":1}}],[\"1~m\",{\"1\":{\"158\":1,\"241\":1}}],[\"1~n+1\",{\"1\":{\"295\":1}}],[\"1~n\",{\"1\":{\"154\":1,\"173\":1,\"199\":1}}],[\"1~now\",{\"1\":{\"151\":1}}],[\"1~pos\",{\"1\":{\"147\":1}}],[\"19925\",{\"1\":{\"484\":1}}],[\"19831\",{\"1\":{\"484\":1}}],[\"19731\",{\"1\":{\"484\":1}}],[\"19624\",{\"1\":{\"484\":1}}],[\"19533\",{\"1\":{\"484\":1}}],[\"19417\",{\"1\":{\"484\":1}}],[\"19318\",{\"1\":{\"484\":1}}],[\"19203\",{\"1\":{\"484\":1}}],[\"19095\",{\"1\":{\"484\":1}}],[\"1915\",{\"1\":{\"484\":1}}],[\"19\",{\"0\":{\"606\":1},\"1\":{\"131\":1,\"132\":1,\"246\":1,\"335\":1,\"516\":1}}],[\"157\",{\"1\":{\"839\":1}}],[\"15798\",{\"1\":{\"484\":1}}],[\"15911\",{\"1\":{\"484\":1}}],[\"15691\",{\"1\":{\"484\":1}}],[\"15604\",{\"1\":{\"484\":1}}],[\"15504\",{\"1\":{\"484\":1}}],[\"15400\",{\"1\":{\"484\":1}}],[\"15315\",{\"1\":{\"484\":1}}],[\"15207\",{\"1\":{\"484\":1}}],[\"1523\",{\"1\":{\"484\":1}}],[\"15088\",{\"1\":{\"484\":1}}],[\"15\",{\"0\":{\"561\":1},\"1\":{\"109\":1,\"110\":1,\"154\":2,\"156\":2,\"157\":2,\"193\":1,\"199\":2,\"217\":1,\"246\":1,\"270\":4,\"288\":1,\"414\":1,\"415\":1,\"482\":1,\"530\":1,\"531\":4,\"773\":3,\"799\":1}}],[\"12951\",{\"1\":{\"484\":1}}],[\"12753\",{\"1\":{\"484\":1}}],[\"12548\",{\"1\":{\"484\":1}}],[\"12449\",{\"1\":{\"484\":1}}],[\"12129\",{\"1\":{\"484\":1}}],[\"12656\",{\"1\":{\"484\":1}}],[\"1265\",{\"1\":{\"484\":31}}],[\"12862\",{\"1\":{\"484\":1}}],[\"128\",{\"1\":{\"478\":1}}],[\"120+1\",{\"1\":{\"740\":1}}],[\"120+1<<\",{\"1\":{\"740\":1}}],[\"12018\",{\"1\":{\"484\":1}}],[\"1209\",{\"1\":{\"484\":1}}],[\"120\",{\"1\":{\"134\":1,\"135\":1,\"136\":1,\"313\":1,\"314\":1,\"599\":4}}],[\"12\",{\"0\":{\"322\":1,\"528\":1},\"1\":{\"134\":1,\"135\":1,\"136\":1,\"156\":1,\"157\":1,\"193\":1,\"246\":1,\"270\":1,\"450\":1,\"455\":3,\"494\":1,\"527\":2,\"572\":1,\"764\":2}}],[\"12228\",{\"1\":{\"484\":1}}],[\"122\",{\"1\":{\"94\":1}}],[\"12344\",{\"1\":{\"484\":1}}],[\"123456\",{\"1\":{\"70\":1,\"74\":1}}],[\"1235\",{\"1\":{\"484\":1}}],[\"123804765\",{\"1\":{\"230\":2,\"231\":1}}],[\"123\",{\"1\":{\"62\":1,\"63\":1,\"656\":1}}],[\"16x\",{\"1\":{\"790\":1}}],[\"16915\",{\"1\":{\"484\":1}}],[\"16819\",{\"1\":{\"484\":1}}],[\"16719\",{\"1\":{\"484\":1}}],[\"16622\",{\"1\":{\"484\":1}}],[\"1663\",{\"1\":{\"484\":1}}],[\"16506\",{\"1\":{\"484\":1}}],[\"16395\",{\"1\":{\"484\":1}}],[\"16305\",{\"1\":{\"484\":1}}],[\"16205\",{\"1\":{\"484\":1}}],[\"16103\",{\"1\":{\"484\":1}}],[\"16017\",{\"1\":{\"484\":1}}],[\"16\",{\"0\":{\"566\":1},\"1\":{\"85\":1,\"246\":1,\"381\":2,\"458\":2,\"744\":1,\"902\":1}}],[\"1个二进制位\",{\"1\":{\"83\":1}}],[\"11922\",{\"1\":{\"484\":1}}],[\"11826\",{\"1\":{\"484\":301}}],[\"11803\",{\"1\":{\"484\":1}}],[\"11773\",{\"1\":{\"484\":1}}],[\"11674\",{\"1\":{\"484\":1}}],[\"11646\",{\"1\":{\"484\":1}}],[\"11622\",{\"1\":{\"484\":1}}],[\"11590\",{\"1\":{\"484\":1}}],[\"11555\",{\"1\":{\"484\":1}}],[\"11530\",{\"1\":{\"484\":1}}],[\"11499\",{\"1\":{\"484\":1}}],[\"11466\",{\"1\":{\"484\":1}}],[\"11438\",{\"1\":{\"484\":1}}],[\"11409\",{\"1\":{\"484\":1}}],[\"11306\",{\"1\":{\"484\":1}}],[\"11286\",{\"1\":{\"484\":1}}],[\"11263\",{\"1\":{\"484\":1}}],[\"11232\",{\"1\":{\"484\":1}}],[\"11234\",{\"1\":{\"221\":1,\"222\":1}}],[\"112345\",{\"1\":{\"211\":1,\"245\":1,\"819\":1,\"898\":1}}],[\"1123456\",{\"1\":{\"172\":1,\"173\":4,\"268\":1}}],[\"11207\",{\"1\":{\"484\":1}}],[\"11180\",{\"1\":{\"484\":1}}],[\"11147\",{\"1\":{\"484\":1}}],[\"11115\",{\"1\":{\"484\":1}}],[\"11011\",{\"1\":{\"484\":1}}],[\"11\",{\"0\":{\"523\":1},\"1\":{\"66\":2,\"195\":1,\"246\":1,\"256\":2,\"267\":2,\"516\":1,\"572\":1,\"764\":2}}],[\"130\",{\"1\":{\"576\":1}}],[\"13059\",{\"1\":{\"484\":1}}],[\"13705\",{\"1\":{\"484\":1}}],[\"13607\",{\"1\":{\"484\":1}}],[\"13511\",{\"1\":{\"484\":1}}],[\"13387\",{\"1\":{\"484\":1}}],[\"13280\",{\"1\":{\"484\":1}}],[\"13165\",{\"1\":{\"484\":1}}],[\"13925\",{\"1\":{\"484\":1}}],[\"1392\",{\"1\":{\"484\":1}}],[\"13812\",{\"1\":{\"484\":1}}],[\"138\",{\"1\":{\"484\":4}}],[\"13\",{\"0\":{\"543\":1},\"1\":{\"66\":2,\"193\":2,\"246\":1,\"455\":2,\"764\":2}}],[\"13+11\",{\"1\":{\"66\":1}}],[\"14992\",{\"1\":{\"484\":1}}],[\"14894\",{\"1\":{\"484\":1}}],[\"1486\",{\"1\":{\"445\":1}}],[\"14795\",{\"1\":{\"484\":1}}],[\"14701\",{\"1\":{\"484\":1}}],[\"14591\",{\"1\":{\"484\":1}}],[\"14487\",{\"1\":{\"484\":1}}],[\"14376\",{\"1\":{\"484\":1}}],[\"14271\",{\"1\":{\"484\":1}}],[\"14148\",{\"1\":{\"484\":1}}],[\"14030\",{\"1\":{\"484\":1}}],[\"1467ms\",{\"1\":{\"110\":1}}],[\"14\",{\"0\":{\"548\":1},\"1\":{\"57\":4,\"246\":1,\"516\":2,\"764\":2}}],[\"1ll<<j\",{\"1\":{\"140\":1}}],[\"1ll<<i\",{\"1\":{\"140\":2}}],[\"1ll\",{\"1\":{\"12\":1,\"13\":4,\"101\":1,\"199\":1,\"414\":1,\"760\":1,\"839\":1}}],[\"1e9\",{\"1\":{\"575\":1,\"576\":1}}],[\"1e14\",{\"1\":{\"478\":1}}],[\"1e\",{\"1\":{\"40\":1,\"245\":1,\"285\":1,\"575\":1,\"576\":1}}],[\"1e8\",{\"1\":{\"3\":1,\"478\":1}}],[\"1e4\",{\"1\":{\"3\":1}}],[\"10==0\",{\"1\":{\"907\":1}}],[\"10^\",{\"1\":{\"645\":1,\"646\":1}}],[\"10^0\",{\"1\":{\"645\":1}}],[\"10^i\",{\"1\":{\"270\":1,\"288\":1}}],[\"10+5\",{\"1\":{\"906\":1}}],[\"10+\",{\"1\":{\"539\":2}}],[\"10906\",{\"1\":{\"484\":1}}],[\"10710\",{\"1\":{\"484\":1}}],[\"10613\",{\"1\":{\"484\":1}}],[\"10405\",{\"1\":{\"484\":1}}],[\"10291\",{\"1\":{\"484\":1}}],[\"1024\",{\"1\":{\"451\":1,\"679\":1}}],[\"101\",{\"1\":{\"735\":1}}],[\"101010\",{\"1\":{\"604\":1}}],[\"1010\",{\"1\":{\"565\":1}}],[\"101112\",{\"1\":{\"537\":1}}],[\"1011\",{\"1\":{\"537\":1}}],[\"10160\",{\"1\":{\"484\":1}}],[\"1018\",{\"1\":{\"484\":1}}],[\"10807\",{\"1\":{\"484\":1}}],[\"1087\",{\"1\":{\"484\":1}}],[\"108\",{\"1\":{\"195\":1}}],[\"10509\",{\"1\":{\"484\":1}}],[\"1051\",{\"1\":{\"484\":1}}],[\"105\",{\"1\":{\"146\":3,\"202\":1,\"203\":1,\"204\":2,\"276\":6,\"307\":3,\"359\":3,\"361\":3,\"370\":1,\"372\":3,\"479\":2,\"480\":2,\"701\":2,\"742\":1,\"747\":1,\"847\":1}}],[\"100+\",{\"1\":{\"539\":2}}],[\"10047\",{\"1\":{\"484\":1}}],[\"1007\",{\"0\":{\"299\":1}}],[\"10014\",{\"1\":{\"484\":1}}],[\"1001\",{\"1\":{\"202\":2,\"203\":2,\"864\":1}}],[\"1003\",{\"1\":{\"200\":6}}],[\"100x\",{\"1\":{\"62\":1}}],[\"1005\",{\"1\":{\"27\":1,\"29\":1,\"30\":1,\"31\":1,\"32\":1,\"120\":4,\"124\":4,\"125\":6,\"154\":2,\"156\":1,\"157\":1,\"160\":1,\"161\":1,\"181\":6,\"194\":4,\"221\":3,\"222\":2,\"260\":1,\"288\":1,\"289\":12,\"293\":1,\"301\":2,\"302\":2,\"303\":2,\"367\":4,\"421\":4,\"456\":2,\"488\":2,\"500\":4,\"522\":4,\"688\":3,\"727\":2,\"742\":1,\"799\":2,\"860\":1,\"888\":1}}],[\"100010\",{\"1\":{\"902\":1}}],[\"1000+\",{\"1\":{\"539\":2}}],[\"10007\",{\"1\":{\"274\":1}}],[\"10005\",{\"1\":{\"260\":2,\"276\":1}}],[\"100005\",{\"1\":{\"163\":1,\"274\":6,\"359\":1,\"361\":1,\"464\":1,\"465\":1,\"466\":1,\"467\":1}}],[\"10000010\",{\"1\":{\"906\":1}}],[\"100000+5\",{\"1\":{\"414\":1}}],[\"1000005\",{\"1\":{\"319\":4,\"633\":1,\"636\":1}}],[\"100000\",{\"1\":{\"19\":1,\"20\":1,\"21\":1,\"23\":1,\"122\":1,\"123\":1,\"148\":1,\"150\":1,\"151\":1,\"165\":1,\"168\":1,\"191\":1,\"196\":5,\"197\":4,\"198\":3,\"208\":2,\"209\":1,\"210\":1,\"213\":1,\"214\":1,\"231\":1,\"233\":2,\"245\":1,\"262\":1,\"291\":1,\"292\":1,\"312\":1,\"313\":2,\"314\":1,\"325\":1,\"329\":2,\"354\":1,\"355\":1,\"356\":1,\"358\":1,\"361\":3,\"365\":2,\"366\":2,\"370\":1,\"372\":2,\"375\":1,\"383\":1,\"384\":1,\"418\":1,\"427\":1,\"457\":2,\"458\":2,\"473\":2,\"475\":1,\"489\":1,\"623\":1}}],[\"10000000\",{\"1\":{\"231\":1,\"262\":1,\"462\":1,\"478\":1}}],[\"1000000000000000000\",{\"1\":{\"452\":1}}],[\"1000000000\",{\"1\":{\"219\":1,\"244\":1,\"259\":1,\"313\":1,\"314\":1,\"354\":1,\"355\":1,\"374\":1,\"375\":1,\"377\":1,\"487\":1}}],[\"100000000\",{\"1\":{\"36\":1,\"231\":1,\"262\":1}}],[\"1000000\",{\"1\":{\"14\":2,\"141\":2,\"231\":1,\"262\":1,\"266\":3,\"284\":1,\"293\":1,\"350\":1,\"485\":1,\"493\":1,\"494\":2}}],[\"10000\",{\"1\":{\"3\":6,\"175\":4,\"218\":1,\"225\":1,\"226\":1,\"228\":2,\"231\":1,\"262\":1,\"378\":1,\"479\":3,\"708\":1}}],[\"1000\",{\"1\":{\"3\":1,\"97\":1,\"109\":1,\"110\":1,\"120\":1,\"124\":1,\"125\":1,\"153\":1,\"158\":1,\"162\":1,\"181\":6,\"191\":2,\"204\":1,\"221\":1,\"222\":1,\"231\":1,\"243\":1,\"251\":1,\"262\":1,\"293\":1,\"336\":1,\"362\":1,\"428\":1,\"484\":3,\"490\":1,\"538\":1,\"539\":2,\"611\":1,\"612\":5,\"679\":1,\"727\":1,\"737\":1,\"786\":1}}],[\"100\",{\"0\":{\"109\":1,\"110\":1,\"116\":1,\"140\":1,\"145\":1,\"151\":1,\"157\":1,\"204\":1,\"210\":1,\"211\":1,\"212\":1,\"257\":1,\"279\":1,\"318\":1,\"403\":1,\"423\":1,\"444\":1,\"448\":1,\"467\":1,\"475\":1},\"1\":{\"3\":3,\"78\":1,\"97\":1,\"98\":2,\"103\":3,\"134\":6,\"135\":6,\"136\":6,\"144\":1,\"147\":1,\"166\":1,\"181\":5,\"196\":5,\"205\":2,\"231\":1,\"246\":1,\"262\":1,\"285\":1,\"305\":1,\"307\":1,\"347\":1,\"348\":2,\"349\":2,\"358\":1,\"362\":2,\"378\":1,\"400\":1,\"413\":1,\"425\":1,\"444\":1,\"503\":1,\"516\":1,\"527\":1,\"538\":1,\"572\":1,\"599\":4,\"609\":2,\"649\":2,\"653\":2,\"656\":1,\"692\":1,\"735\":1,\"872\":6,\"882\":1,\"904\":1,\"909\":1}}],[\"10\",{\"0\":{\"407\":1,\"464\":1,\"510\":1},\"1\":{\"3\":3,\"41\":684,\"59\":1,\"97\":7,\"111\":1,\"131\":3,\"132\":2,\"153\":1,\"176\":3,\"179\":3,\"181\":1,\"182\":23,\"195\":3,\"202\":1,\"203\":2,\"204\":2,\"230\":4,\"231\":14,\"246\":3,\"248\":5,\"249\":10,\"253\":2,\"255\":2,\"257\":1,\"262\":2,\"263\":3,\"264\":2,\"267\":2,\"270\":4,\"273\":3,\"287\":1,\"288\":1,\"319\":1,\"335\":3,\"368\":1,\"369\":1,\"415\":1,\"417\":1,\"425\":4,\"478\":3,\"483\":5,\"484\":12,\"485\":1,\"487\":3,\"489\":1,\"492\":1,\"494\":2,\"495\":1,\"502\":2,\"503\":1,\"507\":2,\"531\":2,\"534\":2,\"537\":1,\"538\":4,\"539\":8,\"572\":1,\"575\":4,\"576\":3,\"579\":2,\"592\":1,\"605\":5,\"609\":4,\"618\":1,\"649\":4,\"653\":8,\"656\":13,\"659\":1,\"662\":12,\"665\":4,\"666\":3,\"692\":4,\"732\":3,\"746\":3,\"764\":2,\"770\":1,\"799\":1,\"812\":9,\"813\":1,\"841\":2,\"844\":1,\"854\":2,\"872\":2,\"904\":1,\"907\":2}}],[\"1\",{\"0\":{\"76\":1,\"89\":1,\"146\":1,\"186\":1,\"230\":1,\"255\":1,\"262\":1,\"354\":1,\"357\":1,\"367\":1,\"407\":1,\"506\":1,\"538\":1,\"868\":1},\"1\":{\"3\":24,\"5\":2,\"11\":6,\"12\":10,\"13\":11,\"14\":5,\"15\":5,\"17\":19,\"18\":2,\"19\":21,\"20\":17,\"21\":35,\"23\":18,\"24\":3,\"27\":4,\"29\":8,\"30\":4,\"31\":4,\"32\":6,\"37\":1,\"40\":2,\"76\":1,\"77\":2,\"79\":1,\"80\":4,\"83\":1,\"85\":6,\"100\":2,\"101\":3,\"109\":21,\"110\":21,\"112\":6,\"113\":7,\"115\":9,\"116\":11,\"117\":7,\"118\":5,\"119\":11,\"120\":9,\"122\":9,\"123\":9,\"124\":9,\"125\":18,\"126\":28,\"127\":2,\"128\":10,\"134\":1,\"135\":1,\"136\":1,\"137\":4,\"139\":5,\"140\":14,\"141\":6,\"142\":9,\"144\":4,\"146\":19,\"147\":14,\"148\":4,\"150\":8,\"151\":9,\"153\":20,\"154\":28,\"156\":8,\"157\":13,\"158\":42,\"160\":13,\"161\":6,\"162\":18,\"163\":11,\"164\":25,\"165\":32,\"166\":14,\"167\":10,\"168\":27,\"169\":12,\"170\":5,\"172\":6,\"173\":8,\"174\":6,\"175\":3,\"176\":14,\"177\":14,\"178\":9,\"179\":8,\"180\":6,\"181\":14,\"182\":34,\"184\":6,\"185\":15,\"186\":23,\"187\":27,\"188\":8,\"190\":3,\"191\":7,\"192\":4,\"193\":14,\"194\":13,\"195\":11,\"196\":85,\"197\":17,\"198\":14,\"199\":49,\"200\":9,\"202\":6,\"203\":12,\"204\":17,\"205\":6,\"208\":8,\"209\":15,\"210\":8,\"211\":8,\"213\":16,\"214\":14,\"215\":8,\"216\":34,\"217\":6,\"218\":3,\"219\":16,\"221\":15,\"222\":15,\"224\":5,\"225\":3,\"226\":2,\"227\":8,\"228\":6,\"230\":11,\"231\":27,\"232\":29,\"233\":18,\"235\":9,\"236\":17,\"237\":46,\"239\":45,\"241\":25,\"242\":21,\"243\":4,\"244\":4,\"245\":2,\"246\":10,\"248\":39,\"249\":20,\"250\":6,\"251\":4,\"253\":21,\"255\":26,\"256\":14,\"257\":12,\"258\":15,\"259\":29,\"260\":22,\"262\":2,\"263\":2,\"264\":3,\"266\":10,\"267\":20,\"268\":11,\"269\":6,\"270\":19,\"272\":22,\"273\":6,\"274\":5,\"275\":15,\"276\":48,\"278\":10,\"279\":10,\"280\":18,\"282\":7,\"283\":10,\"284\":7,\"285\":7,\"286\":20,\"287\":4,\"288\":7,\"289\":10,\"291\":19,\"292\":19,\"293\":7,\"295\":31,\"298\":30,\"299\":5,\"301\":6,\"302\":8,\"303\":6,\"305\":21,\"306\":36,\"307\":8,\"309\":1,\"310\":1,\"312\":13,\"313\":25,\"314\":12,\"317\":14,\"318\":20,\"319\":16,\"320\":42,\"321\":7,\"324\":2,\"325\":7,\"326\":2,\"328\":3,\"329\":30,\"331\":4,\"334\":2,\"335\":18,\"336\":11,\"338\":1,\"340\":17,\"342\":6,\"343\":2,\"345\":1,\"347\":7,\"348\":3,\"349\":8,\"350\":5,\"351\":14,\"352\":8,\"354\":4,\"355\":4,\"356\":8,\"358\":2,\"359\":5,\"361\":6,\"362\":4,\"363\":14,\"365\":6,\"366\":4,\"367\":12,\"368\":9,\"369\":11,\"370\":3,\"371\":11,\"372\":13,\"373\":16,\"374\":16,\"375\":11,\"376\":6,\"377\":11,\"378\":6,\"379\":11,\"380\":17,\"381\":16,\"383\":12,\"384\":27,\"386\":7,\"391\":6,\"392\":6,\"393\":3,\"394\":3,\"395\":2,\"397\":4,\"399\":3,\"400\":5,\"402\":17,\"404\":1,\"405\":14,\"406\":1,\"407\":1,\"410\":20,\"412\":3,\"413\":8,\"414\":12,\"415\":15,\"417\":1,\"418\":6,\"419\":4,\"421\":13,\"422\":14,\"423\":14,\"426\":17,\"427\":7,\"428\":7,\"430\":8,\"432\":4,\"433\":5,\"436\":3,\"437\":13,\"438\":18,\"440\":4,\"441\":7,\"443\":13,\"444\":22,\"446\":7,\"447\":8,\"448\":12,\"450\":3,\"451\":3,\"452\":5,\"453\":12,\"455\":4,\"456\":13,\"457\":10,\"458\":7,\"461\":3,\"462\":3,\"464\":5,\"465\":5,\"466\":4,\"467\":4,\"469\":1,\"470\":2,\"471\":2,\"473\":2,\"475\":10,\"478\":5,\"479\":4,\"480\":18,\"482\":1,\"483\":1,\"484\":6,\"485\":11,\"487\":1,\"488\":7,\"489\":1,\"490\":12,\"492\":19,\"493\":3,\"494\":1,\"495\":8,\"497\":4,\"498\":13,\"499\":16,\"500\":10,\"503\":1,\"504\":3,\"505\":19,\"509\":2,\"512\":1,\"513\":9,\"515\":1,\"516\":3,\"518\":1,\"519\":3,\"521\":1,\"522\":8,\"524\":2,\"525\":3,\"526\":3,\"527\":6,\"530\":1,\"533\":1,\"534\":1,\"535\":1,\"537\":1,\"538\":2,\"539\":3,\"541\":2,\"542\":20,\"544\":4,\"545\":1,\"546\":1,\"547\":3,\"550\":2,\"553\":2,\"554\":1,\"556\":1,\"557\":4,\"559\":1,\"560\":3,\"562\":1,\"563\":1,\"564\":2,\"565\":3,\"568\":1,\"571\":1,\"572\":3,\"574\":1,\"575\":13,\"576\":6,\"578\":1,\"579\":2,\"582\":1,\"586\":3,\"588\":2,\"589\":3,\"591\":1,\"595\":2,\"598\":1,\"601\":1,\"602\":7,\"604\":1,\"605\":7,\"608\":1,\"611\":1,\"614\":1,\"615\":1,\"618\":6,\"622\":1,\"626\":1,\"627\":2,\"629\":1,\"633\":2,\"636\":2,\"639\":2,\"642\":1,\"643\":1,\"645\":4,\"646\":3,\"648\":1,\"649\":2,\"652\":2,\"653\":3,\"655\":2,\"656\":1,\"658\":1,\"659\":1,\"661\":1,\"662\":5,\"665\":1,\"668\":2,\"671\":1,\"672\":4,\"674\":2,\"675\":19,\"678\":1,\"681\":1,\"682\":4,\"684\":1,\"685\":5,\"687\":1,\"688\":13,\"691\":1,\"695\":4,\"700\":1,\"701\":8,\"704\":1,\"705\":4,\"707\":1,\"708\":4,\"711\":2,\"714\":5,\"718\":1,\"720\":1,\"721\":3,\"724\":4,\"726\":1,\"727\":5,\"729\":2,\"730\":1,\"732\":20,\"734\":1,\"735\":5,\"736\":1,\"737\":8,\"740\":6,\"742\":3,\"744\":9,\"746\":3,\"747\":3,\"751\":1,\"754\":5,\"757\":4,\"760\":4,\"764\":4,\"767\":5,\"770\":4,\"772\":1,\"773\":3,\"777\":2,\"780\":1,\"783\":1,\"786\":2,\"793\":1,\"796\":2,\"799\":10,\"803\":4,\"805\":1,\"806\":3,\"809\":1,\"812\":7,\"813\":2,\"815\":1,\"816\":2,\"818\":1,\"819\":2,\"822\":2,\"825\":1,\"826\":1,\"828\":1,\"829\":1,\"831\":1,\"832\":1,\"835\":1,\"836\":2,\"838\":2,\"839\":6,\"841\":1,\"842\":1,\"843\":3,\"844\":3,\"846\":1,\"847\":5,\"850\":1,\"851\":1,\"853\":1,\"856\":1,\"859\":1,\"860\":4,\"863\":1,\"864\":1,\"866\":2,\"868\":2,\"869\":2,\"871\":1,\"872\":7,\"874\":1,\"875\":36,\"878\":1,\"881\":1,\"882\":1,\"884\":1,\"885\":1,\"887\":1,\"888\":4,\"891\":1,\"894\":1,\"895\":1,\"897\":3,\"898\":7}}],[\"vacation\",{\"0\":{\"356\":1}}],[\"val\",{\"1\":{\"128\":3,\"847\":3}}],[\"vote\",{\"0\":{\"343\":1}}],[\"void\",{\"1\":{\"3\":2,\"11\":1,\"12\":1,\"13\":2,\"14\":1,\"15\":2,\"17\":2,\"19\":3,\"20\":2,\"21\":4,\"23\":1,\"40\":1,\"109\":1,\"110\":1,\"142\":2,\"154\":1,\"158\":3,\"160\":1,\"170\":1,\"172\":2,\"173\":2,\"176\":1,\"178\":1,\"180\":1,\"182\":2,\"185\":1,\"186\":1,\"187\":1,\"188\":2,\"190\":1,\"194\":1,\"195\":1,\"196\":5,\"198\":3,\"199\":1,\"200\":1,\"202\":1,\"203\":1,\"209\":1,\"213\":1,\"214\":1,\"216\":4,\"217\":1,\"228\":1,\"236\":1,\"237\":3,\"239\":3,\"242\":1,\"248\":1,\"249\":1,\"253\":1,\"255\":1,\"256\":1,\"258\":1,\"259\":1,\"262\":1,\"263\":1,\"264\":1,\"265\":1,\"266\":1,\"268\":1,\"272\":1,\"278\":1,\"279\":1,\"282\":1,\"283\":1,\"284\":1,\"285\":1,\"289\":2,\"291\":2,\"292\":2,\"295\":1,\"298\":3,\"299\":1,\"301\":1,\"305\":1,\"312\":2,\"313\":4,\"314\":2,\"318\":1,\"319\":1,\"331\":2,\"351\":1,\"375\":1,\"376\":1,\"383\":2,\"384\":2,\"400\":1,\"402\":1,\"410\":1,\"415\":2,\"433\":1,\"440\":1,\"444\":1,\"447\":1,\"475\":1,\"478\":1,\"490\":1,\"618\":1,\"633\":1,\"844\":1,\"875\":2}}],[\"video\",{\"1\":{\"726\":1}}],[\"vitamin\",{\"0\":{\"340\":1}}],[\"vi\",{\"1\":{\"164\":3,\"340\":3,\"846\":1}}],[\"vis\",{\"1\":{\"14\":4,\"150\":4,\"156\":4,\"157\":4,\"167\":4,\"179\":4,\"185\":5,\"186\":8,\"187\":8,\"194\":4,\"196\":12,\"200\":5,\"241\":5,\"242\":6,\"253\":5,\"255\":7,\"256\":4,\"268\":9,\"305\":6,\"307\":4,\"352\":4,\"402\":6,\"428\":3,\"438\":6,\"443\":11,\"457\":5,\"509\":6,\"772\":3,\"773\":5,\"906\":3}}],[\"vector\",{\"0\":{\"103\":1},\"1\":{\"726\":1}}],[\"vector<string>>\",{\"1\":{\"464\":1,\"465\":2,\"466\":1,\"467\":1}}],[\"vector<line>\",{\"1\":{\"312\":1,\"313\":2,\"314\":1}}],[\"vector<plan>\",{\"1\":{\"219\":2}}],[\"vector<pair<int\",{\"1\":{\"13\":1,\"14\":1,\"127\":1,\"182\":2,\"190\":1,\"198\":1,\"241\":2,\"242\":1,\"266\":1,\"295\":1,\"340\":1,\"352\":1,\"433\":1,\"438\":1}}],[\"vector<char>\",{\"1\":{\"40\":2,\"422\":1,\"423\":1}}],[\"vector<int>\",{\"1\":{\"3\":1,\"11\":1,\"12\":1,\"13\":1,\"14\":1,\"15\":1,\"40\":2,\"103\":2,\"109\":1,\"110\":1,\"115\":1,\"116\":1,\"125\":1,\"126\":1,\"150\":1,\"151\":1,\"156\":1,\"157\":1,\"164\":1,\"168\":1,\"170\":1,\"192\":1,\"196\":5,\"200\":1,\"208\":2,\"209\":1,\"214\":1,\"215\":1,\"225\":1,\"226\":1,\"228\":1,\"257\":2,\"274\":2,\"298\":2,\"312\":1,\"313\":1,\"365\":1,\"366\":2,\"375\":1,\"383\":1,\"384\":3,\"395\":1,\"422\":1,\"423\":1,\"436\":3,\"444\":4,\"462\":1,\"479\":1,\"480\":1,\"484\":1,\"494\":1,\"636\":1}}],[\"v\",{\"0\":{\"382\":1},\"1\":{\"3\":70,\"11\":26,\"12\":24,\"13\":18,\"14\":14,\"15\":28,\"163\":3,\"182\":13,\"198\":43,\"215\":13,\"228\":4,\"243\":3,\"278\":6,\"279\":6,\"293\":3,\"295\":6,\"340\":2,\"352\":7,\"358\":3,\"359\":3,\"361\":4,\"362\":4,\"365\":5,\"366\":11,\"375\":10,\"383\":11,\"384\":15,\"428\":4,\"433\":9,\"436\":4,\"438\":6,\"444\":15,\"479\":7,\"494\":2,\"498\":4,\"847\":4}}],[\"实现一个循环\",{\"1\":{\"453\":1}}],[\"实现\",{\"1\":{\"352\":1}}],[\"实现的内容\",{\"1\":{\"3\":1}}],[\"实际上是完全不会的\",{\"1\":{\"900\":1}}],[\"实际上不管做多少次\",{\"1\":{\"806\":1}}],[\"实际上直接暴力从前往后枚举终点\",{\"1\":{\"802\":1}}],[\"实际上我们很容易用\",{\"1\":{\"772\":1}}],[\"实际上有下面几个意义\",{\"1\":{\"737\":1}}],[\"实际上利用数组记好二月之外的天数\",{\"1\":{\"571\":1}}],[\"实际上这个双重循环的时间复杂度还是\",{\"1\":{\"559\":1}}],[\"实际上这个规律也是我出完题目之后才发现的\",{\"1\":{\"402\":1}}],[\"实际上这题的\",{\"1\":{\"495\":1}}],[\"实际上这道题我们可以把每个数字\",{\"1\":{\"494\":1}}],[\"实际上答案就是长度大于等于\",{\"1\":{\"493\":1}}],[\"实际上间接的依赖也会丢分\",{\"1\":{\"492\":1}}],[\"实际上可以保证\",{\"1\":{\"772\":1}}],[\"实际上可以考虑用五个字符\",{\"1\":{\"530\":1}}],[\"实际上可以考虑分段达标\",{\"1\":{\"484\":1}}],[\"实际上可以套一个数位\",{\"1\":{\"335\":1}}],[\"实际上为了避免上溢出\",{\"1\":{\"414\":1}}],[\"实际上因为需要第一节课时间稍短一点\",{\"1\":{\"665\":1}}],[\"实际上因为最终乘积的小于\",{\"1\":{\"470\":1}}],[\"实际上因为是在树上\",{\"1\":{\"414\":1}}],[\"实际上因为定义了\",{\"1\":{\"3\":1}}],[\"实际上\",{\"1\":{\"413\":1}}],[\"实际上也有更简单的方法\",{\"1\":{\"410\":1}}],[\"实际上也可以递归输出\",{\"1\":{\"115\":1,\"116\":1,\"125\":1}}],[\"实际上能拿到\",{\"1\":{\"402\":1}}],[\"实际上容易发现\",{\"1\":{\"400\":1}}],[\"实际上容易想到就是进行\",{\"1\":{\"350\":1}}],[\"实际上手动模拟一下\",{\"1\":{\"400\":1}}],[\"实际上就是\",{\"1\":{\"335\":1}}],[\"实际上完全可以用和前面类似的方法\",{\"1\":{\"329\":1}}],[\"实际上储存的数可能会有一点点偏差\",{\"1\":{\"91\":1}}],[\"允许\",{\"1\":{\"3\":1}}],[\"+2\",{\"1\":{\"267\":1,\"404\":6}}],[\"+b\",{\"1\":{\"267\":2,\"691\":1}}],[\"+base\",{\"1\":{\"221\":1,\"222\":1}}],[\"+a\",{\"1\":{\"267\":2}}],[\"+10\",{\"1\":{\"902\":1}}],[\"+1<<\",{\"1\":{\"544\":1}}],[\"+1\",{\"1\":{\"126\":1,\"258\":1,\"267\":1,\"312\":1,\"313\":1,\"320\":5,\"366\":1,\"404\":1,\"453\":1,\"541\":1,\"668\":1,\"828\":1}}],[\"++girltot\",{\"1\":{\"522\":1}}],[\"++boytot\",{\"1\":{\"522\":1}}],[\"++b1\",{\"1\":{\"289\":2}}],[\"++cur\",{\"1\":{\"509\":1}}],[\"++cntc\",{\"1\":{\"192\":1}}],[\"++cntp\",{\"1\":{\"192\":1}}],[\"++scccnt\",{\"1\":{\"444\":1}}],[\"++ytot\",{\"1\":{\"298\":1}}],[\"++k\",{\"1\":{\"285\":1}}],[\"++len\",{\"1\":{\"273\":1,\"335\":1}}],[\"++dlen\",{\"1\":{\"270\":1}}],[\"++j\",{\"1\":{\"269\":1,\"285\":3}}],[\"++a1\",{\"1\":{\"289\":2}}],[\"++ally\",{\"1\":{\"169\":1}}],[\"++a\",{\"1\":{\"64\":1}}],[\"++\",{\"1\":{\"31\":1,\"160\":1,\"161\":1,\"178\":2,\"193\":2,\"197\":2,\"213\":2,\"214\":1,\"224\":1,\"226\":1,\"256\":1,\"260\":1,\"268\":1,\"321\":1,\"328\":1,\"334\":1,\"348\":1,\"350\":1,\"366\":1,\"369\":1,\"395\":1,\"444\":3,\"518\":1,\"519\":1,\"576\":1,\"727\":2,\"742\":1}}],[\"++tot\",{\"1\":{\"15\":1,\"23\":2,\"268\":1,\"269\":1,\"313\":2,\"314\":2,\"319\":2,\"415\":1}}],[\"++idx\",{\"1\":{\"444\":1}}],[\"++i\",{\"1\":{\"3\":2,\"40\":2,\"269\":1,\"285\":1,\"816\":2}}],[\"+=1\",{\"1\":{\"453\":1}}],[\"+=y\",{\"1\":{\"236\":1}}],[\"+=\",{\"1\":{\"3\":8,\"5\":1,\"15\":1,\"17\":3,\"18\":2,\"19\":8,\"20\":5,\"21\":8,\"23\":3,\"64\":3,\"81\":1,\"109\":1,\"110\":1,\"119\":2,\"134\":2,\"135\":2,\"136\":2,\"141\":2,\"144\":1,\"146\":3,\"147\":3,\"148\":1,\"150\":2,\"151\":2,\"153\":2,\"154\":6,\"156\":1,\"157\":1,\"158\":1,\"160\":3,\"161\":3,\"162\":8,\"163\":1,\"165\":3,\"166\":1,\"167\":1,\"169\":2,\"176\":1,\"177\":1,\"179\":3,\"181\":2,\"182\":5,\"190\":1,\"191\":1,\"194\":1,\"197\":3,\"199\":2,\"203\":2,\"204\":1,\"205\":1,\"208\":2,\"209\":1,\"210\":1,\"211\":1,\"213\":3,\"214\":4,\"216\":1,\"219\":4,\"221\":2,\"222\":2,\"224\":2,\"225\":2,\"226\":1,\"228\":1,\"236\":3,\"237\":9,\"239\":9,\"244\":3,\"245\":1,\"250\":2,\"251\":3,\"257\":2,\"258\":4,\"259\":5,\"260\":1,\"266\":3,\"268\":1,\"270\":5,\"273\":2,\"275\":4,\"278\":1,\"279\":1,\"286\":4,\"291\":2,\"292\":2,\"298\":2,\"302\":2,\"306\":2,\"312\":2,\"313\":4,\"314\":2,\"319\":1,\"320\":4,\"325\":1,\"328\":2,\"329\":4,\"331\":2,\"334\":1,\"335\":3,\"338\":1,\"340\":1,\"348\":1,\"368\":1,\"369\":3,\"376\":1,\"378\":1,\"379\":2,\"381\":1,\"389\":2,\"395\":1,\"410\":2,\"426\":3,\"427\":5,\"428\":1,\"433\":1,\"435\":2,\"437\":7,\"441\":3,\"444\":1,\"450\":1,\"451\":1,\"453\":7,\"460\":5,\"462\":3,\"464\":1,\"465\":2,\"466\":3,\"467\":3,\"478\":1,\"498\":3,\"503\":1,\"516\":4,\"531\":2,\"534\":2,\"538\":2,\"542\":1,\"546\":1,\"554\":1,\"560\":2,\"565\":1,\"575\":2,\"576\":1,\"586\":1,\"592\":1,\"599\":12,\"605\":1,\"615\":2,\"643\":1,\"695\":3,\"701\":1,\"705\":5,\"708\":2,\"727\":2,\"732\":3,\"744\":5,\"745\":1,\"746\":1,\"754\":1,\"780\":1,\"783\":1,\"786\":1,\"796\":1,\"799\":3,\"805\":1,\"812\":5,\"813\":1,\"816\":1,\"826\":1,\"857\":1,\"860\":1,\"872\":1,\"875\":4,\"882\":1,\"885\":1,\"888\":1,\"895\":1,\"898\":2}}],[\"+\",{\"1\":{\"3\":21,\"7\":1,\"8\":1,\"11\":5,\"12\":4,\"13\":9,\"14\":5,\"15\":2,\"17\":16,\"18\":3,\"19\":21,\"20\":17,\"21\":35,\"23\":13,\"24\":3,\"27\":1,\"29\":2,\"32\":2,\"38\":1,\"40\":10,\"41\":872,\"57\":1,\"58\":1,\"59\":1,\"63\":2,\"64\":1,\"66\":4,\"81\":1,\"85\":3,\"93\":1,\"95\":2,\"99\":3,\"100\":3,\"109\":9,\"110\":9,\"111\":3,\"112\":3,\"113\":7,\"115\":5,\"116\":7,\"117\":5,\"118\":1,\"119\":2,\"120\":1,\"122\":9,\"123\":8,\"124\":1,\"125\":1,\"126\":7,\"127\":3,\"128\":4,\"129\":1,\"134\":1,\"135\":1,\"136\":1,\"137\":16,\"139\":1,\"140\":2,\"141\":3,\"142\":10,\"144\":3,\"146\":10,\"147\":10,\"148\":3,\"150\":8,\"151\":10,\"153\":4,\"154\":5,\"158\":18,\"161\":1,\"162\":6,\"163\":6,\"164\":19,\"165\":4,\"166\":8,\"167\":2,\"168\":5,\"169\":13,\"170\":1,\"172\":1,\"173\":3,\"175\":6,\"176\":11,\"177\":1,\"178\":2,\"179\":4,\"180\":5,\"181\":16,\"182\":10,\"184\":3,\"185\":4,\"186\":8,\"187\":11,\"188\":5,\"190\":2,\"191\":6,\"192\":7,\"193\":5,\"194\":5,\"195\":3,\"196\":32,\"197\":12,\"198\":20,\"199\":19,\"200\":2,\"202\":7,\"203\":7,\"204\":16,\"205\":3,\"208\":6,\"209\":2,\"210\":2,\"211\":5,\"213\":12,\"214\":6,\"215\":5,\"216\":26,\"217\":3,\"218\":1,\"219\":8,\"221\":21,\"222\":28,\"225\":4,\"226\":4,\"228\":2,\"230\":4,\"231\":12,\"232\":13,\"233\":17,\"235\":3,\"236\":8,\"237\":33,\"239\":34,\"241\":11,\"242\":12,\"243\":2,\"244\":7,\"245\":1,\"246\":5,\"248\":1,\"249\":1,\"250\":2,\"251\":7,\"253\":6,\"255\":6,\"256\":11,\"258\":12,\"259\":16,\"260\":9,\"262\":15,\"263\":7,\"264\":6,\"265\":2,\"266\":5,\"267\":4,\"268\":9,\"270\":4,\"272\":11,\"274\":8,\"275\":4,\"276\":9,\"278\":10,\"279\":10,\"280\":11,\"282\":4,\"283\":3,\"284\":2,\"285\":3,\"286\":6,\"287\":1,\"289\":4,\"291\":19,\"292\":19,\"293\":4,\"295\":18,\"298\":20,\"299\":8,\"301\":2,\"302\":5,\"303\":8,\"305\":12,\"306\":7,\"307\":7,\"312\":12,\"313\":24,\"314\":12,\"317\":8,\"318\":6,\"319\":1,\"320\":15,\"325\":8,\"329\":25,\"331\":2,\"333\":2,\"334\":1,\"336\":7,\"338\":6,\"340\":5,\"342\":2,\"343\":4,\"347\":4,\"348\":2,\"349\":8,\"350\":3,\"351\":8,\"352\":2,\"354\":5,\"355\":3,\"356\":9,\"358\":4,\"359\":1,\"361\":2,\"362\":5,\"363\":4,\"365\":3,\"366\":5,\"367\":2,\"368\":7,\"369\":5,\"370\":1,\"371\":6,\"372\":6,\"373\":10,\"374\":3,\"375\":5,\"376\":5,\"377\":5,\"378\":4,\"379\":2,\"380\":4,\"381\":4,\"383\":6,\"384\":15,\"391\":3,\"392\":5,\"393\":11,\"394\":2,\"395\":1,\"399\":2,\"400\":5,\"402\":8,\"405\":15,\"406\":2,\"410\":15,\"413\":9,\"414\":5,\"415\":9,\"417\":1,\"418\":4,\"421\":3,\"422\":5,\"423\":5,\"426\":6,\"427\":7,\"428\":5,\"430\":3,\"431\":3,\"433\":1,\"436\":4,\"437\":2,\"438\":4,\"441\":4,\"443\":10,\"444\":22,\"446\":2,\"447\":7,\"448\":6,\"450\":1,\"455\":3,\"456\":12,\"457\":13,\"458\":2,\"460\":4,\"462\":2,\"464\":4,\"465\":4,\"466\":1,\"467\":1,\"469\":3,\"471\":3,\"473\":2,\"475\":5,\"477\":12,\"478\":3,\"479\":1,\"480\":2,\"482\":1,\"483\":1,\"484\":4,\"485\":11,\"488\":2,\"489\":1,\"490\":9,\"492\":3,\"493\":3,\"494\":3,\"495\":11,\"497\":3,\"499\":5,\"500\":3,\"502\":3,\"504\":2,\"505\":10,\"513\":8,\"516\":5,\"519\":3,\"522\":6,\"524\":1,\"525\":4,\"526\":1,\"527\":6,\"530\":1,\"531\":1,\"535\":2,\"538\":9,\"557\":2,\"560\":2,\"563\":4,\"575\":20,\"576\":2,\"583\":1,\"589\":1,\"596\":1,\"609\":2,\"612\":3,\"618\":1,\"627\":2,\"656\":9,\"659\":1,\"662\":1,\"666\":1,\"672\":2,\"675\":2,\"682\":4,\"688\":6,\"692\":1,\"695\":1,\"701\":2,\"705\":5,\"708\":3,\"714\":2,\"724\":2,\"727\":2,\"729\":1,\"732\":3,\"734\":6,\"737\":5,\"745\":1,\"746\":1,\"747\":1,\"754\":3,\"760\":4,\"764\":2,\"767\":1,\"770\":1,\"783\":2,\"786\":2,\"790\":2,\"799\":4,\"803\":6,\"806\":1,\"812\":7,\"813\":1,\"819\":1,\"823\":1,\"829\":1,\"836\":7,\"839\":3,\"844\":2,\"872\":14,\"875\":6,\"895\":1,\"898\":5}}],[\"bg08\",{\"1\":{\"805\":1}}],[\"bv1pe421w7jl\",{\"1\":{\"726\":1}}],[\"bl++\",{\"1\":{\"672\":1,\"685\":1}}],[\"blen\",{\"1\":{\"672\":4}}],[\"bl\",{\"1\":{\"672\":6,\"685\":7}}],[\"block\",{\"1\":{\"342\":2}}],[\"bmi\",{\"0\":{\"638\":1},\"1\":{\"639\":2}}],[\"b+1\",{\"1\":{\"668\":1}}],[\"b+=db\",{\"1\":{\"633\":1}}],[\"b++\",{\"1\":{\"305\":1,\"431\":1,\"630\":1,\"633\":2,\"662\":1}}],[\"b<=3\",{\"1\":{\"630\":1}}],[\"b>b\",{\"1\":{\"623\":1}}],[\"b=12\",{\"1\":{\"633\":1}}],[\"b=11\",{\"1\":{\"633\":1}}],[\"b==3\",{\"1\":{\"630\":1}}],[\"b==2\",{\"1\":{\"630\":1}}],[\"b==1\",{\"1\":{\"630\":1}}],[\"b==b\",{\"1\":{\"623\":1}}],[\"b=0\",{\"1\":{\"630\":1,\"633\":2}}],[\"b=y\",{\"1\":{\"507\":1}}],[\"b4\",{\"1\":{\"477\":3}}],[\"b3\",{\"1\":{\"477\":3,\"599\":3,\"810\":3}}],[\"b2\",{\"1\":{\"477\":3,\"599\":3,\"810\":3}}],[\"bellman\",{\"1\":{\"772\":1}}],[\"bella\",{\"1\":{\"324\":1}}],[\"best=tt\",{\"1\":{\"636\":1}}],[\"best\",{\"1\":{\"636\":1}}],[\"begin\",{\"1\":{\"3\":3,\"103\":1,\"126\":2,\"151\":1,\"182\":1,\"198\":1,\"208\":1,\"211\":1,\"214\":3,\"225\":2,\"241\":2,\"298\":3,\"309\":2,\"310\":1,\"312\":6,\"313\":7,\"314\":1,\"417\":2,\"438\":1,\"462\":2,\"589\":1}}],[\"b1\",{\"1\":{\"289\":6,\"477\":3,\"599\":3,\"809\":1,\"810\":3}}],[\"bb\",{\"1\":{\"267\":3,\"305\":7,\"413\":1}}],[\"bfs\",{\"1\":{\"179\":1,\"259\":2,\"295\":3,\"352\":1,\"436\":1,\"438\":3,\"443\":2}}],[\"bx\",{\"1\":{\"164\":1}}],[\"break\",{\"1\":{\"136\":1,\"141\":1,\"158\":1,\"174\":1,\"178\":2,\"179\":1,\"181\":2,\"184\":1,\"185\":1,\"196\":7,\"197\":2,\"199\":2,\"203\":1,\"205\":1,\"217\":1,\"219\":1,\"230\":1,\"232\":1,\"235\":2,\"243\":1,\"246\":1,\"250\":2,\"259\":1,\"269\":1,\"280\":1,\"286\":1,\"287\":1,\"301\":1,\"317\":2,\"318\":2,\"331\":2,\"335\":1,\"342\":2,\"362\":1,\"370\":1,\"410\":2,\"415\":1,\"421\":1,\"422\":1,\"423\":2,\"462\":2,\"470\":1,\"478\":1,\"484\":3,\"488\":1,\"504\":1,\"505\":2,\"509\":4,\"526\":1,\"557\":1,\"560\":1,\"575\":2,\"646\":1,\"682\":1,\"685\":2,\"735\":2,\"736\":1,\"786\":1,\"799\":1,\"804\":2,\"857\":1,\"881\":1,\"882\":1}}],[\"bad\",{\"1\":{\"854\":1}}],[\"balance\",{\"0\":{\"340\":1}}],[\"balticoi\",{\"0\":{\"294\":1}}],[\"base\",{\"1\":{\"221\":19,\"222\":24,\"303\":3,\"503\":2}}],[\"bank\",{\"1\":{\"134\":4,\"135\":4,\"136\":4}}],[\"back\",{\"1\":{\"3\":4,\"11\":2,\"12\":2,\"13\":4,\"14\":4,\"15\":2,\"103\":1,\"104\":3,\"106\":1,\"109\":1,\"110\":1,\"115\":1,\"116\":1,\"125\":1,\"126\":1,\"127\":8,\"150\":1,\"151\":1,\"156\":2,\"157\":2,\"164\":1,\"170\":3,\"182\":2,\"190\":1,\"192\":3,\"196\":5,\"198\":4,\"200\":3,\"208\":1,\"214\":1,\"215\":2,\"219\":4,\"225\":1,\"226\":1,\"228\":2,\"241\":2,\"242\":1,\"257\":2,\"266\":1,\"274\":2,\"295\":10,\"298\":3,\"312\":4,\"313\":6,\"314\":2,\"340\":1,\"352\":2,\"365\":1,\"366\":2,\"375\":2,\"383\":2,\"384\":6,\"395\":1,\"422\":4,\"423\":4,\"433\":2,\"436\":1,\"438\":1,\"444\":8,\"462\":1,\"464\":1,\"465\":1,\"466\":1,\"467\":1,\"479\":1,\"480\":4,\"494\":1,\"636\":5,\"872\":1}}],[\"bilibili\",{\"1\":{\"726\":1}}],[\"bi\",{\"1\":{\"436\":3}}],[\"binary\",{\"1\":{\"414\":1}}],[\"big\",{\"1\":{\"210\":8}}],[\"biginttiny\",{\"1\":{\"3\":36,\"5\":2,\"7\":1,\"8\":2}}],[\"bit\",{\"1\":{\"83\":2}}],[\"bitset\",{\"1\":{\"442\":1}}],[\"bitset<maxtot\",{\"1\":{\"444\":1}}],[\"bitset<maxn\",{\"1\":{\"158\":3,\"162\":1}}],[\"bitset<1005>\",{\"1\":{\"268\":1}}],[\"bits\",{\"1\":{\"47\":1}}],[\"bytes\",{\"1\":{\"83\":6}}],[\"byte\",{\"1\":{\"83\":3}}],[\"by\",{\"1\":{\"40\":1}}],[\"build\",{\"1\":{\"15\":3,\"17\":4,\"19\":4,\"20\":4,\"21\":4,\"216\":4,\"237\":4,\"239\":4,\"291\":4,\"292\":4}}],[\"buf\",{\"1\":{\"3\":3}}],[\"boy\",{\"1\":{\"522\":5}}],[\"boytot\",{\"1\":{\"522\":3}}],[\"bob\",{\"1\":{\"324\":1}}],[\"bottom\",{\"1\":{\"260\":5}}],[\"both\",{\"1\":{\"246\":1}}],[\"book2\",{\"1\":{\"381\":5}}],[\"book1\",{\"1\":{\"381\":5}}],[\"book\",{\"1\":{\"242\":5,\"288\":5,\"302\":4,\"307\":5,\"359\":5,\"365\":5,\"374\":5,\"378\":6}}],[\"bool>\",{\"1\":{\"179\":1}}],[\"boolean\",{\"1\":{\"80\":1}}],[\"bool\",{\"1\":{\"3\":7,\"14\":1,\"40\":3,\"61\":1,\"128\":1,\"136\":1,\"137\":1,\"147\":1,\"150\":2,\"151\":2,\"154\":1,\"156\":1,\"157\":1,\"162\":1,\"163\":1,\"166\":1,\"167\":1,\"168\":1,\"169\":1,\"172\":1,\"173\":1,\"178\":1,\"179\":1,\"180\":1,\"181\":2,\"182\":3,\"184\":1,\"185\":2,\"186\":1,\"187\":3,\"191\":1,\"192\":1,\"194\":1,\"196\":10,\"198\":2,\"202\":1,\"203\":1,\"204\":1,\"205\":2,\"215\":1,\"217\":1,\"219\":2,\"241\":2,\"242\":1,\"244\":2,\"245\":1,\"249\":3,\"250\":2,\"253\":1,\"255\":1,\"256\":1,\"259\":1,\"260\":1,\"262\":1,\"263\":1,\"270\":2,\"273\":2,\"276\":2,\"285\":1,\"286\":2,\"289\":4,\"291\":1,\"293\":1,\"301\":2,\"306\":2,\"307\":4,\"312\":1,\"313\":2,\"314\":1,\"325\":1,\"340\":1,\"342\":1,\"352\":1,\"370\":1,\"378\":2,\"393\":1,\"394\":1,\"402\":1,\"410\":2,\"414\":1,\"415\":2,\"417\":1,\"428\":4,\"432\":2,\"436\":1,\"437\":1,\"438\":2,\"444\":1,\"457\":1,\"462\":1,\"471\":1,\"479\":1,\"483\":1,\"484\":4,\"485\":1,\"487\":1,\"489\":1,\"490\":1,\"500\":2,\"505\":1,\"509\":1,\"519\":1,\"522\":1,\"538\":1,\"539\":1,\"579\":1,\"592\":1,\"605\":1,\"623\":1,\"649\":1,\"675\":1,\"685\":1,\"701\":1,\"732\":5,\"735\":1,\"737\":1,\"773\":1,\"777\":1,\"786\":1,\"799\":1,\"816\":1,\"832\":1,\"857\":1,\"872\":2}}],[\"bound\",{\"1\":{\"113\":1,\"122\":1,\"126\":1,\"213\":1,\"214\":1,\"225\":1,\"233\":1,\"236\":3,\"237\":3,\"258\":1,\"298\":2,\"310\":1,\"312\":2,\"313\":2,\"331\":2,\"457\":1,\"462\":1}}],[\"borrow\",{\"1\":{\"3\":4}}],[\"b\",{\"0\":{\"189\":1,\"334\":1,\"346\":1,\"355\":1,\"398\":1,\"514\":1,\"532\":1,\"552\":1,\"570\":1,\"584\":1,\"597\":1,\"610\":1,\"628\":1,\"641\":1,\"654\":1,\"667\":1,\"680\":1,\"693\":1,\"706\":1,\"719\":1,\"735\":1,\"745\":1,\"811\":1,\"824\":1,\"837\":1,\"852\":1,\"865\":1,\"880\":1,\"893\":1},\"1\":{\"3\":71,\"7\":3,\"8\":3,\"40\":6,\"63\":7,\"64\":13,\"66\":6,\"77\":1,\"78\":1,\"79\":1,\"80\":1,\"83\":3,\"99\":3,\"117\":1,\"120\":4,\"122\":8,\"123\":7,\"124\":4,\"125\":5,\"126\":8,\"128\":4,\"129\":12,\"141\":6,\"144\":3,\"146\":11,\"147\":6,\"148\":3,\"150\":3,\"151\":3,\"154\":13,\"156\":1,\"157\":1,\"164\":4,\"175\":4,\"179\":9,\"181\":6,\"186\":4,\"188\":10,\"191\":2,\"198\":2,\"202\":2,\"203\":2,\"204\":2,\"218\":3,\"221\":5,\"222\":5,\"224\":3,\"225\":3,\"226\":3,\"233\":15,\"241\":9,\"242\":6,\"250\":10,\"260\":3,\"262\":11,\"263\":11,\"264\":11,\"265\":13,\"267\":12,\"275\":6,\"282\":4,\"283\":4,\"284\":4,\"289\":6,\"299\":3,\"305\":6,\"312\":2,\"313\":2,\"325\":5,\"333\":4,\"343\":9,\"356\":3,\"377\":10,\"388\":6,\"389\":10,\"395\":4,\"402\":5,\"403\":2,\"405\":9,\"413\":16,\"419\":6,\"425\":4,\"431\":7,\"435\":5,\"436\":4,\"437\":7,\"450\":6,\"456\":3,\"458\":5,\"460\":22,\"464\":2,\"465\":2,\"471\":8,\"473\":4,\"475\":6,\"477\":4,\"483\":5,\"488\":6,\"489\":4,\"490\":4,\"494\":5,\"499\":4,\"508\":2,\"513\":17,\"519\":4,\"522\":2,\"525\":3,\"527\":5,\"530\":3,\"531\":7,\"535\":3,\"539\":4,\"541\":1,\"542\":1,\"544\":5,\"562\":4,\"563\":4,\"569\":6,\"579\":3,\"583\":3,\"596\":3,\"609\":6,\"612\":3,\"622\":16,\"623\":6,\"632\":1,\"633\":10,\"640\":3,\"653\":5,\"656\":7,\"662\":2,\"668\":2,\"669\":3,\"672\":7,\"679\":9,\"685\":11,\"691\":1,\"692\":2,\"708\":4,\"721\":7,\"731\":4,\"751\":3,\"760\":2,\"772\":1,\"773\":3,\"777\":4,\"790\":5,\"799\":2,\"806\":3,\"826\":3,\"892\":3}}],[\"<x\",{\"1\":{\"636\":1}}],[\"<ctime>\",{\"1\":{\"551\":1}}],[\"<cmath>\",{\"1\":{\"477\":1}}],[\"<cstdio>\",{\"1\":{\"89\":1}}],[\"<数字\",{\"1\":{\"343\":1}}],[\"<维生素量\",{\"1\":{\"340\":1}}],[\"<i\",{\"1\":{\"258\":1}}],[\"<iostream>\",{\"1\":{\"188\":1,\"740\":1,\"742\":1}}],[\"<深度\",{\"1\":{\"13\":1}}],[\"<bits\",{\"1\":{\"11\":1,\"12\":1,\"13\":1,\"14\":1,\"15\":1,\"17\":1,\"19\":1,\"20\":1,\"21\":1,\"23\":1,\"27\":1,\"29\":1,\"30\":1,\"31\":1,\"32\":1,\"40\":1,\"46\":1,\"48\":1,\"49\":1,\"50\":1,\"52\":1,\"53\":1,\"54\":1,\"57\":1,\"59\":1,\"60\":1,\"61\":1,\"63\":3,\"64\":1,\"66\":1,\"70\":1,\"74\":1,\"89\":1,\"90\":1,\"109\":1,\"110\":1,\"111\":1,\"112\":1,\"113\":1,\"115\":1,\"116\":1,\"117\":1,\"118\":1,\"119\":1,\"120\":1,\"122\":1,\"123\":1,\"124\":1,\"125\":1,\"126\":1,\"127\":1,\"128\":1,\"129\":1,\"131\":1,\"132\":1,\"134\":1,\"135\":1,\"136\":1,\"137\":1,\"141\":1,\"142\":1,\"144\":1,\"146\":1,\"147\":1,\"148\":1,\"150\":1,\"151\":1,\"153\":1,\"154\":1,\"156\":1,\"157\":1,\"158\":1,\"160\":1,\"161\":1,\"162\":1,\"163\":1,\"164\":1,\"165\":1,\"166\":1,\"167\":1,\"168\":1,\"169\":1,\"170\":1,\"172\":1,\"173\":1,\"174\":1,\"175\":1,\"176\":1,\"177\":1,\"178\":1,\"179\":1,\"180\":1,\"181\":2,\"182\":2,\"184\":1,\"185\":1,\"186\":1,\"187\":1,\"190\":1,\"191\":1,\"192\":1,\"193\":4,\"194\":1,\"195\":2,\"196\":5,\"197\":4,\"198\":3,\"199\":4,\"200\":1,\"202\":1,\"203\":1,\"204\":1,\"205\":2,\"208\":2,\"209\":1,\"210\":1,\"211\":1,\"213\":1,\"214\":1,\"215\":1,\"216\":2,\"217\":1,\"218\":1,\"219\":2,\"221\":1,\"222\":1,\"224\":1,\"225\":1,\"226\":1,\"227\":1,\"228\":1,\"230\":1,\"231\":1,\"232\":1,\"233\":2,\"235\":1,\"236\":1,\"237\":1,\"239\":1,\"242\":1,\"243\":1,\"244\":2,\"245\":1,\"246\":1,\"248\":1,\"249\":1,\"250\":2,\"251\":1,\"253\":1,\"255\":1,\"256\":1,\"257\":1,\"258\":1,\"259\":1,\"260\":1,\"262\":1,\"263\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":2,\"268\":1,\"269\":1,\"270\":1,\"272\":1,\"273\":1,\"274\":1,\"275\":2,\"276\":2,\"278\":1,\"279\":1,\"280\":1,\"282\":1,\"283\":1,\"284\":1,\"285\":1,\"286\":2,\"287\":1,\"288\":1,\"289\":2,\"291\":1,\"292\":1,\"293\":1,\"295\":1,\"298\":2,\"299\":1,\"301\":1,\"302\":1,\"303\":1,\"305\":1,\"306\":1,\"307\":2,\"309\":1,\"310\":1,\"312\":1,\"313\":2,\"314\":1,\"317\":1,\"318\":1,\"319\":1,\"320\":3,\"323\":1,\"324\":1,\"325\":1,\"326\":1,\"329\":1,\"331\":1,\"333\":1,\"334\":1,\"335\":1,\"336\":1,\"338\":1,\"340\":1,\"342\":1,\"343\":1,\"345\":1,\"347\":1,\"348\":1,\"349\":1,\"350\":1,\"351\":1,\"352\":1,\"354\":1,\"355\":1,\"356\":1,\"358\":1,\"359\":1,\"361\":1,\"362\":1,\"363\":1,\"365\":1,\"366\":1,\"367\":1,\"368\":1,\"369\":1,\"370\":1,\"371\":1,\"372\":1,\"373\":1,\"374\":1,\"375\":1,\"376\":1,\"377\":1,\"378\":1,\"379\":1,\"380\":1,\"381\":1,\"383\":1,\"384\":1,\"386\":1,\"388\":1,\"389\":1,\"391\":1,\"392\":1,\"393\":1,\"394\":1,\"395\":1,\"397\":1,\"399\":1,\"400\":1,\"402\":2,\"405\":1,\"410\":1,\"412\":1,\"413\":2,\"414\":1,\"415\":4,\"417\":1,\"418\":1,\"419\":1,\"421\":1,\"422\":1,\"423\":1,\"425\":1,\"426\":1,\"427\":1,\"428\":1,\"430\":1,\"431\":1,\"432\":1,\"433\":1,\"435\":1,\"436\":2,\"437\":1,\"438\":1,\"440\":1,\"441\":1,\"443\":1,\"444\":1,\"446\":1,\"447\":1,\"448\":1,\"450\":1,\"451\":1,\"452\":1,\"453\":1,\"455\":1,\"456\":1,\"457\":1,\"458\":1,\"460\":1,\"461\":1,\"462\":1,\"464\":1,\"465\":1,\"466\":1,\"467\":1,\"469\":1,\"470\":1,\"471\":1,\"473\":1,\"475\":1,\"477\":1,\"478\":1,\"479\":1,\"480\":1,\"482\":1,\"483\":1,\"484\":2,\"485\":1,\"487\":1,\"488\":1,\"489\":1,\"490\":1,\"492\":1,\"493\":1,\"494\":1,\"495\":1,\"497\":1,\"498\":1,\"499\":1,\"500\":1,\"502\":1,\"503\":1,\"504\":1,\"505\":1,\"509\":2,\"513\":1,\"516\":1,\"519\":1,\"522\":1,\"531\":1,\"534\":1,\"535\":1,\"538\":1,\"542\":1,\"551\":1,\"554\":1,\"557\":1,\"560\":1,\"569\":1,\"572\":1,\"579\":1,\"583\":1,\"586\":1,\"589\":1,\"592\":1,\"596\":1,\"599\":1,\"602\":1,\"605\":1,\"609\":1,\"612\":1,\"615\":1,\"618\":1,\"622\":1,\"627\":1,\"630\":1,\"633\":1,\"636\":1,\"640\":1,\"643\":1,\"646\":1,\"649\":1,\"653\":1,\"656\":1,\"659\":1,\"662\":1,\"666\":1,\"669\":1,\"672\":1,\"675\":1,\"679\":1,\"682\":1,\"685\":1,\"688\":1,\"692\":1,\"695\":1,\"698\":1,\"701\":1,\"705\":1,\"708\":1,\"711\":1,\"714\":1,\"718\":1,\"721\":1,\"724\":1,\"727\":1,\"729\":1,\"730\":1,\"731\":1,\"732\":1,\"734\":1,\"735\":1,\"736\":1,\"737\":1,\"739\":1,\"741\":1,\"744\":1,\"745\":1,\"746\":1,\"747\":1,\"751\":1,\"754\":1,\"757\":1,\"760\":1,\"764\":1,\"767\":1,\"770\":1,\"773\":1,\"777\":1,\"780\":1,\"783\":1,\"786\":1,\"790\":1,\"793\":1,\"796\":1,\"799\":1,\"801\":1,\"803\":1,\"805\":1,\"806\":1,\"810\":1,\"813\":1,\"816\":1,\"819\":1,\"823\":1,\"826\":1,\"829\":1,\"832\":1,\"836\":1,\"839\":1,\"844\":1,\"847\":1,\"851\":1,\"854\":1,\"857\":1,\"860\":1,\"864\":1,\"868\":1,\"869\":1,\"872\":1,\"875\":1,\"879\":1,\"882\":1,\"885\":1,\"888\":1,\"892\":1,\"895\":1,\"898\":1,\"907\":1}}],[\"<<a\",{\"1\":{\"636\":2}}],[\"<<b<<endl\",{\"1\":{\"633\":2}}],[\"<<r\",{\"1\":{\"621\":1}}],[\"<<n\",{\"1\":{\"620\":1}}],[\"<<nxtt\",{\"1\":{\"321\":1}}],[\"<<1<<\",{\"1\":{\"620\":1}}],[\"<<char\",{\"1\":{\"507\":1}}],[\"<<endl\",{\"1\":{\"321\":2,\"636\":1,\"902\":1}}],[\"<<pret\",{\"1\":{\"321\":1}}],[\"<<points\",{\"1\":{\"241\":1}}],[\"<<tail\",{\"1\":{\"321\":1}}],[\"<<head\",{\"1\":{\"321\":1}}],[\"<<l\",{\"1\":{\"241\":2}}],[\"<<\",{\"1\":{\"5\":1,\"7\":1,\"8\":1,\"11\":2,\"12\":4,\"13\":6,\"14\":2,\"15\":2,\"17\":2,\"19\":2,\"20\":2,\"21\":2,\"23\":2,\"24\":2,\"27\":2,\"29\":2,\"30\":2,\"31\":2,\"32\":2,\"38\":1,\"40\":5,\"46\":1,\"48\":1,\"50\":3,\"52\":3,\"53\":3,\"54\":1,\"57\":8,\"59\":2,\"60\":2,\"61\":2,\"63\":8,\"64\":2,\"66\":4,\"70\":4,\"74\":4,\"76\":2,\"77\":3,\"78\":3,\"79\":2,\"80\":2,\"90\":3,\"109\":8,\"110\":8,\"111\":12,\"112\":1,\"113\":1,\"115\":4,\"116\":4,\"117\":1,\"118\":1,\"119\":1,\"120\":1,\"122\":2,\"123\":2,\"124\":1,\"125\":5,\"126\":2,\"127\":2,\"128\":8,\"129\":11,\"131\":2,\"132\":2,\"134\":1,\"135\":2,\"136\":2,\"137\":2,\"139\":4,\"140\":4,\"141\":1,\"142\":2,\"144\":1,\"146\":1,\"147\":1,\"148\":2,\"150\":2,\"151\":2,\"153\":6,\"154\":1,\"156\":1,\"157\":1,\"158\":5,\"160\":2,\"161\":2,\"162\":33,\"163\":6,\"164\":6,\"165\":20,\"166\":1,\"167\":2,\"168\":6,\"169\":1,\"170\":10,\"172\":12,\"173\":12,\"174\":10,\"175\":1,\"176\":1,\"177\":1,\"178\":14,\"179\":2,\"180\":1,\"181\":6,\"182\":2,\"184\":3,\"185\":3,\"186\":3,\"187\":2,\"188\":5,\"190\":1,\"191\":2,\"192\":14,\"193\":4,\"194\":2,\"195\":13,\"196\":14,\"197\":4,\"198\":16,\"199\":9,\"200\":2,\"202\":2,\"203\":5,\"204\":2,\"205\":6,\"208\":4,\"209\":4,\"210\":2,\"211\":4,\"213\":4,\"214\":6,\"215\":2,\"216\":4,\"217\":5,\"218\":3,\"219\":12,\"221\":3,\"222\":4,\"224\":2,\"225\":2,\"226\":2,\"227\":3,\"228\":2,\"230\":1,\"231\":1,\"232\":2,\"233\":4,\"235\":4,\"236\":4,\"237\":4,\"239\":4,\"241\":8,\"242\":6,\"243\":2,\"244\":6,\"245\":2,\"246\":4,\"248\":9,\"249\":3,\"250\":2,\"251\":1,\"253\":1,\"255\":1,\"256\":1,\"257\":5,\"258\":1,\"259\":1,\"260\":6,\"262\":8,\"263\":8,\"264\":8,\"265\":23,\"266\":2,\"267\":4,\"268\":18,\"269\":3,\"270\":3,\"272\":3,\"273\":2,\"274\":2,\"275\":8,\"276\":9,\"278\":1,\"279\":1,\"280\":9,\"282\":10,\"283\":4,\"284\":4,\"285\":5,\"286\":2,\"287\":2,\"288\":2,\"289\":4,\"291\":2,\"292\":2,\"293\":1,\"295\":2,\"298\":4,\"299\":3,\"301\":1,\"302\":1,\"303\":2,\"305\":1,\"306\":17,\"307\":4,\"309\":4,\"310\":6,\"312\":2,\"313\":3,\"314\":1,\"317\":2,\"318\":2,\"319\":4,\"320\":3,\"321\":4,\"323\":2,\"324\":3,\"325\":2,\"326\":2,\"329\":2,\"331\":5,\"333\":1,\"334\":1,\"335\":2,\"336\":1,\"338\":1,\"340\":1,\"342\":2,\"343\":2,\"345\":2,\"347\":5,\"348\":4,\"349\":4,\"350\":1,\"351\":2,\"352\":4,\"354\":1,\"355\":1,\"356\":1,\"358\":1,\"359\":1,\"361\":1,\"362\":1,\"363\":1,\"365\":1,\"366\":1,\"367\":1,\"368\":3,\"369\":3,\"370\":2,\"371\":1,\"372\":1,\"373\":1,\"374\":6,\"375\":1,\"376\":1,\"377\":2,\"378\":1,\"379\":1,\"380\":1,\"381\":7,\"383\":2,\"384\":2,\"386\":5,\"388\":4,\"389\":4,\"391\":2,\"392\":2,\"393\":2,\"394\":4,\"395\":1,\"397\":3,\"399\":1,\"400\":1,\"402\":2,\"405\":1,\"410\":10,\"412\":1,\"413\":16,\"414\":2,\"415\":4,\"417\":3,\"418\":3,\"419\":1,\"421\":4,\"422\":4,\"423\":4,\"425\":1,\"426\":34,\"427\":1,\"428\":2,\"430\":3,\"431\":1,\"432\":2,\"433\":1,\"435\":1,\"436\":2,\"437\":1,\"438\":3,\"440\":1,\"441\":1,\"443\":1,\"444\":18,\"446\":8,\"447\":8,\"448\":11,\"450\":3,\"451\":2,\"452\":4,\"453\":2,\"455\":1,\"456\":2,\"457\":1,\"458\":3,\"460\":1,\"461\":8,\"462\":1,\"464\":1,\"465\":1,\"466\":1,\"467\":1,\"469\":1,\"470\":5,\"471\":11,\"473\":11,\"475\":2,\"477\":3,\"478\":1,\"479\":1,\"480\":28,\"482\":3,\"483\":2,\"484\":4,\"485\":1,\"487\":1,\"488\":6,\"489\":2,\"490\":4,\"492\":2,\"493\":1,\"494\":1,\"495\":1,\"497\":2,\"498\":1,\"499\":1,\"500\":1,\"502\":6,\"503\":2,\"504\":2,\"505\":2,\"513\":5,\"516\":17,\"519\":5,\"522\":6,\"524\":2,\"525\":4,\"526\":4,\"531\":7,\"534\":5,\"535\":1,\"538\":6,\"542\":2,\"544\":1,\"547\":4,\"551\":2,\"554\":1,\"557\":3,\"560\":2,\"562\":4,\"563\":6,\"564\":4,\"565\":6,\"569\":2,\"572\":6,\"579\":1,\"583\":2,\"586\":1,\"589\":2,\"592\":1,\"596\":1,\"599\":10,\"602\":3,\"605\":1,\"609\":1,\"612\":8,\"615\":1,\"618\":1,\"622\":7,\"627\":2,\"630\":1,\"636\":3,\"640\":8,\"643\":1,\"646\":6,\"649\":1,\"653\":9,\"656\":30,\"659\":2,\"662\":2,\"666\":5,\"669\":1,\"672\":5,\"675\":7,\"679\":6,\"682\":1,\"685\":5,\"688\":2,\"692\":3,\"695\":1,\"698\":6,\"701\":1,\"705\":1,\"708\":1,\"711\":2,\"714\":2,\"718\":1,\"721\":1,\"724\":3,\"727\":4,\"729\":1,\"730\":1,\"731\":24,\"732\":1,\"734\":2,\"735\":1,\"736\":3,\"737\":12,\"741\":2,\"744\":1,\"745\":1,\"746\":2,\"747\":2,\"751\":12,\"754\":4,\"757\":1,\"760\":1,\"764\":2,\"767\":4,\"770\":1,\"773\":2,\"777\":4,\"780\":1,\"783\":1,\"786\":1,\"790\":4,\"793\":4,\"796\":9,\"799\":1,\"801\":2,\"803\":1,\"805\":1,\"806\":4,\"810\":2,\"813\":2,\"819\":2,\"823\":4,\"826\":2,\"829\":2,\"832\":2,\"836\":4,\"839\":2,\"844\":2,\"847\":2,\"851\":3,\"854\":2,\"857\":2,\"860\":1,\"864\":1,\"868\":1,\"869\":1,\"872\":10,\"875\":2,\"879\":2,\"882\":1,\"885\":2,\"888\":1,\"892\":3,\"895\":1,\"898\":1,\"902\":1,\"907\":3}}],[\"<=10\",{\"1\":{\"575\":2}}],[\"<=\",{\"1\":{\"5\":1,\"11\":3,\"12\":3,\"13\":2,\"14\":4,\"15\":1,\"17\":6,\"18\":2,\"19\":7,\"20\":7,\"21\":10,\"23\":7,\"27\":4,\"29\":4,\"30\":3,\"31\":4,\"32\":3,\"72\":1,\"79\":2,\"80\":2,\"81\":1,\"109\":3,\"110\":3,\"112\":3,\"113\":3,\"115\":3,\"116\":4,\"117\":4,\"118\":2,\"119\":3,\"120\":4,\"122\":6,\"123\":6,\"124\":4,\"125\":4,\"126\":7,\"127\":2,\"128\":3,\"134\":1,\"135\":1,\"136\":1,\"137\":3,\"139\":2,\"140\":2,\"141\":5,\"144\":4,\"146\":8,\"147\":8,\"148\":4,\"150\":6,\"151\":6,\"153\":1,\"154\":9,\"156\":5,\"157\":5,\"158\":16,\"160\":3,\"161\":3,\"162\":15,\"163\":6,\"164\":10,\"165\":2,\"166\":12,\"167\":2,\"168\":3,\"169\":5,\"170\":2,\"173\":8,\"174\":3,\"175\":6,\"176\":4,\"177\":6,\"178\":6,\"179\":2,\"180\":2,\"181\":9,\"182\":15,\"184\":2,\"185\":3,\"186\":3,\"188\":18,\"190\":2,\"191\":3,\"192\":3,\"193\":9,\"194\":8,\"195\":3,\"196\":39,\"197\":13,\"198\":19,\"199\":12,\"200\":5,\"202\":2,\"203\":3,\"204\":9,\"205\":4,\"208\":5,\"209\":2,\"210\":4,\"211\":3,\"213\":6,\"214\":5,\"215\":5,\"216\":12,\"217\":4,\"218\":4,\"219\":9,\"221\":4,\"222\":4,\"224\":4,\"225\":3,\"226\":4,\"227\":5,\"228\":2,\"230\":5,\"231\":10,\"232\":5,\"233\":12,\"235\":1,\"236\":2,\"237\":7,\"239\":6,\"241\":17,\"242\":15,\"243\":3,\"244\":4,\"245\":2,\"246\":5,\"248\":12,\"249\":5,\"250\":5,\"251\":3,\"253\":2,\"257\":4,\"258\":5,\"259\":14,\"260\":8,\"262\":21,\"263\":3,\"264\":3,\"265\":2,\"266\":5,\"267\":8,\"268\":2,\"269\":1,\"270\":4,\"272\":2,\"273\":1,\"274\":3,\"275\":6,\"276\":10,\"278\":3,\"279\":3,\"280\":6,\"285\":7,\"286\":6,\"287\":5,\"288\":3,\"289\":14,\"291\":6,\"292\":5,\"293\":5,\"295\":7,\"298\":5,\"299\":8,\"301\":2,\"302\":4,\"303\":2,\"305\":2,\"306\":8,\"307\":9,\"310\":1,\"312\":5,\"313\":10,\"314\":5,\"317\":4,\"318\":6,\"319\":3,\"320\":15,\"323\":2,\"324\":2,\"325\":3,\"326\":1,\"329\":4,\"331\":4,\"334\":2,\"335\":6,\"336\":2,\"340\":8,\"342\":4,\"343\":1,\"345\":1,\"347\":3,\"348\":3,\"349\":2,\"350\":3,\"351\":2,\"352\":1,\"354\":2,\"355\":2,\"356\":2,\"358\":2,\"359\":4,\"361\":6,\"362\":4,\"363\":2,\"365\":3,\"366\":3,\"367\":4,\"368\":4,\"369\":4,\"370\":3,\"371\":3,\"372\":5,\"373\":5,\"374\":5,\"375\":1,\"376\":5,\"377\":8,\"378\":1,\"379\":5,\"380\":4,\"381\":5,\"383\":2,\"384\":2,\"386\":5,\"391\":2,\"392\":3,\"393\":3,\"394\":2,\"395\":1,\"397\":1,\"399\":3,\"400\":1,\"402\":1,\"405\":1,\"410\":7,\"412\":3,\"413\":3,\"414\":3,\"415\":10,\"417\":1,\"418\":4,\"419\":4,\"421\":3,\"422\":3,\"423\":4,\"425\":3,\"426\":5,\"427\":4,\"428\":4,\"430\":6,\"432\":2,\"433\":1,\"436\":4,\"437\":2,\"438\":6,\"441\":1,\"443\":21,\"444\":20,\"446\":1,\"447\":2,\"450\":1,\"451\":3,\"455\":2,\"456\":3,\"457\":3,\"458\":3,\"461\":4,\"462\":4,\"464\":3,\"465\":3,\"466\":3,\"467\":3,\"470\":3,\"473\":5,\"475\":5,\"478\":1,\"479\":4,\"480\":7,\"484\":4,\"485\":4,\"488\":5,\"490\":8,\"492\":4,\"493\":3,\"494\":2,\"495\":3,\"497\":1,\"498\":8,\"499\":6,\"500\":5,\"503\":1,\"505\":6,\"516\":2,\"519\":1,\"522\":3,\"525\":1,\"527\":2,\"534\":1,\"538\":2,\"539\":5,\"546\":1,\"554\":1,\"557\":3,\"560\":4,\"575\":5,\"576\":4,\"579\":1,\"586\":2,\"589\":1,\"592\":1,\"599\":3,\"605\":6,\"612\":3,\"615\":3,\"618\":1,\"627\":1,\"643\":1,\"649\":7,\"659\":1,\"669\":1,\"675\":6,\"688\":8,\"695\":2,\"701\":6,\"705\":2,\"708\":4,\"711\":3,\"714\":1,\"721\":1,\"724\":2,\"727\":4,\"729\":1,\"730\":1,\"732\":7,\"735\":2,\"737\":3,\"746\":1,\"747\":3,\"754\":2,\"757\":1,\"760\":2,\"767\":5,\"770\":3,\"772\":1,\"773\":3,\"777\":2,\"783\":1,\"786\":3,\"793\":1,\"796\":6,\"799\":7,\"803\":2,\"806\":2,\"809\":3,\"812\":3,\"813\":1,\"819\":2,\"826\":1,\"832\":4,\"836\":3,\"839\":3,\"847\":1,\"860\":3,\"868\":1,\"869\":1,\"872\":2,\"875\":9,\"882\":1,\"888\":3,\"895\":1,\"898\":2}}],[\"<\",{\"1\":{\"3\":17,\"11\":1,\"12\":2,\"13\":5,\"14\":2,\"15\":2,\"18\":2,\"27\":1,\"30\":1,\"40\":3,\"72\":1,\"78\":2,\"80\":1,\"81\":1,\"109\":1,\"110\":1,\"112\":1,\"115\":1,\"117\":1,\"118\":2,\"119\":4,\"126\":1,\"127\":7,\"129\":1,\"141\":1,\"142\":4,\"146\":1,\"147\":1,\"150\":1,\"151\":2,\"153\":5,\"154\":1,\"156\":1,\"157\":2,\"158\":2,\"160\":2,\"161\":2,\"163\":1,\"164\":1,\"165\":4,\"166\":1,\"167\":3,\"168\":7,\"172\":4,\"173\":1,\"174\":1,\"178\":1,\"179\":3,\"180\":1,\"182\":1,\"184\":1,\"185\":1,\"186\":1,\"187\":6,\"188\":2,\"190\":2,\"191\":2,\"192\":7,\"193\":2,\"196\":2,\"197\":3,\"198\":5,\"199\":4,\"200\":2,\"202\":1,\"203\":4,\"204\":2,\"209\":1,\"211\":1,\"215\":2,\"226\":1,\"228\":1,\"241\":5,\"242\":5,\"244\":2,\"246\":3,\"250\":2,\"253\":1,\"256\":2,\"257\":1,\"259\":1,\"260\":1,\"262\":2,\"263\":3,\"264\":2,\"266\":1,\"267\":3,\"268\":3,\"269\":2,\"273\":1,\"274\":2,\"275\":6,\"276\":1,\"282\":5,\"283\":4,\"284\":3,\"285\":4,\"286\":4,\"288\":1,\"289\":2,\"295\":1,\"298\":1,\"305\":5,\"309\":1,\"312\":1,\"313\":3,\"314\":2,\"319\":1,\"320\":2,\"335\":1,\"336\":6,\"338\":1,\"340\":2,\"343\":1,\"352\":1,\"361\":1,\"378\":2,\"383\":2,\"384\":4,\"395\":2,\"399\":1,\"402\":2,\"410\":1,\"413\":3,\"417\":2,\"421\":3,\"422\":3,\"423\":3,\"431\":1,\"432\":1,\"433\":1,\"435\":2,\"436\":2,\"438\":4,\"440\":1,\"453\":2,\"461\":3,\"462\":2,\"475\":1,\"477\":1,\"478\":2,\"479\":1,\"480\":3,\"482\":2,\"484\":2,\"499\":2,\"504\":2,\"513\":1,\"516\":4,\"519\":3,\"522\":1,\"526\":4,\"527\":3,\"531\":4,\"538\":2,\"539\":1,\"542\":1,\"557\":2,\"563\":1,\"565\":2,\"575\":9,\"579\":2,\"583\":2,\"602\":1,\"605\":1,\"618\":1,\"622\":4,\"646\":2,\"666\":2,\"672\":3,\"685\":3,\"705\":3,\"729\":1,\"732\":2,\"736\":2,\"746\":3,\"747\":1,\"759\":1,\"770\":1,\"786\":2,\"796\":1,\"805\":4,\"819\":1,\"829\":1,\"851\":1,\"857\":1,\"864\":9,\"872\":2,\"875\":5,\"885\":1,\"892\":2}}],[\"sb\",{\"1\":{\"633\":3}}],[\"spj\",{\"1\":{\"565\":1}}],[\"special\",{\"1\":{\"551\":1}}],[\"sprintf\",{\"1\":{\"3\":1}}],[\"s++\",{\"1\":{\"539\":2,\"575\":2}}],[\"s+\",{\"1\":{\"507\":1}}],[\"s=z\",{\"1\":{\"507\":1}}],[\"sa\",{\"1\":{\"633\":3}}],[\"same\",{\"1\":{\"508\":1,\"622\":2,\"672\":1,\"685\":1}}],[\"save\",{\"1\":{\"453\":2}}],[\"santa\",{\"0\":{\"331\":1}}],[\"smax\",{\"1\":{\"448\":10}}],[\"small\",{\"1\":{\"210\":12}}],[\"sheng\",{\"1\":{\"493\":2}}],[\"shun\",{\"1\":{\"500\":2}}],[\"shui\",{\"1\":{\"450\":2}}],[\"shu\",{\"1\":{\"435\":2}}],[\"shang\",{\"1\":{\"433\":2}}],[\"show\",{\"0\":{\"293\":1}}],[\"showfunc\",{\"1\":{\"158\":1}}],[\"sk\",{\"1\":{\"378\":4}}],[\"skyscraper\",{\"0\":{\"277\":1}}],[\"slimes\",{\"0\":{\"373\":1}}],[\"squares\",{\"0\":{\"338\":1}}],[\"sqrt\",{\"1\":{\"11\":1,\"129\":2,\"198\":1,\"291\":1,\"292\":1,\"478\":2,\"551\":1,\"793\":1}}],[\"snaky\",{\"0\":{\"336\":1}}],[\"snake\",{\"0\":{\"335\":1}}],[\"snum\",{\"1\":{\"246\":2}}],[\"sy\",{\"1\":{\"331\":11,\"336\":4}}],[\"sync\",{\"1\":{\"11\":1,\"12\":1,\"13\":1,\"14\":1,\"15\":1,\"17\":1,\"19\":1,\"20\":1,\"21\":1,\"23\":1,\"109\":1,\"110\":1,\"111\":1,\"112\":1,\"113\":1,\"115\":1,\"116\":1,\"117\":1,\"120\":1,\"122\":1,\"123\":1,\"124\":1,\"125\":1,\"126\":1,\"127\":1,\"128\":1,\"137\":1,\"141\":1,\"142\":1,\"144\":1,\"146\":1,\"147\":1,\"148\":1,\"154\":1,\"158\":1,\"163\":1,\"164\":1,\"165\":1,\"166\":1,\"167\":1,\"168\":1,\"169\":1,\"170\":1,\"175\":1,\"176\":1,\"177\":1,\"178\":1,\"179\":1,\"180\":1,\"181\":2,\"182\":2,\"184\":1,\"185\":1,\"186\":1,\"187\":1,\"190\":1,\"192\":1,\"193\":4,\"195\":2,\"196\":5,\"197\":4,\"198\":3,\"199\":4,\"202\":1,\"203\":1,\"204\":1,\"205\":2,\"208\":2,\"209\":1,\"210\":1,\"211\":1,\"213\":1,\"214\":1,\"215\":1,\"216\":2,\"217\":1,\"218\":1,\"219\":2,\"221\":1,\"222\":1,\"224\":1,\"225\":1,\"226\":1,\"227\":1,\"228\":1,\"230\":1,\"231\":1,\"232\":1,\"233\":2,\"235\":1,\"236\":1,\"237\":1,\"239\":1,\"242\":1,\"244\":2,\"245\":1,\"246\":1,\"248\":1,\"249\":1,\"250\":2,\"253\":1,\"255\":1,\"256\":1,\"257\":1,\"258\":1,\"259\":1,\"260\":1,\"265\":1,\"266\":1,\"267\":2,\"268\":1,\"270\":1,\"272\":1,\"273\":1,\"274\":1,\"275\":2,\"276\":2,\"278\":1,\"279\":1,\"280\":1,\"282\":1,\"283\":1,\"284\":1,\"285\":1,\"286\":2,\"287\":1,\"288\":1,\"291\":1,\"292\":1,\"293\":1,\"295\":1,\"298\":2,\"299\":1,\"301\":1,\"302\":1,\"303\":1,\"306\":1,\"307\":1,\"309\":1,\"310\":1,\"312\":1,\"313\":2,\"314\":1,\"317\":1,\"318\":1,\"319\":1,\"320\":3,\"321\":1,\"331\":1,\"333\":1,\"334\":1,\"335\":1,\"336\":1,\"338\":1,\"340\":1,\"345\":1,\"347\":1,\"348\":1,\"349\":1,\"350\":1,\"351\":1,\"352\":1,\"354\":1,\"355\":1,\"356\":1,\"358\":1,\"359\":1,\"361\":1,\"362\":1,\"363\":1,\"365\":1,\"366\":1,\"367\":1,\"368\":1,\"369\":1,\"370\":1,\"371\":1,\"372\":1,\"373\":1,\"374\":1,\"375\":1,\"376\":1,\"377\":1,\"381\":1,\"383\":1,\"384\":1,\"386\":1,\"388\":1,\"389\":1,\"391\":1,\"392\":1,\"393\":1,\"394\":1,\"395\":1,\"399\":1,\"400\":1,\"402\":2,\"405\":1,\"410\":1,\"412\":1,\"413\":2,\"414\":1,\"417\":1,\"418\":1,\"419\":1,\"421\":1,\"422\":1,\"423\":1,\"425\":1,\"426\":1,\"427\":1,\"428\":1,\"443\":1,\"444\":1,\"445\":2,\"446\":1,\"447\":1,\"458\":1,\"460\":1,\"461\":1,\"475\":1,\"542\":1,\"560\":1,\"596\":1,\"599\":1,\"602\":1,\"605\":1,\"729\":1,\"730\":1,\"731\":1,\"732\":1,\"734\":1,\"735\":1,\"736\":1,\"737\":1,\"741\":1,\"790\":1,\"793\":1,\"796\":1,\"799\":1,\"819\":1,\"906\":1}}],[\"sx\",{\"1\":{\"331\":11,\"336\":4}}],[\"solved\",{\"1\":{\"872\":8}}],[\"solution\",{\"1\":{\"285\":1,\"295\":1}}],[\"son\",{\"1\":{\"319\":17}}],[\"sorting\",{\"0\":{\"142\":1}}],[\"sort\",{\"1\":{\"128\":1,\"150\":1,\"151\":2,\"163\":1,\"172\":4,\"181\":2,\"182\":1,\"191\":1,\"193\":1,\"197\":2,\"198\":1,\"202\":1,\"203\":1,\"204\":1,\"208\":2,\"213\":1,\"214\":1,\"241\":2,\"246\":1,\"258\":1,\"298\":2,\"307\":1,\"312\":2,\"313\":3,\"314\":1,\"325\":2,\"347\":1,\"349\":1,\"392\":1,\"410\":1,\"417\":1,\"418\":1,\"426\":2,\"430\":1,\"438\":1,\"441\":1,\"455\":1,\"456\":1,\"457\":1,\"485\":1,\"519\":1,\"522\":2,\"589\":1,\"623\":3,\"675\":1,\"688\":2,\"732\":1,\"759\":3,\"760\":1,\"799\":1,\"872\":1,\"898\":1}}],[\"s2019\",{\"0\":{\"315\":1}}],[\"s2\",{\"1\":{\"282\":7,\"283\":6,\"284\":9,\"902\":2}}],[\"s2col\",{\"1\":{\"187\":5}}],[\"s1\",{\"1\":{\"282\":3,\"283\":4,\"284\":5,\"902\":2}}],[\"sdoi2009\",{\"0\":{\"266\":1}}],[\"sdoi2011\",{\"0\":{\"166\":1}}],[\"school\",{\"1\":{\"872\":5}}],[\"scccnt\",{\"1\":{\"444\":3}}],[\"scc\",{\"1\":{\"444\":5}}],[\"scoi2009\",{\"0\":{\"273\":1}}],[\"scoi2005\",{\"0\":{\"252\":1}}],[\"score\",{\"1\":{\"182\":11,\"456\":14,\"492\":19}}],[\"scanf\",{\"1\":{\"83\":1,\"527\":4}}],[\"sss\",{\"1\":{\"576\":2}}],[\"sstr\",{\"1\":{\"246\":2}}],[\"ss\",{\"1\":{\"156\":4,\"157\":6,\"160\":9,\"161\":3,\"265\":9,\"527\":4,\"575\":30,\"576\":11}}],[\"swp\",{\"1\":{\"737\":1}}],[\"switch\",{\"0\":{\"294\":1},\"1\":{\"40\":1}}],[\"swap\",{\"1\":{\"11\":1,\"12\":1,\"13\":1,\"27\":1,\"29\":1,\"30\":1,\"32\":1,\"127\":1,\"129\":1,\"158\":1,\"160\":2,\"163\":1,\"164\":2,\"173\":2,\"174\":1,\"191\":1,\"209\":1,\"211\":1,\"231\":8,\"267\":2,\"285\":1,\"291\":2,\"292\":2,\"343\":1,\"405\":1,\"483\":1,\"488\":2,\"513\":6,\"557\":1,\"609\":3,\"737\":1}}],[\"seq\",{\"1\":{\"464\":3,\"465\":5,\"466\":3,\"467\":3}}],[\"seed\",{\"1\":{\"457\":7,\"551\":4,\"760\":3,\"839\":5}}],[\"september\",{\"1\":{\"455\":1}}],[\"search\",{\"1\":{\"414\":1}}],[\"seventeen\",{\"1\":{\"246\":1}}],[\"seven\",{\"1\":{\"246\":1,\"484\":2}}],[\"seoncd\",{\"1\":{\"241\":1}}],[\"segtree\",{\"1\":{\"216\":4,\"239\":5}}],[\"se\",{\"1\":{\"193\":3}}],[\"set<string>\",{\"1\":{\"193\":1}}],[\"set<int>>\",{\"1\":{\"331\":1}}],[\"set<int>\",{\"1\":{\"137\":1,\"309\":2,\"310\":2,\"480\":1}}],[\"set\",{\"0\":{\"375\":1},\"1\":{\"158\":1,\"162\":2,\"815\":2}}],[\"setprecision\",{\"1\":{\"90\":1,\"129\":2,\"181\":1,\"205\":2,\"244\":2,\"285\":1,\"368\":1,\"369\":1,\"450\":1,\"640\":1}}],[\"setsign\",{\"1\":{\"3\":7}}],[\"second<<\",{\"1\":{\"241\":2}}],[\"second++\",{\"1\":{\"190\":1,\"438\":2}}],[\"second\",{\"1\":{\"13\":2,\"14\":1,\"125\":1,\"127\":13,\"141\":1,\"144\":2,\"160\":1,\"161\":1,\"167\":4,\"182\":4,\"190\":1,\"198\":5,\"241\":13,\"242\":4,\"246\":1,\"259\":2,\"266\":1,\"267\":2,\"276\":2,\"295\":1,\"340\":1,\"342\":1,\"343\":12,\"352\":1,\"370\":1,\"392\":1,\"410\":2,\"418\":2,\"421\":2,\"422\":2,\"423\":3,\"433\":1,\"438\":5,\"443\":1,\"508\":1,\"622\":4,\"672\":2,\"685\":2,\"727\":4}}],[\"sun<=n\",{\"1\":{\"630\":1}}],[\"sun+=275\",{\"1\":{\"630\":7}}],[\"sun+=888\",{\"1\":{\"630\":7}}],[\"sun+=150\",{\"1\":{\"630\":7}}],[\"sun\",{\"1\":{\"630\":1}}],[\"sushi\",{\"0\":{\"369\":1}}],[\"subtree\",{\"0\":{\"382\":1}}],[\"subtask\",{\"1\":{\"421\":1}}],[\"subtaskab\",{\"1\":{\"198\":2}}],[\"subtaska\",{\"1\":{\"198\":2}}],[\"subtask3\",{\"1\":{\"196\":2}}],[\"subtask2\",{\"1\":{\"196\":2}}],[\"subtask1\",{\"1\":{\"196\":2}}],[\"substr\",{\"1\":{\"3\":1}}],[\"sum>n\",{\"1\":{\"804\":1}}],[\"sum==n\",{\"1\":{\"804\":1}}],[\"sum=0\",{\"1\":{\"742\":1,\"804\":1}}],[\"sum=1\",{\"1\":{\"623\":1}}],[\"sum+=now\",{\"1\":{\"804\":1}}],[\"sum+=\",{\"1\":{\"742\":1}}],[\"sum+=p\",{\"1\":{\"623\":1}}],[\"sum++\",{\"1\":{\"250\":2,\"575\":9}}],[\"sum2++\",{\"1\":{\"563\":1}}],[\"sum2\",{\"1\":{\"563\":3}}],[\"sumeven\",{\"1\":{\"274\":4}}],[\"sumodd\",{\"1\":{\"274\":4}}],[\"sumb\",{\"1\":{\"221\":3,\"222\":3,\"513\":4}}],[\"suma\",{\"1\":{\"221\":3,\"222\":3,\"513\":4}}],[\"sumq\",{\"1\":{\"163\":6}}],[\"sumnow\",{\"1\":{\"151\":3}}],[\"sum1++\",{\"1\":{\"563\":1}}],[\"sum1\",{\"1\":{\"146\":3,\"563\":3}}],[\"sum\",{\"0\":{\"334\":1,\"378\":1},\"1\":{\"5\":3,\"19\":1,\"20\":1,\"21\":1,\"141\":4,\"150\":4,\"151\":4,\"154\":8,\"166\":5,\"169\":7,\"180\":4,\"181\":6,\"196\":7,\"224\":6,\"232\":6,\"236\":1,\"250\":6,\"270\":8,\"298\":13,\"326\":4,\"334\":4,\"340\":3,\"372\":11,\"373\":8,\"380\":7,\"415\":8,\"433\":4,\"451\":3,\"478\":3,\"493\":6,\"503\":3,\"560\":5,\"565\":3,\"575\":5,\"605\":3,\"623\":2,\"705\":2,\"727\":4,\"857\":3,\"882\":4,\"895\":4}}],[\"silver\",{\"1\":{\"872\":1}}],[\"sixteen\",{\"1\":{\"246\":1}}],[\"six\",{\"1\":{\"246\":1}}],[\"sij\",{\"1\":{\"196\":3}}],[\"siz=a\",{\"1\":{\"636\":1}}],[\"siz\",{\"1\":{\"15\":7,\"146\":18,\"147\":8,\"427\":6,\"636\":3}}],[\"sizeof\",{\"1\":{\"14\":1,\"128\":1,\"200\":2,\"204\":1,\"221\":1,\"222\":1,\"232\":1,\"260\":1,\"270\":1,\"273\":1,\"280\":1,\"306\":1,\"318\":1,\"377\":1,\"378\":1,\"633\":1}}],[\"size\",{\"1\":{\"3\":29,\"12\":1,\"13\":3,\"14\":2,\"15\":2,\"103\":1,\"104\":1,\"105\":1,\"106\":1,\"115\":1,\"116\":1,\"125\":1,\"126\":1,\"127\":4,\"137\":1,\"142\":2,\"148\":1,\"156\":1,\"157\":2,\"160\":2,\"168\":2,\"169\":1,\"170\":2,\"179\":5,\"182\":3,\"190\":2,\"192\":6,\"193\":1,\"196\":13,\"198\":1,\"200\":2,\"208\":1,\"210\":4,\"215\":2,\"219\":2,\"226\":1,\"228\":1,\"236\":1,\"237\":1,\"239\":1,\"241\":3,\"242\":1,\"246\":1,\"257\":1,\"262\":1,\"263\":1,\"264\":1,\"266\":1,\"274\":4,\"275\":5,\"282\":7,\"283\":5,\"284\":4,\"286\":4,\"287\":1,\"295\":1,\"298\":1,\"313\":1,\"314\":1,\"340\":3,\"343\":1,\"352\":1,\"363\":4,\"378\":1,\"383\":2,\"384\":6,\"395\":2,\"410\":4,\"417\":1,\"431\":1,\"433\":1,\"438\":1,\"440\":1,\"453\":2,\"462\":2,\"479\":1,\"480\":4,\"504\":3,\"519\":1,\"526\":1,\"538\":1,\"542\":1,\"546\":1,\"557\":2,\"564\":1,\"575\":1,\"576\":1,\"602\":1,\"615\":1,\"618\":1,\"636\":5,\"645\":2,\"646\":3,\"672\":5,\"685\":7,\"714\":2,\"736\":2,\"746\":2,\"796\":7,\"805\":3,\"816\":2,\"828\":1,\"829\":1,\"842\":3,\"843\":1,\"844\":1,\"857\":1,\"875\":2}}],[\"signed\",{\"1\":{\"19\":1,\"20\":1,\"21\":1,\"83\":1,\"109\":1,\"110\":1,\"119\":1,\"127\":1,\"128\":1,\"139\":1,\"140\":1,\"144\":1,\"146\":1,\"147\":1,\"148\":1,\"151\":1,\"163\":1,\"167\":1,\"169\":1,\"176\":1,\"181\":2,\"195\":2,\"224\":1,\"225\":1,\"226\":1,\"241\":1,\"245\":1,\"257\":1,\"266\":1,\"270\":1,\"274\":1,\"291\":1,\"292\":1,\"293\":1,\"298\":2,\"303\":1,\"305\":1,\"313\":1,\"314\":1,\"329\":1,\"331\":1,\"335\":1,\"338\":1,\"358\":1,\"359\":1,\"362\":1,\"371\":1,\"373\":1,\"375\":1,\"377\":1,\"381\":1,\"383\":1,\"384\":1,\"395\":1,\"402\":1,\"405\":1,\"410\":1,\"413\":2,\"414\":1,\"415\":4,\"418\":1,\"428\":1,\"435\":1,\"437\":1,\"461\":1,\"470\":1,\"471\":1,\"475\":1,\"478\":1,\"483\":1,\"484\":3,\"485\":1,\"488\":1,\"493\":1,\"495\":1,\"516\":1,\"579\":1,\"705\":1,\"708\":1,\"803\":1,\"804\":1}}],[\"sign\",{\"1\":{\"3\":25}}],[\"stones\",{\"0\":{\"370\":1}}],[\"step\",{\"1\":{\"194\":4,\"217\":9}}],[\"sta3++\",{\"1\":{\"306\":1}}],[\"sta3\",{\"1\":{\"306\":8}}],[\"sta2++\",{\"1\":{\"306\":1}}],[\"sta2\",{\"1\":{\"306\":23}}],[\"sta1++\",{\"1\":{\"306\":1}}],[\"sta1\",{\"1\":{\"306\":21}}],[\"start++\",{\"1\":{\"735\":2}}],[\"start\",{\"1\":{\"285\":1,\"735\":6}}],[\"star\",{\"1\":{\"215\":5}}],[\"stable\",{\"1\":{\"182\":1}}],[\"sta++\",{\"1\":{\"109\":2,\"110\":2,\"199\":1}}],[\"sta\",{\"1\":{\"105\":7,\"109\":19,\"110\":20,\"199\":5,\"248\":13,\"257\":7,\"280\":2,\"319\":13,\"374\":7,\"381\":14}}],[\"stack<int>\",{\"1\":{\"105\":1,\"235\":1,\"236\":1,\"237\":1,\"239\":1,\"319\":1,\"444\":1,\"475\":1}}],[\"stack\",{\"0\":{\"105\":1}}],[\"standard\",{\"1\":{\"47\":1,\"55\":1}}],[\"st\",{\"1\":{\"13\":10,\"231\":4,\"235\":4,\"236\":6,\"237\":7,\"239\":7,\"484\":3,\"490\":2,\"527\":6,\"623\":4}}],[\"stdout\",{\"1\":{\"198\":1,\"321\":1,\"397\":1,\"399\":1,\"400\":1,\"402\":2,\"405\":1,\"410\":1,\"412\":1,\"413\":2,\"415\":4,\"421\":1,\"422\":1,\"423\":1,\"425\":1,\"426\":1,\"427\":1,\"428\":1,\"430\":1,\"431\":1,\"432\":1,\"433\":1,\"435\":1,\"436\":2,\"437\":1,\"438\":1,\"445\":1,\"450\":1,\"452\":1,\"453\":1,\"455\":1,\"456\":1,\"457\":1,\"458\":1,\"480\":1,\"482\":1,\"483\":1,\"484\":2,\"487\":1,\"488\":1,\"489\":1,\"490\":1,\"492\":1,\"493\":1,\"494\":1,\"495\":1,\"497\":1,\"498\":1,\"499\":1,\"500\":1,\"698\":1,\"705\":1,\"708\":1,\"711\":1,\"714\":1,\"718\":1,\"721\":1,\"724\":1,\"727\":1}}],[\"stdin\",{\"1\":{\"198\":1,\"321\":1,\"397\":1,\"399\":1,\"400\":1,\"402\":2,\"405\":1,\"410\":1,\"412\":1,\"413\":2,\"415\":4,\"421\":1,\"422\":1,\"423\":1,\"425\":1,\"426\":1,\"427\":1,\"428\":1,\"430\":1,\"431\":1,\"432\":1,\"433\":1,\"435\":1,\"436\":2,\"437\":1,\"438\":1,\"450\":1,\"452\":1,\"453\":1,\"455\":1,\"456\":1,\"457\":1,\"458\":1,\"480\":1,\"482\":1,\"483\":1,\"484\":1,\"487\":1,\"488\":1,\"489\":1,\"490\":1,\"492\":1,\"493\":1,\"494\":1,\"495\":1,\"497\":1,\"498\":1,\"499\":1,\"500\":1,\"698\":1,\"705\":1,\"708\":1,\"711\":1,\"714\":1,\"718\":1,\"721\":1,\"724\":1,\"727\":1}}],[\"stdio\",{\"1\":{\"11\":1,\"12\":1,\"13\":1,\"14\":1,\"15\":1,\"17\":1,\"19\":1,\"20\":1,\"21\":1,\"23\":1,\"109\":1,\"110\":1,\"111\":1,\"112\":1,\"113\":1,\"115\":1,\"116\":1,\"117\":1,\"120\":1,\"122\":1,\"123\":1,\"124\":1,\"125\":1,\"126\":1,\"127\":1,\"128\":1,\"137\":1,\"141\":1,\"142\":1,\"144\":1,\"146\":1,\"147\":1,\"148\":1,\"154\":1,\"158\":1,\"163\":1,\"164\":1,\"165\":1,\"166\":1,\"167\":1,\"168\":1,\"169\":1,\"170\":1,\"175\":1,\"176\":1,\"177\":1,\"178\":1,\"179\":1,\"180\":1,\"181\":2,\"182\":2,\"184\":1,\"185\":1,\"186\":1,\"187\":1,\"190\":1,\"192\":1,\"193\":4,\"195\":2,\"196\":5,\"197\":4,\"198\":3,\"199\":4,\"202\":1,\"203\":1,\"204\":1,\"205\":2,\"208\":2,\"209\":1,\"210\":1,\"211\":1,\"213\":1,\"214\":1,\"215\":1,\"216\":2,\"217\":1,\"218\":1,\"219\":2,\"221\":1,\"222\":1,\"224\":1,\"225\":1,\"226\":1,\"227\":1,\"228\":1,\"230\":1,\"231\":1,\"232\":1,\"233\":2,\"235\":1,\"236\":1,\"237\":1,\"239\":1,\"242\":1,\"244\":2,\"245\":1,\"246\":1,\"248\":1,\"249\":1,\"250\":2,\"253\":1,\"255\":1,\"256\":1,\"257\":1,\"258\":1,\"259\":1,\"260\":1,\"265\":1,\"266\":1,\"267\":2,\"268\":1,\"270\":1,\"272\":1,\"273\":1,\"274\":1,\"275\":2,\"276\":2,\"278\":1,\"279\":1,\"280\":1,\"282\":1,\"283\":1,\"284\":1,\"285\":1,\"286\":2,\"287\":1,\"288\":1,\"291\":1,\"292\":1,\"293\":1,\"295\":1,\"298\":2,\"299\":1,\"301\":1,\"302\":1,\"303\":1,\"306\":1,\"307\":1,\"309\":1,\"310\":1,\"312\":1,\"313\":2,\"314\":1,\"317\":1,\"318\":1,\"319\":1,\"320\":3,\"321\":1,\"331\":1,\"333\":1,\"334\":1,\"335\":1,\"336\":1,\"338\":1,\"340\":1,\"345\":1,\"347\":1,\"348\":1,\"349\":1,\"350\":1,\"351\":1,\"352\":1,\"354\":1,\"355\":1,\"356\":1,\"358\":1,\"359\":1,\"361\":1,\"362\":1,\"363\":1,\"365\":1,\"366\":1,\"367\":1,\"368\":1,\"369\":1,\"370\":1,\"371\":1,\"372\":1,\"373\":1,\"374\":1,\"375\":1,\"376\":1,\"377\":1,\"381\":1,\"383\":1,\"384\":1,\"386\":1,\"388\":1,\"389\":1,\"391\":1,\"392\":1,\"393\":1,\"394\":1,\"395\":1,\"399\":1,\"400\":1,\"402\":2,\"405\":1,\"410\":1,\"412\":1,\"413\":2,\"414\":1,\"417\":1,\"418\":1,\"419\":1,\"421\":1,\"422\":1,\"423\":1,\"425\":1,\"426\":1,\"427\":1,\"428\":1,\"443\":1,\"444\":1,\"445\":2,\"446\":1,\"447\":1,\"458\":1,\"460\":1,\"461\":1,\"475\":1,\"542\":1,\"560\":1,\"596\":1,\"599\":1,\"602\":1,\"605\":1,\"729\":1,\"730\":1,\"731\":1,\"732\":1,\"734\":1,\"735\":1,\"736\":1,\"737\":1,\"741\":1,\"790\":1,\"793\":1,\"796\":1,\"799\":1,\"819\":1,\"906\":1}}],[\"stdc++\",{\"1\":{\"11\":1,\"12\":1,\"13\":1,\"14\":1,\"15\":1,\"17\":1,\"19\":1,\"20\":1,\"21\":1,\"23\":1,\"27\":1,\"29\":1,\"30\":1,\"31\":1,\"32\":1,\"40\":1,\"46\":1,\"47\":1,\"48\":1,\"49\":1,\"50\":1,\"52\":1,\"53\":1,\"54\":1,\"57\":1,\"59\":1,\"60\":1,\"61\":1,\"63\":3,\"64\":1,\"66\":1,\"70\":1,\"74\":1,\"89\":1,\"90\":1,\"109\":1,\"110\":1,\"111\":1,\"112\":1,\"113\":1,\"115\":1,\"116\":1,\"117\":1,\"118\":1,\"119\":1,\"120\":1,\"122\":1,\"123\":1,\"124\":1,\"125\":1,\"126\":1,\"127\":1,\"128\":1,\"129\":1,\"131\":1,\"132\":1,\"134\":1,\"135\":1,\"136\":1,\"137\":1,\"139\":1,\"140\":1,\"141\":1,\"142\":1,\"144\":1,\"146\":1,\"147\":1,\"148\":1,\"150\":1,\"151\":1,\"153\":1,\"154\":1,\"156\":1,\"157\":1,\"158\":1,\"160\":1,\"161\":1,\"162\":1,\"163\":1,\"164\":1,\"165\":1,\"166\":1,\"167\":1,\"168\":1,\"169\":1,\"170\":1,\"172\":1,\"173\":1,\"174\":1,\"175\":1,\"176\":1,\"177\":1,\"178\":1,\"179\":1,\"180\":1,\"181\":2,\"182\":2,\"184\":1,\"185\":1,\"186\":1,\"187\":1,\"190\":1,\"191\":1,\"192\":1,\"193\":4,\"194\":1,\"195\":2,\"196\":5,\"197\":4,\"198\":3,\"199\":4,\"200\":1,\"202\":1,\"203\":1,\"204\":1,\"205\":2,\"208\":2,\"209\":1,\"210\":1,\"211\":1,\"213\":1,\"214\":1,\"215\":1,\"216\":2,\"217\":1,\"218\":1,\"219\":2,\"221\":1,\"222\":1,\"224\":1,\"225\":1,\"226\":1,\"227\":1,\"228\":1,\"230\":1,\"231\":1,\"232\":1,\"233\":2,\"235\":1,\"236\":1,\"237\":1,\"239\":1,\"241\":1,\"242\":1,\"243\":1,\"244\":2,\"245\":1,\"246\":1,\"248\":1,\"249\":1,\"250\":2,\"251\":1,\"253\":1,\"255\":1,\"256\":1,\"257\":1,\"258\":1,\"259\":1,\"260\":1,\"262\":1,\"263\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":2,\"268\":1,\"269\":1,\"270\":1,\"272\":1,\"273\":1,\"274\":1,\"275\":2,\"276\":2,\"278\":1,\"279\":1,\"280\":1,\"282\":1,\"283\":1,\"284\":1,\"285\":1,\"286\":2,\"287\":1,\"288\":1,\"289\":2,\"291\":1,\"292\":1,\"293\":1,\"295\":1,\"298\":2,\"299\":1,\"301\":1,\"302\":1,\"303\":1,\"305\":1,\"306\":1,\"307\":2,\"309\":1,\"310\":1,\"312\":1,\"313\":2,\"314\":1,\"317\":1,\"318\":1,\"319\":1,\"320\":3,\"321\":1,\"323\":1,\"324\":1,\"325\":1,\"326\":1,\"329\":1,\"331\":1,\"333\":1,\"334\":1,\"335\":1,\"336\":1,\"338\":1,\"340\":1,\"342\":1,\"343\":1,\"345\":1,\"347\":1,\"348\":1,\"349\":1,\"350\":1,\"351\":1,\"352\":1,\"354\":1,\"355\":1,\"356\":1,\"358\":1,\"359\":1,\"361\":1,\"362\":1,\"363\":1,\"365\":1,\"366\":1,\"367\":1,\"368\":1,\"369\":1,\"370\":1,\"371\":1,\"372\":1,\"373\":1,\"374\":1,\"375\":1,\"376\":1,\"377\":1,\"378\":1,\"379\":1,\"380\":1,\"381\":1,\"383\":1,\"384\":1,\"386\":1,\"388\":1,\"389\":1,\"391\":1,\"392\":1,\"393\":1,\"394\":1,\"395\":1,\"397\":1,\"399\":1,\"400\":1,\"402\":2,\"405\":1,\"410\":1,\"412\":1,\"413\":2,\"414\":1,\"415\":4,\"417\":1,\"418\":1,\"419\":1,\"421\":1,\"422\":1,\"423\":1,\"425\":1,\"426\":1,\"427\":1,\"428\":1,\"430\":1,\"431\":1,\"432\":1,\"433\":1,\"435\":1,\"436\":2,\"437\":1,\"438\":1,\"440\":1,\"441\":1,\"443\":1,\"444\":1,\"446\":1,\"447\":1,\"448\":1,\"450\":1,\"451\":1,\"452\":1,\"453\":1,\"455\":1,\"456\":1,\"457\":1,\"458\":1,\"460\":1,\"461\":1,\"462\":1,\"464\":1,\"465\":1,\"466\":1,\"467\":1,\"469\":1,\"470\":1,\"471\":1,\"473\":1,\"475\":1,\"477\":1,\"478\":1,\"479\":1,\"480\":1,\"482\":1,\"483\":1,\"484\":2,\"485\":1,\"487\":1,\"488\":1,\"489\":1,\"490\":1,\"492\":1,\"493\":1,\"494\":1,\"495\":1,\"497\":1,\"498\":1,\"499\":1,\"500\":1,\"502\":1,\"503\":1,\"504\":1,\"505\":1,\"507\":1,\"508\":1,\"509\":2,\"513\":1,\"516\":1,\"519\":1,\"522\":1,\"524\":1,\"525\":1,\"526\":1,\"527\":1,\"531\":1,\"534\":1,\"535\":1,\"538\":1,\"539\":1,\"542\":1,\"544\":1,\"545\":1,\"546\":1,\"547\":1,\"551\":1,\"554\":1,\"557\":1,\"560\":1,\"562\":1,\"563\":1,\"564\":1,\"565\":1,\"569\":1,\"572\":1,\"575\":1,\"576\":1,\"579\":1,\"583\":1,\"586\":1,\"589\":1,\"592\":1,\"596\":1,\"599\":1,\"602\":1,\"605\":1,\"609\":1,\"612\":1,\"615\":1,\"618\":1,\"620\":1,\"621\":1,\"622\":1,\"623\":1,\"627\":1,\"630\":1,\"633\":1,\"636\":1,\"640\":1,\"643\":1,\"646\":1,\"649\":1,\"653\":1,\"656\":1,\"659\":1,\"662\":1,\"666\":1,\"669\":1,\"672\":1,\"675\":1,\"679\":1,\"682\":1,\"685\":1,\"688\":1,\"692\":1,\"695\":1,\"698\":1,\"701\":1,\"705\":1,\"708\":1,\"711\":1,\"714\":1,\"718\":1,\"721\":1,\"724\":1,\"727\":1,\"729\":1,\"730\":1,\"731\":1,\"732\":1,\"734\":1,\"735\":1,\"736\":1,\"737\":1,\"739\":1,\"741\":1,\"744\":1,\"745\":1,\"746\":1,\"747\":1,\"751\":1,\"754\":1,\"757\":1,\"760\":1,\"764\":1,\"767\":1,\"770\":1,\"773\":1,\"777\":1,\"780\":1,\"783\":1,\"786\":1,\"790\":1,\"793\":1,\"796\":1,\"799\":1,\"801\":1,\"803\":1,\"804\":1,\"805\":1,\"806\":1,\"810\":1,\"813\":1,\"816\":1,\"819\":1,\"823\":1,\"826\":1,\"829\":1,\"832\":1,\"836\":1,\"839\":1,\"844\":1,\"847\":1,\"851\":1,\"854\":1,\"857\":1,\"860\":1,\"864\":1,\"868\":1,\"869\":1,\"872\":1,\"875\":1,\"879\":1,\"882\":1,\"885\":1,\"888\":1,\"892\":1,\"895\":1,\"898\":1,\"902\":1,\"906\":1,\"907\":1,\"911\":1}}],[\"std\",{\"1\":{\"3\":8,\"11\":1,\"12\":1,\"13\":1,\"14\":1,\"15\":1,\"17\":1,\"19\":1,\"20\":1,\"21\":1,\"23\":1,\"27\":1,\"29\":1,\"30\":1,\"31\":1,\"32\":1,\"40\":1,\"46\":1,\"47\":1,\"48\":1,\"49\":1,\"50\":1,\"52\":1,\"53\":1,\"54\":1,\"57\":1,\"59\":1,\"60\":1,\"61\":1,\"63\":3,\"64\":1,\"66\":1,\"70\":1,\"74\":1,\"109\":1,\"110\":1,\"111\":1,\"112\":1,\"113\":1,\"115\":1,\"116\":1,\"117\":1,\"118\":1,\"119\":1,\"120\":1,\"122\":1,\"123\":1,\"124\":1,\"125\":1,\"126\":1,\"127\":1,\"128\":1,\"129\":1,\"131\":1,\"132\":1,\"134\":1,\"135\":1,\"136\":1,\"137\":1,\"139\":1,\"140\":1,\"141\":1,\"142\":1,\"144\":1,\"146\":1,\"147\":1,\"148\":1,\"150\":1,\"151\":1,\"153\":1,\"154\":1,\"156\":1,\"157\":1,\"158\":1,\"160\":1,\"161\":1,\"162\":1,\"163\":1,\"164\":1,\"165\":1,\"166\":1,\"167\":1,\"168\":1,\"169\":1,\"170\":1,\"172\":1,\"173\":1,\"174\":1,\"175\":1,\"176\":1,\"177\":1,\"178\":1,\"179\":1,\"180\":1,\"181\":2,\"182\":2,\"184\":1,\"185\":1,\"186\":1,\"187\":1,\"188\":1,\"190\":1,\"191\":1,\"192\":1,\"193\":4,\"194\":1,\"195\":2,\"196\":5,\"197\":4,\"198\":3,\"199\":4,\"200\":1,\"202\":1,\"203\":1,\"204\":1,\"205\":2,\"208\":2,\"209\":1,\"210\":1,\"211\":1,\"213\":1,\"214\":1,\"215\":1,\"216\":2,\"217\":1,\"218\":1,\"219\":2,\"221\":1,\"222\":1,\"224\":1,\"225\":1,\"226\":1,\"227\":1,\"228\":1,\"230\":1,\"231\":1,\"232\":1,\"233\":2,\"235\":1,\"236\":1,\"237\":1,\"239\":1,\"241\":1,\"242\":1,\"243\":1,\"244\":2,\"245\":1,\"246\":1,\"248\":1,\"249\":1,\"250\":2,\"251\":1,\"253\":1,\"255\":1,\"256\":1,\"257\":1,\"258\":1,\"259\":1,\"260\":1,\"262\":1,\"263\":1,\"264\":1,\"265\":1,\"266\":1,\"267\":2,\"268\":1,\"269\":1,\"270\":1,\"272\":1,\"273\":1,\"274\":1,\"275\":2,\"276\":2,\"278\":1,\"279\":1,\"280\":1,\"282\":1,\"283\":1,\"284\":1,\"285\":2,\"286\":2,\"287\":1,\"288\":1,\"289\":2,\"291\":1,\"292\":1,\"293\":1,\"295\":1,\"298\":2,\"299\":1,\"301\":1,\"302\":1,\"303\":1,\"305\":1,\"306\":1,\"307\":2,\"309\":1,\"310\":1,\"312\":1,\"313\":2,\"314\":1,\"317\":1,\"318\":1,\"319\":1,\"320\":3,\"321\":1,\"323\":1,\"324\":1,\"325\":1,\"326\":1,\"329\":1,\"331\":1,\"333\":1,\"334\":1,\"335\":1,\"336\":1,\"338\":1,\"340\":1,\"342\":1,\"343\":1,\"345\":1,\"347\":1,\"348\":1,\"349\":1,\"350\":1,\"351\":1,\"352\":1,\"354\":1,\"355\":1,\"356\":1,\"358\":1,\"359\":1,\"361\":1,\"362\":1,\"363\":1,\"365\":1,\"366\":1,\"367\":1,\"368\":1,\"369\":1,\"370\":1,\"371\":1,\"372\":1,\"373\":1,\"374\":1,\"375\":1,\"376\":1,\"377\":1,\"378\":1,\"379\":1,\"380\":1,\"381\":1,\"383\":1,\"384\":1,\"386\":1,\"388\":1,\"389\":1,\"391\":1,\"392\":1,\"393\":1,\"394\":1,\"395\":1,\"397\":1,\"399\":1,\"400\":1,\"402\":2,\"405\":1,\"410\":1,\"412\":1,\"413\":2,\"414\":1,\"415\":5,\"417\":1,\"418\":1,\"419\":1,\"421\":1,\"422\":1,\"423\":1,\"425\":1,\"426\":1,\"427\":1,\"428\":1,\"430\":1,\"431\":1,\"432\":1,\"433\":1,\"435\":1,\"436\":2,\"437\":1,\"438\":1,\"440\":1,\"441\":1,\"443\":1,\"444\":1,\"446\":1,\"447\":1,\"448\":1,\"450\":1,\"451\":1,\"452\":1,\"453\":1,\"455\":1,\"456\":1,\"457\":1,\"458\":1,\"460\":1,\"461\":1,\"462\":1,\"464\":1,\"465\":1,\"466\":1,\"467\":1,\"469\":1,\"470\":1,\"471\":1,\"473\":1,\"475\":1,\"477\":1,\"478\":1,\"479\":1,\"480\":1,\"482\":1,\"483\":1,\"484\":2,\"485\":1,\"487\":1,\"488\":1,\"489\":1,\"490\":1,\"492\":1,\"493\":1,\"494\":1,\"495\":1,\"497\":1,\"498\":1,\"499\":1,\"500\":1,\"502\":1,\"503\":1,\"504\":1,\"505\":1,\"507\":1,\"508\":1,\"509\":2,\"513\":1,\"516\":1,\"519\":1,\"522\":1,\"524\":1,\"525\":1,\"526\":1,\"531\":1,\"534\":1,\"535\":1,\"538\":1,\"539\":1,\"542\":1,\"544\":1,\"545\":1,\"546\":1,\"547\":1,\"551\":1,\"554\":1,\"557\":1,\"560\":1,\"562\":1,\"563\":1,\"564\":1,\"565\":1,\"569\":1,\"572\":1,\"575\":2,\"576\":2,\"579\":1,\"583\":1,\"586\":1,\"589\":1,\"592\":1,\"596\":1,\"599\":1,\"602\":1,\"605\":1,\"609\":1,\"612\":1,\"615\":1,\"618\":1,\"620\":1,\"621\":1,\"622\":1,\"623\":1,\"627\":1,\"630\":1,\"633\":1,\"636\":1,\"640\":1,\"643\":1,\"646\":1,\"649\":1,\"653\":1,\"656\":1,\"659\":1,\"662\":1,\"666\":1,\"669\":1,\"672\":1,\"675\":1,\"679\":1,\"682\":1,\"685\":1,\"688\":1,\"692\":1,\"695\":1,\"698\":1,\"701\":1,\"705\":1,\"708\":1,\"711\":1,\"714\":1,\"718\":1,\"721\":1,\"724\":1,\"727\":1,\"729\":1,\"730\":1,\"731\":1,\"732\":1,\"734\":1,\"735\":1,\"736\":1,\"737\":1,\"739\":1,\"740\":1,\"741\":1,\"742\":1,\"744\":1,\"745\":1,\"746\":1,\"747\":1,\"751\":1,\"754\":1,\"757\":1,\"760\":1,\"764\":1,\"767\":1,\"770\":1,\"773\":1,\"777\":1,\"780\":1,\"783\":1,\"786\":1,\"790\":1,\"793\":1,\"796\":1,\"799\":1,\"801\":1,\"803\":1,\"804\":1,\"805\":1,\"806\":1,\"810\":1,\"813\":1,\"816\":1,\"819\":1,\"823\":1,\"826\":1,\"829\":1,\"832\":1,\"836\":1,\"839\":1,\"843\":1,\"844\":1,\"847\":1,\"851\":1,\"854\":1,\"857\":1,\"860\":1,\"864\":1,\"868\":1,\"869\":1,\"872\":1,\"875\":1,\"879\":1,\"882\":1,\"885\":1,\"888\":1,\"892\":1,\"895\":1,\"898\":1,\"902\":1,\"906\":1,\"907\":1}}],[\"straight\",{\"0\":{\"141\":1}}],[\"struct\",{\"1\":{\"3\":1,\"128\":1,\"191\":1,\"202\":1,\"203\":1,\"204\":1,\"219\":2,\"268\":1,\"312\":1,\"313\":2,\"314\":1,\"377\":1,\"519\":1,\"623\":1,\"872\":1}}],[\"str\",{\"1\":{\"3\":2,\"5\":1,\"7\":1,\"8\":1}}],[\"stringstream\",{\"1\":{\"265\":2}}],[\"string\",{\"1\":{\"3\":6,\"7\":1,\"8\":1,\"40\":5,\"61\":1,\"63\":2,\"70\":2,\"74\":2,\"126\":1,\"142\":1,\"156\":1,\"157\":1,\"160\":3,\"161\":2,\"165\":1,\"168\":2,\"169\":1,\"178\":1,\"179\":4,\"184\":1,\"185\":1,\"186\":1,\"187\":1,\"188\":2,\"192\":1,\"193\":8,\"246\":3,\"262\":1,\"263\":1,\"264\":1,\"265\":2,\"268\":3,\"269\":1,\"275\":2,\"282\":3,\"283\":3,\"284\":2,\"286\":2,\"287\":2,\"319\":1,\"329\":1,\"343\":1,\"351\":1,\"363\":2,\"378\":1,\"379\":1,\"380\":1,\"410\":1,\"417\":2,\"431\":1,\"440\":1,\"453\":2,\"455\":3,\"456\":2,\"464\":3,\"465\":3,\"466\":4,\"467\":4,\"487\":1,\"504\":1,\"509\":1,\"519\":1,\"522\":1,\"526\":1,\"538\":1,\"542\":3,\"546\":2,\"557\":2,\"564\":1,\"575\":1,\"576\":2,\"579\":4,\"589\":1,\"602\":1,\"615\":1,\"618\":1,\"622\":1,\"633\":1,\"646\":1,\"659\":1,\"671\":1,\"672\":1,\"685\":1,\"698\":1,\"711\":1,\"714\":1,\"731\":1,\"732\":1,\"736\":1,\"741\":1,\"746\":1,\"757\":1,\"783\":1,\"796\":1,\"805\":3,\"816\":1,\"829\":1,\"843\":1,\"844\":1,\"857\":1,\"872\":2,\"875\":5,\"885\":1,\"902\":2,\"911\":1}}],[\"s\",{\"0\":{\"197\":1,\"198\":1,\"199\":1,\"378\":1,\"699\":1},\"1\":{\"3\":14,\"11\":4,\"12\":4,\"13\":4,\"14\":3,\"15\":8,\"126\":5,\"142\":9,\"147\":2,\"156\":3,\"157\":3,\"160\":3,\"161\":6,\"168\":41,\"169\":6,\"178\":12,\"184\":10,\"185\":11,\"186\":14,\"187\":17,\"188\":9,\"192\":9,\"193\":17,\"196\":45,\"198\":11,\"211\":6,\"244\":6,\"246\":10,\"265\":10,\"268\":8,\"269\":7,\"275\":8,\"286\":16,\"309\":9,\"310\":9,\"319\":9,\"328\":1,\"329\":18,\"336\":1,\"345\":3,\"351\":7,\"363\":7,\"379\":3,\"380\":3,\"410\":11,\"417\":11,\"431\":7,\"440\":6,\"444\":11,\"456\":6,\"464\":8,\"465\":8,\"466\":7,\"467\":11,\"475\":7,\"503\":6,\"504\":9,\"509\":1,\"516\":3,\"518\":1,\"519\":4,\"522\":3,\"526\":8,\"538\":10,\"539\":1,\"542\":3,\"546\":6,\"557\":10,\"564\":4,\"575\":7,\"579\":2,\"589\":6,\"602\":7,\"615\":5,\"618\":6,\"633\":2,\"645\":1,\"646\":9,\"659\":3,\"714\":12,\"732\":4,\"736\":6,\"746\":5,\"757\":6,\"764\":2,\"773\":3,\"783\":6,\"786\":3,\"796\":9,\"805\":4,\"828\":1,\"829\":4,\"842\":3,\"844\":5,\"857\":6,\"872\":4,\"875\":11,\"885\":4,\"902\":2}}],[\"=b\",{\"1\":{\"633\":2}}],[\"=s\",{\"1\":{\"546\":1}}],[\"=j\",{\"1\":{\"509\":1}}],[\"=2\",{\"1\":{\"453\":1,\"545\":1}}],[\"=true\",{\"1\":{\"816\":1}}],[\"=tim\",{\"1\":{\"633\":1}}],[\"=tail\",{\"1\":{\"321\":1}}],[\"=tott\",{\"1\":{\"321\":1}}],[\"=tott+1\",{\"1\":{\"321\":1}}],[\"=nxt\",{\"1\":{\"321\":1}}],[\"=nxtt\",{\"1\":{\"321\":2}}],[\"=pret\",{\"1\":{\"321\":2}}],[\"=1\",{\"1\":{\"321\":2,\"509\":4,\"902\":1}}],[\"=0||i==n\",{\"1\":{\"623\":1}}],[\"=0\",{\"1\":{\"321\":9,\"633\":1}}],[\"=i\",{\"1\":{\"321\":3,\"509\":1,\"906\":1}}],[\"=i+1\",{\"1\":{\"321\":1}}],[\"=a\",{\"1\":{\"216\":1,\"633\":1}}],[\"==sss\",{\"1\":{\"576\":1}}],[\"==ss\",{\"1\":{\"575\":1,\"576\":1}}],[\"==0\",{\"1\":{\"544\":1}}],[\"==true\",{\"1\":{\"509\":1}}],[\"==tail\",{\"1\":{\"321\":1}}],[\"====\",{\"1\":{\"473\":2}}],[\"========\",{\"1\":{\"196\":6}}],[\"==a\",{\"1\":{\"321\":2}}],[\"==\",{\"1\":{\"3\":12,\"11\":1,\"12\":2,\"13\":1,\"14\":3,\"15\":3,\"17\":4,\"19\":2,\"20\":2,\"21\":4,\"23\":2,\"24\":1,\"40\":2,\"72\":1,\"74\":2,\"81\":1,\"98\":4,\"100\":1,\"109\":1,\"110\":1,\"119\":3,\"120\":1,\"124\":1,\"125\":2,\"126\":1,\"127\":2,\"129\":1,\"131\":3,\"132\":3,\"136\":1,\"137\":23,\"139\":1,\"140\":2,\"142\":5,\"146\":4,\"147\":1,\"153\":2,\"154\":4,\"156\":4,\"157\":6,\"158\":3,\"160\":6,\"161\":2,\"162\":12,\"163\":4,\"165\":9,\"167\":4,\"168\":11,\"169\":1,\"170\":5,\"174\":3,\"176\":1,\"177\":4,\"178\":1,\"179\":4,\"180\":3,\"181\":4,\"182\":5,\"185\":3,\"186\":5,\"187\":8,\"188\":4,\"190\":2,\"191\":2,\"192\":4,\"194\":1,\"195\":11,\"196\":17,\"197\":1,\"198\":2,\"199\":6,\"200\":2,\"203\":4,\"204\":1,\"209\":1,\"210\":1,\"215\":4,\"216\":7,\"217\":4,\"218\":5,\"221\":5,\"222\":6,\"224\":1,\"225\":2,\"227\":3,\"228\":2,\"230\":9,\"231\":6,\"232\":2,\"235\":6,\"236\":6,\"237\":9,\"239\":10,\"242\":4,\"243\":3,\"245\":1,\"246\":1,\"251\":4,\"253\":2,\"255\":3,\"256\":4,\"259\":4,\"260\":1,\"262\":3,\"263\":3,\"264\":4,\"265\":3,\"267\":1,\"268\":8,\"269\":2,\"270\":16,\"272\":5,\"273\":5,\"275\":11,\"276\":12,\"278\":1,\"279\":1,\"282\":2,\"283\":5,\"284\":3,\"286\":12,\"287\":2,\"288\":2,\"289\":4,\"291\":4,\"292\":4,\"295\":5,\"299\":1,\"301\":1,\"302\":1,\"305\":4,\"306\":9,\"307\":3,\"309\":1,\"310\":3,\"312\":4,\"313\":8,\"314\":4,\"317\":8,\"318\":8,\"319\":9,\"320\":2,\"326\":2,\"328\":1,\"329\":14,\"331\":4,\"335\":1,\"336\":5,\"342\":1,\"343\":6,\"351\":3,\"352\":2,\"359\":1,\"363\":2,\"366\":2,\"367\":2,\"369\":3,\"370\":1,\"371\":1,\"372\":1,\"373\":1,\"374\":3,\"375\":1,\"377\":2,\"378\":3,\"379\":1,\"380\":1,\"381\":1,\"383\":2,\"384\":3,\"389\":2,\"391\":1,\"395\":2,\"397\":2,\"399\":2,\"400\":1,\"402\":1,\"410\":2,\"412\":1,\"415\":3,\"417\":1,\"419\":3,\"421\":1,\"422\":1,\"423\":1,\"425\":2,\"428\":1,\"431\":4,\"432\":1,\"433\":1,\"437\":4,\"438\":2,\"440\":3,\"441\":1,\"444\":8,\"446\":2,\"447\":6,\"448\":3,\"452\":4,\"453\":3,\"455\":1,\"456\":3,\"457\":3,\"458\":1,\"460\":20,\"465\":1,\"466\":1,\"467\":1,\"469\":1,\"471\":7,\"480\":3,\"484\":5,\"488\":3,\"489\":1,\"490\":1,\"492\":12,\"494\":1,\"495\":1,\"498\":1,\"499\":2,\"504\":2,\"505\":5,\"509\":5,\"513\":25,\"516\":1,\"522\":1,\"525\":1,\"526\":4,\"527\":2,\"538\":2,\"539\":1,\"542\":3,\"557\":3,\"563\":1,\"564\":1,\"565\":2,\"569\":2,\"572\":10,\"575\":36,\"576\":1,\"579\":2,\"592\":1,\"602\":3,\"605\":1,\"612\":2,\"618\":1,\"622\":6,\"633\":1,\"646\":1,\"649\":2,\"653\":9,\"656\":27,\"662\":3,\"669\":2,\"672\":2,\"679\":4,\"685\":10,\"688\":2,\"701\":2,\"714\":2,\"718\":8,\"724\":1,\"730\":1,\"732\":8,\"735\":1,\"736\":2,\"741\":5,\"744\":5,\"745\":2,\"747\":1,\"757\":2,\"764\":18,\"767\":4,\"793\":1,\"799\":1,\"801\":1,\"803\":1,\"812\":1,\"829\":1,\"832\":1,\"839\":1,\"843\":2,\"844\":1,\"847\":2,\"851\":1,\"854\":1,\"857\":2,\"864\":1,\"868\":1,\"872\":6,\"875\":5,\"885\":3,\"892\":1,\"898\":1}}],[\"=\",{\"1\":{\"3\":46,\"5\":4,\"7\":2,\"11\":19,\"12\":17,\"13\":20,\"14\":17,\"15\":23,\"17\":10,\"18\":2,\"19\":11,\"20\":8,\"21\":45,\"23\":20,\"24\":2,\"27\":4,\"29\":4,\"30\":4,\"31\":4,\"32\":5,\"38\":3,\"40\":12,\"41\":684,\"60\":2,\"61\":1,\"62\":1,\"63\":8,\"64\":11,\"72\":1,\"78\":1,\"79\":1,\"80\":1,\"81\":6,\"83\":6,\"85\":1,\"98\":2,\"100\":6,\"101\":1,\"109\":8,\"110\":8,\"111\":3,\"112\":8,\"113\":11,\"115\":11,\"116\":20,\"117\":16,\"118\":8,\"119\":14,\"120\":7,\"122\":14,\"123\":18,\"124\":7,\"125\":15,\"126\":20,\"127\":14,\"128\":9,\"129\":5,\"131\":3,\"132\":3,\"134\":6,\"135\":6,\"136\":8,\"137\":8,\"139\":10,\"140\":15,\"141\":10,\"142\":5,\"144\":10,\"146\":21,\"147\":24,\"148\":11,\"150\":14,\"151\":15,\"153\":16,\"154\":21,\"156\":15,\"157\":23,\"158\":31,\"160\":19,\"161\":14,\"162\":26,\"163\":16,\"164\":28,\"165\":33,\"166\":19,\"167\":15,\"168\":28,\"169\":21,\"170\":11,\"172\":4,\"173\":21,\"174\":3,\"175\":8,\"176\":11,\"177\":11,\"178\":14,\"179\":16,\"180\":3,\"181\":23,\"182\":50,\"184\":14,\"185\":23,\"186\":25,\"187\":45,\"188\":10,\"190\":8,\"191\":10,\"192\":17,\"193\":21,\"194\":13,\"195\":14,\"196\":102,\"197\":35,\"198\":28,\"199\":55,\"200\":13,\"202\":6,\"203\":14,\"204\":16,\"205\":13,\"208\":5,\"209\":2,\"210\":2,\"211\":4,\"213\":18,\"214\":12,\"215\":28,\"216\":37,\"217\":6,\"218\":9,\"219\":32,\"221\":13,\"222\":16,\"224\":7,\"225\":8,\"226\":8,\"227\":12,\"228\":10,\"230\":18,\"231\":40,\"232\":20,\"233\":32,\"235\":9,\"236\":21,\"237\":26,\"239\":20,\"241\":32,\"242\":33,\"243\":11,\"244\":14,\"245\":8,\"246\":13,\"248\":29,\"249\":22,\"250\":10,\"251\":22,\"253\":11,\"255\":6,\"256\":10,\"257\":10,\"258\":12,\"259\":35,\"260\":29,\"262\":15,\"263\":18,\"264\":16,\"265\":3,\"266\":20,\"267\":19,\"268\":20,\"269\":14,\"270\":18,\"272\":5,\"273\":8,\"274\":16,\"275\":31,\"276\":33,\"278\":7,\"279\":7,\"280\":10,\"282\":11,\"283\":15,\"284\":11,\"285\":24,\"286\":24,\"287\":8,\"288\":7,\"289\":36,\"291\":13,\"292\":10,\"293\":16,\"295\":20,\"298\":20,\"299\":11,\"301\":14,\"302\":11,\"303\":9,\"305\":19,\"306\":18,\"307\":24,\"309\":5,\"310\":4,\"312\":12,\"313\":28,\"314\":16,\"317\":11,\"318\":12,\"319\":23,\"320\":30,\"321\":3,\"324\":12,\"325\":5,\"326\":4,\"328\":3,\"329\":30,\"331\":10,\"334\":3,\"335\":14,\"336\":21,\"338\":3,\"340\":23,\"342\":13,\"343\":18,\"345\":3,\"347\":7,\"348\":6,\"349\":5,\"350\":7,\"351\":12,\"352\":10,\"354\":8,\"355\":8,\"356\":6,\"358\":6,\"359\":9,\"361\":11,\"362\":10,\"363\":11,\"365\":12,\"366\":11,\"367\":9,\"368\":7,\"369\":12,\"370\":4,\"371\":8,\"372\":17,\"373\":11,\"374\":11,\"375\":7,\"376\":13,\"377\":26,\"378\":12,\"379\":12,\"380\":13,\"381\":17,\"383\":11,\"384\":23,\"386\":5,\"388\":5,\"389\":5,\"391\":18,\"392\":8,\"393\":13,\"394\":6,\"395\":10,\"397\":1,\"399\":9,\"400\":6,\"402\":18,\"405\":14,\"410\":24,\"412\":6,\"413\":14,\"414\":11,\"415\":33,\"417\":4,\"418\":8,\"419\":9,\"421\":13,\"422\":14,\"423\":14,\"425\":8,\"426\":10,\"427\":13,\"428\":16,\"430\":11,\"431\":5,\"432\":10,\"433\":10,\"435\":8,\"436\":10,\"437\":19,\"438\":21,\"440\":9,\"441\":5,\"443\":31,\"444\":42,\"446\":7,\"447\":13,\"448\":12,\"450\":2,\"451\":6,\"453\":4,\"455\":4,\"456\":8,\"457\":10,\"458\":9,\"460\":9,\"461\":1,\"462\":9,\"464\":10,\"465\":11,\"466\":9,\"467\":12,\"469\":1,\"470\":2,\"471\":20,\"473\":6,\"475\":16,\"477\":4,\"478\":7,\"479\":10,\"480\":9,\"483\":8,\"484\":31,\"485\":14,\"487\":6,\"488\":8,\"489\":5,\"490\":12,\"492\":12,\"493\":9,\"494\":9,\"495\":11,\"497\":6,\"498\":11,\"499\":16,\"500\":12,\"502\":3,\"503\":3,\"504\":7,\"505\":20,\"509\":1,\"513\":10,\"516\":13,\"519\":8,\"522\":8,\"524\":1,\"525\":3,\"526\":11,\"527\":8,\"531\":5,\"534\":6,\"535\":2,\"538\":5,\"539\":3,\"542\":15,\"551\":5,\"554\":2,\"557\":8,\"560\":10,\"564\":1,\"565\":8,\"569\":6,\"572\":13,\"575\":15,\"576\":10,\"579\":8,\"583\":1,\"586\":5,\"589\":2,\"592\":4,\"596\":2,\"599\":11,\"602\":4,\"605\":18,\"609\":3,\"612\":6,\"615\":3,\"618\":6,\"622\":4,\"627\":2,\"630\":3,\"633\":1,\"643\":3,\"646\":4,\"649\":2,\"653\":6,\"656\":22,\"659\":4,\"662\":6,\"666\":4,\"669\":2,\"672\":6,\"675\":25,\"679\":2,\"682\":3,\"685\":15,\"688\":12,\"692\":5,\"695\":9,\"701\":9,\"705\":9,\"708\":4,\"711\":4,\"714\":9,\"718\":1,\"721\":10,\"724\":4,\"727\":4,\"729\":5,\"730\":3,\"732\":22,\"735\":9,\"736\":4,\"737\":7,\"741\":5,\"744\":1,\"745\":1,\"746\":9,\"747\":7,\"754\":6,\"757\":4,\"760\":5,\"764\":20,\"767\":6,\"770\":7,\"772\":2,\"773\":5,\"777\":4,\"780\":4,\"783\":4,\"786\":7,\"790\":5,\"793\":4,\"796\":5,\"799\":7,\"803\":9,\"805\":10,\"806\":3,\"810\":6,\"812\":5,\"813\":2,\"816\":1,\"819\":6,\"823\":1,\"826\":2,\"829\":2,\"832\":9,\"836\":2,\"839\":8,\"846\":1,\"847\":4,\"854\":3,\"857\":5,\"860\":6,\"864\":11,\"868\":3,\"869\":3,\"872\":15,\"875\":20,\"882\":2,\"885\":4,\"888\":6,\"892\":2,\"895\":2,\"898\":2,\"907\":6}}],[\"a乘b小于c吗\",{\"0\":{\"890\":1}}],[\"are\",{\"1\":{\"741\":2}}],[\"argv\",{\"1\":{\"551\":2}}],[\"argc\",{\"1\":{\"551\":2}}],[\"am\",{\"1\":{\"741\":2}}],[\"american\",{\"1\":{\"55\":1}}],[\"a^2+a\",{\"1\":{\"695\":1}}],[\"a^a\",{\"1\":{\"695\":1}}],[\"a<=3\",{\"1\":{\"630\":1}}],[\"a<=b\",{\"1\":{\"544\":1}}],[\"a=11\",{\"1\":{\"633\":1}}],[\"a=12\",{\"1\":{\"633\":1}}],[\"a=b=11\",{\"1\":{\"633\":1}}],[\"a=b=0\",{\"1\":{\"633\":1}}],[\"a==b\",{\"1\":{\"633\":1}}],[\"a==3\",{\"1\":{\"630\":1}}],[\"a==2\",{\"1\":{\"630\":1}}],[\"a==1\",{\"1\":{\"630\":1}}],[\"a=0\",{\"1\":{\"630\":1,\"633\":2}}],[\"a=x\",{\"1\":{\"507\":1}}],[\"a>=\",{\"1\":{\"902\":1}}],[\"a>=b\",{\"1\":{\"267\":1,\"483\":1}}],[\"a>11\",{\"1\":{\"633\":1}}],[\"a>>p\",{\"1\":{\"623\":1}}],[\"a>b\",{\"1\":{\"623\":1,\"633\":2}}],[\"a0274\",{\"1\":{\"571\":1}}],[\"age\",{\"1\":{\"482\":2}}],[\"august\",{\"1\":{\"455\":1}}],[\"auto\",{\"1\":{\"127\":3,\"141\":1,\"144\":1,\"160\":1,\"161\":1,\"167\":1,\"198\":1,\"211\":1,\"309\":1,\"310\":1,\"331\":2,\"465\":1}}],[\"applepen\",{\"1\":{\"519\":1}}],[\"apple\",{\"1\":{\"519\":1}}],[\"april\",{\"1\":{\"455\":1}}],[\"apc\",{\"0\":{\"192\":1}}],[\"apc001\",{\"0\":{\"192\":1}}],[\"a+=da\",{\"1\":{\"633\":1}}],[\"a+b=b\",{\"0\":{\"507\":1}}],[\"a+b\",{\"0\":{\"745\":1},\"1\":{\"413\":2}}],[\"a++\",{\"1\":{\"64\":2,\"81\":1,\"305\":1,\"431\":1,\"575\":2,\"630\":1,\"633\":2}}],[\"atcoder\",{\"0\":{\"353\":1,\"914\":1},\"1\":{\"420\":1}}],[\"at\",{\"1\":{\"351\":1,\"437\":1}}],[\"ai++\",{\"1\":{\"649\":1}}],[\"aij\",{\"1\":{\"451\":3}}],[\"ai\",{\"1\":{\"326\":4,\"340\":3,\"342\":4,\"418\":1,\"436\":4,\"554\":3,\"649\":3,\"868\":4,\"869\":3,\"882\":3,\"895\":3}}],[\"al++\",{\"1\":{\"672\":1,\"685\":1}}],[\"alen\",{\"1\":{\"672\":4}}],[\"al\",{\"1\":{\"672\":6,\"685\":7}}],[\"already\",{\"1\":{\"309\":1,\"310\":1}}],[\"alter\",{\"0\":{\"286\":1}}],[\"all++\",{\"1\":{\"736\":1}}],[\"ally\",{\"1\":{\"169\":12}}],[\"all\",{\"0\":{\"350\":1},\"1\":{\"150\":4,\"151\":6,\"298\":5,\"736\":3}}],[\"ahoi2017初中组\",{\"0\":{\"286\":1}}],[\"a~b\",{\"1\":{\"218\":1}}],[\"a~z\",{\"1\":{\"184\":1}}],[\"ay\",{\"1\":{\"200\":4}}],[\"ax\",{\"1\":{\"164\":1,\"200\":9}}],[\"acos\",{\"1\":{\"575\":1,\"576\":1}}],[\"ac\",{\"0\":{\"160\":1},\"1\":{\"902\":1}}],[\"accepted\",{\"1\":{\"69\":1}}],[\"aa\",{\"1\":{\"153\":16,\"162\":7,\"166\":7,\"267\":3,\"305\":7,\"413\":1,\"692\":2}}],[\"a4\",{\"1\":{\"111\":3,\"477\":3,\"502\":3}}],[\"a3\",{\"1\":{\"111\":3,\"477\":3,\"502\":3,\"599\":3,\"809\":1,\"810\":3}}],[\"a23456789tjqk\",{\"1\":{\"193\":2,\"763\":1}}],[\"a2\",{\"1\":{\"111\":3,\"477\":3,\"502\":3,\"599\":3,\"809\":1,\"810\":3}}],[\"a1\",{\"1\":{\"111\":3,\"141\":4,\"289\":6,\"477\":3,\"502\":3,\"599\":3,\"704\":1,\"705\":12,\"809\":1,\"810\":3}}],[\"a1b2c3\",{\"1\":{\"62\":1}}],[\"assert\",{\"1\":{\"377\":2,\"421\":1,\"422\":1,\"423\":1,\"839\":1}}],[\"ascii\",{\"1\":{\"93\":1,\"94\":2,\"518\":1}}],[\"ask\",{\"1\":{\"14\":7,\"170\":3,\"172\":3,\"448\":5}}],[\"another\",{\"1\":{\"246\":1}}],[\"an\",{\"0\":{\"141\":1,\"142\":1},\"1\":{\"495\":2}}],[\"and\",{\"1\":{\"73\":1,\"74\":1,\"81\":1,\"165\":1}}],[\"ans3\",{\"1\":{\"810\":4}}],[\"ans+=p\",{\"1\":{\"623\":1}}],[\"ans++\",{\"1\":{\"180\":1,\"241\":1,\"242\":1,\"243\":1,\"250\":2,\"251\":1,\"253\":1,\"255\":1,\"256\":1,\"267\":1,\"301\":1,\"303\":1,\"307\":2,\"331\":2,\"399\":1,\"400\":1,\"419\":1,\"425\":1,\"430\":1,\"441\":1,\"457\":1,\"479\":1,\"494\":1,\"505\":2,\"545\":2,\"557\":1,\"575\":2,\"605\":1,\"630\":1,\"643\":1,\"649\":1,\"669\":1,\"757\":1,\"780\":1,\"804\":1,\"829\":1,\"832\":2,\"898\":1}}],[\"ans=0\",{\"1\":{\"623\":1,\"804\":1}}],[\"ansb\",{\"1\":{\"324\":8}}],[\"ansk\",{\"1\":{\"275\":6}}],[\"ans2++\",{\"1\":{\"198\":1,\"218\":1}}],[\"ans2\",{\"1\":{\"198\":8,\"202\":5,\"203\":5,\"218\":2,\"405\":3,\"440\":5,\"596\":2,\"810\":4}}],[\"ans1++\",{\"1\":{\"198\":4,\"218\":1}}],[\"ans1\",{\"1\":{\"198\":8,\"202\":6,\"203\":6,\"218\":2,\"405\":2,\"440\":5,\"596\":2,\"810\":4}}],[\"ansc\",{\"1\":{\"192\":4}}],[\"anscnt\",{\"1\":{\"158\":3,\"275\":8}}],[\"ansp\",{\"1\":{\"192\":4}}],[\"ansa\",{\"1\":{\"192\":7,\"324\":8}}],[\"anslen\",{\"1\":{\"142\":5}}],[\"ansf\",{\"1\":{\"119\":4}}],[\"ansi\",{\"1\":{\"115\":8,\"116\":8}}],[\"answer\",{\"1\":{\"69\":1,\"129\":1,\"179\":1,\"551\":1}}],[\"ans\",{\"1\":{\"14\":6,\"23\":3,\"112\":4,\"113\":4,\"117\":4,\"118\":4,\"119\":3,\"122\":4,\"123\":4,\"137\":15,\"139\":3,\"140\":3,\"141\":4,\"142\":4,\"144\":4,\"146\":4,\"147\":4,\"151\":4,\"153\":5,\"154\":6,\"158\":10,\"160\":7,\"161\":4,\"164\":3,\"165\":4,\"166\":4,\"167\":3,\"168\":1,\"169\":3,\"172\":2,\"175\":3,\"176\":3,\"178\":5,\"179\":9,\"180\":3,\"181\":3,\"182\":11,\"187\":4,\"190\":3,\"193\":6,\"194\":3,\"195\":7,\"197\":13,\"199\":25,\"200\":6,\"204\":4,\"205\":3,\"213\":3,\"215\":4,\"217\":8,\"219\":8,\"224\":4,\"225\":4,\"226\":3,\"228\":3,\"232\":4,\"233\":8,\"236\":3,\"237\":3,\"241\":2,\"242\":2,\"243\":2,\"250\":28,\"251\":2,\"253\":3,\"255\":3,\"256\":3,\"257\":5,\"258\":3,\"259\":6,\"260\":4,\"266\":4,\"267\":2,\"268\":4,\"273\":5,\"274\":10,\"276\":4,\"278\":5,\"279\":6,\"286\":6,\"288\":5,\"293\":3,\"298\":6,\"301\":3,\"302\":4,\"303\":4,\"305\":5,\"306\":4,\"307\":4,\"309\":5,\"310\":10,\"312\":3,\"313\":6,\"314\":3,\"319\":3,\"320\":14,\"325\":3,\"329\":10,\"331\":3,\"336\":5,\"338\":3,\"340\":3,\"342\":6,\"350\":4,\"351\":4,\"352\":4,\"361\":3,\"363\":5,\"365\":4,\"366\":4,\"368\":3,\"376\":4,\"377\":4,\"379\":4,\"380\":4,\"395\":4,\"399\":2,\"400\":2,\"402\":5,\"410\":8,\"412\":4,\"414\":5,\"415\":22,\"419\":3,\"425\":2,\"427\":4,\"430\":2,\"435\":4,\"437\":3,\"441\":5,\"443\":4,\"444\":4,\"446\":3,\"447\":2,\"448\":3,\"453\":8,\"457\":2,\"460\":11,\"462\":4,\"464\":4,\"465\":6,\"466\":4,\"467\":4,\"471\":6,\"479\":2,\"485\":3,\"490\":5,\"493\":4,\"494\":2,\"500\":3,\"504\":4,\"505\":2,\"516\":7,\"534\":4,\"542\":3,\"545\":1,\"551\":1,\"554\":3,\"557\":1,\"560\":3,\"575\":2,\"579\":4,\"592\":3,\"599\":4,\"605\":3,\"612\":1,\"630\":2,\"643\":4,\"649\":3,\"656\":22,\"669\":2,\"685\":8,\"705\":5,\"708\":5,\"730\":3,\"744\":8,\"745\":5,\"754\":3,\"757\":2,\"760\":4,\"770\":5,\"780\":2,\"783\":3,\"786\":3,\"799\":5,\"805\":3,\"812\":5,\"813\":4,\"819\":4,\"823\":3,\"826\":3,\"829\":2,\"832\":2,\"860\":3,\"864\":23,\"868\":5,\"869\":5,\"888\":3,\"892\":4,\"898\":2}}],[\"adopqrabdeopq469\",{\"1\":{\"805\":1}}],[\"adj\",{\"1\":{\"80\":1}}],[\"admin\",{\"1\":{\"70\":1,\"74\":1}}],[\"add\",{\"1\":{\"3\":2,\"21\":9,\"37\":1,\"184\":3,\"185\":3,\"186\":8,\"187\":7,\"190\":2,\"213\":4,\"214\":4,\"453\":4,\"483\":2,\"714\":3}}],[\"abba\",{\"0\":{\"508\":1}}],[\"ab\",{\"1\":{\"144\":5,\"198\":1}}],[\"abcde\",{\"1\":{\"588\":1}}],[\"abcdefg\",{\"1\":{\"56\":1}}],[\"abcd\",{\"1\":{\"541\":1}}],[\"abc170\",{\"1\":{\"420\":2}}],[\"abc408\",{\"0\":{\"344\":1}}],[\"abc341\",{\"1\":{\"437\":1}}],[\"abc391\",{\"0\":{\"341\":1}}],[\"abc390\",{\"0\":{\"339\":1}}],[\"abc389\",{\"0\":{\"337\":1}}],[\"abc387\",{\"0\":{\"332\":1}}],[\"abc385\",{\"0\":{\"330\":1}}],[\"abc\",{\"1\":{\"62\":1,\"691\":1}}],[\"abs\",{\"1\":{\"40\":1,\"259\":4,\"267\":4,\"273\":1,\"309\":2,\"310\":2,\"354\":2,\"355\":1,\"413\":6,\"633\":1,\"724\":2,\"729\":4}}],[\"absless\",{\"1\":{\"3\":4}}],[\"a\",{\"0\":{\"189\":1,\"277\":1,\"333\":1,\"345\":1,\"354\":1,\"397\":1,\"511\":1,\"529\":1,\"549\":1,\"567\":1,\"581\":1,\"594\":1,\"607\":1,\"625\":1,\"638\":1,\"651\":1,\"664\":1,\"677\":1,\"690\":1,\"703\":1,\"716\":1,\"734\":1,\"744\":1,\"808\":1,\"821\":1,\"834\":1,\"849\":1,\"862\":1,\"877\":1,\"890\":1},\"1\":{\"3\":20,\"7\":3,\"8\":3,\"13\":14,\"17\":3,\"19\":4,\"20\":4,\"21\":4,\"23\":3,\"27\":7,\"29\":7,\"30\":7,\"31\":3,\"32\":7,\"40\":5,\"56\":2,\"60\":4,\"61\":2,\"63\":11,\"64\":21,\"66\":6,\"77\":1,\"78\":1,\"79\":1,\"80\":1,\"81\":1,\"89\":1,\"90\":1,\"92\":1,\"93\":1,\"94\":4,\"95\":4,\"97\":4,\"99\":3,\"101\":4,\"103\":12,\"112\":5,\"113\":5,\"115\":7,\"116\":8,\"117\":4,\"118\":7,\"119\":8,\"120\":4,\"122\":4,\"123\":4,\"124\":4,\"125\":6,\"126\":15,\"128\":13,\"129\":8,\"139\":9,\"140\":9,\"141\":5,\"142\":2,\"144\":3,\"146\":14,\"147\":9,\"148\":6,\"150\":8,\"151\":10,\"153\":5,\"154\":4,\"162\":13,\"163\":5,\"164\":4,\"166\":4,\"167\":7,\"172\":2,\"173\":17,\"174\":8,\"175\":4,\"176\":5,\"177\":4,\"179\":11,\"181\":6,\"182\":8,\"184\":4,\"185\":4,\"186\":8,\"187\":3,\"188\":31,\"190\":4,\"191\":11,\"192\":8,\"195\":2,\"198\":21,\"199\":20,\"202\":13,\"203\":27,\"204\":17,\"208\":8,\"209\":14,\"210\":11,\"211\":12,\"213\":11,\"214\":10,\"216\":5,\"218\":10,\"219\":18,\"221\":5,\"222\":5,\"224\":5,\"225\":7,\"226\":12,\"227\":5,\"232\":5,\"233\":8,\"235\":7,\"236\":8,\"237\":8,\"239\":8,\"241\":10,\"242\":6,\"246\":17,\"248\":9,\"249\":11,\"250\":16,\"258\":12,\"259\":2,\"262\":13,\"263\":13,\"264\":13,\"265\":13,\"266\":6,\"267\":19,\"268\":7,\"269\":2,\"272\":4,\"280\":5,\"282\":5,\"283\":5,\"284\":5,\"285\":17,\"289\":6,\"291\":4,\"292\":3,\"298\":12,\"299\":5,\"301\":5,\"302\":6,\"303\":5,\"305\":6,\"307\":17,\"312\":2,\"313\":2,\"319\":7,\"320\":39,\"321\":3,\"325\":5,\"326\":3,\"333\":4,\"340\":9,\"343\":13,\"347\":10,\"348\":3,\"349\":9,\"351\":3,\"356\":3,\"370\":4,\"371\":8,\"372\":4,\"373\":4,\"374\":3,\"376\":3,\"377\":14,\"381\":3,\"388\":6,\"389\":10,\"393\":4,\"395\":3,\"402\":7,\"403\":2,\"405\":10,\"410\":5,\"412\":3,\"413\":15,\"414\":3,\"418\":12,\"419\":6,\"425\":3,\"427\":3,\"428\":4,\"431\":7,\"435\":5,\"436\":5,\"437\":22,\"441\":13,\"443\":12,\"444\":19,\"450\":6,\"456\":6,\"457\":10,\"458\":3,\"460\":11,\"464\":2,\"465\":2,\"471\":8,\"473\":3,\"475\":3,\"477\":4,\"483\":5,\"484\":2,\"485\":5,\"487\":4,\"488\":11,\"489\":9,\"490\":4,\"492\":8,\"493\":3,\"494\":5,\"495\":8,\"498\":3,\"499\":4,\"500\":3,\"507\":5,\"508\":2,\"513\":16,\"519\":12,\"522\":5,\"525\":3,\"527\":5,\"530\":4,\"531\":10,\"535\":2,\"539\":4,\"542\":23,\"544\":4,\"546\":3,\"560\":7,\"562\":3,\"563\":4,\"565\":8,\"569\":5,\"575\":7,\"576\":3,\"579\":3,\"583\":3,\"596\":4,\"605\":3,\"609\":6,\"612\":3,\"622\":16,\"623\":7,\"633\":12,\"636\":10,\"640\":8,\"653\":5,\"656\":7,\"662\":2,\"668\":2,\"669\":3,\"672\":8,\"675\":20,\"679\":5,\"685\":13,\"688\":7,\"691\":1,\"692\":3,\"695\":11,\"708\":5,\"718\":17,\"721\":5,\"731\":4,\"734\":4,\"737\":11,\"742\":3,\"746\":8,\"747\":4,\"751\":3,\"754\":3,\"760\":7,\"764\":2,\"770\":5,\"772\":1,\"773\":3,\"777\":4,\"783\":2,\"790\":5,\"796\":2,\"799\":8,\"806\":3,\"816\":6,\"819\":6,\"826\":3,\"832\":4,\"843\":3,\"846\":2,\"847\":9,\"860\":5,\"864\":28,\"872\":23,\"875\":14,\"888\":5,\"892\":3,\"898\":6,\"902\":8}}]],\"version\":2}}")).map(([e,t])=>[e,It(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:s,options:n,id:o}})=>{const r=Ct[s];e==="suggest"?self.postMessage([e,o,tt(t,r,n)]):e==="search"?self.postMessage([e,o,Z(t,r,n)]):self.postMessage({suggestions:[e,o,tt(t,r,n)],results:[e,o,Z(t,r,n)]})};
//# sourceMappingURL=index.js.map
